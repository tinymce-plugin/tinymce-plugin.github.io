(function() {
  var typeOf = function(x2) {
    if (x2 === null) {
      return "null";
    }
    if (x2 === void 0) {
      return "undefined";
    }
    var t2 = typeof x2;
    if (t2 === "object" && (Array.prototype.isPrototypeOf(x2) || x2.constructor && x2.constructor.name === "Array")) {
      return "array";
    }
    if (t2 === "object" && (String.prototype.isPrototypeOf(x2) || x2.constructor && x2.constructor.name === "String")) {
      return "string";
    }
    return t2;
  };
  var isEquatableType = function(x2) {
    return [
      "undefined",
      "boolean",
      "number",
      "string",
      "function",
      "xml",
      "null"
    ].indexOf(x2) !== -1;
  };
  var sort = function(xs, compareFn) {
    var clone2 = Array.prototype.slice.call(xs);
    return clone2.sort(compareFn);
  };
  var contramap = function(eqa, f) {
    return eq(function(x2, y2) {
      return eqa.eq(f(x2), f(y2));
    });
  };
  var eq = function(f) {
    return { eq: f };
  };
  var tripleEq = eq(function(x2, y2) {
    return x2 === y2;
  });
  var eqString = tripleEq;
  var eqArray = function(eqa) {
    return eq(function(x2, y2) {
      if (x2.length !== y2.length) {
        return false;
      }
      var len = x2.length;
      for (var i = 0; i < len; i++) {
        if (!eqa.eq(x2[i], y2[i])) {
          return false;
        }
      }
      return true;
    });
  };
  var eqSortedArray = function(eqa, compareFn) {
    return contramap(eqArray(eqa), function(xs) {
      return sort(xs, compareFn);
    });
  };
  var eqRecord = function(eqa) {
    return eq(function(x2, y2) {
      var kx = Object.keys(x2);
      var ky = Object.keys(y2);
      if (!eqSortedArray(eqString).eq(kx, ky)) {
        return false;
      }
      var len = kx.length;
      for (var i = 0; i < len; i++) {
        var q2 = kx[i];
        if (!eqa.eq(x2[q2], y2[q2])) {
          return false;
        }
      }
      return true;
    });
  };
  var eqAny = eq(function(x2, y2) {
    if (x2 === y2) {
      return true;
    }
    var tx = typeOf(x2);
    var ty = typeOf(y2);
    if (tx !== ty) {
      return false;
    }
    if (isEquatableType(tx)) {
      return x2 === y2;
    } else if (tx === "array") {
      return eqArray(eqAny).eq(x2, y2);
    } else if (tx === "object") {
      return eqRecord(eqAny).eq(x2, y2);
    }
    return false;
  });
  var typeOf$1 = function(x2) {
    var t2 = typeof x2;
    if (x2 === null) {
      return "null";
    } else if (t2 === "object" && (Array.prototype.isPrototypeOf(x2) || x2.constructor && x2.constructor.name === "Array")) {
      return "array";
    } else if (t2 === "object" && (String.prototype.isPrototypeOf(x2) || x2.constructor && x2.constructor.name === "String")) {
      return "string";
    } else {
      return t2;
    }
  };
  var isType = function(type2) {
    return function(value2) {
      return typeOf$1(value2) === type2;
    };
  };
  var isSimpleType = function(type2) {
    return function(value2) {
      return typeof value2 === type2;
    };
  };
  var eq$1 = function(t2) {
    return function(a) {
      return t2 === a;
    };
  };
  var isString = isType("string");
  var isObject = isType("object");
  var isArray = isType("array");
  var isNull = eq$1(null);
  var isBoolean = isSimpleType("boolean");
  var isUndefined = eq$1(void 0);
  var isNullable = function(a) {
    return a === null || a === void 0;
  };
  var isNonNullable = function(a) {
    return !isNullable(a);
  };
  var isFunction2 = isSimpleType("function");
  var isNumber = isSimpleType("number");
  var noop = function() {
  };
  var compose = function(fa2, fb2) {
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return fa2(fb2.apply(null, args));
    };
  };
  var compose1 = function(fbc, fab) {
    return function(a) {
      return fbc(fab(a));
    };
  };
  var constant = function(value2) {
    return function() {
      return value2;
    };
  };
  var identity = function(x2) {
    return x2;
  };
  function curry(fn) {
    var initialArgs = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      initialArgs[_i - 1] = arguments[_i];
    }
    return function() {
      var restArgs = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        restArgs[_i2] = arguments[_i2];
      }
      var all2 = initialArgs.concat(restArgs);
      return fn.apply(null, all2);
    };
  }
  var not = function(f) {
    return function(t2) {
      return !f(t2);
    };
  };
  var die = function(msg) {
    return function() {
      throw new Error(msg);
    };
  };
  var apply = function(f) {
    return f();
  };
  var call = function(f) {
    f();
  };
  var never = constant(false);
  var always = constant(true);
  var none = function() {
    return NONE;
  };
  var NONE = function() {
    var eq2 = function(o) {
      return o.isNone();
    };
    var call2 = function(thunk) {
      return thunk();
    };
    var id2 = function(n2) {
      return n2;
    };
    var me2 = {
      fold: function(n2, _s) {
        return n2();
      },
      is: never,
      isSome: never,
      isNone: always,
      getOr: id2,
      getOrThunk: call2,
      getOrDie: function(msg) {
        throw new Error(msg || "error: getOrDie called on none.");
      },
      getOrNull: constant(null),
      getOrUndefined: constant(void 0),
      or: id2,
      orThunk: call2,
      map: none,
      each: noop,
      bind: none,
      exists: never,
      forall: always,
      filter: none,
      equals: eq2,
      equals_: eq2,
      toArray: function() {
        return [];
      },
      toString: constant("none()")
    };
    return me2;
  }();
  var some = function(a) {
    var constant_a = constant(a);
    var self2 = function() {
      return me2;
    };
    var bind2 = function(f) {
      return f(a);
    };
    var me2 = {
      fold: function(n2, s) {
        return s(a);
      },
      is: function(v2) {
        return a === v2;
      },
      isSome: always,
      isNone: never,
      getOr: constant_a,
      getOrThunk: constant_a,
      getOrDie: constant_a,
      getOrNull: constant_a,
      getOrUndefined: constant_a,
      or: self2,
      orThunk: self2,
      map: function(f) {
        return some(f(a));
      },
      each: function(f) {
        f(a);
      },
      bind: bind2,
      exists: bind2,
      forall: bind2,
      filter: function(f) {
        return f(a) ? me2 : NONE;
      },
      toArray: function() {
        return [a];
      },
      toString: function() {
        return "some(" + a + ")";
      },
      equals: function(o) {
        return o.is(a);
      },
      equals_: function(o, elementEq) {
        return o.fold(never, function(b) {
          return elementEq(a, b);
        });
      }
    };
    return me2;
  };
  var from = function(value2) {
    return value2 === null || value2 === void 0 ? NONE : some(value2);
  };
  var Optional = {
    some,
    none,
    from
  };
  var nativeSlice = Array.prototype.slice;
  var nativeIndexOf = Array.prototype.indexOf;
  var nativePush = Array.prototype.push;
  var rawIndexOf = function(ts, t2) {
    return nativeIndexOf.call(ts, t2);
  };
  var indexOf = function(xs, x2) {
    var r3 = rawIndexOf(xs, x2);
    return r3 === -1 ? Optional.none() : Optional.some(r3);
  };
  var contains = function(xs, x2) {
    return rawIndexOf(xs, x2) > -1;
  };
  var exists = function(xs, pred) {
    for (var i = 0, len = xs.length; i < len; i++) {
      var x2 = xs[i];
      if (pred(x2, i)) {
        return true;
      }
    }
    return false;
  };
  var map = function(xs, f) {
    var len = xs.length;
    var r3 = new Array(len);
    for (var i = 0; i < len; i++) {
      var x2 = xs[i];
      r3[i] = f(x2, i);
    }
    return r3;
  };
  var each = function(xs, f) {
    for (var i = 0, len = xs.length; i < len; i++) {
      var x2 = xs[i];
      f(x2, i);
    }
  };
  var eachr = function(xs, f) {
    for (var i = xs.length - 1; i >= 0; i--) {
      var x2 = xs[i];
      f(x2, i);
    }
  };
  var partition = function(xs, pred) {
    var pass = [];
    var fail = [];
    for (var i = 0, len = xs.length; i < len; i++) {
      var x2 = xs[i];
      var arr2 = pred(x2, i) ? pass : fail;
      arr2.push(x2);
    }
    return {
      pass,
      fail
    };
  };
  var filter = function(xs, pred) {
    var r3 = [];
    for (var i = 0, len = xs.length; i < len; i++) {
      var x2 = xs[i];
      if (pred(x2, i)) {
        r3.push(x2);
      }
    }
    return r3;
  };
  var foldr = function(xs, f, acc) {
    eachr(xs, function(x2) {
      acc = f(acc, x2);
    });
    return acc;
  };
  var foldl = function(xs, f, acc) {
    each(xs, function(x2) {
      acc = f(acc, x2);
    });
    return acc;
  };
  var findUntil = function(xs, pred, until) {
    for (var i = 0, len = xs.length; i < len; i++) {
      var x2 = xs[i];
      if (pred(x2, i)) {
        return Optional.some(x2);
      } else if (until(x2, i)) {
        break;
      }
    }
    return Optional.none();
  };
  var find = function(xs, pred) {
    return findUntil(xs, pred, never);
  };
  var findIndex = function(xs, pred) {
    for (var i = 0, len = xs.length; i < len; i++) {
      var x2 = xs[i];
      if (pred(x2, i)) {
        return Optional.some(i);
      }
    }
    return Optional.none();
  };
  var flatten = function(xs) {
    var r3 = [];
    for (var i = 0, len = xs.length; i < len; ++i) {
      if (!isArray(xs[i])) {
        throw new Error("Arr.flatten item " + i + " was not an array, input: " + xs);
      }
      nativePush.apply(r3, xs[i]);
    }
    return r3;
  };
  var bind = function(xs, f) {
    return flatten(map(xs, f));
  };
  var forall = function(xs, pred) {
    for (var i = 0, len = xs.length; i < len; ++i) {
      var x2 = xs[i];
      if (pred(x2, i) !== true) {
        return false;
      }
    }
    return true;
  };
  var reverse = function(xs) {
    var r3 = nativeSlice.call(xs, 0);
    r3.reverse();
    return r3;
  };
  var difference = function(a1, a2) {
    return filter(a1, function(x2) {
      return !contains(a2, x2);
    });
  };
  var mapToObject = function(xs, f) {
    var r3 = {};
    for (var i = 0, len = xs.length; i < len; i++) {
      var x2 = xs[i];
      r3[String(x2)] = f(x2, i);
    }
    return r3;
  };
  var sort$1 = function(xs, comparator) {
    var copy = nativeSlice.call(xs, 0);
    copy.sort(comparator);
    return copy;
  };
  var get = function(xs, i) {
    return i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();
  };
  var head = function(xs) {
    return get(xs, 0);
  };
  var last = function(xs) {
    return get(xs, xs.length - 1);
  };
  var from$1 = isFunction2(Array.from) ? Array.from : function(x2) {
    return nativeSlice.call(x2);
  };
  var findMap = function(arr2, f) {
    for (var i = 0; i < arr2.length; i++) {
      var r3 = f(arr2[i], i);
      if (r3.isSome()) {
        return r3;
      }
    }
    return Optional.none();
  };
  var keys = Object.keys;
  var hasOwnProperty2 = Object.hasOwnProperty;
  var each$1 = function(obj, f) {
    var props = keys(obj);
    for (var k = 0, len = props.length; k < len; k++) {
      var i = props[k];
      var x2 = obj[i];
      f(x2, i);
    }
  };
  var map$1 = function(obj, f) {
    return tupleMap(obj, function(x2, i) {
      return {
        k: i,
        v: f(x2, i)
      };
    });
  };
  var tupleMap = function(obj, f) {
    var r3 = {};
    each$1(obj, function(x2, i) {
      var tuple = f(x2, i);
      r3[tuple.k] = tuple.v;
    });
    return r3;
  };
  var objAcc = function(r3) {
    return function(x2, i) {
      r3[i] = x2;
    };
  };
  var internalFilter = function(obj, pred, onTrue, onFalse) {
    var r3 = {};
    each$1(obj, function(x2, i) {
      (pred(x2, i) ? onTrue : onFalse)(x2, i);
    });
    return r3;
  };
  var bifilter = function(obj, pred) {
    var t2 = {};
    var f = {};
    internalFilter(obj, pred, objAcc(t2), objAcc(f));
    return {
      t: t2,
      f
    };
  };
  var filter$1 = function(obj, pred) {
    var t2 = {};
    internalFilter(obj, pred, objAcc(t2), noop);
    return t2;
  };
  var mapToArray = function(obj, f) {
    var r3 = [];
    each$1(obj, function(value2, name2) {
      r3.push(f(value2, name2));
    });
    return r3;
  };
  var values = function(obj) {
    return mapToArray(obj, function(v2) {
      return v2;
    });
  };
  var get$1 = function(obj, key) {
    return has(obj, key) ? Optional.from(obj[key]) : Optional.none();
  };
  var has = function(obj, key) {
    return hasOwnProperty2.call(obj, key);
  };
  var hasNonNullableKey = function(obj, key) {
    return has(obj, key) && obj[key] !== void 0 && obj[key] !== null;
  };
  var equal = function(a1, a2, eq2) {
    if (eq2 === void 0) {
      eq2 = eqAny;
    }
    return eqRecord(eq2).eq(a1, a2);
  };
  var isArray$1 = Array.isArray;
  var toArray = function(obj) {
    if (!isArray$1(obj)) {
      var array = [];
      for (var i = 0, l2 = obj.length; i < l2; i++) {
        array[i] = obj[i];
      }
      return array;
    } else {
      return obj;
    }
  };
  var each$2 = function(o, cb2, s) {
    var n2, l2;
    if (!o) {
      return false;
    }
    s = s || o;
    if (o.length !== void 0) {
      for (n2 = 0, l2 = o.length; n2 < l2; n2++) {
        if (cb2.call(s, o[n2], n2, o) === false) {
          return false;
        }
      }
    } else {
      for (n2 in o) {
        if (o.hasOwnProperty(n2)) {
          if (cb2.call(s, o[n2], n2, o) === false) {
            return false;
          }
        }
      }
    }
    return true;
  };
  var map$2 = function(array, callback) {
    var out = [];
    each$2(array, function(item, index) {
      out.push(callback(item, index, array));
    });
    return out;
  };
  var filter$2 = function(a, f) {
    var o = [];
    each$2(a, function(v2, index) {
      if (!f || f(v2, index, a)) {
        o.push(v2);
      }
    });
    return o;
  };
  var indexOf$1 = function(a, v2) {
    if (a) {
      for (var i = 0, l2 = a.length; i < l2; i++) {
        if (a[i] === v2) {
          return i;
        }
      }
    }
    return -1;
  };
  var reduce = function(collection, iteratee, accumulator, thisArg) {
    var acc = isUndefined(accumulator) ? collection[0] : accumulator;
    for (var i = 0; i < collection.length; i++) {
      acc = iteratee.call(thisArg, acc, collection[i], i);
    }
    return acc;
  };
  var findIndex$1 = function(array, predicate, thisArg) {
    var i, l2;
    for (i = 0, l2 = array.length; i < l2; i++) {
      if (predicate.call(thisArg, array[i], i, array)) {
        return i;
      }
    }
    return -1;
  };
  var last$1 = function(collection) {
    return collection[collection.length - 1];
  };
  var __assign2 = function() {
    __assign2 = Object.assign || function __assign3(t2) {
      for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
        s = arguments[i];
        for (var p2 in s)
          if (Object.prototype.hasOwnProperty.call(s, p2))
            t2[p2] = s[p2];
      }
      return t2;
    };
    return __assign2.apply(this, arguments);
  };
  function __rest(s, e) {
    var t2 = {};
    for (var p2 in s)
      if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)
        t2[p2] = s[p2];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
        if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
          t2[p2[i]] = s[p2[i]];
      }
    return t2;
  }
  function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++)
      s += arguments[i].length;
    for (var r3 = Array(s), k = 0, i = 0; i < il; i++)
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
        r3[k] = a[j];
    return r3;
  }
  var cached = function(f) {
    var called = false;
    var r3;
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (!called) {
        called = true;
        r3 = f.apply(null, args);
      }
      return r3;
    };
  };
  var DeviceType = function(os2, browser2, userAgent2, mediaMatch2) {
    var isiPad = os2.isiOS() && /ipad/i.test(userAgent2) === true;
    var isiPhone = os2.isiOS() && !isiPad;
    var isMobile = os2.isiOS() || os2.isAndroid();
    var isTouch2 = isMobile || mediaMatch2("(pointer:coarse)");
    var isTablet2 = isiPad || !isiPhone && isMobile && mediaMatch2("(min-device-width:768px)");
    var isPhone2 = isiPhone || isMobile && !isTablet2;
    var iOSwebview = browser2.isSafari() && os2.isiOS() && /safari/i.test(userAgent2) === false;
    var isDesktop = !isPhone2 && !isTablet2 && !iOSwebview;
    return {
      isiPad: constant(isiPad),
      isiPhone: constant(isiPhone),
      isTablet: constant(isTablet2),
      isPhone: constant(isPhone2),
      isTouch: constant(isTouch2),
      isAndroid: os2.isAndroid,
      isiOS: os2.isiOS,
      isWebView: constant(iOSwebview),
      isDesktop: constant(isDesktop)
    };
  };
  var firstMatch = function(regexes, s) {
    for (var i = 0; i < regexes.length; i++) {
      var x2 = regexes[i];
      if (x2.test(s)) {
        return x2;
      }
    }
    return void 0;
  };
  var find$1 = function(regexes, agent) {
    var r3 = firstMatch(regexes, agent);
    if (!r3) {
      return {
        major: 0,
        minor: 0
      };
    }
    var group = function(i) {
      return Number(agent.replace(r3, "$" + i));
    };
    return nu(group(1), group(2));
  };
  var detect = function(versionRegexes, agent) {
    var cleanedAgent = String(agent).toLowerCase();
    if (versionRegexes.length === 0) {
      return unknown();
    }
    return find$1(versionRegexes, cleanedAgent);
  };
  var unknown = function() {
    return nu(0, 0);
  };
  var nu = function(major, minor) {
    return {
      major,
      minor
    };
  };
  var Version = {
    nu,
    detect,
    unknown
  };
  var detect$1 = function(candidates, userAgent2) {
    var agent = String(userAgent2).toLowerCase();
    return find(candidates, function(candidate) {
      return candidate.search(agent);
    });
  };
  var detectBrowser = function(browsers2, userAgent2) {
    return detect$1(browsers2, userAgent2).map(function(browser2) {
      var version = Version.detect(browser2.versionRegexes, userAgent2);
      return {
        current: browser2.name,
        version
      };
    });
  };
  var detectOs = function(oses2, userAgent2) {
    return detect$1(oses2, userAgent2).map(function(os2) {
      var version = Version.detect(os2.versionRegexes, userAgent2);
      return {
        current: os2.name,
        version
      };
    });
  };
  var UaString = {
    detectBrowser,
    detectOs
  };
  var removeFromStart = function(str, numChars) {
    return str.substring(numChars);
  };
  var checkRange = function(str, substr, start2) {
    return substr === "" || str.length >= substr.length && str.substr(start2, start2 + substr.length) === substr;
  };
  var removeLeading = function(str, prefix) {
    return startsWith(str, prefix) ? removeFromStart(str, prefix.length) : str;
  };
  var contains$1 = function(str, substr) {
    return str.indexOf(substr) !== -1;
  };
  var startsWith = function(str, prefix) {
    return checkRange(str, prefix, 0);
  };
  var blank = function(r3) {
    return function(s) {
      return s.replace(r3, "");
    };
  };
  var trim = blank(/^\s+|\s+$/g);
  var lTrim = blank(/^\s+/g);
  var rTrim = blank(/\s+$/g);
  var isNotEmpty = function(s) {
    return s.length > 0;
  };
  var normalVersionRegex = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/;
  var checkContains = function(target) {
    return function(uastring) {
      return contains$1(uastring, target);
    };
  };
  var browsers = [
    {
      name: "Edge",
      versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
      search: function(uastring) {
        return contains$1(uastring, "edge/") && contains$1(uastring, "chrome") && contains$1(uastring, "safari") && contains$1(uastring, "applewebkit");
      }
    },
    {
      name: "Chrome",
      versionRegexes: [
        /.*?chrome\/([0-9]+)\.([0-9]+).*/,
        normalVersionRegex
      ],
      search: function(uastring) {
        return contains$1(uastring, "chrome") && !contains$1(uastring, "chromeframe");
      }
    },
    {
      name: "IE",
      versionRegexes: [
        /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
        /.*?rv:([0-9]+)\.([0-9]+).*/
      ],
      search: function(uastring) {
        return contains$1(uastring, "msie") || contains$1(uastring, "trident");
      }
    },
    {
      name: "Opera",
      versionRegexes: [
        normalVersionRegex,
        /.*?opera\/([0-9]+)\.([0-9]+).*/
      ],
      search: checkContains("opera")
    },
    {
      name: "Firefox",
      versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
      search: checkContains("firefox")
    },
    {
      name: "Safari",
      versionRegexes: [
        normalVersionRegex,
        /.*?cpu os ([0-9]+)_([0-9]+).*/
      ],
      search: function(uastring) {
        return (contains$1(uastring, "safari") || contains$1(uastring, "mobile/")) && contains$1(uastring, "applewebkit");
      }
    }
  ];
  var oses = [
    {
      name: "Windows",
      search: checkContains("win"),
      versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
    },
    {
      name: "iOS",
      search: function(uastring) {
        return contains$1(uastring, "iphone") || contains$1(uastring, "ipad");
      },
      versionRegexes: [
        /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
        /.*cpu os ([0-9]+)_([0-9]+).*/,
        /.*cpu iphone os ([0-9]+)_([0-9]+).*/
      ]
    },
    {
      name: "Android",
      search: checkContains("android"),
      versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
    },
    {
      name: "OSX",
      search: checkContains("mac os x"),
      versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
    },
    {
      name: "Linux",
      search: checkContains("linux"),
      versionRegexes: []
    },
    {
      name: "Solaris",
      search: checkContains("sunos"),
      versionRegexes: []
    },
    {
      name: "FreeBSD",
      search: checkContains("freebsd"),
      versionRegexes: []
    },
    {
      name: "ChromeOS",
      search: checkContains("cros"),
      versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
    }
  ];
  var PlatformInfo = {
    browsers: constant(browsers),
    oses: constant(oses)
  };
  var edge = "Edge";
  var chrome = "Chrome";
  var ie2 = "IE";
  var opera = "Opera";
  var firefox = "Firefox";
  var safari = "Safari";
  var unknown$1 = function() {
    return nu$1({
      current: void 0,
      version: Version.unknown()
    });
  };
  var nu$1 = function(info) {
    var current = info.current;
    var version = info.version;
    var isBrowser = function(name2) {
      return function() {
        return current === name2;
      };
    };
    return {
      current,
      version,
      isEdge: isBrowser(edge),
      isChrome: isBrowser(chrome),
      isIE: isBrowser(ie2),
      isOpera: isBrowser(opera),
      isFirefox: isBrowser(firefox),
      isSafari: isBrowser(safari)
    };
  };
  var Browser = {
    unknown: unknown$1,
    nu: nu$1,
    edge: constant(edge),
    chrome: constant(chrome),
    ie: constant(ie2),
    opera: constant(opera),
    firefox: constant(firefox),
    safari: constant(safari)
  };
  var windows = "Windows";
  var ios = "iOS";
  var android = "Android";
  var linux = "Linux";
  var osx = "OSX";
  var solaris = "Solaris";
  var freebsd = "FreeBSD";
  var chromeos = "ChromeOS";
  var unknown$2 = function() {
    return nu$2({
      current: void 0,
      version: Version.unknown()
    });
  };
  var nu$2 = function(info) {
    var current = info.current;
    var version = info.version;
    var isOS = function(name2) {
      return function() {
        return current === name2;
      };
    };
    return {
      current,
      version,
      isWindows: isOS(windows),
      isiOS: isOS(ios),
      isAndroid: isOS(android),
      isOSX: isOS(osx),
      isLinux: isOS(linux),
      isSolaris: isOS(solaris),
      isFreeBSD: isOS(freebsd),
      isChromeOS: isOS(chromeos)
    };
  };
  var OperatingSystem = {
    unknown: unknown$2,
    nu: nu$2,
    windows: constant(windows),
    ios: constant(ios),
    android: constant(android),
    linux: constant(linux),
    osx: constant(osx),
    solaris: constant(solaris),
    freebsd: constant(freebsd),
    chromeos: constant(chromeos)
  };
  var detect$2 = function(userAgent2, mediaMatch2) {
    var browsers2 = PlatformInfo.browsers();
    var oses2 = PlatformInfo.oses();
    var browser2 = UaString.detectBrowser(browsers2, userAgent2).fold(Browser.unknown, Browser.nu);
    var os2 = UaString.detectOs(oses2, userAgent2).fold(OperatingSystem.unknown, OperatingSystem.nu);
    var deviceType2 = DeviceType(os2, browser2, userAgent2, mediaMatch2);
    return {
      browser: browser2,
      os: os2,
      deviceType: deviceType2
    };
  };
  var PlatformDetection = { detect: detect$2 };
  var mediaMatch = function(query) {
    return window.matchMedia(query).matches;
  };
  var platform = cached(function() {
    return PlatformDetection.detect(navigator.userAgent, mediaMatch);
  });
  var detect$3 = function() {
    return platform();
  };
  var userAgent = navigator.userAgent;
  var platform$1 = detect$3();
  var browser = platform$1.browser;
  var os = platform$1.os;
  var deviceType = platform$1.deviceType;
  var webkit = /WebKit/.test(userAgent) && !browser.isEdge();
  var fileApi = "FormData" in window && "FileReader" in window && "URL" in window && !!URL.createObjectURL;
  var windowsPhone = userAgent.indexOf("Windows Phone") !== -1;
  var Env = {
    opera: browser.isOpera(),
    webkit,
    ie: browser.isIE() || browser.isEdge() ? browser.version.major : false,
    gecko: browser.isFirefox(),
    mac: os.isOSX() || os.isiOS(),
    iOS: deviceType.isiPad() || deviceType.isiPhone(),
    android: os.isAndroid(),
    contentEditable: true,
    transparentSrc: "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
    caretAfter: true,
    range: window.getSelection && "Range" in window,
    documentMode: browser.isIE() ? document.documentMode || 7 : 10,
    fileApi,
    ceFalse: true,
    cacheSuffix: null,
    container: null,
    experimentalShadowDom: false,
    canHaveCSP: !browser.isIE(),
    desktop: deviceType.isDesktop(),
    windowsPhone,
    browser: {
      current: browser.current,
      version: browser.version,
      isChrome: browser.isChrome,
      isEdge: browser.isEdge,
      isFirefox: browser.isFirefox,
      isIE: browser.isIE,
      isOpera: browser.isOpera,
      isSafari: browser.isSafari
    },
    os: {
      current: os.current,
      version: os.version,
      isAndroid: os.isAndroid,
      isChromeOS: os.isChromeOS,
      isFreeBSD: os.isFreeBSD,
      isiOS: os.isiOS,
      isLinux: os.isLinux,
      isOSX: os.isOSX,
      isSolaris: os.isSolaris,
      isWindows: os.isWindows
    },
    deviceType: {
      isDesktop: deviceType.isDesktop,
      isiPad: deviceType.isiPad,
      isiPhone: deviceType.isiPhone,
      isPhone: deviceType.isPhone,
      isTablet: deviceType.isTablet,
      isTouch: deviceType.isTouch,
      isWebView: deviceType.isWebView
    }
  };
  var whiteSpaceRegExp = /^\s*|\s*$/g;
  var trim$1 = function(str) {
    return str === null || str === void 0 ? "" : ("" + str).replace(whiteSpaceRegExp, "");
  };
  var is = function(obj, type2) {
    if (!type2) {
      return obj !== void 0;
    }
    if (type2 === "array" && isArray$1(obj)) {
      return true;
    }
    return typeof obj === type2;
  };
  var makeMap = function(items, delim, map2) {
    var i;
    items = items || [];
    delim = delim || ",";
    if (typeof items === "string") {
      items = items.split(delim);
    }
    map2 = map2 || {};
    i = items.length;
    while (i--) {
      map2[items[i]] = {};
    }
    return map2;
  };
  var hasOwnProperty$1 = function(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  };
  var create = function(s, p2, root) {
    var self2 = this;
    var sp, scn, c, de2 = 0;
    s = /^((static) )?([\w.]+)(:([\w.]+))?/.exec(s);
    var cn = s[3].match(/(^|\.)(\w+)$/i)[2];
    var ns = self2.createNS(s[3].replace(/\.\w+$/, ""), root);
    if (ns[cn]) {
      return;
    }
    if (s[2] === "static") {
      ns[cn] = p2;
      if (this.onCreate) {
        this.onCreate(s[2], s[3], ns[cn]);
      }
      return;
    }
    if (!p2[cn]) {
      p2[cn] = function() {
      };
      de2 = 1;
    }
    ns[cn] = p2[cn];
    self2.extend(ns[cn].prototype, p2);
    if (s[5]) {
      sp = self2.resolve(s[5]).prototype;
      scn = s[5].match(/\.(\w+)$/i)[1];
      c = ns[cn];
      if (de2) {
        ns[cn] = function() {
          return sp[scn].apply(this, arguments);
        };
      } else {
        ns[cn] = function() {
          this.parent = sp[scn];
          return c.apply(this, arguments);
        };
      }
      ns[cn].prototype[cn] = ns[cn];
      self2.each(sp, function(f, n2) {
        ns[cn].prototype[n2] = sp[n2];
      });
      self2.each(p2, function(f, n2) {
        if (sp[n2]) {
          ns[cn].prototype[n2] = function() {
            this.parent = sp[n2];
            return f.apply(this, arguments);
          };
        } else {
          if (n2 !== cn) {
            ns[cn].prototype[n2] = f;
          }
        }
      });
    }
    self2.each(p2.static, function(f, n2) {
      ns[cn][n2] = f;
    });
  };
  var extend = function(obj) {
    var exts = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      exts[_i - 1] = arguments[_i];
    }
    for (var i = 0; i < exts.length; i++) {
      var ext = exts[i];
      for (var name_1 in ext) {
        if (ext.hasOwnProperty(name_1)) {
          var value2 = ext[name_1];
          if (value2 !== void 0) {
            obj[name_1] = value2;
          }
        }
      }
    }
    return obj;
  };
  var walk = function(o, f, n2, s) {
    s = s || this;
    if (o) {
      if (n2) {
        o = o[n2];
      }
      each$2(o, function(o2, i) {
        if (f.call(s, o2, i, n2) === false) {
          return false;
        }
        walk(o2, f, n2, s);
      });
    }
  };
  var createNS = function(n2, o) {
    var i, v2;
    o = o || window;
    n2 = n2.split(".");
    for (i = 0; i < n2.length; i++) {
      v2 = n2[i];
      if (!o[v2]) {
        o[v2] = {};
      }
      o = o[v2];
    }
    return o;
  };
  var resolve = function(n2, o) {
    var i, l2;
    o = o || window;
    n2 = n2.split(".");
    for (i = 0, l2 = n2.length; i < l2; i++) {
      o = o[n2[i]];
      if (!o) {
        break;
      }
    }
    return o;
  };
  var explode = function(s, d) {
    if (!s || is(s, "array")) {
      return s;
    }
    return map$2(s.split(d || ","), trim$1);
  };
  var _addCacheSuffix = function(url) {
    var cacheSuffix = Env.cacheSuffix;
    if (cacheSuffix) {
      url += (url.indexOf("?") === -1 ? "?" : "&") + cacheSuffix;
    }
    return url;
  };
  var Tools = {
    trim: trim$1,
    isArray: isArray$1,
    is,
    toArray,
    makeMap,
    each: each$2,
    map: map$2,
    grep: filter$2,
    inArray: indexOf$1,
    hasOwn: hasOwnProperty$1,
    extend,
    create,
    walk,
    createNS,
    resolve,
    explode,
    _addCacheSuffix
  };
  var fromHtml = function(html, scope) {
    var doc2 = scope || document;
    var div = doc2.createElement("div");
    div.innerHTML = html;
    if (!div.hasChildNodes() || div.childNodes.length > 1) {
      console.error("HTML does not have a single root node", html);
      throw new Error("HTML must have a single root node");
    }
    return fromDom(div.childNodes[0]);
  };
  var fromTag = function(tag, scope) {
    var doc2 = scope || document;
    var node = doc2.createElement(tag);
    return fromDom(node);
  };
  var fromText = function(text, scope) {
    var doc2 = scope || document;
    var node = doc2.createTextNode(text);
    return fromDom(node);
  };
  var fromDom = function(node) {
    if (node === null || node === void 0) {
      throw new Error("Node cannot be null or undefined");
    }
    return { dom: node };
  };
  var fromPoint = function(docElm, x2, y2) {
    return Optional.from(docElm.dom.elementFromPoint(x2, y2)).map(fromDom);
  };
  var SugarElement = {
    fromHtml,
    fromTag,
    fromText,
    fromDom,
    fromPoint
  };
  var toArray$1 = function(target, f) {
    var r3 = [];
    var recurse = function(e) {
      r3.push(e);
      return f(e);
    };
    var cur = f(target);
    do {
      cur = cur.bind(recurse);
    } while (cur.isSome());
    return r3;
  };
  var compareDocumentPosition = function(a, b, match2) {
    return (a.compareDocumentPosition(b) & match2) !== 0;
  };
  var documentPositionContainedBy = function(a, b) {
    return compareDocumentPosition(a, b, Node.DOCUMENT_POSITION_CONTAINED_BY);
  };
  var COMMENT = 8;
  var DOCUMENT = 9;
  var DOCUMENT_FRAGMENT = 11;
  var ELEMENT = 1;
  var TEXT = 3;
  var is$1 = function(element, selector) {
    var dom2 = element.dom;
    if (dom2.nodeType !== ELEMENT) {
      return false;
    } else {
      var elem = dom2;
      if (elem.matches !== void 0) {
        return elem.matches(selector);
      } else if (elem.msMatchesSelector !== void 0) {
        return elem.msMatchesSelector(selector);
      } else if (elem.webkitMatchesSelector !== void 0) {
        return elem.webkitMatchesSelector(selector);
      } else if (elem.mozMatchesSelector !== void 0) {
        return elem.mozMatchesSelector(selector);
      } else {
        throw new Error("Browser lacks native selectors");
      }
    }
  };
  var bypassSelector = function(dom2) {
    return dom2.nodeType !== ELEMENT && dom2.nodeType !== DOCUMENT && dom2.nodeType !== DOCUMENT_FRAGMENT || dom2.childElementCount === 0;
  };
  var all = function(selector, scope) {
    var base = scope === void 0 ? document : scope.dom;
    return bypassSelector(base) ? [] : map(base.querySelectorAll(selector), SugarElement.fromDom);
  };
  var one = function(selector, scope) {
    var base = scope === void 0 ? document : scope.dom;
    return bypassSelector(base) ? Optional.none() : Optional.from(base.querySelector(selector)).map(SugarElement.fromDom);
  };
  var eq$2 = function(e1, e2) {
    return e1.dom === e2.dom;
  };
  var regularContains = function(e1, e2) {
    var d1 = e1.dom;
    var d2 = e2.dom;
    return d1 === d2 ? false : d1.contains(d2);
  };
  var ieContains = function(e1, e2) {
    return documentPositionContainedBy(e1.dom, e2.dom);
  };
  var contains$2 = function(e1, e2) {
    return detect$3().browser.isIE() ? ieContains(e1, e2) : regularContains(e1, e2);
  };
  typeof window !== "undefined" ? window : Function("return this;")();
  var name = function(element) {
    var r3 = element.dom.nodeName;
    return r3.toLowerCase();
  };
  var type = function(element) {
    return element.dom.nodeType;
  };
  var isType$1 = function(t2) {
    return function(element) {
      return type(element) === t2;
    };
  };
  var isComment = function(element) {
    return type(element) === COMMENT || name(element) === "#comment";
  };
  var isElement = isType$1(ELEMENT);
  var isText = isType$1(TEXT);
  var isDocument = isType$1(DOCUMENT);
  var isDocumentFragment = isType$1(DOCUMENT_FRAGMENT);
  var owner = function(element) {
    return SugarElement.fromDom(element.dom.ownerDocument);
  };
  var documentOrOwner = function(dos) {
    return isDocument(dos) ? dos : owner(dos);
  };
  var documentElement = function(element) {
    return SugarElement.fromDom(documentOrOwner(element).dom.documentElement);
  };
  var defaultView = function(element) {
    return SugarElement.fromDom(documentOrOwner(element).dom.defaultView);
  };
  var parent = function(element) {
    return Optional.from(element.dom.parentNode).map(SugarElement.fromDom);
  };
  var parents = function(element, isRoot) {
    var stop2 = isFunction2(isRoot) ? isRoot : never;
    var dom2 = element.dom;
    var ret = [];
    while (dom2.parentNode !== null && dom2.parentNode !== void 0) {
      var rawParent = dom2.parentNode;
      var p2 = SugarElement.fromDom(rawParent);
      ret.push(p2);
      if (stop2(p2) === true) {
        break;
      } else {
        dom2 = rawParent;
      }
    }
    return ret;
  };
  var siblings = function(element) {
    var filterSelf = function(elements) {
      return filter(elements, function(x2) {
        return !eq$2(element, x2);
      });
    };
    return parent(element).map(children).map(filterSelf).getOr([]);
  };
  var prevSibling = function(element) {
    return Optional.from(element.dom.previousSibling).map(SugarElement.fromDom);
  };
  var nextSibling = function(element) {
    return Optional.from(element.dom.nextSibling).map(SugarElement.fromDom);
  };
  var prevSiblings = function(element) {
    return reverse(toArray$1(element, prevSibling));
  };
  var nextSiblings = function(element) {
    return toArray$1(element, nextSibling);
  };
  var children = function(element) {
    return map(element.dom.childNodes, SugarElement.fromDom);
  };
  var child = function(element, index) {
    var cs = element.dom.childNodes;
    return Optional.from(cs[index]).map(SugarElement.fromDom);
  };
  var firstChild = function(element) {
    return child(element, 0);
  };
  var lastChild = function(element) {
    return child(element, element.dom.childNodes.length - 1);
  };
  var childNodesCount = function(element) {
    return element.dom.childNodes.length;
  };
  var getHead = function(doc2) {
    var b = doc2.dom.head;
    if (b === null || b === void 0) {
      throw new Error("Head is not available yet");
    }
    return SugarElement.fromDom(b);
  };
  var isShadowRoot = function(dos) {
    return isDocumentFragment(dos) && isNonNullable(dos.dom.host);
  };
  var supported = isFunction2(Element.prototype.attachShadow) && isFunction2(Node.prototype.getRootNode);
  var isSupported = constant(supported);
  var getRootNode = supported ? function(e) {
    return SugarElement.fromDom(e.dom.getRootNode());
  } : documentOrOwner;
  var getStyleContainer = function(dos) {
    return isShadowRoot(dos) ? dos : getHead(documentOrOwner(dos));
  };
  var getShadowRoot = function(e) {
    var r3 = getRootNode(e);
    return isShadowRoot(r3) ? Optional.some(r3) : Optional.none();
  };
  var getShadowHost = function(e) {
    return SugarElement.fromDom(e.dom.host);
  };
  var getOriginalEventTarget = function(event) {
    if (isSupported() && isNonNullable(event.target)) {
      var el = SugarElement.fromDom(event.target);
      if (isElement(el) && isOpenShadowHost(el)) {
        if (event.composed && event.composedPath) {
          var composedPath = event.composedPath();
          if (composedPath) {
            return head(composedPath);
          }
        }
      }
    }
    return Optional.from(event.target);
  };
  var isOpenShadowHost = function(element) {
    return isNonNullable(element.dom.shadowRoot);
  };
  var before = function(marker, element) {
    var parent$1 = parent(marker);
    parent$1.each(function(v2) {
      v2.dom.insertBefore(element.dom, marker.dom);
    });
  };
  var after = function(marker, element) {
    var sibling2 = nextSibling(marker);
    sibling2.fold(function() {
      var parent$1 = parent(marker);
      parent$1.each(function(v2) {
        append(v2, element);
      });
    }, function(v2) {
      before(v2, element);
    });
  };
  var prepend = function(parent2, element) {
    var firstChild$1 = firstChild(parent2);
    firstChild$1.fold(function() {
      append(parent2, element);
    }, function(v2) {
      parent2.dom.insertBefore(element.dom, v2.dom);
    });
  };
  var append = function(parent2, element) {
    parent2.dom.appendChild(element.dom);
  };
  var wrap = function(element, wrapper) {
    before(element, wrapper);
    append(wrapper, element);
  };
  var before$1 = function(marker, elements) {
    each(elements, function(x2) {
      before(marker, x2);
    });
  };
  var append$1 = function(parent2, elements) {
    each(elements, function(x2) {
      append(parent2, x2);
    });
  };
  var empty = function(element) {
    element.dom.textContent = "";
    each(children(element), function(rogue) {
      remove(rogue);
    });
  };
  var remove = function(element) {
    var dom2 = element.dom;
    if (dom2.parentNode !== null) {
      dom2.parentNode.removeChild(dom2);
    }
  };
  var unwrap = function(wrapper) {
    var children$1 = children(wrapper);
    if (children$1.length > 0) {
      before$1(wrapper, children$1);
    }
    remove(wrapper);
  };
  var inBody = function(element) {
    var dom2 = isText(element) ? element.dom.parentNode : element.dom;
    if (dom2 === void 0 || dom2 === null || dom2.ownerDocument === null) {
      return false;
    }
    var doc2 = dom2.ownerDocument;
    return getShadowRoot(SugarElement.fromDom(dom2)).fold(function() {
      return doc2.body.contains(dom2);
    }, compose1(inBody, getShadowHost));
  };
  var r2 = function(left, top) {
    var translate2 = function(x2, y2) {
      return r2(left + x2, top + y2);
    };
    return {
      left,
      top,
      translate: translate2
    };
  };
  var SugarPosition = r2;
  var boxPosition = function(dom2) {
    var box = dom2.getBoundingClientRect();
    return SugarPosition(box.left, box.top);
  };
  var firstDefinedOrZero = function(a, b) {
    if (a !== void 0) {
      return a;
    } else {
      return b !== void 0 ? b : 0;
    }
  };
  var absolute = function(element) {
    var doc2 = element.dom.ownerDocument;
    var body = doc2.body;
    var win = doc2.defaultView;
    var html = doc2.documentElement;
    if (body === element.dom) {
      return SugarPosition(body.offsetLeft, body.offsetTop);
    }
    var scrollTop = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageYOffset, html.scrollTop);
    var scrollLeft = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageXOffset, html.scrollLeft);
    var clientTop = firstDefinedOrZero(html.clientTop, body.clientTop);
    var clientLeft = firstDefinedOrZero(html.clientLeft, body.clientLeft);
    return viewport(element).translate(scrollLeft - clientLeft, scrollTop - clientTop);
  };
  var viewport = function(element) {
    var dom2 = element.dom;
    var doc2 = dom2.ownerDocument;
    var body = doc2.body;
    if (body === dom2) {
      return SugarPosition(body.offsetLeft, body.offsetTop);
    }
    if (!inBody(element)) {
      return SugarPosition(0, 0);
    }
    return boxPosition(dom2);
  };
  var get$2 = function(_DOC) {
    var doc2 = _DOC !== void 0 ? _DOC.dom : document;
    var x2 = doc2.body.scrollLeft || doc2.documentElement.scrollLeft;
    var y2 = doc2.body.scrollTop || doc2.documentElement.scrollTop;
    return SugarPosition(x2, y2);
  };
  var to = function(x2, y2, _DOC) {
    var doc2 = _DOC !== void 0 ? _DOC.dom : document;
    var win = doc2.defaultView;
    if (win) {
      win.scrollTo(x2, y2);
    }
  };
  var intoView = function(element, alignToTop) {
    var isSafari = detect$3().browser.isSafari();
    if (isSafari && isFunction2(element.dom.scrollIntoViewIfNeeded)) {
      element.dom.scrollIntoViewIfNeeded(false);
    } else {
      element.dom.scrollIntoView(alignToTop);
    }
  };
  var get$3 = function(_win) {
    var win = _win === void 0 ? window : _win;
    return Optional.from(win["visualViewport"]);
  };
  var bounds = function(x2, y2, width, height) {
    return {
      x: x2,
      y: y2,
      width,
      height,
      right: x2 + width,
      bottom: y2 + height
    };
  };
  var getBounds = function(_win) {
    var win = _win === void 0 ? window : _win;
    var doc2 = win.document;
    var scroll = get$2(SugarElement.fromDom(doc2));
    return get$3(win).fold(function() {
      var html = win.document.documentElement;
      var width = html.clientWidth;
      var height = html.clientHeight;
      return bounds(scroll.left, scroll.top, width, height);
    }, function(visualViewport) {
      return bounds(Math.max(visualViewport.pageLeft, scroll.left), Math.max(visualViewport.pageTop, scroll.top), visualViewport.width, visualViewport.height);
    });
  };
  var isNodeType = function(type2) {
    return function(node) {
      return !!node && node.nodeType === type2;
    };
  };
  var isRestrictedNode = function(node) {
    return !!node && !Object.getPrototypeOf(node);
  };
  var isElement$1 = isNodeType(1);
  var matchNodeNames = function(names) {
    var lowercasedNames = names.map(function(s) {
      return s.toLowerCase();
    });
    return function(node) {
      if (node && node.nodeName) {
        var nodeName = node.nodeName.toLowerCase();
        return contains(lowercasedNames, nodeName);
      }
      return false;
    };
  };
  var matchStyleValues = function(name2, values2) {
    var items = values2.toLowerCase().split(" ");
    return function(node) {
      var i, cssValue;
      if (isElement$1(node)) {
        for (i = 0; i < items.length; i++) {
          var computed = node.ownerDocument.defaultView.getComputedStyle(node, null);
          cssValue = computed ? computed.getPropertyValue(name2) : null;
          if (cssValue === items[i]) {
            return true;
          }
        }
      }
      return false;
    };
  };
  var hasAttribute = function(attrName) {
    return function(node) {
      return isElement$1(node) && node.hasAttribute(attrName);
    };
  };
  var hasAttributeValue = function(attrName, attrValue) {
    return function(node) {
      return isElement$1(node) && node.getAttribute(attrName) === attrValue;
    };
  };
  var isBogus = function(node) {
    return isElement$1(node) && node.hasAttribute("data-mce-bogus");
  };
  var isBogusAll = function(node) {
    return isElement$1(node) && node.getAttribute("data-mce-bogus") === "all";
  };
  var isTable = function(node) {
    return isElement$1(node) && node.tagName === "TABLE";
  };
  var hasContentEditableState = function(value2) {
    return function(node) {
      if (isElement$1(node)) {
        if (node.contentEditable === value2) {
          return true;
        }
        if (node.getAttribute("data-mce-contenteditable") === value2) {
          return true;
        }
      }
      return false;
    };
  };
  var isTextareaOrInput2 = matchNodeNames([
    "textarea",
    "input"
  ]);
  var isText$1 = isNodeType(3);
  var isComment$1 = isNodeType(8);
  var isDocument$1 = isNodeType(9);
  var isDocumentFragment$1 = isNodeType(11);
  var isBr = matchNodeNames(["br"]);
  var isImg = matchNodeNames(["img"]);
  var isContentEditableTrue = hasContentEditableState("true");
  var isContentEditableFalse = hasContentEditableState("false");
  var isTableCell = matchNodeNames([
    "td",
    "th"
  ]);
  var isMedia = matchNodeNames([
    "video",
    "audio",
    "object",
    "embed"
  ]);
  var isSupported$1 = function(dom2) {
    return dom2.style !== void 0 && isFunction2(dom2.style.getPropertyValue);
  };
  var rawSet = function(dom2, key, value2) {
    if (isString(value2) || isBoolean(value2) || isNumber(value2)) {
      dom2.setAttribute(key, value2 + "");
    } else {
      console.error("Invalid call to Attribute.set. Key ", key, ":: Value ", value2, ":: Element ", dom2);
      throw new Error("Attribute value was not simple");
    }
  };
  var set = function(element, key, value2) {
    rawSet(element.dom, key, value2);
  };
  var setAll = function(element, attrs) {
    var dom2 = element.dom;
    each$1(attrs, function(v2, k) {
      rawSet(dom2, k, v2);
    });
  };
  var get$4 = function(element, key) {
    var v2 = element.dom.getAttribute(key);
    return v2 === null ? void 0 : v2;
  };
  var getOpt = function(element, key) {
    return Optional.from(get$4(element, key));
  };
  var has$1 = function(element, key) {
    var dom2 = element.dom;
    return dom2 && dom2.hasAttribute ? dom2.hasAttribute(key) : false;
  };
  var remove$1 = function(element, key) {
    element.dom.removeAttribute(key);
  };
  var clone = function(element) {
    return foldl(element.dom.attributes, function(acc, attr) {
      acc[attr.name] = attr.value;
      return acc;
    }, {});
  };
  var internalSet = function(dom2, property, value2) {
    if (!isString(value2)) {
      console.error("Invalid call to CSS.set. Property ", property, ":: Value ", value2, ":: Element ", dom2);
      throw new Error("CSS value must be a string: " + value2);
    }
    if (isSupported$1(dom2)) {
      dom2.style.setProperty(property, value2);
    }
  };
  var setAll$1 = function(element, css) {
    var dom2 = element.dom;
    each$1(css, function(v2, k) {
      internalSet(dom2, k, v2);
    });
  };
  var get$5 = function(element, property) {
    var dom2 = element.dom;
    var styles = window.getComputedStyle(dom2);
    var r3 = styles.getPropertyValue(property);
    return r3 === "" && !inBody(element) ? getUnsafeProperty(dom2, property) : r3;
  };
  var getUnsafeProperty = function(dom2, property) {
    return isSupported$1(dom2) ? dom2.style.getPropertyValue(property) : "";
  };
  var getRaw = function(element, property) {
    var dom2 = element.dom;
    var raw = getUnsafeProperty(dom2, property);
    return Optional.from(raw).filter(function(r3) {
      return r3.length > 0;
    });
  };
  var getAllRaw = function(element) {
    var css = {};
    var dom2 = element.dom;
    if (isSupported$1(dom2)) {
      for (var i = 0; i < dom2.style.length; i++) {
        var ruleName = dom2.style.item(i);
        css[ruleName] = dom2.style[ruleName];
      }
    }
    return css;
  };
  var reflow = function(e) {
    return e.dom.offsetWidth;
  };
  var browser$1 = detect$3().browser;
  var firstElement = function(nodes) {
    return find(nodes, isElement);
  };
  var getTableCaptionDeltaY = function(elm) {
    if (browser$1.isFirefox() && name(elm) === "table") {
      return firstElement(children(elm)).filter(function(elm2) {
        return name(elm2) === "caption";
      }).bind(function(caption) {
        return firstElement(nextSiblings(caption)).map(function(body) {
          var bodyTop = body.dom.offsetTop;
          var captionTop = caption.dom.offsetTop;
          var captionHeight = caption.dom.offsetHeight;
          return bodyTop <= captionTop ? -captionHeight : 0;
        });
      }).getOr(0);
    } else {
      return 0;
    }
  };
  var hasChild = function(elm, child2) {
    return elm.children && contains(elm.children, child2);
  };
  var getPos = function(body, elm, rootElm) {
    var x2 = 0, y2 = 0, offsetParent;
    var doc2 = body.ownerDocument;
    var pos;
    rootElm = rootElm ? rootElm : body;
    if (elm) {
      if (rootElm === body && elm.getBoundingClientRect && get$5(SugarElement.fromDom(body), "position") === "static") {
        pos = elm.getBoundingClientRect();
        x2 = pos.left + (doc2.documentElement.scrollLeft || body.scrollLeft) - doc2.documentElement.clientLeft;
        y2 = pos.top + (doc2.documentElement.scrollTop || body.scrollTop) - doc2.documentElement.clientTop;
        return {
          x: x2,
          y: y2
        };
      }
      offsetParent = elm;
      while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType && !hasChild(offsetParent, rootElm)) {
        x2 += offsetParent.offsetLeft || 0;
        y2 += offsetParent.offsetTop || 0;
        offsetParent = offsetParent.offsetParent;
      }
      offsetParent = elm.parentNode;
      while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType && !hasChild(offsetParent, rootElm)) {
        x2 -= offsetParent.scrollLeft || 0;
        y2 -= offsetParent.scrollTop || 0;
        offsetParent = offsetParent.parentNode;
      }
      y2 += getTableCaptionDeltaY(SugarElement.fromDom(elm));
    }
    return {
      x: x2,
      y: y2
    };
  };
  var exports$1 = {}, module$1 = { exports: exports$1 };
  (function(define, exports, module2, require) {
    (function(f) {
      if (typeof exports === "object" && typeof module2 !== "undefined") {
        module2.exports = f();
      } else if (typeof define === "function" && define.amd) {
        define([], f);
      } else {
        var g;
        if (typeof window !== "undefined") {
          g = window;
        } else if (typeof global !== "undefined") {
          g = global;
        } else if (typeof self !== "undefined") {
          g = self;
        } else {
          g = this;
        }
        g.EphoxContactWrapper = f();
      }
    })(function() {
      return function() {
        function r3(e, n2, t2) {
          function o(i2, f) {
            if (!n2[i2]) {
              if (!e[i2]) {
                var c = typeof require == "function" && require;
                if (!f && c)
                  return c(i2, true);
                if (u2)
                  return u2(i2, true);
                var a = new Error("Cannot find module '" + i2 + "'");
                throw a.code = "MODULE_NOT_FOUND", a;
              }
              var p2 = n2[i2] = { exports: {} };
              e[i2][0].call(p2.exports, function(r4) {
                var n3 = e[i2][1][r4];
                return o(n3 || r4);
              }, p2, p2.exports, r3, e, n2, t2);
            }
            return n2[i2].exports;
          }
          for (var u2 = typeof require == "function" && require, i = 0; i < t2.length; i++)
            o(t2[i]);
          return o;
        }
        return r3;
      }()({
        1: [
          function(require2, module3, exports2) {
            var process2 = module3.exports = {};
            var cachedSetTimeout;
            var cachedClearTimeout;
            function defaultSetTimout() {
              throw new Error("setTimeout has not been defined");
            }
            function defaultClearTimeout() {
              throw new Error("clearTimeout has not been defined");
            }
            (function() {
              try {
                if (typeof setTimeout === "function") {
                  cachedSetTimeout = setTimeout;
                } else {
                  cachedSetTimeout = defaultSetTimout;
                }
              } catch (e) {
                cachedSetTimeout = defaultSetTimout;
              }
              try {
                if (typeof clearTimeout === "function") {
                  cachedClearTimeout = clearTimeout;
                } else {
                  cachedClearTimeout = defaultClearTimeout;
                }
              } catch (e) {
                cachedClearTimeout = defaultClearTimeout;
              }
            })();
            function runTimeout(fun) {
              if (cachedSetTimeout === setTimeout) {
                return setTimeout(fun, 0);
              }
              if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                cachedSetTimeout = setTimeout;
                return setTimeout(fun, 0);
              }
              try {
                return cachedSetTimeout(fun, 0);
              } catch (e) {
                try {
                  return cachedSetTimeout.call(null, fun, 0);
                } catch (e2) {
                  return cachedSetTimeout.call(this, fun, 0);
                }
              }
            }
            function runClearTimeout(marker) {
              if (cachedClearTimeout === clearTimeout) {
                return clearTimeout(marker);
              }
              if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                cachedClearTimeout = clearTimeout;
                return clearTimeout(marker);
              }
              try {
                return cachedClearTimeout(marker);
              } catch (e) {
                try {
                  return cachedClearTimeout.call(null, marker);
                } catch (e2) {
                  return cachedClearTimeout.call(this, marker);
                }
              }
            }
            var queue = [];
            var draining = false;
            var currentQueue;
            var queueIndex = -1;
            function cleanUpNextTick() {
              if (!draining || !currentQueue) {
                return;
              }
              draining = false;
              if (currentQueue.length) {
                queue = currentQueue.concat(queue);
              } else {
                queueIndex = -1;
              }
              if (queue.length) {
                drainQueue();
              }
            }
            function drainQueue() {
              if (draining) {
                return;
              }
              var timeout = runTimeout(cleanUpNextTick);
              draining = true;
              var len = queue.length;
              while (len) {
                currentQueue = queue;
                queue = [];
                while (++queueIndex < len) {
                  if (currentQueue) {
                    currentQueue[queueIndex].run();
                  }
                }
                queueIndex = -1;
                len = queue.length;
              }
              currentQueue = null;
              draining = false;
              runClearTimeout(timeout);
            }
            process2.nextTick = function(fun) {
              var args = new Array(arguments.length - 1);
              if (arguments.length > 1) {
                for (var i = 1; i < arguments.length; i++) {
                  args[i - 1] = arguments[i];
                }
              }
              queue.push(new Item(fun, args));
              if (queue.length === 1 && !draining) {
                runTimeout(drainQueue);
              }
            };
            function Item(fun, array) {
              this.fun = fun;
              this.array = array;
            }
            Item.prototype.run = function() {
              this.fun.apply(null, this.array);
            };
            process2.title = "browser";
            process2.browser = true;
            process2.env = {};
            process2.argv = [];
            process2.version = "";
            process2.versions = {};
            function noop2() {
            }
            process2.on = noop2;
            process2.addListener = noop2;
            process2.once = noop2;
            process2.off = noop2;
            process2.removeListener = noop2;
            process2.removeAllListeners = noop2;
            process2.emit = noop2;
            process2.prependListener = noop2;
            process2.prependOnceListener = noop2;
            process2.listeners = function(name2) {
              return [];
            };
            process2.binding = function(name2) {
              throw new Error("process.binding is not supported");
            };
            process2.cwd = function() {
              return "/";
            };
            process2.chdir = function(dir2) {
              throw new Error("process.chdir is not supported");
            };
            process2.umask = function() {
              return 0;
            };
          },
          {}
        ],
        2: [
          function(require2, module3, exports2) {
            (function(setImmediate2) {
              (function(root) {
                var setTimeoutFunc = setTimeout;
                function noop2() {
                }
                function bind2(fn, thisArg) {
                  return function() {
                    fn.apply(thisArg, arguments);
                  };
                }
                function Promise2(fn) {
                  if (typeof this !== "object")
                    throw new TypeError("Promises must be constructed via new");
                  if (typeof fn !== "function")
                    throw new TypeError("not a function");
                  this._state = 0;
                  this._handled = false;
                  this._value = void 0;
                  this._deferreds = [];
                  doResolve(fn, this);
                }
                function handle2(self2, deferred) {
                  while (self2._state === 3) {
                    self2 = self2._value;
                  }
                  if (self2._state === 0) {
                    self2._deferreds.push(deferred);
                    return;
                  }
                  self2._handled = true;
                  Promise2._immediateFn(function() {
                    var cb2 = self2._state === 1 ? deferred.onFulfilled : deferred.onRejected;
                    if (cb2 === null) {
                      (self2._state === 1 ? resolve2 : reject)(deferred.promise, self2._value);
                      return;
                    }
                    var ret;
                    try {
                      ret = cb2(self2._value);
                    } catch (e) {
                      reject(deferred.promise, e);
                      return;
                    }
                    resolve2(deferred.promise, ret);
                  });
                }
                function resolve2(self2, newValue) {
                  try {
                    if (newValue === self2)
                      throw new TypeError("A promise cannot be resolved with itself.");
                    if (newValue && (typeof newValue === "object" || typeof newValue === "function")) {
                      var then = newValue.then;
                      if (newValue instanceof Promise2) {
                        self2._state = 3;
                        self2._value = newValue;
                        finale(self2);
                        return;
                      } else if (typeof then === "function") {
                        doResolve(bind2(then, newValue), self2);
                        return;
                      }
                    }
                    self2._state = 1;
                    self2._value = newValue;
                    finale(self2);
                  } catch (e) {
                    reject(self2, e);
                  }
                }
                function reject(self2, newValue) {
                  self2._state = 2;
                  self2._value = newValue;
                  finale(self2);
                }
                function finale(self2) {
                  if (self2._state === 2 && self2._deferreds.length === 0) {
                    Promise2._immediateFn(function() {
                      if (!self2._handled) {
                        Promise2._unhandledRejectionFn(self2._value);
                      }
                    });
                  }
                  for (var i = 0, len = self2._deferreds.length; i < len; i++) {
                    handle2(self2, self2._deferreds[i]);
                  }
                  self2._deferreds = null;
                }
                function Handler(onFulfilled, onRejected, promise2) {
                  this.onFulfilled = typeof onFulfilled === "function" ? onFulfilled : null;
                  this.onRejected = typeof onRejected === "function" ? onRejected : null;
                  this.promise = promise2;
                }
                function doResolve(fn, self2) {
                  var done2 = false;
                  try {
                    fn(function(value2) {
                      if (done2)
                        return;
                      done2 = true;
                      resolve2(self2, value2);
                    }, function(reason) {
                      if (done2)
                        return;
                      done2 = true;
                      reject(self2, reason);
                    });
                  } catch (ex) {
                    if (done2)
                      return;
                    done2 = true;
                    reject(self2, ex);
                  }
                }
                Promise2.prototype["catch"] = function(onRejected) {
                  return this.then(null, onRejected);
                };
                Promise2.prototype.then = function(onFulfilled, onRejected) {
                  var prom = new this.constructor(noop2);
                  handle2(this, new Handler(onFulfilled, onRejected, prom));
                  return prom;
                };
                Promise2.all = function(arr2) {
                  var args = Array.prototype.slice.call(arr2);
                  return new Promise2(function(resolve3, reject2) {
                    if (args.length === 0)
                      return resolve3([]);
                    var remaining = args.length;
                    function res(i2, val) {
                      try {
                        if (val && (typeof val === "object" || typeof val === "function")) {
                          var then = val.then;
                          if (typeof then === "function") {
                            then.call(val, function(val2) {
                              res(i2, val2);
                            }, reject2);
                            return;
                          }
                        }
                        args[i2] = val;
                        if (--remaining === 0) {
                          resolve3(args);
                        }
                      } catch (ex) {
                        reject2(ex);
                      }
                    }
                    for (var i = 0; i < args.length; i++) {
                      res(i, args[i]);
                    }
                  });
                };
                Promise2.resolve = function(value2) {
                  if (value2 && typeof value2 === "object" && value2.constructor === Promise2) {
                    return value2;
                  }
                  return new Promise2(function(resolve3) {
                    resolve3(value2);
                  });
                };
                Promise2.reject = function(value2) {
                  return new Promise2(function(resolve3, reject2) {
                    reject2(value2);
                  });
                };
                Promise2.race = function(values2) {
                  return new Promise2(function(resolve3, reject2) {
                    for (var i = 0, len = values2.length; i < len; i++) {
                      values2[i].then(resolve3, reject2);
                    }
                  });
                };
                Promise2._immediateFn = typeof setImmediate2 === "function" ? function(fn) {
                  setImmediate2(fn);
                } : function(fn) {
                  setTimeoutFunc(fn, 0);
                };
                Promise2._unhandledRejectionFn = function _unhandledRejectionFn(err) {
                  if (typeof console !== "undefined" && console) {
                    console.warn("Possible Unhandled Promise Rejection:", err);
                  }
                };
                Promise2._setImmediateFn = function _setImmediateFn(fn) {
                  Promise2._immediateFn = fn;
                };
                Promise2._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {
                  Promise2._unhandledRejectionFn = fn;
                };
                if (typeof module3 !== "undefined" && module3.exports) {
                  module3.exports = Promise2;
                } else if (!root.Promise) {
                  root.Promise = Promise2;
                }
              })(this);
            }).call(this, require2("timers").setImmediate);
          },
          { "timers": 3 }
        ],
        3: [
          function(require2, module3, exports2) {
            (function(setImmediate2, clearImmediate) {
              var nextTick = require2("process/browser.js").nextTick;
              var apply2 = Function.prototype.apply;
              var slice2 = Array.prototype.slice;
              var immediateIds = {};
              var nextImmediateId = 0;
              exports2.setTimeout = function() {
                return new Timeout(apply2.call(setTimeout, window, arguments), clearTimeout);
              };
              exports2.setInterval = function() {
                return new Timeout(apply2.call(setInterval, window, arguments), clearInterval);
              };
              exports2.clearTimeout = exports2.clearInterval = function(timeout) {
                timeout.close();
              };
              function Timeout(id2, clearFn) {
                this._id = id2;
                this._clearFn = clearFn;
              }
              Timeout.prototype.unref = Timeout.prototype.ref = function() {
              };
              Timeout.prototype.close = function() {
                this._clearFn.call(window, this._id);
              };
              exports2.enroll = function(item, msecs) {
                clearTimeout(item._idleTimeoutId);
                item._idleTimeout = msecs;
              };
              exports2.unenroll = function(item) {
                clearTimeout(item._idleTimeoutId);
                item._idleTimeout = -1;
              };
              exports2._unrefActive = exports2.active = function(item) {
                clearTimeout(item._idleTimeoutId);
                var msecs = item._idleTimeout;
                if (msecs >= 0) {
                  item._idleTimeoutId = setTimeout(function onTimeout() {
                    if (item._onTimeout)
                      item._onTimeout();
                  }, msecs);
                }
              };
              exports2.setImmediate = typeof setImmediate2 === "function" ? setImmediate2 : function(fn) {
                var id2 = nextImmediateId++;
                var args = arguments.length < 2 ? false : slice2.call(arguments, 1);
                immediateIds[id2] = true;
                nextTick(function onNextTick() {
                  if (immediateIds[id2]) {
                    if (args) {
                      fn.apply(null, args);
                    } else {
                      fn.call(null);
                    }
                    exports2.clearImmediate(id2);
                  }
                });
                return id2;
              };
              exports2.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id2) {
                delete immediateIds[id2];
              };
            }).call(this, require2("timers").setImmediate, require2("timers").clearImmediate);
          },
          {
            "process/browser.js": 1,
            "timers": 3
          }
        ],
        4: [
          function(require2, module3, exports2) {
            var promisePolyfill = require2("promise-polyfill");
            var Global = function() {
              if (typeof window !== "undefined") {
                return window;
              } else {
                return Function("return this;")();
              }
            }();
            module3.exports = { boltExport: Global.Promise || promisePolyfill };
          },
          { "promise-polyfill": 2 }
        ]
      }, {}, [4])(4);
    });
  })(void 0, exports$1, module$1, void 0);
  var Promise = module$1.exports.boltExport;
  var nu$3 = function(baseFn) {
    var data2 = Optional.none();
    var callbacks = [];
    var map2 = function(f) {
      return nu$3(function(nCallback) {
        get2(function(data3) {
          nCallback(f(data3));
        });
      });
    };
    var get2 = function(nCallback) {
      if (isReady()) {
        call2(nCallback);
      } else {
        callbacks.push(nCallback);
      }
    };
    var set2 = function(x2) {
      if (!isReady()) {
        data2 = Optional.some(x2);
        run(callbacks);
        callbacks = [];
      }
    };
    var isReady = function() {
      return data2.isSome();
    };
    var run = function(cbs) {
      each(cbs, call2);
    };
    var call2 = function(cb2) {
      data2.each(function(x2) {
        setTimeout(function() {
          cb2(x2);
        }, 0);
      });
    };
    baseFn(set2);
    return {
      get: get2,
      map: map2,
      isReady
    };
  };
  var pure = function(a) {
    return nu$3(function(callback) {
      callback(a);
    });
  };
  var LazyValue = {
    nu: nu$3,
    pure
  };
  var errorReporter = function(err) {
    setTimeout(function() {
      throw err;
    }, 0);
  };
  var make = function(run) {
    var get2 = function(callback) {
      run().then(callback, errorReporter);
    };
    var map2 = function(fab) {
      return make(function() {
        return run().then(fab);
      });
    };
    var bind2 = function(aFutureB) {
      return make(function() {
        return run().then(function(v2) {
          return aFutureB(v2).toPromise();
        });
      });
    };
    var anonBind = function(futureB) {
      return make(function() {
        return run().then(function() {
          return futureB.toPromise();
        });
      });
    };
    var toLazy = function() {
      return LazyValue.nu(get2);
    };
    var toCached = function() {
      var cache = null;
      return make(function() {
        if (cache === null) {
          cache = run();
        }
        return cache;
      });
    };
    var toPromise = run;
    return {
      map: map2,
      bind: bind2,
      anonBind,
      toLazy,
      toCached,
      toPromise,
      get: get2
    };
  };
  var nu$4 = function(baseFn) {
    return make(function() {
      return new Promise(baseFn);
    });
  };
  var pure$1 = function(a) {
    return make(function() {
      return Promise.resolve(a);
    });
  };
  var Future = {
    nu: nu$4,
    pure: pure$1
  };
  var par = function(asyncValues, nu2) {
    return nu2(function(callback) {
      var r3 = [];
      var count2 = 0;
      var cb2 = function(i) {
        return function(value2) {
          r3[i] = value2;
          count2++;
          if (count2 >= asyncValues.length) {
            callback(r3);
          }
        };
      };
      if (asyncValues.length === 0) {
        callback([]);
      } else {
        each(asyncValues, function(asyncValue, i) {
          asyncValue.get(cb2(i));
        });
      }
    });
  };
  var par$1 = function(futures) {
    return par(futures, Future.nu);
  };
  var value = function(o) {
    var is2 = function(v2) {
      return o === v2;
    };
    var or2 = function(_opt) {
      return value(o);
    };
    var orThunk = function(_f) {
      return value(o);
    };
    var map2 = function(f) {
      return value(f(o));
    };
    var mapError = function(_f) {
      return value(o);
    };
    var each2 = function(f) {
      f(o);
    };
    var bind2 = function(f) {
      return f(o);
    };
    var fold = function(_, onValue) {
      return onValue(o);
    };
    var exists2 = function(f) {
      return f(o);
    };
    var forall2 = function(f) {
      return f(o);
    };
    var toOptional = function() {
      return Optional.some(o);
    };
    return {
      is: is2,
      isValue: always,
      isError: never,
      getOr: constant(o),
      getOrThunk: constant(o),
      getOrDie: constant(o),
      or: or2,
      orThunk,
      fold,
      map: map2,
      mapError,
      each: each2,
      bind: bind2,
      exists: exists2,
      forall: forall2,
      toOptional
    };
  };
  var error = function(message) {
    var getOrThunk = function(f) {
      return f();
    };
    var getOrDie = function() {
      return die(String(message))();
    };
    var or2 = function(opt) {
      return opt;
    };
    var orThunk = function(f) {
      return f();
    };
    var map2 = function(_f) {
      return error(message);
    };
    var mapError = function(f) {
      return error(f(message));
    };
    var bind2 = function(_f) {
      return error(message);
    };
    var fold = function(onError, _) {
      return onError(message);
    };
    return {
      is: never,
      isValue: never,
      isError: always,
      getOr: identity,
      getOrThunk,
      getOrDie,
      or: or2,
      orThunk,
      fold,
      map: map2,
      mapError,
      each: noop,
      bind: bind2,
      exists: never,
      forall: always,
      toOptional: Optional.none
    };
  };
  var fromOption = function(opt, err) {
    return opt.fold(function() {
      return error(err);
    }, value);
  };
  var Result = {
    value,
    error,
    fromOption
  };
  var generate = function(cases) {
    if (!isArray(cases)) {
      throw new Error("cases must be an array");
    }
    if (cases.length === 0) {
      throw new Error("there must be at least one case");
    }
    var constructors = [];
    var adt2 = {};
    each(cases, function(acase, count2) {
      var keys$1 = keys(acase);
      if (keys$1.length !== 1) {
        throw new Error("one and only one name per case");
      }
      var key = keys$1[0];
      var value2 = acase[key];
      if (adt2[key] !== void 0) {
        throw new Error("duplicate key detected:" + key);
      } else if (key === "cata") {
        throw new Error("cannot have a case named cata (sorry)");
      } else if (!isArray(value2)) {
        throw new Error("case arguments must be an array");
      }
      constructors.push(key);
      adt2[key] = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var argLength = args.length;
        if (argLength !== value2.length) {
          throw new Error("Wrong number of arguments to case " + key + ". Expected " + value2.length + " (" + value2 + "), got " + argLength);
        }
        var match2 = function(branches) {
          var branchKeys = keys(branches);
          if (constructors.length !== branchKeys.length) {
            throw new Error("Wrong number of arguments to match. Expected: " + constructors.join(",") + "\nActual: " + branchKeys.join(","));
          }
          var allReqd = forall(constructors, function(reqKey) {
            return contains(branchKeys, reqKey);
          });
          if (!allReqd) {
            throw new Error("Not all branches were specified when using match. Specified: " + branchKeys.join(", ") + "\nRequired: " + constructors.join(", "));
          }
          return branches[key].apply(null, args);
        };
        return {
          fold: function() {
            var foldArgs = [];
            for (var _i2 = 0; _i2 < arguments.length; _i2++) {
              foldArgs[_i2] = arguments[_i2];
            }
            if (foldArgs.length !== cases.length) {
              throw new Error("Wrong number of arguments to fold. Expected " + cases.length + ", got " + foldArgs.length);
            }
            var target = foldArgs[count2];
            return target.apply(null, args);
          },
          match: match2,
          log: function(label) {
            console.log(label, {
              constructors,
              constructor: key,
              params: args
            });
          }
        };
      };
    });
    return adt2;
  };
  var Adt = { generate };
  Adt.generate([
    {
      bothErrors: [
        "error1",
        "error2"
      ]
    },
    {
      firstError: [
        "error1",
        "value2"
      ]
    },
    {
      secondError: [
        "value1",
        "error2"
      ]
    },
    {
      bothValues: [
        "value1",
        "value2"
      ]
    }
  ]);
  var unite = function(result) {
    return result.fold(identity, identity);
  };
  function ClosestOrAncestor(is2, ancestor2, scope, a, isRoot) {
    if (is2(scope, a)) {
      return Optional.some(scope);
    } else if (isFunction2(isRoot) && isRoot(scope)) {
      return Optional.none();
    } else {
      return ancestor2(scope, a, isRoot);
    }
  }
  var ancestor = function(scope, predicate, isRoot) {
    var element = scope.dom;
    var stop2 = isFunction2(isRoot) ? isRoot : never;
    while (element.parentNode) {
      element = element.parentNode;
      var el = SugarElement.fromDom(element);
      if (predicate(el)) {
        return Optional.some(el);
      } else if (stop2(el)) {
        break;
      }
    }
    return Optional.none();
  };
  var closest = function(scope, predicate, isRoot) {
    var is2 = function(s, test2) {
      return test2(s);
    };
    return ClosestOrAncestor(is2, ancestor, scope, predicate, isRoot);
  };
  var sibling = function(scope, predicate) {
    var element = scope.dom;
    if (!element.parentNode) {
      return Optional.none();
    }
    return child$1(SugarElement.fromDom(element.parentNode), function(x2) {
      return !eq$2(scope, x2) && predicate(x2);
    });
  };
  var child$1 = function(scope, predicate) {
    var pred = function(node) {
      return predicate(SugarElement.fromDom(node));
    };
    var result = find(scope.dom.childNodes, pred);
    return result.map(SugarElement.fromDom);
  };
  var ancestor$1 = function(scope, selector, isRoot) {
    return ancestor(scope, function(e) {
      return is$1(e, selector);
    }, isRoot);
  };
  var descendant = function(scope, selector) {
    return one(selector, scope);
  };
  var closest$1 = function(scope, selector, isRoot) {
    var is2 = function(element, selector2) {
      return is$1(element, selector2);
    };
    return ClosestOrAncestor(is2, ancestor$1, scope, selector, isRoot);
  };
  var promise = function() {
    var bind2 = function(fn, thisArg) {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        fn.apply(thisArg, args);
      };
    };
    var isArray2 = Array.isArray || function(value2) {
      return Object.prototype.toString.call(value2) === "[object Array]";
    };
    var Promise2 = function(fn) {
      if (typeof this !== "object") {
        throw new TypeError("Promises must be constructed via new");
      }
      if (typeof fn !== "function") {
        throw new TypeError("not a function");
      }
      this._state = null;
      this._value = null;
      this._deferreds = [];
      doResolve(fn, bind2(resolve2, this), bind2(reject, this));
    };
    var asap = Promise2.immediateFn || typeof setImmediate === "function" && setImmediate || function(fn) {
      return setTimeout(fn, 1);
    };
    function handle2(deferred) {
      var me2 = this;
      if (this._state === null) {
        this._deferreds.push(deferred);
        return;
      }
      asap(function() {
        var cb2 = me2._state ? deferred.onFulfilled : deferred.onRejected;
        if (cb2 === null) {
          (me2._state ? deferred.resolve : deferred.reject)(me2._value);
          return;
        }
        var ret;
        try {
          ret = cb2(me2._value);
        } catch (e) {
          deferred.reject(e);
          return;
        }
        deferred.resolve(ret);
      });
    }
    function resolve2(newValue) {
      try {
        if (newValue === this) {
          throw new TypeError("A promise cannot be resolved with itself.");
        }
        if (newValue && (typeof newValue === "object" || typeof newValue === "function")) {
          var then = newValue.then;
          if (typeof then === "function") {
            doResolve(bind2(then, newValue), bind2(resolve2, this), bind2(reject, this));
            return;
          }
        }
        this._state = true;
        this._value = newValue;
        finale.call(this);
      } catch (e) {
        reject.call(this, e);
      }
    }
    function reject(newValue) {
      this._state = false;
      this._value = newValue;
      finale.call(this);
    }
    function finale() {
      for (var i = 0, len = this._deferreds.length; i < len; i++) {
        handle2.call(this, this._deferreds[i]);
      }
      this._deferreds = null;
    }
    function Handler(onFulfilled, onRejected, resolve3, reject2) {
      this.onFulfilled = typeof onFulfilled === "function" ? onFulfilled : null;
      this.onRejected = typeof onRejected === "function" ? onRejected : null;
      this.resolve = resolve3;
      this.reject = reject2;
    }
    var doResolve = function(fn, onFulfilled, onRejected) {
      var done2 = false;
      try {
        fn(function(value2) {
          if (done2) {
            return;
          }
          done2 = true;
          onFulfilled(value2);
        }, function(reason) {
          if (done2) {
            return;
          }
          done2 = true;
          onRejected(reason);
        });
      } catch (ex) {
        if (done2) {
          return;
        }
        done2 = true;
        onRejected(ex);
      }
    };
    Promise2.prototype.catch = function(onRejected) {
      return this.then(null, onRejected);
    };
    Promise2.prototype.then = function(onFulfilled, onRejected) {
      var me2 = this;
      return new Promise2(function(resolve3, reject2) {
        handle2.call(me2, new Handler(onFulfilled, onRejected, resolve3, reject2));
      });
    };
    Promise2.all = function() {
      var values2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        values2[_i] = arguments[_i];
      }
      var args = Array.prototype.slice.call(values2.length === 1 && isArray2(values2[0]) ? values2[0] : values2);
      return new Promise2(function(resolve3, reject2) {
        if (args.length === 0) {
          return resolve3([]);
        }
        var remaining = args.length;
        var res = function(i2, val) {
          try {
            if (val && (typeof val === "object" || typeof val === "function")) {
              var then = val.then;
              if (typeof then === "function") {
                then.call(val, function(val2) {
                  res(i2, val2);
                }, reject2);
                return;
              }
            }
            args[i2] = val;
            if (--remaining === 0) {
              resolve3(args);
            }
          } catch (ex) {
            reject2(ex);
          }
        };
        for (var i = 0; i < args.length; i++) {
          res(i, args[i]);
        }
      });
    };
    Promise2.resolve = function(value2) {
      if (value2 && typeof value2 === "object" && value2.constructor === Promise2) {
        return value2;
      }
      return new Promise2(function(resolve3) {
        resolve3(value2);
      });
    };
    Promise2.reject = function(value2) {
      return new Promise2(function(resolve3, reject2) {
        reject2(value2);
      });
    };
    Promise2.race = function(values2) {
      return new Promise2(function(resolve3, reject2) {
        for (var i = 0, len = values2.length; i < len; i++) {
          values2[i].then(resolve3, reject2);
        }
      });
    };
    return Promise2;
  };
  var promiseObj = window.Promise ? window.Promise : promise();
  var requestAnimationFramePromise;
  var requestAnimationFrame = function(callback, element) {
    var requestAnimationFrameFunc = window.requestAnimationFrame;
    var vendors = [
      "ms",
      "moz",
      "webkit"
    ];
    var featurefill = function(cb2) {
      window.setTimeout(cb2, 0);
    };
    for (var i = 0; i < vendors.length && !requestAnimationFrameFunc; i++) {
      requestAnimationFrameFunc = window[vendors[i] + "RequestAnimationFrame"];
    }
    if (!requestAnimationFrameFunc) {
      requestAnimationFrameFunc = featurefill;
    }
    requestAnimationFrameFunc(callback, element);
  };
  var wrappedSetTimeout = function(callback, time) {
    if (typeof time !== "number") {
      time = 0;
    }
    return setTimeout(callback, time);
  };
  var wrappedSetInterval = function(callback, time) {
    if (typeof time !== "number") {
      time = 1;
    }
    return setInterval(callback, time);
  };
  var wrappedClearTimeout = function(id2) {
    return clearTimeout(id2);
  };
  var wrappedClearInterval = function(id2) {
    return clearInterval(id2);
  };
  var debounce = function(callback, time) {
    var timer;
    var func = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      clearTimeout(timer);
      timer = wrappedSetTimeout(function() {
        callback.apply(this, args);
      }, time);
    };
    func.stop = function() {
      clearTimeout(timer);
    };
    return func;
  };
  var Delay = {
    requestAnimationFrame: function(callback, element) {
      if (requestAnimationFramePromise) {
        requestAnimationFramePromise.then(callback);
        return;
      }
      requestAnimationFramePromise = new promiseObj(function(resolve2) {
        if (!element) {
          element = document.body;
        }
        requestAnimationFrame(resolve2, element);
      }).then(callback);
    },
    setTimeout: wrappedSetTimeout,
    setInterval: wrappedSetInterval,
    setEditorTimeout: function(editor, callback, time) {
      return wrappedSetTimeout(function() {
        if (!editor.removed) {
          callback();
        }
      }, time);
    },
    setEditorInterval: function(editor, callback, time) {
      var timer = wrappedSetInterval(function() {
        if (!editor.removed) {
          callback();
        } else {
          clearInterval(timer);
        }
      }, time);
      return timer;
    },
    debounce,
    throttle: debounce,
    clearInterval: wrappedClearInterval,
    clearTimeout: wrappedClearTimeout
  };
  var StyleSheetLoader = function(documentOrShadowRoot, settings) {
    if (settings === void 0) {
      settings = {};
    }
    var idCount = 0;
    var loadedStates = {};
    var edos = SugarElement.fromDom(documentOrShadowRoot);
    var doc2 = documentOrOwner(edos);
    var maxLoadTime = settings.maxLoadTime || 5e3;
    var _setReferrerPolicy = function(referrerPolicy) {
      settings.referrerPolicy = referrerPolicy;
    };
    var addStyle = function(element) {
      append(getStyleContainer(edos), element);
    };
    var removeStyle = function(id2) {
      var styleContainer = getStyleContainer(edos);
      descendant(styleContainer, "#" + id2).each(remove);
    };
    var getOrCreateState = function(url) {
      return get$1(loadedStates, url).getOrThunk(function() {
        return {
          id: "mce-u" + idCount++,
          passed: [],
          failed: [],
          count: 0
        };
      });
    };
    var load = function(url, success, failure) {
      var link;
      var urlWithSuffix = Tools._addCacheSuffix(url);
      var state = getOrCreateState(urlWithSuffix);
      loadedStates[urlWithSuffix] = state;
      state.count++;
      var resolve2 = function(callbacks, status) {
        var i = callbacks.length;
        while (i--) {
          callbacks[i]();
        }
        state.status = status;
        state.passed = [];
        state.failed = [];
        if (link) {
          link.onload = null;
          link.onerror = null;
          link = null;
        }
      };
      var passed = function() {
        return resolve2(state.passed, 2);
      };
      var failed = function() {
        return resolve2(state.failed, 3);
      };
      var wait = function(testCallback, waitCallback) {
        if (!testCallback()) {
          if (Date.now() - startTime < maxLoadTime) {
            Delay.setTimeout(waitCallback);
          } else {
            failed();
          }
        }
      };
      var waitForWebKitLinkLoaded = function() {
        wait(function() {
          var styleSheets = documentOrShadowRoot.styleSheets;
          var i = styleSheets.length;
          while (i--) {
            var styleSheet = styleSheets[i];
            var owner2 = styleSheet.ownerNode;
            if (owner2 && owner2.id === link.id) {
              passed();
              return true;
            }
          }
          return false;
        }, waitForWebKitLinkLoaded);
      };
      if (success) {
        state.passed.push(success);
      }
      if (failure) {
        state.failed.push(failure);
      }
      if (state.status === 1) {
        return;
      }
      if (state.status === 2) {
        passed();
        return;
      }
      if (state.status === 3) {
        failed();
        return;
      }
      state.status = 1;
      var linkElem = SugarElement.fromTag("link", doc2.dom);
      setAll(linkElem, {
        rel: "stylesheet",
        type: "text/css",
        id: state.id
      });
      var startTime = Date.now();
      if (settings.contentCssCors) {
        set(linkElem, "crossOrigin", "anonymous");
      }
      if (settings.referrerPolicy) {
        set(linkElem, "referrerpolicy", settings.referrerPolicy);
      }
      link = linkElem.dom;
      link.onload = waitForWebKitLinkLoaded;
      link.onerror = failed;
      addStyle(linkElem);
      set(linkElem, "href", urlWithSuffix);
    };
    var loadF = function(url) {
      return Future.nu(function(resolve2) {
        load(url, compose(resolve2, constant(Result.value(url))), compose(resolve2, constant(Result.error(url))));
      });
    };
    var loadAll = function(urls, success, failure) {
      par$1(map(urls, loadF)).get(function(result) {
        var parts = partition(result, function(r3) {
          return r3.isValue();
        });
        if (parts.fail.length > 0) {
          failure(parts.fail.map(unite));
        } else {
          success(parts.pass.map(unite));
        }
      });
    };
    var unload = function(url) {
      var urlWithSuffix = Tools._addCacheSuffix(url);
      get$1(loadedStates, urlWithSuffix).each(function(state) {
        var count2 = --state.count;
        if (count2 === 0) {
          delete loadedStates[urlWithSuffix];
          removeStyle(state.id);
        }
      });
    };
    var unloadAll = function(urls) {
      each(urls, function(url) {
        unload(url);
      });
    };
    return {
      load,
      loadAll,
      unload,
      unloadAll,
      _setReferrerPolicy
    };
  };
  var create$1 = function() {
    var map2 = /* @__PURE__ */ new WeakMap();
    var forElement = function(referenceElement, settings) {
      var root = getRootNode(referenceElement);
      var rootDom = root.dom;
      return Optional.from(map2.get(rootDom)).getOrThunk(function() {
        var sl = StyleSheetLoader(rootDom, settings);
        map2.set(rootDom, sl);
        return sl;
      });
    };
    return { forElement };
  };
  var instance = create$1();
  var DomTreeWalker = function() {
    function DomTreeWalker2(startNode, rootNode) {
      this.node = startNode;
      this.rootNode = rootNode;
      this.current = this.current.bind(this);
      this.next = this.next.bind(this);
      this.prev = this.prev.bind(this);
      this.prev2 = this.prev2.bind(this);
    }
    DomTreeWalker2.prototype.current = function() {
      return this.node;
    };
    DomTreeWalker2.prototype.next = function(shallow2) {
      this.node = this.findSibling(this.node, "firstChild", "nextSibling", shallow2);
      return this.node;
    };
    DomTreeWalker2.prototype.prev = function(shallow2) {
      this.node = this.findSibling(this.node, "lastChild", "previousSibling", shallow2);
      return this.node;
    };
    DomTreeWalker2.prototype.prev2 = function(shallow2) {
      this.node = this.findPreviousNode(this.node, "lastChild", "previousSibling", shallow2);
      return this.node;
    };
    DomTreeWalker2.prototype.findSibling = function(node, startName, siblingName, shallow2) {
      var sibling2, parent2;
      if (node) {
        if (!shallow2 && node[startName]) {
          return node[startName];
        }
        if (node !== this.rootNode) {
          sibling2 = node[siblingName];
          if (sibling2) {
            return sibling2;
          }
          for (parent2 = node.parentNode; parent2 && parent2 !== this.rootNode; parent2 = parent2.parentNode) {
            sibling2 = parent2[siblingName];
            if (sibling2) {
              return sibling2;
            }
          }
        }
      }
    };
    DomTreeWalker2.prototype.findPreviousNode = function(node, startName, siblingName, shallow2) {
      var sibling2, parent2, child2;
      if (node) {
        sibling2 = node[siblingName];
        if (this.rootNode && sibling2 === this.rootNode) {
          return;
        }
        if (sibling2) {
          if (!shallow2) {
            for (child2 = sibling2[startName]; child2; child2 = child2[startName]) {
              if (!child2[startName]) {
                return child2;
              }
            }
          }
          return sibling2;
        }
        parent2 = node.parentNode;
        if (parent2 && parent2 !== this.rootNode) {
          return parent2;
        }
      }
    };
    return DomTreeWalker2;
  }();
  var blocks = [
    "article",
    "aside",
    "details",
    "div",
    "dt",
    "figcaption",
    "footer",
    "form",
    "fieldset",
    "header",
    "hgroup",
    "html",
    "main",
    "nav",
    "section",
    "summary",
    "body",
    "p",
    "dl",
    "multicol",
    "dd",
    "figure",
    "address",
    "center",
    "blockquote",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "listing",
    "xmp",
    "pre",
    "plaintext",
    "menu",
    "dir",
    "ul",
    "ol",
    "li",
    "hr",
    "table",
    "tbody",
    "thead",
    "tfoot",
    "th",
    "tr",
    "td",
    "caption"
  ];
  var tableCells = [
    "td",
    "th"
  ];
  var tableSections = [
    "thead",
    "tbody",
    "tfoot"
  ];
  var textBlocks = [
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "p",
    "div",
    "address",
    "pre",
    "form",
    "blockquote",
    "center",
    "dir",
    "fieldset",
    "header",
    "footer",
    "article",
    "section",
    "hgroup",
    "aside",
    "nav",
    "figure"
  ];
  var headings = [
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6"
  ];
  var listItems = [
    "li",
    "dd",
    "dt"
  ];
  var lists = [
    "ul",
    "ol",
    "dl"
  ];
  var wsElements = [
    "pre",
    "script",
    "textarea",
    "style"
  ];
  var lazyLookup = function(items) {
    var lookup;
    return function(node) {
      lookup = lookup ? lookup : mapToObject(items, always);
      return lookup.hasOwnProperty(name(node));
    };
  };
  var isHeading = lazyLookup(headings);
  var isBlock = lazyLookup(blocks);
  var isTable$1 = function(node) {
    return name(node) === "table";
  };
  var isInline = function(node) {
    return isElement(node) && !isBlock(node);
  };
  var isBr$1 = function(node) {
    return isElement(node) && name(node) === "br";
  };
  var isTextBlock = lazyLookup(textBlocks);
  var isList = lazyLookup(lists);
  var isListItem = lazyLookup(listItems);
  var isTableSection = lazyLookup(tableSections);
  var isTableCell$1 = lazyLookup(tableCells);
  var isWsPreserveElement = lazyLookup(wsElements);
  var ancestor$2 = function(scope, selector, isRoot) {
    return ancestor$1(scope, selector, isRoot).isSome();
  };
  var zeroWidth = "\uFEFF";
  var nbsp = "\xA0";
  var isZwsp = function(char) {
    return char === zeroWidth;
  };
  var removeZwsp = function(s) {
    return s.replace(/\uFEFF/g, "");
  };
  var ZWSP = zeroWidth;
  var isZwsp$1 = isZwsp;
  var trim$2 = removeZwsp;
  var isElement$2 = isElement$1;
  var isText$2 = isText$1;
  var isCaretContainerBlock = function(node) {
    if (isText$2(node)) {
      node = node.parentNode;
    }
    return isElement$2(node) && node.hasAttribute("data-mce-caret");
  };
  var isCaretContainerInline = function(node) {
    return isText$2(node) && isZwsp$1(node.data);
  };
  var isCaretContainer = function(node) {
    return isCaretContainerBlock(node) || isCaretContainerInline(node);
  };
  var hasContent = function(node) {
    return node.firstChild !== node.lastChild || !isBr(node.firstChild);
  };
  var insertInline = function(node, before2) {
    var sibling2;
    var doc2 = node.ownerDocument;
    var textNode = doc2.createTextNode(ZWSP);
    var parentNode = node.parentNode;
    if (!before2) {
      sibling2 = node.nextSibling;
      if (isText$2(sibling2)) {
        if (isCaretContainer(sibling2)) {
          return sibling2;
        }
        if (startsWithCaretContainer(sibling2)) {
          sibling2.splitText(1);
          return sibling2;
        }
      }
      if (node.nextSibling) {
        parentNode.insertBefore(textNode, node.nextSibling);
      } else {
        parentNode.appendChild(textNode);
      }
    } else {
      sibling2 = node.previousSibling;
      if (isText$2(sibling2)) {
        if (isCaretContainer(sibling2)) {
          return sibling2;
        }
        if (endsWithCaretContainer(sibling2)) {
          return sibling2.splitText(sibling2.data.length - 1);
        }
      }
      parentNode.insertBefore(textNode, node);
    }
    return textNode;
  };
  var isBeforeInline = function(pos) {
    var container = pos.container();
    if (!isText$1(container)) {
      return false;
    }
    return container.data.charAt(pos.offset()) === ZWSP || pos.isAtStart() && isCaretContainerInline(container.previousSibling);
  };
  var isAfterInline = function(pos) {
    var container = pos.container();
    if (!isText$1(container)) {
      return false;
    }
    return container.data.charAt(pos.offset() - 1) === ZWSP || pos.isAtEnd() && isCaretContainerInline(container.nextSibling);
  };
  var createBogusBr = function() {
    var br = document.createElement("br");
    br.setAttribute("data-mce-bogus", "1");
    return br;
  };
  var insertBlock = function(blockName, node, before2) {
    var doc2 = node.ownerDocument;
    var blockNode = doc2.createElement(blockName);
    blockNode.setAttribute("data-mce-caret", before2 ? "before" : "after");
    blockNode.setAttribute("data-mce-bogus", "all");
    blockNode.appendChild(createBogusBr());
    var parentNode = node.parentNode;
    if (!before2) {
      if (node.nextSibling) {
        parentNode.insertBefore(blockNode, node.nextSibling);
      } else {
        parentNode.appendChild(blockNode);
      }
    } else {
      parentNode.insertBefore(blockNode, node);
    }
    return blockNode;
  };
  var startsWithCaretContainer = function(node) {
    return isText$2(node) && node.data[0] === ZWSP;
  };
  var endsWithCaretContainer = function(node) {
    return isText$2(node) && node.data[node.data.length - 1] === ZWSP;
  };
  var trimBogusBr = function(elm) {
    var brs = elm.getElementsByTagName("br");
    var lastBr = brs[brs.length - 1];
    if (isBogus(lastBr)) {
      lastBr.parentNode.removeChild(lastBr);
    }
  };
  var showCaretContainerBlock = function(caretContainer) {
    if (caretContainer && caretContainer.hasAttribute("data-mce-caret")) {
      trimBogusBr(caretContainer);
      caretContainer.removeAttribute("data-mce-caret");
      caretContainer.removeAttribute("data-mce-bogus");
      caretContainer.removeAttribute("style");
      caretContainer.removeAttribute("_moz_abspos");
      return caretContainer;
    }
    return null;
  };
  var isRangeInCaretContainerBlock = function(range2) {
    return isCaretContainerBlock(range2.startContainer);
  };
  var isContentEditableTrue$1 = isContentEditableTrue;
  var isContentEditableFalse$1 = isContentEditableFalse;
  var isBr$2 = isBr;
  var isText$3 = isText$1;
  var isInvalidTextElement = matchNodeNames([
    "script",
    "style",
    "textarea"
  ]);
  var isAtomicInline = matchNodeNames([
    "img",
    "input",
    "textarea",
    "hr",
    "iframe",
    "video",
    "audio",
    "object",
    "embed"
  ]);
  var isTable$2 = matchNodeNames(["table"]);
  var isCaretContainer$1 = isCaretContainer;
  var isCaretCandidate = function(node) {
    if (isCaretContainer$1(node)) {
      return false;
    }
    if (isText$3(node)) {
      return !isInvalidTextElement(node.parentNode);
    }
    return isAtomicInline(node) || isBr$2(node) || isTable$2(node) || isNonUiContentEditableFalse(node);
  };
  var isUnselectable = function(node) {
    return isElement$1(node) && node.getAttribute("unselectable") === "true";
  };
  var isNonUiContentEditableFalse = function(node) {
    return isUnselectable(node) === false && isContentEditableFalse$1(node);
  };
  var isInEditable = function(node, root) {
    for (node = node.parentNode; node && node !== root; node = node.parentNode) {
      if (isNonUiContentEditableFalse(node)) {
        return false;
      }
      if (isContentEditableTrue$1(node)) {
        return true;
      }
    }
    return true;
  };
  var isAtomicContentEditableFalse = function(node) {
    if (!isNonUiContentEditableFalse(node)) {
      return false;
    }
    return foldl(from$1(node.getElementsByTagName("*")), function(result, elm) {
      return result || isContentEditableTrue$1(elm);
    }, false) !== true;
  };
  var isAtomic = function(node) {
    return isAtomicInline(node) || isAtomicContentEditableFalse(node);
  };
  var isEditableCaretCandidate = function(node, root) {
    return isCaretCandidate(node) && isInEditable(node, root);
  };
  var whiteSpaceRegExp$1 = /^[ \t\r\n]*$/;
  var isWhitespaceText = function(text) {
    return whiteSpaceRegExp$1.test(text);
  };
  var hasWhitespacePreserveParent = function(node, rootNode) {
    var rootElement = SugarElement.fromDom(rootNode);
    var startNode = SugarElement.fromDom(node);
    return ancestor$2(startNode, "pre,code", curry(eq$2, rootElement));
  };
  var isWhitespace = function(node, rootNode) {
    return isText$1(node) && isWhitespaceText(node.data) && hasWhitespacePreserveParent(node, rootNode) === false;
  };
  var isNamedAnchor = function(node) {
    return isElement$1(node) && node.nodeName === "A" && !node.hasAttribute("href") && (node.hasAttribute("name") || node.hasAttribute("id"));
  };
  var isContent = function(node, rootNode) {
    return isCaretCandidate(node) && isWhitespace(node, rootNode) === false || isNamedAnchor(node) || isBookmark(node);
  };
  var isBookmark = hasAttribute("data-mce-bookmark");
  var isBogus$1 = hasAttribute("data-mce-bogus");
  var isBogusAll$1 = hasAttributeValue("data-mce-bogus", "all");
  var isEmptyNode = function(targetNode, skipBogus) {
    var node, brCount = 0;
    if (isContent(targetNode, targetNode)) {
      return false;
    } else {
      node = targetNode.firstChild;
      if (!node) {
        return true;
      }
      var walker = new DomTreeWalker(node, targetNode);
      do {
        if (skipBogus) {
          if (isBogusAll$1(node)) {
            node = walker.next(true);
            continue;
          }
          if (isBogus$1(node)) {
            node = walker.next();
            continue;
          }
        }
        if (isBr(node)) {
          brCount++;
          node = walker.next();
          continue;
        }
        if (isContent(node, targetNode)) {
          return false;
        }
        node = walker.next();
      } while (node);
      return brCount <= 1;
    }
  };
  var isEmpty = function(elm, skipBogus) {
    if (skipBogus === void 0) {
      skipBogus = true;
    }
    return isEmptyNode(elm.dom, skipBogus);
  };
  var isSpan = function(node) {
    return node.nodeName.toLowerCase() === "span";
  };
  var isInlineContent = function(node, root) {
    return isNonNullable(node) && (isContent(node, root) || isInline(SugarElement.fromDom(node)));
  };
  var surroundedByInlineContent = function(node, root) {
    var prev = new DomTreeWalker(node, root).prev(false);
    var next = new DomTreeWalker(node, root).next(false);
    var prevIsInline = isUndefined(prev) || isInlineContent(prev, root);
    var nextIsInline = isUndefined(next) || isInlineContent(next, root);
    return prevIsInline && nextIsInline;
  };
  var isBookmarkNode = function(node) {
    return isSpan(node) && node.getAttribute("data-mce-type") === "bookmark";
  };
  var isKeepTextNode = function(node, root) {
    return isText$1(node) && node.data.length > 0 && surroundedByInlineContent(node, root);
  };
  var isKeepElement = function(node) {
    return isElement$1(node) ? node.childNodes.length > 0 : false;
  };
  var isDocument$2 = function(node) {
    return isDocumentFragment$1(node) || isDocument$1(node);
  };
  var trimNode = function(dom2, node, root) {
    var rootNode = root || node;
    if (isElement$1(node) && isBookmarkNode(node)) {
      return node;
    }
    var children2 = node.childNodes;
    for (var i = children2.length - 1; i >= 0; i--) {
      trimNode(dom2, children2[i], rootNode);
    }
    if (isElement$1(node)) {
      var currentChildren = node.childNodes;
      if (currentChildren.length === 1 && isBookmarkNode(currentChildren[0])) {
        node.parentNode.insertBefore(currentChildren[0], node);
      }
    }
    if (!isDocument$2(node) && !isContent(node, rootNode) && !isKeepElement(node) && !isKeepTextNode(node, rootNode)) {
      dom2.remove(node);
    }
    return node;
  };
  var makeMap$1 = Tools.makeMap;
  var attrsCharsRegExp = /[&<>\"\u0060\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
  var textCharsRegExp = /[<>&\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
  var rawCharsRegExp = /[<>&\"\']/g;
  var entityRegExp = /&#([a-z0-9]+);?|&([a-z0-9]+);/gi;
  var asciiMap = {
    128: "\u20AC",
    130: "\u201A",
    131: "\u0192",
    132: "\u201E",
    133: "\u2026",
    134: "\u2020",
    135: "\u2021",
    136: "\u02C6",
    137: "\u2030",
    138: "\u0160",
    139: "\u2039",
    140: "\u0152",
    142: "\u017D",
    145: "\u2018",
    146: "\u2019",
    147: "\u201C",
    148: "\u201D",
    149: "\u2022",
    150: "\u2013",
    151: "\u2014",
    152: "\u02DC",
    153: "\u2122",
    154: "\u0161",
    155: "\u203A",
    156: "\u0153",
    158: "\u017E",
    159: "\u0178"
  };
  var baseEntities = {
    '"': "&quot;",
    "'": "&#39;",
    "<": "&lt;",
    ">": "&gt;",
    "&": "&amp;",
    "`": "&#96;"
  };
  var reverseEntities = {
    "&lt;": "<",
    "&gt;": ">",
    "&amp;": "&",
    "&quot;": '"',
    "&apos;": "'"
  };
  var nativeDecode = function(text) {
    var elm = SugarElement.fromTag("div").dom;
    elm.innerHTML = text;
    return elm.textContent || elm.innerText || text;
  };
  var buildEntitiesLookup = function(items, radix) {
    var i, chr, entity;
    var lookup = {};
    if (items) {
      items = items.split(",");
      radix = radix || 10;
      for (i = 0; i < items.length; i += 2) {
        chr = String.fromCharCode(parseInt(items[i], radix));
        if (!baseEntities[chr]) {
          entity = "&" + items[i + 1] + ";";
          lookup[chr] = entity;
          lookup[entity] = chr;
        }
      }
      return lookup;
    }
  };
  var namedEntities = buildEntitiesLookup("50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,t9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro", 32);
  var encodeRaw = function(text, attr) {
    return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function(chr) {
      return baseEntities[chr] || chr;
    });
  };
  var encodeAllRaw = function(text) {
    return ("" + text).replace(rawCharsRegExp, function(chr) {
      return baseEntities[chr] || chr;
    });
  };
  var encodeNumeric = function(text, attr) {
    return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function(chr) {
      if (chr.length > 1) {
        return "&#" + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + ";";
      }
      return baseEntities[chr] || "&#" + chr.charCodeAt(0) + ";";
    });
  };
  var encodeNamed = function(text, attr, entities) {
    entities = entities || namedEntities;
    return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function(chr) {
      return baseEntities[chr] || entities[chr] || chr;
    });
  };
  var getEncodeFunc = function(name2, entities) {
    var entitiesMap = buildEntitiesLookup(entities) || namedEntities;
    var encodeNamedAndNumeric = function(text, attr) {
      return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function(chr) {
        if (baseEntities[chr] !== void 0) {
          return baseEntities[chr];
        }
        if (entitiesMap[chr] !== void 0) {
          return entitiesMap[chr];
        }
        if (chr.length > 1) {
          return "&#" + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + ";";
        }
        return "&#" + chr.charCodeAt(0) + ";";
      });
    };
    var encodeCustomNamed = function(text, attr) {
      return encodeNamed(text, attr, entitiesMap);
    };
    var nameMap = makeMap$1(name2.replace(/\+/g, ","));
    if (nameMap.named && nameMap.numeric) {
      return encodeNamedAndNumeric;
    }
    if (nameMap.named) {
      if (entities) {
        return encodeCustomNamed;
      }
      return encodeNamed;
    }
    if (nameMap.numeric) {
      return encodeNumeric;
    }
    return encodeRaw;
  };
  var decode = function(text) {
    return text.replace(entityRegExp, function(all2, numeric) {
      if (numeric) {
        if (numeric.charAt(0).toLowerCase() === "x") {
          numeric = parseInt(numeric.substr(1), 16);
        } else {
          numeric = parseInt(numeric, 10);
        }
        if (numeric > 65535) {
          numeric -= 65536;
          return String.fromCharCode(55296 + (numeric >> 10), 56320 + (numeric & 1023));
        }
        return asciiMap[numeric] || String.fromCharCode(numeric);
      }
      return reverseEntities[all2] || namedEntities[all2] || nativeDecode(all2);
    });
  };
  var Entities = {
    encodeRaw,
    encodeAllRaw,
    encodeNumeric,
    encodeNamed,
    getEncodeFunc,
    decode
  };
  var mapCache = {}, dummyObj = {};
  var makeMap$2 = Tools.makeMap, each$3 = Tools.each, extend$1 = Tools.extend, explode$1 = Tools.explode, inArray = Tools.inArray;
  var split = function(items, delim) {
    items = Tools.trim(items);
    return items ? items.split(delim || " ") : [];
  };
  var compileSchema = function(type2) {
    var schema = {};
    var globalAttributes, blockContent;
    var phrasingContent, flowContent, html4BlockContent, html4PhrasingContent;
    var add2 = function(name2, attributes2, children2) {
      var ni2, attributesOrder, element;
      var arrayToMap = function(array, obj) {
        var map2 = {};
        var i, l2;
        for (i = 0, l2 = array.length; i < l2; i++) {
          map2[array[i]] = obj || {};
        }
        return map2;
      };
      children2 = children2 || [];
      attributes2 = attributes2 || "";
      if (typeof children2 === "string") {
        children2 = split(children2);
      }
      var names = split(name2);
      ni2 = names.length;
      while (ni2--) {
        attributesOrder = split([
          globalAttributes,
          attributes2
        ].join(" "));
        element = {
          attributes: arrayToMap(attributesOrder),
          attributesOrder,
          children: arrayToMap(children2, dummyObj)
        };
        schema[names[ni2]] = element;
      }
    };
    var addAttrs = function(name2, attributes2) {
      var ni2, schemaItem, i, l2;
      var names = split(name2);
      ni2 = names.length;
      var attrs = split(attributes2);
      while (ni2--) {
        schemaItem = schema[names[ni2]];
        for (i = 0, l2 = attrs.length; i < l2; i++) {
          schemaItem.attributes[attrs[i]] = {};
          schemaItem.attributesOrder.push(attrs[i]);
        }
      }
    };
    if (mapCache[type2]) {
      return mapCache[type2];
    }
    globalAttributes = "id accesskey class dir lang style tabindex title role";
    blockContent = "address blockquote div dl fieldset form h1 h2 h3 h4 h5 h6 hr menu ol p pre table ul";
    phrasingContent = "a abbr b bdo br button cite code del dfn em embed i iframe img input ins kbd label map noscript object q s samp script select small span strong sub sup textarea u var #text #comment";
    if (type2 !== "html4") {
      globalAttributes += " contenteditable contextmenu draggable dropzone hidden spellcheck translate";
      blockContent += " article aside details dialog figure main header footer hgroup section nav";
      phrasingContent += " audio canvas command datalist mark meter output picture progress time wbr video ruby bdi keygen";
    }
    if (type2 !== "html5-strict") {
      globalAttributes += " xml:lang";
      html4PhrasingContent = "acronym applet basefont big font strike tt";
      phrasingContent = [
        phrasingContent,
        html4PhrasingContent
      ].join(" ");
      each$3(split(html4PhrasingContent), function(name2) {
        add2(name2, "", phrasingContent);
      });
      html4BlockContent = "center dir isindex noframes";
      blockContent = [
        blockContent,
        html4BlockContent
      ].join(" ");
      flowContent = [
        blockContent,
        phrasingContent
      ].join(" ");
      each$3(split(html4BlockContent), function(name2) {
        add2(name2, "", flowContent);
      });
    }
    flowContent = flowContent || [
      blockContent,
      phrasingContent
    ].join(" ");
    add2("html", "manifest", "head body");
    add2("head", "", "base command link meta noscript script style title");
    add2("title hr noscript br");
    add2("base", "href target");
    add2("link", "href rel media hreflang type sizes hreflang");
    add2("meta", "name http-equiv content charset");
    add2("style", "media type scoped");
    add2("script", "src async defer type charset");
    add2("body", "onafterprint onbeforeprint onbeforeunload onblur onerror onfocus onhashchange onload onmessage onoffline ononline onpagehide onpageshow onpopstate onresize onscroll onstorage onunload", flowContent);
    add2("address dt dd div caption", "", flowContent);
    add2("h1 h2 h3 h4 h5 h6 pre p abbr code var samp kbd sub sup i b u bdo span legend em strong small s cite dfn", "", phrasingContent);
    add2("blockquote", "cite", flowContent);
    add2("ol", "reversed start type", "li");
    add2("ul", "", "li");
    add2("li", "value", flowContent);
    add2("dl", "", "dt dd");
    add2("a", "href target rel media hreflang type", phrasingContent);
    add2("q", "cite", phrasingContent);
    add2("ins del", "cite datetime", flowContent);
    add2("img", "src sizes srcset alt usemap ismap width height");
    add2("iframe", "src name width height", flowContent);
    add2("embed", "src type width height");
    add2("object", "data type typemustmatch name usemap form width height", [
      flowContent,
      "param"
    ].join(" "));
    add2("param", "name value");
    add2("map", "name", [
      flowContent,
      "area"
    ].join(" "));
    add2("area", "alt coords shape href target rel media hreflang type");
    add2("table", "border", "caption colgroup thead tfoot tbody tr" + (type2 === "html4" ? " col" : ""));
    add2("colgroup", "span", "col");
    add2("col", "span");
    add2("tbody thead tfoot", "", "tr");
    add2("tr", "", "td th");
    add2("td", "colspan rowspan headers", flowContent);
    add2("th", "colspan rowspan headers scope abbr", flowContent);
    add2("form", "accept-charset action autocomplete enctype method name novalidate target", flowContent);
    add2("fieldset", "disabled form name", [
      flowContent,
      "legend"
    ].join(" "));
    add2("label", "form for", phrasingContent);
    add2("input", "accept alt autocomplete checked dirname disabled form formaction formenctype formmethod formnovalidate formtarget height list max maxlength min multiple name pattern readonly required size src step type value width");
    add2("button", "disabled form formaction formenctype formmethod formnovalidate formtarget name type value", type2 === "html4" ? flowContent : phrasingContent);
    add2("select", "disabled form multiple name required size", "option optgroup");
    add2("optgroup", "disabled label", "option");
    add2("option", "disabled label selected value");
    add2("textarea", "cols dirname disabled form maxlength name readonly required rows wrap");
    add2("menu", "type label", [
      flowContent,
      "li"
    ].join(" "));
    add2("noscript", "", flowContent);
    if (type2 !== "html4") {
      add2("wbr");
      add2("ruby", "", [
        phrasingContent,
        "rt rp"
      ].join(" "));
      add2("figcaption", "", flowContent);
      add2("mark rt rp summary bdi", "", phrasingContent);
      add2("canvas", "width height", flowContent);
      add2("video", "src crossorigin poster preload autoplay mediagroup loop muted controls width height buffered", [
        flowContent,
        "track source"
      ].join(" "));
      add2("audio", "src crossorigin preload autoplay mediagroup loop muted controls buffered volume", [
        flowContent,
        "track source"
      ].join(" "));
      add2("picture", "", "img source");
      add2("source", "src srcset type media sizes");
      add2("track", "kind src srclang label default");
      add2("datalist", "", [
        phrasingContent,
        "option"
      ].join(" "));
      add2("article section nav aside main header footer", "", flowContent);
      add2("hgroup", "", "h1 h2 h3 h4 h5 h6");
      add2("figure", "", [
        flowContent,
        "figcaption"
      ].join(" "));
      add2("time", "datetime", phrasingContent);
      add2("dialog", "open", flowContent);
      add2("command", "type label icon disabled checked radiogroup command");
      add2("output", "for form name", phrasingContent);
      add2("progress", "value max", phrasingContent);
      add2("meter", "value min max low high optimum", phrasingContent);
      add2("details", "open", [
        flowContent,
        "summary"
      ].join(" "));
      add2("keygen", "autofocus challenge disabled form keytype name");
    }
    if (type2 !== "html5-strict") {
      addAttrs("script", "language xml:space");
      addAttrs("style", "xml:space");
      addAttrs("object", "declare classid code codebase codetype archive standby align border hspace vspace");
      addAttrs("embed", "align name hspace vspace");
      addAttrs("param", "valuetype type");
      addAttrs("a", "charset name rev shape coords");
      addAttrs("br", "clear");
      addAttrs("applet", "codebase archive code object alt name width height align hspace vspace");
      addAttrs("img", "name longdesc align border hspace vspace");
      addAttrs("iframe", "longdesc frameborder marginwidth marginheight scrolling align");
      addAttrs("font basefont", "size color face");
      addAttrs("input", "usemap align");
      addAttrs("select");
      addAttrs("textarea");
      addAttrs("h1 h2 h3 h4 h5 h6 div p legend caption", "align");
      addAttrs("ul", "type compact");
      addAttrs("li", "type");
      addAttrs("ol dl menu dir", "compact");
      addAttrs("pre", "width xml:space");
      addAttrs("hr", "align noshade size width");
      addAttrs("isindex", "prompt");
      addAttrs("table", "summary width frame rules cellspacing cellpadding align bgcolor");
      addAttrs("col", "width align char charoff valign");
      addAttrs("colgroup", "width align char charoff valign");
      addAttrs("thead", "align char charoff valign");
      addAttrs("tr", "align char charoff valign bgcolor");
      addAttrs("th", "axis align char charoff valign nowrap bgcolor width height");
      addAttrs("form", "accept");
      addAttrs("td", "abbr axis scope align char charoff valign nowrap bgcolor width height");
      addAttrs("tfoot", "align char charoff valign");
      addAttrs("tbody", "align char charoff valign");
      addAttrs("area", "nohref");
      addAttrs("body", "background bgcolor text link vlink alink");
    }
    if (type2 !== "html4") {
      addAttrs("input button select textarea", "autofocus");
      addAttrs("input textarea", "placeholder");
      addAttrs("a", "download");
      addAttrs("link script img", "crossorigin");
      addAttrs("img", "loading");
      addAttrs("iframe", "sandbox seamless allowfullscreen loading");
    }
    each$3(split("a form meter progress dfn"), function(name2) {
      if (schema[name2]) {
        delete schema[name2].children[name2];
      }
    });
    delete schema.caption.children.table;
    delete schema.script;
    mapCache[type2] = schema;
    return schema;
  };
  var compileElementMap = function(value2, mode) {
    var styles;
    if (value2) {
      styles = {};
      if (typeof value2 === "string") {
        value2 = { "*": value2 };
      }
      each$3(value2, function(value3, key) {
        styles[key] = styles[key.toUpperCase()] = mode === "map" ? makeMap$2(value3, /[, ]/) : explode$1(value3, /[, ]/);
      });
    }
    return styles;
  };
  var Schema = function(settings) {
    var elements = {};
    var children2 = {};
    var patternElements = [];
    var customElementsMap = {}, specialElements = {};
    var createLookupTable = function(option, defaultValue, extendWith) {
      var value2 = settings[option];
      if (!value2) {
        value2 = mapCache[option];
        if (!value2) {
          value2 = makeMap$2(defaultValue, " ", makeMap$2(defaultValue.toUpperCase(), " "));
          value2 = extend$1(value2, extendWith);
          mapCache[option] = value2;
        }
      } else {
        value2 = makeMap$2(value2, /[, ]/, makeMap$2(value2.toUpperCase(), /[, ]/));
      }
      return value2;
    };
    settings = settings || {};
    var schemaItems = compileSchema(settings.schema);
    if (settings.verify_html === false) {
      settings.valid_elements = "*[*]";
    }
    var validStyles = compileElementMap(settings.valid_styles);
    var invalidStyles = compileElementMap(settings.invalid_styles, "map");
    var validClasses = compileElementMap(settings.valid_classes, "map");
    var whiteSpaceElementsMap = createLookupTable("whitespace_elements", "pre script noscript style textarea video audio iframe object code");
    var selfClosingElementsMap = createLookupTable("self_closing_elements", "colgroup dd dt li option p td tfoot th thead tr");
    var shortEndedElementsMap = createLookupTable("short_ended_elements", "area base basefont br col frame hr img input isindex link meta param embed source wbr track");
    var boolAttrMap = createLookupTable("boolean_attributes", "checked compact declare defer disabled ismap multiple nohref noresize noshade nowrap readonly selected autoplay loop controls");
    var nonEmptyOrMoveCaretBeforeOnEnter = "td th iframe video audio object script code";
    var nonEmptyElementsMap = createLookupTable("non_empty_elements", nonEmptyOrMoveCaretBeforeOnEnter + " pre", shortEndedElementsMap);
    var moveCaretBeforeOnEnterElementsMap = createLookupTable("move_caret_before_on_enter_elements", nonEmptyOrMoveCaretBeforeOnEnter + " table", shortEndedElementsMap);
    var textBlockElementsMap = createLookupTable("text_block_elements", "h1 h2 h3 h4 h5 h6 p div address pre form blockquote center dir fieldset header footer article section hgroup aside main nav figure");
    var blockElementsMap = createLookupTable("block_elements", "hr table tbody thead tfoot th tr td li ol ul caption dl dt dd noscript menu isindex option datalist select optgroup figcaption details summary", textBlockElementsMap);
    var textInlineElementsMap = createLookupTable("text_inline_elements", "span strong b em i font strike u var cite dfn code mark q sup sub samp");
    each$3((settings.special || "script noscript iframe noframes noembed title style textarea xmp").split(" "), function(name2) {
      specialElements[name2] = new RegExp("</" + name2 + "[^>]*>", "gi");
    });
    var patternToRegExp = function(str) {
      return new RegExp("^" + str.replace(/([?+*])/g, ".$1") + "$");
    };
    var addValidElements = function(validElements) {
      var ei2, el, ai2, al, matches2, element, attr, attrData, elementName, attrName, attrType, attributes2, attributesOrder, prefix, outputName, globalAttributes, globalAttributesOrder, value2;
      var elementRuleRegExp = /^([#+\-])?([^\[!\/]+)(?:\/([^\[!]+))?(?:(!?)\[([^\]]+)])?$/, attrRuleRegExp = /^([!\-])?(\w+[\\:]:\w+|[^=:<]+)?(?:([=:<])(.*))?$/, hasPatternsRegExp = /[*?+]/;
      if (validElements) {
        var validElementsArr = split(validElements, ",");
        if (elements["@"]) {
          globalAttributes = elements["@"].attributes;
          globalAttributesOrder = elements["@"].attributesOrder;
        }
        for (ei2 = 0, el = validElementsArr.length; ei2 < el; ei2++) {
          matches2 = elementRuleRegExp.exec(validElementsArr[ei2]);
          if (matches2) {
            prefix = matches2[1];
            elementName = matches2[2];
            outputName = matches2[3];
            attrData = matches2[5];
            attributes2 = {};
            attributesOrder = [];
            element = {
              attributes: attributes2,
              attributesOrder
            };
            if (prefix === "#") {
              element.paddEmpty = true;
            }
            if (prefix === "-") {
              element.removeEmpty = true;
            }
            if (matches2[4] === "!") {
              element.removeEmptyAttrs = true;
            }
            if (globalAttributes) {
              each$1(globalAttributes, function(value3, key) {
                attributes2[key] = value3;
              });
              attributesOrder.push.apply(attributesOrder, globalAttributesOrder);
            }
            if (attrData) {
              attrData = split(attrData, "|");
              for (ai2 = 0, al = attrData.length; ai2 < al; ai2++) {
                matches2 = attrRuleRegExp.exec(attrData[ai2]);
                if (matches2) {
                  attr = {};
                  attrType = matches2[1];
                  attrName = matches2[2].replace(/[\\:]:/g, ":");
                  prefix = matches2[3];
                  value2 = matches2[4];
                  if (attrType === "!") {
                    element.attributesRequired = element.attributesRequired || [];
                    element.attributesRequired.push(attrName);
                    attr.required = true;
                  }
                  if (attrType === "-") {
                    delete attributes2[attrName];
                    attributesOrder.splice(inArray(attributesOrder, attrName), 1);
                    continue;
                  }
                  if (prefix) {
                    if (prefix === "=") {
                      element.attributesDefault = element.attributesDefault || [];
                      element.attributesDefault.push({
                        name: attrName,
                        value: value2
                      });
                      attr.defaultValue = value2;
                    }
                    if (prefix === ":") {
                      element.attributesForced = element.attributesForced || [];
                      element.attributesForced.push({
                        name: attrName,
                        value: value2
                      });
                      attr.forcedValue = value2;
                    }
                    if (prefix === "<") {
                      attr.validValues = makeMap$2(value2, "?");
                    }
                  }
                  if (hasPatternsRegExp.test(attrName)) {
                    element.attributePatterns = element.attributePatterns || [];
                    attr.pattern = patternToRegExp(attrName);
                    element.attributePatterns.push(attr);
                  } else {
                    if (!attributes2[attrName]) {
                      attributesOrder.push(attrName);
                    }
                    attributes2[attrName] = attr;
                  }
                }
              }
            }
            if (!globalAttributes && elementName === "@") {
              globalAttributes = attributes2;
              globalAttributesOrder = attributesOrder;
            }
            if (outputName) {
              element.outputName = elementName;
              elements[outputName] = element;
            }
            if (hasPatternsRegExp.test(elementName)) {
              element.pattern = patternToRegExp(elementName);
              patternElements.push(element);
            } else {
              elements[elementName] = element;
            }
          }
        }
      }
    };
    var setValidElements = function(validElements) {
      elements = {};
      patternElements = [];
      addValidElements(validElements);
      each$3(schemaItems, function(element, name2) {
        children2[name2] = element.children;
      });
    };
    var addCustomElements = function(customElements) {
      var customElementRegExp = /^(~)?(.+)$/;
      if (customElements) {
        mapCache.text_block_elements = mapCache.block_elements = null;
        each$3(split(customElements, ","), function(rule) {
          var matches2 = customElementRegExp.exec(rule), inline = matches2[1] === "~", cloneName = inline ? "span" : "div", name2 = matches2[2];
          children2[name2] = children2[cloneName];
          customElementsMap[name2] = cloneName;
          if (!inline) {
            blockElementsMap[name2.toUpperCase()] = {};
            blockElementsMap[name2] = {};
          }
          if (!elements[name2]) {
            var customRule = elements[cloneName];
            customRule = extend$1({}, customRule);
            delete customRule.removeEmptyAttrs;
            delete customRule.removeEmpty;
            elements[name2] = customRule;
          }
          each$3(children2, function(element, elmName) {
            if (element[cloneName]) {
              children2[elmName] = element = extend$1({}, children2[elmName]);
              element[name2] = element[cloneName];
            }
          });
        });
      }
    };
    var addValidChildren = function(validChildren) {
      var childRuleRegExp = /^([+\-]?)([A-Za-z0-9_\-.\u00b7\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u037d\u037f-\u1fff\u200c-\u200d\u203f-\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]+)\[([^\]]+)]$/;
      mapCache[settings.schema] = null;
      if (validChildren) {
        each$3(split(validChildren, ","), function(rule) {
          var matches2 = childRuleRegExp.exec(rule);
          var parent2, prefix;
          if (matches2) {
            prefix = matches2[1];
            if (prefix) {
              parent2 = children2[matches2[2]];
            } else {
              parent2 = children2[matches2[2]] = { "#comment": {} };
            }
            parent2 = children2[matches2[2]];
            each$3(split(matches2[3], "|"), function(child2) {
              if (prefix === "-") {
                delete parent2[child2];
              } else {
                parent2[child2] = {};
              }
            });
          }
        });
      }
    };
    var getElementRule = function(name2) {
      var element = elements[name2], i;
      if (element) {
        return element;
      }
      i = patternElements.length;
      while (i--) {
        element = patternElements[i];
        if (element.pattern.test(name2)) {
          return element;
        }
      }
    };
    if (!settings.valid_elements) {
      each$3(schemaItems, function(element, name2) {
        elements[name2] = {
          attributes: element.attributes,
          attributesOrder: element.attributesOrder
        };
        children2[name2] = element.children;
      });
      if (settings.schema !== "html5") {
        each$3(split("strong/b em/i"), function(item) {
          var items = split(item, "/");
          elements[items[1]].outputName = items[0];
        });
      }
      each$3(split("ol ul sub sup blockquote span font a table tbody strong em b i"), function(name2) {
        if (elements[name2]) {
          elements[name2].removeEmpty = true;
        }
      });
      each$3(split("p h1 h2 h3 h4 h5 h6 th td pre div address caption li"), function(name2) {
        elements[name2].paddEmpty = true;
      });
      each$3(split("span"), function(name2) {
        elements[name2].removeEmptyAttrs = true;
      });
    } else {
      setValidElements(settings.valid_elements);
    }
    addCustomElements(settings.custom_elements);
    addValidChildren(settings.valid_children);
    addValidElements(settings.extended_valid_elements);
    addValidChildren("+ol[ul|ol],+ul[ul|ol]");
    each$3({
      dd: "dl",
      dt: "dl",
      li: "ul ol",
      td: "tr",
      th: "tr",
      tr: "tbody thead tfoot",
      tbody: "table",
      thead: "table",
      tfoot: "table",
      legend: "fieldset",
      area: "map",
      param: "video audio object"
    }, function(parents2, item) {
      if (elements[item]) {
        elements[item].parentsRequired = split(parents2);
      }
    });
    if (settings.invalid_elements) {
      each$3(explode$1(settings.invalid_elements), function(item) {
        if (elements[item]) {
          delete elements[item];
        }
      });
    }
    if (!getElementRule("span")) {
      addValidElements("span[!data-mce-type|*]");
    }
    var getValidStyles = function() {
      return validStyles;
    };
    var getInvalidStyles = function() {
      return invalidStyles;
    };
    var getValidClasses = function() {
      return validClasses;
    };
    var getBoolAttrs = function() {
      return boolAttrMap;
    };
    var getBlockElements = function() {
      return blockElementsMap;
    };
    var getTextBlockElements = function() {
      return textBlockElementsMap;
    };
    var getTextInlineElements = function() {
      return textInlineElementsMap;
    };
    var getShortEndedElements = function() {
      return shortEndedElementsMap;
    };
    var getSelfClosingElements = function() {
      return selfClosingElementsMap;
    };
    var getNonEmptyElements = function() {
      return nonEmptyElementsMap;
    };
    var getMoveCaretBeforeOnEnterElements = function() {
      return moveCaretBeforeOnEnterElementsMap;
    };
    var getWhiteSpaceElements = function() {
      return whiteSpaceElementsMap;
    };
    var getSpecialElements = function() {
      return specialElements;
    };
    var isValidChild = function(name2, child2) {
      var parent2 = children2[name2.toLowerCase()];
      return !!(parent2 && parent2[child2.toLowerCase()]);
    };
    var isValid2 = function(name2, attr) {
      var attrPatterns, i;
      var rule = getElementRule(name2);
      if (rule) {
        if (attr) {
          if (rule.attributes[attr]) {
            return true;
          }
          attrPatterns = rule.attributePatterns;
          if (attrPatterns) {
            i = attrPatterns.length;
            while (i--) {
              if (attrPatterns[i].pattern.test(name2)) {
                return true;
              }
            }
          }
        } else {
          return true;
        }
      }
      return false;
    };
    var getCustomElements = function() {
      return customElementsMap;
    };
    return {
      children: children2,
      elements,
      getValidStyles,
      getValidClasses,
      getBlockElements,
      getInvalidStyles,
      getShortEndedElements,
      getTextBlockElements,
      getTextInlineElements,
      getBoolAttrs,
      getElementRule,
      getSelfClosingElements,
      getNonEmptyElements,
      getMoveCaretBeforeOnEnterElements,
      getWhiteSpaceElements,
      getSpecialElements,
      isValidChild,
      isValid: isValid2,
      getCustomElements,
      addValidElements,
      setValidElements,
      addCustomElements,
      addValidChildren
    };
  };
  var toHex = function(match2, r3, g, b) {
    var hex = function(val) {
      val = parseInt(val, 10).toString(16);
      return val.length > 1 ? val : "0" + val;
    };
    return "#" + hex(r3) + hex(g) + hex(b);
  };
  var Styles = function(settings, schema) {
    var _this = this;
    var rgbRegExp = /rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)/gi;
    var urlOrStrRegExp = /(?:url(?:(?:\(\s*\"([^\"]+)\"\s*\))|(?:\(\s*\'([^\']+)\'\s*\))|(?:\(\s*([^)\s]+)\s*\))))|(?:\'([^\']+)\')|(?:\"([^\"]+)\")/gi;
    var styleRegExp = /\s*([^:]+):\s*([^;]+);?/g;
    var trimRightRegExp = /\s+$/;
    var i;
    var encodingLookup = {};
    var validStyles;
    var invalidStyles;
    var invisibleChar = zeroWidth;
    settings = settings || {};
    if (schema) {
      validStyles = schema.getValidStyles();
      invalidStyles = schema.getInvalidStyles();
    }
    var encodingItems = (`\\" \\' \\; \\: ; : ` + invisibleChar).split(" ");
    for (i = 0; i < encodingItems.length; i++) {
      encodingLookup[encodingItems[i]] = invisibleChar + i;
      encodingLookup[invisibleChar + i] = encodingItems[i];
    }
    return {
      toHex: function(color) {
        return color.replace(rgbRegExp, toHex);
      },
      parse: function(css) {
        var styles = {};
        var matches2, name2, value2, isEncoded;
        var urlConverter = settings.url_converter;
        var urlConverterScope = settings.url_converter_scope || _this;
        var compress = function(prefix, suffix, noJoin) {
          var top = styles[prefix + "-top" + suffix];
          if (!top) {
            return;
          }
          var right = styles[prefix + "-right" + suffix];
          if (!right) {
            return;
          }
          var bottom = styles[prefix + "-bottom" + suffix];
          if (!bottom) {
            return;
          }
          var left = styles[prefix + "-left" + suffix];
          if (!left) {
            return;
          }
          var box = [
            top,
            right,
            bottom,
            left
          ];
          i = box.length - 1;
          while (i--) {
            if (box[i] !== box[i + 1]) {
              break;
            }
          }
          if (i > -1 && noJoin) {
            return;
          }
          styles[prefix + suffix] = i === -1 ? box[0] : box.join(" ");
          delete styles[prefix + "-top" + suffix];
          delete styles[prefix + "-right" + suffix];
          delete styles[prefix + "-bottom" + suffix];
          delete styles[prefix + "-left" + suffix];
        };
        var canCompress = function(key) {
          var value3 = styles[key], i2;
          if (!value3) {
            return;
          }
          value3 = value3.split(" ");
          i2 = value3.length;
          while (i2--) {
            if (value3[i2] !== value3[0]) {
              return false;
            }
          }
          styles[key] = value3[0];
          return true;
        };
        var compress2 = function(target, a, b, c) {
          if (!canCompress(a)) {
            return;
          }
          if (!canCompress(b)) {
            return;
          }
          if (!canCompress(c)) {
            return;
          }
          styles[target] = styles[a] + " " + styles[b] + " " + styles[c];
          delete styles[a];
          delete styles[b];
          delete styles[c];
        };
        var encode = function(str) {
          isEncoded = true;
          return encodingLookup[str];
        };
        var decode2 = function(str, keepSlashes) {
          if (isEncoded) {
            str = str.replace(/\uFEFF[0-9]/g, function(str2) {
              return encodingLookup[str2];
            });
          }
          if (!keepSlashes) {
            str = str.replace(/\\([\'\";:])/g, "$1");
          }
          return str;
        };
        var decodeSingleHexSequence = function(escSeq) {
          return String.fromCharCode(parseInt(escSeq.slice(1), 16));
        };
        var decodeHexSequences = function(value3) {
          return value3.replace(/\\[0-9a-f]+/gi, decodeSingleHexSequence);
        };
        var processUrl = function(match2, url, url2, url3, str, str2) {
          str = str || str2;
          if (str) {
            str = decode2(str);
            return "'" + str.replace(/\'/g, "\\'") + "'";
          }
          url = decode2(url || url2 || url3);
          if (!settings.allow_script_urls) {
            var scriptUrl = url.replace(/[\s\r\n]+/g, "");
            if (/(java|vb)script:/i.test(scriptUrl)) {
              return "";
            }
            if (!settings.allow_svg_data_urls && /^data:image\/svg/i.test(scriptUrl)) {
              return "";
            }
          }
          if (urlConverter) {
            url = urlConverter.call(urlConverterScope, url, "style");
          }
          return "url('" + url.replace(/\'/g, "\\'") + "')";
        };
        if (css) {
          css = css.replace(/[\u0000-\u001F]/g, "");
          css = css.replace(/\\[\"\';:\uFEFF]/g, encode).replace(/\"[^\"]+\"|\'[^\']+\'/g, function(str) {
            return str.replace(/[;:]/g, encode);
          });
          while (matches2 = styleRegExp.exec(css)) {
            styleRegExp.lastIndex = matches2.index + matches2[0].length;
            name2 = matches2[1].replace(trimRightRegExp, "").toLowerCase();
            value2 = matches2[2].replace(trimRightRegExp, "");
            if (name2 && value2) {
              name2 = decodeHexSequences(name2);
              value2 = decodeHexSequences(value2);
              if (name2.indexOf(invisibleChar) !== -1 || name2.indexOf('"') !== -1) {
                continue;
              }
              if (!settings.allow_script_urls && (name2 === "behavior" || /expression\s*\(|\/\*|\*\//.test(value2))) {
                continue;
              }
              if (name2 === "font-weight" && value2 === "700") {
                value2 = "bold";
              } else if (name2 === "color" || name2 === "background-color") {
                value2 = value2.toLowerCase();
              }
              value2 = value2.replace(rgbRegExp, toHex);
              value2 = value2.replace(urlOrStrRegExp, processUrl);
              styles[name2] = isEncoded ? decode2(value2, true) : value2;
            }
          }
          compress("border", "", true);
          compress("border", "-width");
          compress("border", "-color");
          compress("border", "-style");
          compress("padding", "");
          compress("margin", "");
          compress2("border", "border-width", "border-style", "border-color");
          if (styles.border === "medium none") {
            delete styles.border;
          }
          if (styles["border-image"] === "none") {
            delete styles["border-image"];
          }
        }
        return styles;
      },
      serialize: function(styles, elementName) {
        var css = "";
        var serializeStyles = function(name2) {
          var value2;
          var styleList = validStyles[name2];
          if (styleList) {
            for (var i_1 = 0, l2 = styleList.length; i_1 < l2; i_1++) {
              name2 = styleList[i_1];
              value2 = styles[name2];
              if (value2) {
                css += (css.length > 0 ? " " : "") + name2 + ": " + value2 + ";";
              }
            }
          }
        };
        var isValid2 = function(name2, elementName2) {
          var styleMap = invalidStyles["*"];
          if (styleMap && styleMap[name2]) {
            return false;
          }
          styleMap = invalidStyles[elementName2];
          return !(styleMap && styleMap[name2]);
        };
        if (elementName && validStyles) {
          serializeStyles("*");
          serializeStyles(elementName);
        } else {
          each$1(styles, function(value2, name2) {
            if (value2 && (!invalidStyles || isValid2(name2, elementName))) {
              css += (css.length > 0 ? " " : "") + name2 + ": " + value2 + ";";
            }
          });
        }
        return css;
      }
    };
  };
  var eventExpandoPrefix = "mce-data-";
  var mouseEventRe = /^(?:mouse|contextmenu)|click/;
  var deprecated = {
    keyLocation: 1,
    layerX: 1,
    layerY: 1,
    returnValue: 1,
    webkitMovementX: 1,
    webkitMovementY: 1,
    keyIdentifier: 1,
    mozPressure: 1
  };
  var hasIsDefaultPrevented = function(event) {
    return event.isDefaultPrevented === returnTrue || event.isDefaultPrevented === returnFalse;
  };
  var returnFalse = never;
  var returnTrue = always;
  var addEvent = function(target, name2, callback, capture) {
    if (target.addEventListener) {
      target.addEventListener(name2, callback, capture || false);
    } else if (target.attachEvent) {
      target.attachEvent("on" + name2, callback);
    }
  };
  var removeEvent = function(target, name2, callback, capture) {
    if (target.removeEventListener) {
      target.removeEventListener(name2, callback, capture || false);
    } else if (target.detachEvent) {
      target.detachEvent("on" + name2, callback);
    }
  };
  var isMouseEvent = function(event) {
    return mouseEventRe.test(event.type);
  };
  var fix = function(originalEvent, data2) {
    var name2;
    var event = data2 || {};
    for (name2 in originalEvent) {
      if (!deprecated[name2]) {
        event[name2] = originalEvent[name2];
      }
    }
    if (!event.target) {
      event.target = event.srcElement || document;
    }
    if (event.composedPath) {
      event.composedPath = function() {
        return originalEvent.composedPath();
      };
    }
    if (originalEvent && isMouseEvent(originalEvent) && originalEvent.pageX === void 0 && originalEvent.clientX !== void 0) {
      var eventDoc = event.target.ownerDocument || document;
      var doc2 = eventDoc.documentElement;
      var body = eventDoc.body;
      event.pageX = originalEvent.clientX + (doc2 && doc2.scrollLeft || body && body.scrollLeft || 0) - (doc2 && doc2.clientLeft || body && body.clientLeft || 0);
      event.pageY = originalEvent.clientY + (doc2 && doc2.scrollTop || body && body.scrollTop || 0) - (doc2 && doc2.clientTop || body && body.clientTop || 0);
    }
    event.preventDefault = function() {
      event.defaultPrevented = true;
      event.isDefaultPrevented = returnTrue;
      if (originalEvent) {
        if (originalEvent.preventDefault) {
          originalEvent.preventDefault();
        } else {
          originalEvent.returnValue = false;
        }
      }
    };
    event.stopPropagation = function() {
      event.cancelBubble = true;
      event.isPropagationStopped = returnTrue;
      if (originalEvent) {
        if (originalEvent.stopPropagation) {
          originalEvent.stopPropagation();
        } else {
          originalEvent.cancelBubble = true;
        }
      }
    };
    event.stopImmediatePropagation = function() {
      event.isImmediatePropagationStopped = returnTrue;
      event.stopPropagation();
    };
    if (hasIsDefaultPrevented(event) === false) {
      event.isDefaultPrevented = event.defaultPrevented === true ? returnTrue : returnFalse;
      event.isPropagationStopped = event.cancelBubble === true ? returnTrue : returnFalse;
      event.isImmediatePropagationStopped = returnFalse;
    }
    if (typeof event.metaKey === "undefined") {
      event.metaKey = false;
    }
    return event;
  };
  var bindOnReady = function(win, callback, eventUtils) {
    var doc2 = win.document, event = { type: "ready" };
    if (eventUtils.domLoaded) {
      callback(event);
      return;
    }
    var isDocReady = function() {
      return doc2.readyState === "complete" || doc2.readyState === "interactive" && doc2.body;
    };
    var readyHandler = function() {
      removeEvent(win, "DOMContentLoaded", readyHandler);
      removeEvent(win, "load", readyHandler);
      if (!eventUtils.domLoaded) {
        eventUtils.domLoaded = true;
        callback(event);
      }
      win = null;
    };
    if (isDocReady()) {
      readyHandler();
    } else {
      addEvent(win, "DOMContentLoaded", readyHandler);
    }
    if (!eventUtils.domLoaded) {
      addEvent(win, "load", readyHandler);
    }
  };
  var EventUtils = function() {
    function EventUtils2() {
      this.domLoaded = false;
      this.events = {};
      this.count = 1;
      this.expando = eventExpandoPrefix + (+new Date()).toString(32);
      this.hasMouseEnterLeave = "onmouseenter" in document.documentElement;
      this.hasFocusIn = "onfocusin" in document.documentElement;
      this.count = 1;
    }
    EventUtils2.prototype.bind = function(target, names, callback, scope) {
      var self2 = this;
      var id2, callbackList, i, name2, fakeName, nativeHandler, capture;
      var win = window;
      var defaultNativeHandler = function(evt) {
        self2.executeHandlers(fix(evt || win.event), id2);
      };
      if (!target || target.nodeType === 3 || target.nodeType === 8) {
        return;
      }
      if (!target[self2.expando]) {
        id2 = self2.count++;
        target[self2.expando] = id2;
        self2.events[id2] = {};
      } else {
        id2 = target[self2.expando];
      }
      scope = scope || target;
      var namesList = names.split(" ");
      i = namesList.length;
      while (i--) {
        name2 = namesList[i];
        nativeHandler = defaultNativeHandler;
        fakeName = capture = false;
        if (name2 === "DOMContentLoaded") {
          name2 = "ready";
        }
        if (self2.domLoaded && name2 === "ready" && target.readyState === "complete") {
          callback.call(scope, fix({ type: name2 }));
          continue;
        }
        if (!self2.hasMouseEnterLeave) {
          fakeName = self2.mouseEnterLeave[name2];
          if (fakeName) {
            nativeHandler = function(evt) {
              var current = evt.currentTarget;
              var related = evt.relatedTarget;
              if (related && current.contains) {
                related = current.contains(related);
              } else {
                while (related && related !== current) {
                  related = related.parentNode;
                }
              }
              if (!related) {
                evt = fix(evt || win.event);
                evt.type = evt.type === "mouseout" ? "mouseleave" : "mouseenter";
                evt.target = current;
                self2.executeHandlers(evt, id2);
              }
            };
          }
        }
        if (!self2.hasFocusIn && (name2 === "focusin" || name2 === "focusout")) {
          capture = true;
          fakeName = name2 === "focusin" ? "focus" : "blur";
          nativeHandler = function(evt) {
            evt = fix(evt || win.event);
            evt.type = evt.type === "focus" ? "focusin" : "focusout";
            self2.executeHandlers(evt, id2);
          };
        }
        callbackList = self2.events[id2][name2];
        if (!callbackList) {
          self2.events[id2][name2] = callbackList = [{
            func: callback,
            scope
          }];
          callbackList.fakeName = fakeName;
          callbackList.capture = capture;
          callbackList.nativeHandler = nativeHandler;
          if (name2 === "ready") {
            bindOnReady(target, nativeHandler, self2);
          } else {
            addEvent(target, fakeName || name2, nativeHandler, capture);
          }
        } else {
          if (name2 === "ready" && self2.domLoaded) {
            callback(fix({ type: name2 }));
          } else {
            callbackList.push({
              func: callback,
              scope
            });
          }
        }
      }
      target = callbackList = null;
      return callback;
    };
    EventUtils2.prototype.unbind = function(target, names, callback) {
      var callbackList, i, ci2, name2, eventMap;
      if (!target || target.nodeType === 3 || target.nodeType === 8) {
        return this;
      }
      var id2 = target[this.expando];
      if (id2) {
        eventMap = this.events[id2];
        if (names) {
          var namesList = names.split(" ");
          i = namesList.length;
          while (i--) {
            name2 = namesList[i];
            callbackList = eventMap[name2];
            if (callbackList) {
              if (callback) {
                ci2 = callbackList.length;
                while (ci2--) {
                  if (callbackList[ci2].func === callback) {
                    var nativeHandler = callbackList.nativeHandler;
                    var fakeName = callbackList.fakeName, capture = callbackList.capture;
                    callbackList = callbackList.slice(0, ci2).concat(callbackList.slice(ci2 + 1));
                    callbackList.nativeHandler = nativeHandler;
                    callbackList.fakeName = fakeName;
                    callbackList.capture = capture;
                    eventMap[name2] = callbackList;
                  }
                }
              }
              if (!callback || callbackList.length === 0) {
                delete eventMap[name2];
                removeEvent(target, callbackList.fakeName || name2, callbackList.nativeHandler, callbackList.capture);
              }
            }
          }
        } else {
          each$1(eventMap, function(callbackList2, name3) {
            removeEvent(target, callbackList2.fakeName || name3, callbackList2.nativeHandler, callbackList2.capture);
          });
          eventMap = {};
        }
        for (name2 in eventMap) {
          if (has(eventMap, name2)) {
            return this;
          }
        }
        delete this.events[id2];
        try {
          delete target[this.expando];
        } catch (ex) {
          target[this.expando] = null;
        }
      }
      return this;
    };
    EventUtils2.prototype.fire = function(target, name2, args) {
      var id2;
      if (!target || target.nodeType === 3 || target.nodeType === 8) {
        return this;
      }
      var event = fix(null, args);
      event.type = name2;
      event.target = target;
      do {
        id2 = target[this.expando];
        if (id2) {
          this.executeHandlers(event, id2);
        }
        target = target.parentNode || target.ownerDocument || target.defaultView || target.parentWindow;
      } while (target && !event.isPropagationStopped());
      return this;
    };
    EventUtils2.prototype.clean = function(target) {
      var i, children2;
      if (!target || target.nodeType === 3 || target.nodeType === 8) {
        return this;
      }
      if (target[this.expando]) {
        this.unbind(target);
      }
      if (!target.getElementsByTagName) {
        target = target.document;
      }
      if (target && target.getElementsByTagName) {
        this.unbind(target);
        children2 = target.getElementsByTagName("*");
        i = children2.length;
        while (i--) {
          target = children2[i];
          if (target[this.expando]) {
            this.unbind(target);
          }
        }
      }
      return this;
    };
    EventUtils2.prototype.destroy = function() {
      this.events = {};
    };
    EventUtils2.prototype.cancel = function(e) {
      if (e) {
        e.preventDefault();
        e.stopImmediatePropagation();
      }
      return false;
    };
    EventUtils2.prototype.executeHandlers = function(evt, id2) {
      var container = this.events[id2];
      var callbackList = container && container[evt.type];
      if (callbackList) {
        for (var i = 0, l2 = callbackList.length; i < l2; i++) {
          var callback = callbackList[i];
          if (callback && callback.func.call(callback.scope, evt) === false) {
            evt.preventDefault();
          }
          if (evt.isImmediatePropagationStopped()) {
            return;
          }
        }
      }
    };
    EventUtils2.Event = new EventUtils2();
    return EventUtils2;
  }();
  var support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document$1, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains$3, expando = "sizzle" + -new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function(a, b) {
    if (a === b) {
      hasDuplicate = true;
    }
    return 0;
  }, strundefined = "undefined", MAX_NEGATIVE = 1 << 31, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, indexOf$2 = arr.indexOf || function(elem) {
    var i = 0, len = this.length;
    for (; i < len; i++) {
      if (this[i] === elem) {
        return i;
      }
    }
    return -1;
  }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", whitespace = "[\\x20\\t\\r\\n\\f]", identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+", attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + `*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(` + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + identifier + `)(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|` + attributes + ")*)|.*)\\)|)", rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rattributeQuotes = new RegExp("=" + whitespace + `*([^\\]'"]*?)` + whitespace + "*\\]", "g"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
    ID: new RegExp("^#(" + identifier + ")"),
    CLASS: new RegExp("^\\.(" + identifier + ")"),
    TAG: new RegExp("^(" + identifier + "|[*])"),
    ATTR: new RegExp("^" + attributes),
    PSEUDO: new RegExp("^" + pseudos),
    CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
    bool: new RegExp("^(?:" + booleans + ")$", "i"),
    needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
  }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, rescape = /'|\\/g, runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"), funescape = function(_, escaped, escapedWhitespace) {
    var high = "0x" + escaped - 65536;
    return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
  };
  try {
    push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
    arr[preferredDoc.childNodes.length].nodeType;
  } catch (e) {
    push = {
      apply: arr.length ? function(target, els) {
        push_native.apply(target, slice.call(els));
      } : function(target, els) {
        var j = target.length, i = 0;
        while (target[j++] = els[i++]) {
        }
        target.length = j - 1;
      }
    };
  }
  var Sizzle = function(selector, context2, results, seed2) {
    var match2, elem, m2, nodeType, i, groups, old, nid, newContext, newSelector;
    if ((context2 ? context2.ownerDocument || context2 : preferredDoc) !== document$1) {
      setDocument(context2);
    }
    context2 = context2 || document$1;
    results = results || [];
    if (!selector || typeof selector !== "string") {
      return results;
    }
    if ((nodeType = context2.nodeType) !== 1 && nodeType !== 9) {
      return [];
    }
    if (documentIsHTML && !seed2) {
      if (match2 = rquickExpr.exec(selector)) {
        if (m2 = match2[1]) {
          if (nodeType === 9) {
            elem = context2.getElementById(m2);
            if (elem && elem.parentNode) {
              if (elem.id === m2) {
                results.push(elem);
                return results;
              }
            } else {
              return results;
            }
          } else {
            if (context2.ownerDocument && (elem = context2.ownerDocument.getElementById(m2)) && contains$3(context2, elem) && elem.id === m2) {
              results.push(elem);
              return results;
            }
          }
        } else if (match2[2]) {
          push.apply(results, context2.getElementsByTagName(selector));
          return results;
        } else if ((m2 = match2[3]) && support.getElementsByClassName) {
          push.apply(results, context2.getElementsByClassName(m2));
          return results;
        }
      }
      if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
        nid = old = expando;
        newContext = context2;
        newSelector = nodeType === 9 && selector;
        if (nodeType === 1 && context2.nodeName.toLowerCase() !== "object") {
          groups = tokenize(selector);
          if (old = context2.getAttribute("id")) {
            nid = old.replace(rescape, "\\$&");
          } else {
            context2.setAttribute("id", nid);
          }
          nid = "[id='" + nid + "'] ";
          i = groups.length;
          while (i--) {
            groups[i] = nid + toSelector(groups[i]);
          }
          newContext = rsibling.test(selector) && testContext(context2.parentNode) || context2;
          newSelector = groups.join(",");
        }
        if (newSelector) {
          try {
            push.apply(results, newContext.querySelectorAll(newSelector));
            return results;
          } catch (qsaError) {
          } finally {
            if (!old) {
              context2.removeAttribute("id");
            }
          }
        }
      }
    }
    return select(selector.replace(rtrim, "$1"), context2, results, seed2);
  };
  function createCache() {
    var keys2 = [];
    function cache(key, value2) {
      if (keys2.push(key + " ") > Expr.cacheLength) {
        delete cache[keys2.shift()];
      }
      return cache[key + " "] = value2;
    }
    return cache;
  }
  function markFunction(fn) {
    fn[expando] = true;
    return fn;
  }
  function siblingCheck(a, b) {
    var cur = b && a, diff2 = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
    if (diff2) {
      return diff2;
    }
    if (cur) {
      while (cur = cur.nextSibling) {
        if (cur === b) {
          return -1;
        }
      }
    }
    return a ? 1 : -1;
  }
  function createInputPseudo(type2) {
    return function(elem) {
      var name2 = elem.nodeName.toLowerCase();
      return name2 === "input" && elem.type === type2;
    };
  }
  function createButtonPseudo(type2) {
    return function(elem) {
      var name2 = elem.nodeName.toLowerCase();
      return (name2 === "input" || name2 === "button") && elem.type === type2;
    };
  }
  function createPositionalPseudo(fn) {
    return markFunction(function(argument) {
      argument = +argument;
      return markFunction(function(seed2, matches2) {
        var j, matchIndexes = fn([], seed2.length, argument), i = matchIndexes.length;
        while (i--) {
          if (seed2[j = matchIndexes[i]]) {
            seed2[j] = !(matches2[j] = seed2[j]);
          }
        }
      });
    });
  }
  function testContext(context2) {
    return context2 && typeof context2.getElementsByTagName !== strundefined && context2;
  }
  support = Sizzle.support = {};
  isXML = Sizzle.isXML = function(elem) {
    var documentElement2 = elem && (elem.ownerDocument || elem).documentElement;
    return documentElement2 ? documentElement2.nodeName !== "HTML" : false;
  };
  setDocument = Sizzle.setDocument = function(node) {
    var hasCompare, doc2 = node ? node.ownerDocument || node : preferredDoc, parent2 = doc2.defaultView;
    function getTop(win) {
      try {
        return win.top;
      } catch (ex) {
      }
      return null;
    }
    if (doc2 === document$1 || doc2.nodeType !== 9 || !doc2.documentElement) {
      return document$1;
    }
    document$1 = doc2;
    docElem = doc2.documentElement;
    documentIsHTML = !isXML(doc2);
    if (parent2 && parent2 !== getTop(parent2)) {
      if (parent2.addEventListener) {
        parent2.addEventListener("unload", function() {
          setDocument();
        }, false);
      } else if (parent2.attachEvent) {
        parent2.attachEvent("onunload", function() {
          setDocument();
        });
      }
    }
    support.attributes = true;
    support.getElementsByTagName = true;
    support.getElementsByClassName = rnative.test(doc2.getElementsByClassName);
    support.getById = true;
    Expr.find.ID = function(id2, context2) {
      if (typeof context2.getElementById !== strundefined && documentIsHTML) {
        var m2 = context2.getElementById(id2);
        return m2 && m2.parentNode ? [m2] : [];
      }
    };
    Expr.filter.ID = function(id2) {
      var attrId = id2.replace(runescape, funescape);
      return function(elem) {
        return elem.getAttribute("id") === attrId;
      };
    };
    Expr.find.TAG = support.getElementsByTagName ? function(tag, context2) {
      if (typeof context2.getElementsByTagName !== strundefined) {
        return context2.getElementsByTagName(tag);
      }
    } : function(tag, context2) {
      var elem, tmp = [], i = 0, results = context2.getElementsByTagName(tag);
      if (tag === "*") {
        while (elem = results[i++]) {
          if (elem.nodeType === 1) {
            tmp.push(elem);
          }
        }
        return tmp;
      }
      return results;
    };
    Expr.find.CLASS = support.getElementsByClassName && function(className, context2) {
      if (documentIsHTML) {
        return context2.getElementsByClassName(className);
      }
    };
    rbuggyMatches = [];
    rbuggyQSA = [];
    support.disconnectedMatch = true;
    rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
    rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
    hasCompare = rnative.test(docElem.compareDocumentPosition);
    contains$3 = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
      var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
      return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
    } : function(a, b) {
      if (b) {
        while (b = b.parentNode) {
          if (b === a) {
            return true;
          }
        }
      }
      return false;
    };
    sortOrder = hasCompare ? function(a, b) {
      if (a === b) {
        hasDuplicate = true;
        return 0;
      }
      var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
      if (compare) {
        return compare;
      }
      compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
      if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
        if (a === doc2 || a.ownerDocument === preferredDoc && contains$3(preferredDoc, a)) {
          return -1;
        }
        if (b === doc2 || b.ownerDocument === preferredDoc && contains$3(preferredDoc, b)) {
          return 1;
        }
        return sortInput ? indexOf$2.call(sortInput, a) - indexOf$2.call(sortInput, b) : 0;
      }
      return compare & 4 ? -1 : 1;
    } : function(a, b) {
      if (a === b) {
        hasDuplicate = true;
        return 0;
      }
      var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];
      if (!aup || !bup) {
        return a === doc2 ? -1 : b === doc2 ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf$2.call(sortInput, a) - indexOf$2.call(sortInput, b) : 0;
      } else if (aup === bup) {
        return siblingCheck(a, b);
      }
      cur = a;
      while (cur = cur.parentNode) {
        ap.unshift(cur);
      }
      cur = b;
      while (cur = cur.parentNode) {
        bp.unshift(cur);
      }
      while (ap[i] === bp[i]) {
        i++;
      }
      return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
    };
    return doc2;
  };
  Sizzle.matches = function(expr, elements) {
    return Sizzle(expr, null, null, elements);
  };
  Sizzle.matchesSelector = function(elem, expr) {
    if ((elem.ownerDocument || elem) !== document$1) {
      setDocument(elem);
    }
    expr = expr.replace(rattributeQuotes, "='$1']");
    if (support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
      try {
        var ret = matches.call(elem, expr);
        if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
          return ret;
        }
      } catch (e) {
      }
    }
    return Sizzle(expr, document$1, null, [elem]).length > 0;
  };
  Sizzle.contains = function(context2, elem) {
    if ((context2.ownerDocument || context2) !== document$1) {
      setDocument(context2);
    }
    return contains$3(context2, elem);
  };
  Sizzle.attr = function(elem, name2) {
    if ((elem.ownerDocument || elem) !== document$1) {
      setDocument(elem);
    }
    var fn = Expr.attrHandle[name2.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name2.toLowerCase()) ? fn(elem, name2, !documentIsHTML) : void 0;
    return val !== void 0 ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name2) : (val = elem.getAttributeNode(name2)) && val.specified ? val.value : null;
  };
  Sizzle.error = function(msg) {
    throw new Error("Syntax error, unrecognized expression: " + msg);
  };
  Sizzle.uniqueSort = function(results) {
    var elem, duplicates = [], j = 0, i = 0;
    hasDuplicate = !support.detectDuplicates;
    sortInput = !support.sortStable && results.slice(0);
    results.sort(sortOrder);
    if (hasDuplicate) {
      while (elem = results[i++]) {
        if (elem === results[i]) {
          j = duplicates.push(i);
        }
      }
      while (j--) {
        results.splice(duplicates[j], 1);
      }
    }
    sortInput = null;
    return results;
  };
  getText = Sizzle.getText = function(elem) {
    var node, ret = "", i = 0, nodeType = elem.nodeType;
    if (!nodeType) {
      while (node = elem[i++]) {
        ret += getText(node);
      }
    } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
      if (typeof elem.textContent === "string") {
        return elem.textContent;
      } else {
        for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
          ret += getText(elem);
        }
      }
    } else if (nodeType === 3 || nodeType === 4) {
      return elem.nodeValue;
    }
    return ret;
  };
  Expr = Sizzle.selectors = {
    cacheLength: 50,
    createPseudo: markFunction,
    match: matchExpr,
    attrHandle: {},
    find: {},
    relative: {
      ">": {
        dir: "parentNode",
        first: true
      },
      " ": { dir: "parentNode" },
      "+": {
        dir: "previousSibling",
        first: true
      },
      "~": { dir: "previousSibling" }
    },
    preFilter: {
      ATTR: function(match2) {
        match2[1] = match2[1].replace(runescape, funescape);
        match2[3] = (match2[3] || match2[4] || match2[5] || "").replace(runescape, funescape);
        if (match2[2] === "~=") {
          match2[3] = " " + match2[3] + " ";
        }
        return match2.slice(0, 4);
      },
      CHILD: function(match2) {
        match2[1] = match2[1].toLowerCase();
        if (match2[1].slice(0, 3) === "nth") {
          if (!match2[3]) {
            Sizzle.error(match2[0]);
          }
          match2[4] = +(match2[4] ? match2[5] + (match2[6] || 1) : 2 * (match2[3] === "even" || match2[3] === "odd"));
          match2[5] = +(match2[7] + match2[8] || match2[3] === "odd");
        } else if (match2[3]) {
          Sizzle.error(match2[0]);
        }
        return match2;
      },
      PSEUDO: function(match2) {
        var excess, unquoted = !match2[6] && match2[2];
        if (matchExpr.CHILD.test(match2[0])) {
          return null;
        }
        if (match2[3]) {
          match2[2] = match2[4] || match2[5] || "";
        } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
          match2[0] = match2[0].slice(0, excess);
          match2[2] = unquoted.slice(0, excess);
        }
        return match2.slice(0, 3);
      }
    },
    filter: {
      TAG: function(nodeNameSelector) {
        var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
        return nodeNameSelector === "*" ? function() {
          return true;
        } : function(elem) {
          return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
        };
      },
      CLASS: function(className) {
        var pattern = classCache[className + " "];
        return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
          return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute("class") || "");
        });
      },
      ATTR: function(name2, operator, check) {
        return function(elem) {
          var result = Sizzle.attr(elem, name2);
          if (result == null) {
            return operator === "!=";
          }
          if (!operator) {
            return true;
          }
          result += "";
          return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
        };
      },
      CHILD: function(type2, what, argument, first2, last2) {
        var simple = type2.slice(0, 3) !== "nth", forward = type2.slice(-4) !== "last", ofType = what === "of-type";
        return first2 === 1 && last2 === 0 ? function(elem) {
          return !!elem.parentNode;
        } : function(elem, context2, xml) {
          var cache, outerCache, node, diff2, nodeIndex2, start2, dir2 = simple !== forward ? "nextSibling" : "previousSibling", parent2 = elem.parentNode, name2 = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType;
          if (parent2) {
            if (simple) {
              while (dir2) {
                node = elem;
                while (node = node[dir2]) {
                  if (ofType ? node.nodeName.toLowerCase() === name2 : node.nodeType === 1) {
                    return false;
                  }
                }
                start2 = dir2 = type2 === "only" && !start2 && "nextSibling";
              }
              return true;
            }
            start2 = [forward ? parent2.firstChild : parent2.lastChild];
            if (forward && useCache) {
              outerCache = parent2[expando] || (parent2[expando] = {});
              cache = outerCache[type2] || [];
              nodeIndex2 = cache[0] === dirruns && cache[1];
              diff2 = cache[0] === dirruns && cache[2];
              node = nodeIndex2 && parent2.childNodes[nodeIndex2];
              while (node = ++nodeIndex2 && node && node[dir2] || (diff2 = nodeIndex2 = 0) || start2.pop()) {
                if (node.nodeType === 1 && ++diff2 && node === elem) {
                  outerCache[type2] = [
                    dirruns,
                    nodeIndex2,
                    diff2
                  ];
                  break;
                }
              }
            } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type2]) && cache[0] === dirruns) {
              diff2 = cache[1];
            } else {
              while (node = ++nodeIndex2 && node && node[dir2] || (diff2 = nodeIndex2 = 0) || start2.pop()) {
                if ((ofType ? node.nodeName.toLowerCase() === name2 : node.nodeType === 1) && ++diff2) {
                  if (useCache) {
                    (node[expando] || (node[expando] = {}))[type2] = [
                      dirruns,
                      diff2
                    ];
                  }
                  if (node === elem) {
                    break;
                  }
                }
              }
            }
            diff2 -= last2;
            return diff2 === first2 || diff2 % first2 === 0 && diff2 / first2 >= 0;
          }
        };
      },
      PSEUDO: function(pseudo, argument) {
        var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
        if (fn[expando]) {
          return fn(argument);
        }
        if (fn.length > 1) {
          args = [
            pseudo,
            pseudo,
            "",
            argument
          ];
          return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed2, matches2) {
            var idx, matched = fn(seed2, argument), i = matched.length;
            while (i--) {
              idx = indexOf$2.call(seed2, matched[i]);
              seed2[idx] = !(matches2[idx] = matched[i]);
            }
          }) : function(elem) {
            return fn(elem, 0, args);
          };
        }
        return fn;
      }
    },
    pseudos: {
      not: markFunction(function(selector) {
        var input = [], results = [], matcher = compile(selector.replace(rtrim, "$1"));
        return matcher[expando] ? markFunction(function(seed2, matches2, context2, xml) {
          var elem, unmatched = matcher(seed2, null, xml, []), i = seed2.length;
          while (i--) {
            if (elem = unmatched[i]) {
              seed2[i] = !(matches2[i] = elem);
            }
          }
        }) : function(elem, context2, xml) {
          input[0] = elem;
          matcher(input, null, xml, results);
          input[0] = null;
          return !results.pop();
        };
      }),
      has: markFunction(function(selector) {
        return function(elem) {
          return Sizzle(selector, elem).length > 0;
        };
      }),
      contains: markFunction(function(text) {
        text = text.replace(runescape, funescape);
        return function(elem) {
          return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
        };
      }),
      lang: markFunction(function(lang) {
        if (!ridentifier.test(lang || "")) {
          Sizzle.error("unsupported lang: " + lang);
        }
        lang = lang.replace(runescape, funescape).toLowerCase();
        return function(elem) {
          var elemLang;
          do {
            if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
              elemLang = elemLang.toLowerCase();
              return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
            }
          } while ((elem = elem.parentNode) && elem.nodeType === 1);
          return false;
        };
      }),
      target: function(elem) {
        var hash = window.location && window.location.hash;
        return hash && hash.slice(1) === elem.id;
      },
      root: function(elem) {
        return elem === docElem;
      },
      focus: function(elem) {
        return elem === document$1.activeElement && (!document$1.hasFocus || document$1.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
      },
      enabled: function(elem) {
        return elem.disabled === false;
      },
      disabled: function(elem) {
        return elem.disabled === true;
      },
      checked: function(elem) {
        var nodeName = elem.nodeName.toLowerCase();
        return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
      },
      selected: function(elem) {
        if (elem.parentNode) {
          elem.parentNode.selectedIndex;
        }
        return elem.selected === true;
      },
      empty: function(elem) {
        for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
          if (elem.nodeType < 6) {
            return false;
          }
        }
        return true;
      },
      parent: function(elem) {
        return !Expr.pseudos.empty(elem);
      },
      header: function(elem) {
        return rheader.test(elem.nodeName);
      },
      input: function(elem) {
        return rinputs.test(elem.nodeName);
      },
      button: function(elem) {
        var name2 = elem.nodeName.toLowerCase();
        return name2 === "input" && elem.type === "button" || name2 === "button";
      },
      text: function(elem) {
        var attr;
        return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
      },
      first: createPositionalPseudo(function() {
        return [0];
      }),
      last: createPositionalPseudo(function(matchIndexes, length) {
        return [length - 1];
      }),
      eq: createPositionalPseudo(function(matchIndexes, length, argument) {
        return [argument < 0 ? argument + length : argument];
      }),
      even: createPositionalPseudo(function(matchIndexes, length) {
        var i = 0;
        for (; i < length; i += 2) {
          matchIndexes.push(i);
        }
        return matchIndexes;
      }),
      odd: createPositionalPseudo(function(matchIndexes, length) {
        var i = 1;
        for (; i < length; i += 2) {
          matchIndexes.push(i);
        }
        return matchIndexes;
      }),
      lt: createPositionalPseudo(function(matchIndexes, length, argument) {
        var i = argument < 0 ? argument + length : argument;
        for (; --i >= 0; ) {
          matchIndexes.push(i);
        }
        return matchIndexes;
      }),
      gt: createPositionalPseudo(function(matchIndexes, length, argument) {
        var i = argument < 0 ? argument + length : argument;
        for (; ++i < length; ) {
          matchIndexes.push(i);
        }
        return matchIndexes;
      })
    }
  };
  Expr.pseudos.nth = Expr.pseudos.eq;
  each([
    "radio",
    "checkbox",
    "file",
    "password",
    "image"
  ], function(i) {
    Expr.pseudos[i] = createInputPseudo(i);
  });
  each([
    "submit",
    "reset"
  ], function(i) {
    Expr.pseudos[i] = createButtonPseudo(i);
  });
  function setFilters() {
  }
  setFilters.prototype = Expr.filters = Expr.pseudos;
  Expr.setFilters = new setFilters();
  tokenize = Sizzle.tokenize = function(selector, parseOnly) {
    var matched, match2, tokens, type2, soFar, groups, preFilters, cached2 = tokenCache[selector + " "];
    if (cached2) {
      return parseOnly ? 0 : cached2.slice(0);
    }
    soFar = selector;
    groups = [];
    preFilters = Expr.preFilter;
    while (soFar) {
      if (!matched || (match2 = rcomma.exec(soFar))) {
        if (match2) {
          soFar = soFar.slice(match2[0].length) || soFar;
        }
        groups.push(tokens = []);
      }
      matched = false;
      if (match2 = rcombinators.exec(soFar)) {
        matched = match2.shift();
        tokens.push({
          value: matched,
          type: match2[0].replace(rtrim, " ")
        });
        soFar = soFar.slice(matched.length);
      }
      for (type2 in Expr.filter) {
        if (!Expr.filter.hasOwnProperty(type2)) {
          continue;
        }
        if ((match2 = matchExpr[type2].exec(soFar)) && (!preFilters[type2] || (match2 = preFilters[type2](match2)))) {
          matched = match2.shift();
          tokens.push({
            value: matched,
            type: type2,
            matches: match2
          });
          soFar = soFar.slice(matched.length);
        }
      }
      if (!matched) {
        break;
      }
    }
    return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
  };
  function toSelector(tokens) {
    var i = 0, len = tokens.length, selector = "";
    for (; i < len; i++) {
      selector += tokens[i].value;
    }
    return selector;
  }
  function addCombinator(matcher, combinator, base) {
    var dir2 = combinator.dir, checkNonElements = base && dir2 === "parentNode", doneName = done++;
    return combinator.first ? function(elem, context2, xml) {
      while (elem = elem[dir2]) {
        if (elem.nodeType === 1 || checkNonElements) {
          return matcher(elem, context2, xml);
        }
      }
    } : function(elem, context2, xml) {
      var oldCache, outerCache, newCache = [
        dirruns,
        doneName
      ];
      if (xml) {
        while (elem = elem[dir2]) {
          if (elem.nodeType === 1 || checkNonElements) {
            if (matcher(elem, context2, xml)) {
              return true;
            }
          }
        }
      } else {
        while (elem = elem[dir2]) {
          if (elem.nodeType === 1 || checkNonElements) {
            outerCache = elem[expando] || (elem[expando] = {});
            if ((oldCache = outerCache[dir2]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
              return newCache[2] = oldCache[2];
            } else {
              outerCache[dir2] = newCache;
              if (newCache[2] = matcher(elem, context2, xml)) {
                return true;
              }
            }
          }
        }
      }
    };
  }
  function elementMatcher(matchers) {
    return matchers.length > 1 ? function(elem, context2, xml) {
      var i = matchers.length;
      while (i--) {
        if (!matchers[i](elem, context2, xml)) {
          return false;
        }
      }
      return true;
    } : matchers[0];
  }
  function multipleContexts(selector, contexts, results) {
    var i = 0, len = contexts.length;
    for (; i < len; i++) {
      Sizzle(selector, contexts[i], results);
    }
    return results;
  }
  function condense(unmatched, map2, filter2, context2, xml) {
    var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map2 != null;
    for (; i < len; i++) {
      if (elem = unmatched[i]) {
        if (!filter2 || filter2(elem, context2, xml)) {
          newUnmatched.push(elem);
          if (mapped) {
            map2.push(i);
          }
        }
      }
    }
    return newUnmatched;
  }
  function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
    if (postFilter && !postFilter[expando]) {
      postFilter = setMatcher(postFilter);
    }
    if (postFinder && !postFinder[expando]) {
      postFinder = setMatcher(postFinder, postSelector);
    }
    return markFunction(function(seed2, results, context2, xml) {
      var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed2 || multipleContexts(selector || "*", context2.nodeType ? [context2] : context2, []), matcherIn = preFilter && (seed2 || !selector) ? condense(elems, preMap, preFilter, context2, xml) : elems, matcherOut = matcher ? postFinder || (seed2 ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
      if (matcher) {
        matcher(matcherIn, matcherOut, context2, xml);
      }
      if (postFilter) {
        temp = condense(matcherOut, postMap);
        postFilter(temp, [], context2, xml);
        i = temp.length;
        while (i--) {
          if (elem = temp[i]) {
            matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
          }
        }
      }
      if (seed2) {
        if (postFinder || preFilter) {
          if (postFinder) {
            temp = [];
            i = matcherOut.length;
            while (i--) {
              if (elem = matcherOut[i]) {
                temp.push(matcherIn[i] = elem);
              }
            }
            postFinder(null, matcherOut = [], temp, xml);
          }
          i = matcherOut.length;
          while (i--) {
            if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf$2.call(seed2, elem) : preMap[i]) > -1) {
              seed2[temp] = !(results[temp] = elem);
            }
          }
        }
      } else {
        matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
        if (postFinder) {
          postFinder(null, results, matcherOut, xml);
        } else {
          push.apply(results, matcherOut);
        }
      }
    });
  }
  function matcherFromTokens(tokens) {
    var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
      return elem === checkContext;
    }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
      return indexOf$2.call(checkContext, elem) > -1;
    }, implicitRelative, true), matchers = [function(elem, context2, xml) {
      var ret = !leadingRelative && (xml || context2 !== outermostContext) || ((checkContext = context2).nodeType ? matchContext(elem, context2, xml) : matchAnyContext(elem, context2, xml));
      checkContext = null;
      return ret;
    }];
    for (; i < len; i++) {
      if (matcher = Expr.relative[tokens[i].type]) {
        matchers = [addCombinator(elementMatcher(matchers), matcher)];
      } else {
        matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
        if (matcher[expando]) {
          j = ++i;
          for (; j < len; j++) {
            if (Expr.relative[tokens[j].type]) {
              break;
            }
          }
          return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === " " ? "*" : "" })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
        }
        matchers.push(matcher);
      }
    }
    return elementMatcher(matchers);
  }
  function matcherFromGroupMatchers(elementMatchers, setMatchers) {
    var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed2, context2, xml, results, outermost) {
      var elem, j, matcher, matchedCount = 0, i = "0", unmatched = seed2 && [], setMatched = [], contextBackup = outermostContext, elems = seed2 || byElement && Expr.find.TAG("*", outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
      if (outermost) {
        outermostContext = context2 !== document$1 && context2;
      }
      for (; i !== len && (elem = elems[i]) != null; i++) {
        if (byElement && elem) {
          j = 0;
          while (matcher = elementMatchers[j++]) {
            if (matcher(elem, context2, xml)) {
              results.push(elem);
              break;
            }
          }
          if (outermost) {
            dirruns = dirrunsUnique;
          }
        }
        if (bySet) {
          if (elem = !matcher && elem) {
            matchedCount--;
          }
          if (seed2) {
            unmatched.push(elem);
          }
        }
      }
      matchedCount += i;
      if (bySet && i !== matchedCount) {
        j = 0;
        while (matcher = setMatchers[j++]) {
          matcher(unmatched, setMatched, context2, xml);
        }
        if (seed2) {
          if (matchedCount > 0) {
            while (i--) {
              if (!(unmatched[i] || setMatched[i])) {
                setMatched[i] = pop.call(results);
              }
            }
          }
          setMatched = condense(setMatched);
        }
        push.apply(results, setMatched);
        if (outermost && !seed2 && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
          Sizzle.uniqueSort(results);
        }
      }
      if (outermost) {
        dirruns = dirrunsUnique;
        outermostContext = contextBackup;
      }
      return unmatched;
    };
    return bySet ? markFunction(superMatcher) : superMatcher;
  }
  compile = Sizzle.compile = function(selector, match2) {
    var i, setMatchers = [], elementMatchers = [], cached2 = compilerCache[selector + " "];
    if (!cached2) {
      if (!match2) {
        match2 = tokenize(selector);
      }
      i = match2.length;
      while (i--) {
        cached2 = matcherFromTokens(match2[i]);
        if (cached2[expando]) {
          setMatchers.push(cached2);
        } else {
          elementMatchers.push(cached2);
        }
      }
      cached2 = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
      cached2.selector = selector;
    }
    return cached2;
  };
  select = Sizzle.select = function(selector, context2, results, seed2) {
    var i, tokens, token, type2, find2, compiled = typeof selector === "function" && selector, match2 = !seed2 && tokenize(selector = compiled.selector || selector);
    results = results || [];
    if (match2.length === 1) {
      tokens = match2[0] = match2[0].slice(0);
      if (tokens.length > 2 && (token = tokens[0]).type === "ID" && support.getById && context2.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
        context2 = (Expr.find.ID(token.matches[0].replace(runescape, funescape), context2) || [])[0];
        if (!context2) {
          return results;
        } else if (compiled) {
          context2 = context2.parentNode;
        }
        selector = selector.slice(tokens.shift().value.length);
      }
      i = matchExpr.needsContext.test(selector) ? 0 : tokens.length;
      while (i--) {
        token = tokens[i];
        if (Expr.relative[type2 = token.type]) {
          break;
        }
        if (find2 = Expr.find[type2]) {
          if (seed2 = find2(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context2.parentNode) || context2)) {
            tokens.splice(i, 1);
            selector = seed2.length && toSelector(tokens);
            if (!selector) {
              push.apply(results, seed2);
              return results;
            }
            break;
          }
        }
      }
    }
    (compiled || compile(selector, match2))(seed2, context2, !documentIsHTML, results, rsibling.test(selector) && testContext(context2.parentNode) || context2);
    return results;
  };
  support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
  support.detectDuplicates = !!hasDuplicate;
  setDocument();
  support.sortDetached = true;
  var doc = document;
  var push$1 = Array.prototype.push;
  var slice$1 = Array.prototype.slice;
  var rquickExpr$1 = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/;
  var Event = EventUtils.Event;
  var skipUniques = Tools.makeMap("children,contents,next,prev");
  var isDefined = function(obj) {
    return typeof obj !== "undefined";
  };
  var isString$1 = function(obj) {
    return typeof obj === "string";
  };
  var isWindow = function(obj) {
    return obj && obj === obj.window;
  };
  var createFragment = function(html, fragDoc) {
    fragDoc = fragDoc || doc;
    var container = fragDoc.createElement("div");
    var frag = fragDoc.createDocumentFragment();
    container.innerHTML = html;
    var node;
    while (node = container.firstChild) {
      frag.appendChild(node);
    }
    return frag;
  };
  var domManipulate = function(targetNodes, sourceItem, callback, reverse2) {
    var i;
    if (isString$1(sourceItem)) {
      sourceItem = createFragment(sourceItem, getElementDocument(targetNodes[0]));
    } else if (sourceItem.length && !sourceItem.nodeType) {
      sourceItem = DomQuery.makeArray(sourceItem);
      if (reverse2) {
        for (i = sourceItem.length - 1; i >= 0; i--) {
          domManipulate(targetNodes, sourceItem[i], callback, reverse2);
        }
      } else {
        for (i = 0; i < sourceItem.length; i++) {
          domManipulate(targetNodes, sourceItem[i], callback, reverse2);
        }
      }
      return targetNodes;
    }
    if (sourceItem.nodeType) {
      i = targetNodes.length;
      while (i--) {
        callback.call(targetNodes[i], sourceItem);
      }
    }
    return targetNodes;
  };
  var hasClass = function(node, className) {
    return node && className && (" " + node.className + " ").indexOf(" " + className + " ") !== -1;
  };
  var wrap$1 = function(elements, wrapper, all2) {
    var lastParent, newWrapper;
    wrapper = DomQuery(wrapper)[0];
    elements.each(function() {
      var self2 = this;
      if (!all2 || lastParent !== self2.parentNode) {
        lastParent = self2.parentNode;
        newWrapper = wrapper.cloneNode(false);
        self2.parentNode.insertBefore(newWrapper, self2);
        newWrapper.appendChild(self2);
      } else {
        newWrapper.appendChild(self2);
      }
    });
    return elements;
  };
  var numericCssMap = Tools.makeMap("fillOpacity fontWeight lineHeight opacity orphans widows zIndex zoom", " ");
  var booleanMap = Tools.makeMap("checked compact declare defer disabled ismap multiple nohref noshade nowrap readonly selected", " ");
  var propFix = {
    for: "htmlFor",
    class: "className",
    readonly: "readOnly"
  };
  var cssFix = { float: "cssFloat" };
  var attrHooks = {}, cssHooks = {};
  var DomQueryConstructor = function(selector, context2) {
    return new DomQuery.fn.init(selector, context2);
  };
  var inArray$1 = function(item, array) {
    var i;
    if (array.indexOf) {
      return array.indexOf(item);
    }
    i = array.length;
    while (i--) {
      if (array[i] === item) {
        return i;
      }
    }
    return -1;
  };
  var whiteSpaceRegExp$2 = /^\s*|\s*$/g;
  var trim$3 = function(str) {
    return str === null || str === void 0 ? "" : ("" + str).replace(whiteSpaceRegExp$2, "");
  };
  var each$4 = function(obj, callback) {
    var length, key, i, value2;
    if (obj) {
      length = obj.length;
      if (length === void 0) {
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            value2 = obj[key];
            if (callback.call(value2, key, value2) === false) {
              break;
            }
          }
        }
      } else {
        for (i = 0; i < length; i++) {
          value2 = obj[i];
          if (callback.call(value2, i, value2) === false) {
            break;
          }
        }
      }
    }
    return obj;
  };
  var grep = function(array, callback) {
    var out = [];
    each$4(array, function(i, item) {
      if (callback(item, i)) {
        out.push(item);
      }
    });
    return out;
  };
  var getElementDocument = function(element) {
    if (!element) {
      return doc;
    }
    if (element.nodeType === 9) {
      return element;
    }
    return element.ownerDocument;
  };
  DomQueryConstructor.fn = DomQueryConstructor.prototype = {
    constructor: DomQueryConstructor,
    selector: "",
    context: null,
    length: 0,
    init: function(selector, context2) {
      var self2 = this;
      var match2, node;
      if (!selector) {
        return self2;
      }
      if (selector.nodeType) {
        self2.context = self2[0] = selector;
        self2.length = 1;
        return self2;
      }
      if (context2 && context2.nodeType) {
        self2.context = context2;
      } else {
        if (context2) {
          return DomQuery(selector).attr(context2);
        }
        self2.context = context2 = document;
      }
      if (isString$1(selector)) {
        self2.selector = selector;
        if (selector.charAt(0) === "<" && selector.charAt(selector.length - 1) === ">" && selector.length >= 3) {
          match2 = [
            null,
            selector,
            null
          ];
        } else {
          match2 = rquickExpr$1.exec(selector);
        }
        if (match2) {
          if (match2[1]) {
            node = createFragment(selector, getElementDocument(context2)).firstChild;
            while (node) {
              push$1.call(self2, node);
              node = node.nextSibling;
            }
          } else {
            node = getElementDocument(context2).getElementById(match2[2]);
            if (!node) {
              return self2;
            }
            if (node.id !== match2[2]) {
              return self2.find(selector);
            }
            self2.length = 1;
            self2[0] = node;
          }
        } else {
          return DomQuery(context2).find(selector);
        }
      } else {
        this.add(selector, false);
      }
      return self2;
    },
    toArray: function() {
      return Tools.toArray(this);
    },
    add: function(items, sort2) {
      var self2 = this;
      var nodes, i;
      if (isString$1(items)) {
        return self2.add(DomQuery(items));
      }
      if (sort2 !== false) {
        nodes = DomQuery.unique(self2.toArray().concat(DomQuery.makeArray(items)));
        self2.length = nodes.length;
        for (i = 0; i < nodes.length; i++) {
          self2[i] = nodes[i];
        }
      } else {
        push$1.apply(self2, DomQuery.makeArray(items));
      }
      return self2;
    },
    attr: function(name2, value2) {
      var self2 = this;
      var hook;
      if (typeof name2 === "object") {
        each$4(name2, function(name3, value3) {
          self2.attr(name3, value3);
        });
      } else if (isDefined(value2)) {
        this.each(function() {
          var hook2;
          if (this.nodeType === 1) {
            hook2 = attrHooks[name2];
            if (hook2 && hook2.set) {
              hook2.set(this, value2);
              return;
            }
            if (value2 === null) {
              this.removeAttribute(name2, 2);
            } else {
              this.setAttribute(name2, value2, 2);
            }
          }
        });
      } else {
        if (self2[0] && self2[0].nodeType === 1) {
          hook = attrHooks[name2];
          if (hook && hook.get) {
            return hook.get(self2[0], name2);
          }
          if (booleanMap[name2]) {
            return self2.prop(name2) ? name2 : void 0;
          }
          value2 = self2[0].getAttribute(name2, 2);
          if (value2 === null) {
            value2 = void 0;
          }
        }
        return value2;
      }
      return self2;
    },
    removeAttr: function(name2) {
      return this.attr(name2, null);
    },
    prop: function(name2, value2) {
      var self2 = this;
      name2 = propFix[name2] || name2;
      if (typeof name2 === "object") {
        each$4(name2, function(name3, value3) {
          self2.prop(name3, value3);
        });
      } else if (isDefined(value2)) {
        this.each(function() {
          if (this.nodeType === 1) {
            this[name2] = value2;
          }
        });
      } else {
        if (self2[0] && self2[0].nodeType && name2 in self2[0]) {
          return self2[0][name2];
        }
        return value2;
      }
      return self2;
    },
    css: function(name2, value2) {
      var self2 = this;
      var elm, hook;
      var camel = function(name3) {
        return name3.replace(/-(\D)/g, function(a, b) {
          return b.toUpperCase();
        });
      };
      var dashed = function(name3) {
        return name3.replace(/[A-Z]/g, function(a) {
          return "-" + a;
        });
      };
      if (typeof name2 === "object") {
        each$4(name2, function(name3, value3) {
          self2.css(name3, value3);
        });
      } else {
        if (isDefined(value2)) {
          name2 = camel(name2);
          if (typeof value2 === "number" && !numericCssMap[name2]) {
            value2 = value2.toString() + "px";
          }
          self2.each(function() {
            var style = this.style;
            hook = cssHooks[name2];
            if (hook && hook.set) {
              hook.set(this, value2);
              return;
            }
            try {
              this.style[cssFix[name2] || name2] = value2;
            } catch (ex) {
            }
            if (value2 === null || value2 === "") {
              if (style.removeProperty) {
                style.removeProperty(dashed(name2));
              } else {
                style.removeAttribute(name2);
              }
            }
          });
        } else {
          elm = self2[0];
          hook = cssHooks[name2];
          if (hook && hook.get) {
            return hook.get(elm);
          }
          if (elm.ownerDocument.defaultView) {
            try {
              return elm.ownerDocument.defaultView.getComputedStyle(elm, null).getPropertyValue(dashed(name2));
            } catch (ex) {
              return void 0;
            }
          } else if (elm.currentStyle) {
            return elm.currentStyle[camel(name2)];
          } else {
            return "";
          }
        }
      }
      return self2;
    },
    remove: function() {
      var self2 = this;
      var node, i = this.length;
      while (i--) {
        node = self2[i];
        Event.clean(node);
        if (node.parentNode) {
          node.parentNode.removeChild(node);
        }
      }
      return this;
    },
    empty: function() {
      var self2 = this;
      var node, i = this.length;
      while (i--) {
        node = self2[i];
        while (node.firstChild) {
          node.removeChild(node.firstChild);
        }
      }
      return this;
    },
    html: function(value2) {
      var self2 = this;
      var i;
      if (isDefined(value2)) {
        i = self2.length;
        try {
          while (i--) {
            self2[i].innerHTML = value2;
          }
        } catch (ex) {
          DomQuery(self2[i]).empty().append(value2);
        }
        return self2;
      }
      return self2[0] ? self2[0].innerHTML : "";
    },
    text: function(value2) {
      var self2 = this;
      var i;
      if (isDefined(value2)) {
        i = self2.length;
        while (i--) {
          if ("innerText" in self2[i]) {
            self2[i].innerText = value2;
          } else {
            self2[0].textContent = value2;
          }
        }
        return self2;
      }
      return self2[0] ? self2[0].innerText || self2[0].textContent : "";
    },
    append: function() {
      return domManipulate(this, arguments, function(node) {
        if (this.nodeType === 1 || this.host && this.host.nodeType === 1) {
          this.appendChild(node);
        }
      });
    },
    prepend: function() {
      return domManipulate(this, arguments, function(node) {
        if (this.nodeType === 1 || this.host && this.host.nodeType === 1) {
          this.insertBefore(node, this.firstChild);
        }
      }, true);
    },
    before: function() {
      var self2 = this;
      if (self2[0] && self2[0].parentNode) {
        return domManipulate(self2, arguments, function(node) {
          this.parentNode.insertBefore(node, this);
        });
      }
      return self2;
    },
    after: function() {
      var self2 = this;
      if (self2[0] && self2[0].parentNode) {
        return domManipulate(self2, arguments, function(node) {
          this.parentNode.insertBefore(node, this.nextSibling);
        }, true);
      }
      return self2;
    },
    appendTo: function(val) {
      DomQuery(val).append(this);
      return this;
    },
    prependTo: function(val) {
      DomQuery(val).prepend(this);
      return this;
    },
    replaceWith: function(content) {
      return this.before(content).remove();
    },
    wrap: function(content) {
      return wrap$1(this, content);
    },
    wrapAll: function(content) {
      return wrap$1(this, content, true);
    },
    wrapInner: function(content) {
      this.each(function() {
        DomQuery(this).contents().wrapAll(content);
      });
      return this;
    },
    unwrap: function() {
      return this.parent().each(function() {
        DomQuery(this).replaceWith(this.childNodes);
      });
    },
    clone: function() {
      var result = [];
      this.each(function() {
        result.push(this.cloneNode(true));
      });
      return DomQuery(result);
    },
    addClass: function(className) {
      return this.toggleClass(className, true);
    },
    removeClass: function(className) {
      return this.toggleClass(className, false);
    },
    toggleClass: function(className, state) {
      var self2 = this;
      if (typeof className !== "string") {
        return self2;
      }
      if (className.indexOf(" ") !== -1) {
        each$4(className.split(" "), function() {
          self2.toggleClass(this, state);
        });
      } else {
        self2.each(function(index, node) {
          var classState = hasClass(node, className);
          if (classState !== state) {
            var existingClassName = node.className;
            if (classState) {
              node.className = trim$3((" " + existingClassName + " ").replace(" " + className + " ", " "));
            } else {
              node.className += existingClassName ? " " + className : className;
            }
          }
        });
      }
      return self2;
    },
    hasClass: function(className) {
      return hasClass(this[0], className);
    },
    each: function(callback) {
      return each$4(this, callback);
    },
    on: function(name2, callback) {
      return this.each(function() {
        Event.bind(this, name2, callback);
      });
    },
    off: function(name2, callback) {
      return this.each(function() {
        Event.unbind(this, name2, callback);
      });
    },
    trigger: function(name2) {
      return this.each(function() {
        if (typeof name2 === "object") {
          Event.fire(this, name2.type, name2);
        } else {
          Event.fire(this, name2);
        }
      });
    },
    show: function() {
      return this.css("display", "");
    },
    hide: function() {
      return this.css("display", "none");
    },
    slice: function() {
      return DomQuery(slice$1.apply(this, arguments));
    },
    eq: function(index) {
      return index === -1 ? this.slice(index) : this.slice(index, +index + 1);
    },
    first: function() {
      return this.eq(0);
    },
    last: function() {
      return this.eq(-1);
    },
    find: function(selector) {
      var i, l2;
      var ret = [];
      for (i = 0, l2 = this.length; i < l2; i++) {
        DomQuery.find(selector, this[i], ret);
      }
      return DomQuery(ret);
    },
    filter: function(selector) {
      if (typeof selector === "function") {
        return DomQuery(grep(this.toArray(), function(item, i) {
          return selector(i, item);
        }));
      }
      return DomQuery(DomQuery.filter(selector, this.toArray()));
    },
    closest: function(selector) {
      var result = [];
      if (selector instanceof DomQuery) {
        selector = selector[0];
      }
      this.each(function(i, node) {
        while (node) {
          if (typeof selector === "string" && DomQuery(node).is(selector)) {
            result.push(node);
            break;
          } else if (node === selector) {
            result.push(node);
            break;
          }
          node = node.parentNode;
        }
      });
      return DomQuery(result);
    },
    offset: function(offset) {
      var elm, doc2, docElm;
      var x2 = 0, y2 = 0, pos;
      if (!offset) {
        elm = this[0];
        if (elm) {
          doc2 = elm.ownerDocument;
          docElm = doc2.documentElement;
          if (elm.getBoundingClientRect) {
            pos = elm.getBoundingClientRect();
            x2 = pos.left + (docElm.scrollLeft || doc2.body.scrollLeft) - docElm.clientLeft;
            y2 = pos.top + (docElm.scrollTop || doc2.body.scrollTop) - docElm.clientTop;
          }
        }
        return {
          left: x2,
          top: y2
        };
      }
      return this.css(offset);
    },
    push: push$1,
    sort: Array.prototype.sort,
    splice: Array.prototype.splice
  };
  Tools.extend(DomQueryConstructor, {
    extend: Tools.extend,
    makeArray: function(object) {
      if (isWindow(object) || object.nodeType) {
        return [object];
      }
      return Tools.toArray(object);
    },
    inArray: inArray$1,
    isArray: Tools.isArray,
    each: each$4,
    trim: trim$3,
    grep,
    find: Sizzle,
    expr: Sizzle.selectors,
    unique: Sizzle.uniqueSort,
    text: Sizzle.getText,
    contains: Sizzle.contains,
    filter: function(expr, elems, not2) {
      var i = elems.length;
      if (not2) {
        expr = ":not(" + expr + ")";
      }
      while (i--) {
        if (elems[i].nodeType !== 1) {
          elems.splice(i, 1);
        }
      }
      if (elems.length === 1) {
        elems = DomQuery.find.matchesSelector(elems[0], expr) ? [elems[0]] : [];
      } else {
        elems = DomQuery.find.matches(expr, elems);
      }
      return elems;
    }
  });
  var dir = function(el, prop, until) {
    var matched = [];
    var cur = el[prop];
    if (typeof until !== "string" && until instanceof DomQuery) {
      until = until[0];
    }
    while (cur && cur.nodeType !== 9) {
      if (until !== void 0) {
        if (cur === until) {
          break;
        }
        if (typeof until === "string" && DomQuery(cur).is(until)) {
          break;
        }
      }
      if (cur.nodeType === 1) {
        matched.push(cur);
      }
      cur = cur[prop];
    }
    return matched;
  };
  var sibling$1 = function(node, siblingName, nodeType, until) {
    var result = [];
    if (until instanceof DomQuery) {
      until = until[0];
    }
    for (; node; node = node[siblingName]) {
      if (nodeType && node.nodeType !== nodeType) {
        continue;
      }
      if (until !== void 0) {
        if (node === until) {
          break;
        }
        if (typeof until === "string" && DomQuery(node).is(until)) {
          break;
        }
      }
      result.push(node);
    }
    return result;
  };
  var firstSibling = function(node, siblingName, nodeType) {
    for (node = node[siblingName]; node; node = node[siblingName]) {
      if (node.nodeType === nodeType) {
        return node;
      }
    }
    return null;
  };
  each$4({
    parent: function(node) {
      var parent2 = node.parentNode;
      return parent2 && parent2.nodeType !== 11 ? parent2 : null;
    },
    parents: function(node) {
      return dir(node, "parentNode");
    },
    next: function(node) {
      return firstSibling(node, "nextSibling", 1);
    },
    prev: function(node) {
      return firstSibling(node, "previousSibling", 1);
    },
    children: function(node) {
      return sibling$1(node.firstChild, "nextSibling", 1);
    },
    contents: function(node) {
      return Tools.toArray((node.nodeName === "iframe" ? node.contentDocument || node.contentWindow.document : node).childNodes);
    }
  }, function(name2, fn) {
    DomQueryConstructor.fn[name2] = function(selector) {
      var self2 = this;
      var result = [];
      self2.each(function() {
        var nodes = fn.call(result, this, selector, result);
        if (nodes) {
          if (DomQuery.isArray(nodes)) {
            result.push.apply(result, nodes);
          } else {
            result.push(nodes);
          }
        }
      });
      if (this.length > 1) {
        if (!skipUniques[name2]) {
          result = DomQuery.unique(result);
        }
        if (name2.indexOf("parents") === 0) {
          result = result.reverse();
        }
      }
      var wrappedResult = DomQuery(result);
      if (selector) {
        return wrappedResult.filter(selector);
      }
      return wrappedResult;
    };
  });
  each$4({
    parentsUntil: function(node, until) {
      return dir(node, "parentNode", until);
    },
    nextUntil: function(node, until) {
      return sibling$1(node, "nextSibling", 1, until).slice(1);
    },
    prevUntil: function(node, until) {
      return sibling$1(node, "previousSibling", 1, until).slice(1);
    }
  }, function(name2, fn) {
    DomQueryConstructor.fn[name2] = function(selector, filter2) {
      var self2 = this;
      var result = [];
      self2.each(function() {
        var nodes = fn.call(result, this, selector, result);
        if (nodes) {
          if (DomQuery.isArray(nodes)) {
            result.push.apply(result, nodes);
          } else {
            result.push(nodes);
          }
        }
      });
      if (this.length > 1) {
        result = DomQuery.unique(result);
        if (name2.indexOf("parents") === 0 || name2 === "prevUntil") {
          result = result.reverse();
        }
      }
      var wrappedResult = DomQuery(result);
      if (filter2) {
        return wrappedResult.filter(filter2);
      }
      return wrappedResult;
    };
  });
  DomQueryConstructor.fn.is = function(selector) {
    return !!selector && this.filter(selector).length > 0;
  };
  DomQueryConstructor.fn.init.prototype = DomQueryConstructor.fn;
  DomQueryConstructor.overrideDefaults = function(callback) {
    var defaults;
    var sub = function(selector, context2) {
      defaults = defaults || callback();
      if (arguments.length === 0) {
        selector = defaults.element;
      }
      if (!context2) {
        context2 = defaults.context;
      }
      return new sub.fn.init(selector, context2);
    };
    DomQuery.extend(sub, this);
    return sub;
  };
  DomQueryConstructor.attrHooks = attrHooks;
  DomQueryConstructor.cssHooks = cssHooks;
  var DomQuery = DomQueryConstructor;
  var each$5 = Tools.each;
  var grep$1 = Tools.grep;
  var isIE = Env.ie;
  var simpleSelectorRe = /^([a-z0-9],?)+$/i;
  var setupAttrHooks = function(styles, settings, getContext) {
    var keepValues = settings.keep_values;
    var keepUrlHook = {
      set: function($elm, value2, name2) {
        if (settings.url_converter) {
          value2 = settings.url_converter.call(settings.url_converter_scope || getContext(), value2, name2, $elm[0]);
        }
        $elm.attr("data-mce-" + name2, value2).attr(name2, value2);
      },
      get: function($elm, name2) {
        return $elm.attr("data-mce-" + name2) || $elm.attr(name2);
      }
    };
    var attrHooks2 = {
      style: {
        set: function($elm, value2) {
          if (value2 !== null && typeof value2 === "object") {
            $elm.css(value2);
            return;
          }
          if (keepValues) {
            $elm.attr("data-mce-style", value2);
          }
          if (value2 !== null && typeof value2 === "string") {
            $elm.removeAttr("style");
            $elm.css(styles.parse(value2));
          } else {
            $elm.attr("style", value2);
          }
        },
        get: function($elm) {
          var value2 = $elm.attr("data-mce-style") || $elm.attr("style");
          value2 = styles.serialize(styles.parse(value2), $elm[0].nodeName);
          return value2;
        }
      }
    };
    if (keepValues) {
      attrHooks2.href = attrHooks2.src = keepUrlHook;
    }
    return attrHooks2;
  };
  var updateInternalStyleAttr = function(styles, $elm) {
    var rawValue = $elm.attr("style");
    var value2 = styles.serialize(styles.parse(rawValue), $elm[0].nodeName);
    if (!value2) {
      value2 = null;
    }
    $elm.attr("data-mce-style", value2);
  };
  var findNodeIndex = function(node, normalized) {
    var idx = 0, lastNodeType, nodeType;
    if (node) {
      for (lastNodeType = node.nodeType, node = node.previousSibling; node; node = node.previousSibling) {
        nodeType = node.nodeType;
        if (normalized && nodeType === 3) {
          if (nodeType === lastNodeType || !node.nodeValue.length) {
            continue;
          }
        }
        idx++;
        lastNodeType = nodeType;
      }
    }
    return idx;
  };
  var DOMUtils = function(doc2, settings) {
    if (settings === void 0) {
      settings = {};
    }
    var addedStyles = {};
    var win = window;
    var files = {};
    var counter = 0;
    var stdMode = true;
    var boxModel = true;
    var styleSheetLoader = instance.forElement(SugarElement.fromDom(doc2), {
      contentCssCors: settings.contentCssCors,
      referrerPolicy: settings.referrerPolicy
    });
    var boundEvents = [];
    var schema = settings.schema ? settings.schema : Schema({});
    var styles = Styles({
      url_converter: settings.url_converter,
      url_converter_scope: settings.url_converter_scope
    }, settings.schema);
    var events = settings.ownEvents ? new EventUtils() : EventUtils.Event;
    var blockElementsMap = schema.getBlockElements();
    var $ = DomQuery.overrideDefaults(function() {
      return {
        context: doc2,
        element: self2.getRoot()
      };
    });
    var isBlock2 = function(node) {
      if (typeof node === "string") {
        return !!blockElementsMap[node];
      } else if (node) {
        var type2 = node.nodeType;
        if (type2) {
          return !!(type2 === 1 && blockElementsMap[node.nodeName]);
        }
      }
      return false;
    };
    var get2 = function(elm) {
      return elm && doc2 && isString(elm) ? doc2.getElementById(elm) : elm;
    };
    var $$ = function(elm) {
      return $(typeof elm === "string" ? get2(elm) : elm);
    };
    var getAttrib = function(elm, name2, defaultVal) {
      var hook, value2;
      var $elm = $$(elm);
      if ($elm.length) {
        hook = attrHooks2[name2];
        if (hook && hook.get) {
          value2 = hook.get($elm, name2);
        } else {
          value2 = $elm.attr(name2);
        }
      }
      if (typeof value2 === "undefined") {
        value2 = defaultVal || "";
      }
      return value2;
    };
    var getAttribs = function(elm) {
      var node = get2(elm);
      if (!node) {
        return [];
      }
      return node.attributes;
    };
    var setAttrib = function(elm, name2, value2) {
      if (value2 === "") {
        value2 = null;
      }
      var $elm = $$(elm);
      var originalValue = $elm.attr(name2);
      if (!$elm.length) {
        return;
      }
      var hook = attrHooks2[name2];
      if (hook && hook.set) {
        hook.set($elm, value2, name2);
      } else {
        $elm.attr(name2, value2);
      }
      if (originalValue !== value2 && settings.onSetAttrib) {
        settings.onSetAttrib({
          attrElm: $elm,
          attrName: name2,
          attrValue: value2
        });
      }
    };
    var clone2 = function(node, deep2) {
      if (!isIE || node.nodeType !== 1 || deep2) {
        return node.cloneNode(deep2);
      } else {
        var clone_1 = doc2.createElement(node.nodeName);
        each$5(getAttribs(node), function(attr) {
          setAttrib(clone_1, attr.nodeName, getAttrib(node, attr.nodeName));
        });
        return clone_1;
      }
    };
    var getRoot = function() {
      return settings.root_element || doc2.body;
    };
    var getViewPort = function(argWin) {
      var vp = getBounds(argWin);
      return {
        x: vp.x,
        y: vp.y,
        w: vp.width,
        h: vp.height
      };
    };
    var getPos$1 = function(elm, rootElm) {
      return getPos(doc2.body, get2(elm), rootElm);
    };
    var setStyle = function(elm, name2, value2) {
      var $elm = isString(name2) ? $$(elm).css(name2, value2) : $$(elm).css(name2);
      if (settings.update_styles) {
        updateInternalStyleAttr(styles, $elm);
      }
    };
    var setStyles = function(elm, stylesArg) {
      var $elm = $$(elm).css(stylesArg);
      if (settings.update_styles) {
        updateInternalStyleAttr(styles, $elm);
      }
    };
    var getStyle2 = function(elm, name2, computed) {
      var $elm = $$(elm);
      if (computed) {
        return $elm.css(name2);
      }
      name2 = name2.replace(/-(\D)/g, function(a, b) {
        return b.toUpperCase();
      });
      if (name2 === "float") {
        name2 = Env.browser.isIE() ? "styleFloat" : "cssFloat";
      }
      return $elm[0] && $elm[0].style ? $elm[0].style[name2] : void 0;
    };
    var getSize = function(elm) {
      var w, h;
      elm = get2(elm);
      w = getStyle2(elm, "width");
      h = getStyle2(elm, "height");
      if (w.indexOf("px") === -1) {
        w = 0;
      }
      if (h.indexOf("px") === -1) {
        h = 0;
      }
      return {
        w: parseInt(w, 10) || elm.offsetWidth || elm.clientWidth,
        h: parseInt(h, 10) || elm.offsetHeight || elm.clientHeight
      };
    };
    var getRect = function(elm) {
      elm = get2(elm);
      var pos = getPos$1(elm);
      var size = getSize(elm);
      return {
        x: pos.x,
        y: pos.y,
        w: size.w,
        h: size.h
      };
    };
    var is2 = function(elm, selector) {
      var i;
      if (!elm) {
        return false;
      }
      if (!Array.isArray(elm)) {
        if (selector === "*") {
          return elm.nodeType === 1;
        }
        if (simpleSelectorRe.test(selector)) {
          var selectors = selector.toLowerCase().split(/,/);
          var elmName = elm.nodeName.toLowerCase();
          for (i = selectors.length - 1; i >= 0; i--) {
            if (selectors[i] === elmName) {
              return true;
            }
          }
          return false;
        }
        if (elm.nodeType && elm.nodeType !== 1) {
          return false;
        }
      }
      var elms = !Array.isArray(elm) ? [elm] : elm;
      return Sizzle(selector, elms[0].ownerDocument || elms[0], null, elms).length > 0;
    };
    var getParents2 = function(elm, selector, root, collect) {
      var result = [];
      var selectorVal;
      var node = get2(elm);
      collect = collect === void 0;
      root = root || (getRoot().nodeName !== "BODY" ? getRoot().parentNode : null);
      if (Tools.is(selector, "string")) {
        selectorVal = selector;
        if (selector === "*") {
          selector = function(node2) {
            return node2.nodeType === 1;
          };
        } else {
          selector = function(node2) {
            return is2(node2, selectorVal);
          };
        }
      }
      while (node) {
        if (node === root || isNullable(node.nodeType) || isDocument$1(node) || isDocumentFragment$1(node)) {
          break;
        }
        if (!selector || typeof selector === "function" && selector(node)) {
          if (collect) {
            result.push(node);
          } else {
            return [node];
          }
        }
        node = node.parentNode;
      }
      return collect ? result : null;
    };
    var getParent = function(node, selector, root) {
      var parents2 = getParents2(node, selector, root, false);
      return parents2 && parents2.length > 0 ? parents2[0] : null;
    };
    var _findSib = function(node, selector, name2) {
      var func = selector;
      if (node) {
        if (typeof selector === "string") {
          func = function(node2) {
            return is2(node2, selector);
          };
        }
        for (node = node[name2]; node; node = node[name2]) {
          if (typeof func === "function" && func(node)) {
            return node;
          }
        }
      }
      return null;
    };
    var getNext = function(node, selector) {
      return _findSib(node, selector, "nextSibling");
    };
    var getPrev = function(node, selector) {
      return _findSib(node, selector, "previousSibling");
    };
    var select2 = function(selector, scope) {
      return Sizzle(selector, get2(scope) || settings.root_element || doc2, []);
    };
    var run = function(elm, func, scope) {
      var result;
      var node = typeof elm === "string" ? get2(elm) : elm;
      if (!node) {
        return false;
      }
      if (Tools.isArray(node) && (node.length || node.length === 0)) {
        result = [];
        each$5(node, function(elm2, i) {
          if (elm2) {
            result.push(func.call(scope, typeof elm2 === "string" ? get2(elm2) : elm2, i));
          }
        });
        return result;
      }
      var context2 = scope ? scope : this;
      return func.call(context2, node);
    };
    var setAttribs = function(elm, attrs) {
      $$(elm).each(function(i, node) {
        each$5(attrs, function(value2, name2) {
          setAttrib(node, name2, value2);
        });
      });
    };
    var setHTML = function(elm, html) {
      var $elm = $$(elm);
      if (isIE) {
        $elm.each(function(i, target) {
          if (target.canHaveHTML === false) {
            return;
          }
          while (target.firstChild) {
            target.removeChild(target.firstChild);
          }
          try {
            target.innerHTML = "<br>" + html;
            target.removeChild(target.firstChild);
          } catch (ex) {
            DomQuery("<div></div>").html("<br>" + html).contents().slice(1).appendTo(target);
          }
          return html;
        });
      } else {
        $elm.html(html);
      }
    };
    var add2 = function(parentElm, name2, attrs, html, create3) {
      return run(parentElm, function(parentElm2) {
        var newElm = typeof name2 === "string" ? doc2.createElement(name2) : name2;
        setAttribs(newElm, attrs);
        if (html) {
          if (typeof html !== "string" && html.nodeType) {
            newElm.appendChild(html);
          } else if (typeof html === "string") {
            setHTML(newElm, html);
          }
        }
        return !create3 ? parentElm2.appendChild(newElm) : newElm;
      });
    };
    var create2 = function(name2, attrs, html) {
      return add2(doc2.createElement(name2), name2, attrs, html, true);
    };
    var decode2 = Entities.decode;
    var encode = Entities.encodeAllRaw;
    var createHTML = function(name2, attrs, html) {
      var outHtml = "", key;
      outHtml += "<" + name2;
      for (key in attrs) {
        if (attrs.hasOwnProperty(key) && attrs[key] !== null && typeof attrs[key] !== "undefined") {
          outHtml += " " + key + '="' + encode(attrs[key]) + '"';
        }
      }
      if (typeof html !== "undefined") {
        return outHtml + ">" + html + "</" + name2 + ">";
      }
      return outHtml + " />";
    };
    var createFragment2 = function(html) {
      var node;
      var container = doc2.createElement("div");
      var frag = doc2.createDocumentFragment();
      frag.appendChild(container);
      if (html) {
        container.innerHTML = html;
      }
      while (node = container.firstChild) {
        frag.appendChild(node);
      }
      frag.removeChild(container);
      return frag;
    };
    var remove2 = function(node, keepChildren) {
      var $node = $$(node);
      if (keepChildren) {
        $node.each(function() {
          var child2;
          while (child2 = this.firstChild) {
            if (child2.nodeType === 3 && child2.data.length === 0) {
              this.removeChild(child2);
            } else {
              this.parentNode.insertBefore(child2, this);
            }
          }
        }).remove();
      } else {
        $node.remove();
      }
      return $node.length > 1 ? $node.toArray() : $node[0];
    };
    var removeAllAttribs = function(e) {
      return run(e, function(e2) {
        var i;
        var attrs = e2.attributes;
        for (i = attrs.length - 1; i >= 0; i--) {
          e2.removeAttributeNode(attrs.item(i));
        }
      });
    };
    var parseStyle = function(cssText) {
      return styles.parse(cssText);
    };
    var serializeStyle = function(stylesArg, name2) {
      return styles.serialize(stylesArg, name2);
    };
    var addStyle = function(cssText) {
      var head2, styleElm;
      if (self2 !== DOMUtils.DOM && doc2 === document) {
        if (addedStyles[cssText]) {
          return;
        }
        addedStyles[cssText] = true;
      }
      styleElm = doc2.getElementById("mceDefaultStyles");
      if (!styleElm) {
        styleElm = doc2.createElement("style");
        styleElm.id = "mceDefaultStyles";
        styleElm.type = "text/css";
        head2 = doc2.getElementsByTagName("head")[0];
        if (head2.firstChild) {
          head2.insertBefore(styleElm, head2.firstChild);
        } else {
          head2.appendChild(styleElm);
        }
      }
      if (styleElm.styleSheet) {
        styleElm.styleSheet.cssText += cssText;
      } else {
        styleElm.appendChild(doc2.createTextNode(cssText));
      }
    };
    var loadCSS = function(urls) {
      if (!urls) {
        urls = "";
      }
      each(urls.split(","), function(url) {
        files[url] = true;
        styleSheetLoader.load(url, noop);
      });
    };
    var toggleClass2 = function(elm, cls, state) {
      $$(elm).toggleClass(cls, state).each(function() {
        if (this.className === "") {
          DomQuery(this).attr("class", null);
        }
      });
    };
    var addClass = function(elm, cls) {
      $$(elm).addClass(cls);
    };
    var removeClass = function(elm, cls) {
      toggleClass2(elm, cls, false);
    };
    var hasClass2 = function(elm, cls) {
      return $$(elm).hasClass(cls);
    };
    var show = function(elm) {
      $$(elm).show();
    };
    var hide = function(elm) {
      $$(elm).hide();
    };
    var isHidden = function(elm) {
      return $$(elm).css("display") === "none";
    };
    var uniqueId2 = function(prefix) {
      return (!prefix ? "mce_" : prefix) + counter++;
    };
    var getOuterHTML = function(elm) {
      var node = typeof elm === "string" ? get2(elm) : elm;
      return isElement$1(node) ? node.outerHTML : DomQuery("<div></div>").append(DomQuery(node).clone()).html();
    };
    var setOuterHTML = function(elm, html) {
      $$(elm).each(function() {
        try {
          if ("outerHTML" in this) {
            this.outerHTML = html;
            return;
          }
        } catch (ex) {
        }
        remove2(DomQuery(this).html(html), true);
      });
    };
    var insertAfter2 = function(node, reference) {
      var referenceNode = get2(reference);
      return run(node, function(node2) {
        var parent2 = referenceNode.parentNode;
        var nextSibling2 = referenceNode.nextSibling;
        if (nextSibling2) {
          parent2.insertBefore(node2, nextSibling2);
        } else {
          parent2.appendChild(node2);
        }
        return node2;
      });
    };
    var replace = function(newElm, oldElm, keepChildren) {
      return run(oldElm, function(oldElm2) {
        if (Tools.is(oldElm2, "array")) {
          newElm = newElm.cloneNode(true);
        }
        if (keepChildren) {
          each$5(grep$1(oldElm2.childNodes), function(node) {
            newElm.appendChild(node);
          });
        }
        return oldElm2.parentNode.replaceChild(newElm, oldElm2);
      });
    };
    var rename = function(elm, name2) {
      var newElm;
      if (elm.nodeName !== name2.toUpperCase()) {
        newElm = create2(name2);
        each$5(getAttribs(elm), function(attrNode) {
          setAttrib(newElm, attrNode.nodeName, getAttrib(elm, attrNode.nodeName));
        });
        replace(newElm, elm, true);
      }
      return newElm || elm;
    };
    var findCommonAncestor = function(a, b) {
      var ps = a, pe2;
      while (ps) {
        pe2 = b;
        while (pe2 && ps !== pe2) {
          pe2 = pe2.parentNode;
        }
        if (ps === pe2) {
          break;
        }
        ps = ps.parentNode;
      }
      if (!ps && a.ownerDocument) {
        return a.ownerDocument.documentElement;
      }
      return ps;
    };
    var toHex2 = function(rgbVal) {
      return styles.toHex(Tools.trim(rgbVal));
    };
    var isNonEmptyElement2 = function(node) {
      if (isElement$1(node)) {
        var isNamedAnchor2 = node.nodeName.toLowerCase() === "a" && !getAttrib(node, "href") && getAttrib(node, "id");
        if (getAttrib(node, "name") || getAttrib(node, "data-mce-bookmark") || isNamedAnchor2) {
          return true;
        }
      }
      return false;
    };
    var isEmpty2 = function(node, elements) {
      var type2, name2, brCount = 0;
      if (isNonEmptyElement2(node)) {
        return false;
      }
      node = node.firstChild;
      if (node) {
        var walker = new DomTreeWalker(node, node.parentNode);
        var whitespace2 = schema ? schema.getWhiteSpaceElements() : {};
        elements = elements || (schema ? schema.getNonEmptyElements() : null);
        do {
          type2 = node.nodeType;
          if (isElement$1(node)) {
            var bogusVal = node.getAttribute("data-mce-bogus");
            if (bogusVal) {
              node = walker.next(bogusVal === "all");
              continue;
            }
            name2 = node.nodeName.toLowerCase();
            if (elements && elements[name2]) {
              if (name2 === "br") {
                brCount++;
                node = walker.next();
                continue;
              }
              return false;
            }
            if (isNonEmptyElement2(node)) {
              return false;
            }
          }
          if (type2 === 8) {
            return false;
          }
          if (type2 === 3 && !isWhitespaceText(node.nodeValue)) {
            return false;
          }
          if (type2 === 3 && node.parentNode && whitespace2[node.parentNode.nodeName] && isWhitespaceText(node.nodeValue)) {
            return false;
          }
          node = walker.next();
        } while (node);
      }
      return brCount <= 1;
    };
    var createRng = function() {
      return doc2.createRange();
    };
    var split2 = function(parentElm, splitElm, replacementElm) {
      var range2 = createRng();
      var beforeFragment;
      var afterFragment;
      var parentNode;
      if (parentElm && splitElm) {
        range2.setStart(parentElm.parentNode, findNodeIndex(parentElm));
        range2.setEnd(splitElm.parentNode, findNodeIndex(splitElm));
        beforeFragment = range2.extractContents();
        range2 = createRng();
        range2.setStart(splitElm.parentNode, findNodeIndex(splitElm) + 1);
        range2.setEnd(parentElm.parentNode, findNodeIndex(parentElm) + 1);
        afterFragment = range2.extractContents();
        parentNode = parentElm.parentNode;
        parentNode.insertBefore(trimNode(self2, beforeFragment), parentElm);
        if (replacementElm) {
          parentNode.insertBefore(replacementElm, parentElm);
        } else {
          parentNode.insertBefore(splitElm, parentElm);
        }
        parentNode.insertBefore(trimNode(self2, afterFragment), parentElm);
        remove2(parentElm);
        return replacementElm || splitElm;
      }
    };
    var bind2 = function(target, name2, func, scope) {
      if (Tools.isArray(target)) {
        var i = target.length;
        var rv = [];
        while (i--) {
          rv[i] = bind2(target[i], name2, func, scope);
        }
        return rv;
      }
      if (settings.collect && (target === doc2 || target === win)) {
        boundEvents.push([
          target,
          name2,
          func,
          scope
        ]);
      }
      var output = events.bind(target, name2, func, scope || self2);
      return output;
    };
    var unbind = function(target, name2, func) {
      if (Tools.isArray(target)) {
        var i = target.length;
        var rv = [];
        while (i--) {
          rv[i] = unbind(target[i], name2, func);
        }
        return rv;
      } else {
        if (boundEvents.length > 0 && (target === doc2 || target === win)) {
          var i = boundEvents.length;
          while (i--) {
            var item = boundEvents[i];
            if (target === item[0] && (!name2 || name2 === item[1]) && (!func || func === item[2])) {
              events.unbind(item[0], item[1], item[2]);
            }
          }
        }
        return events.unbind(target, name2, func);
      }
    };
    var fire = function(target, name2, evt) {
      return events.fire(target, name2, evt);
    };
    var getContentEditable = function(node) {
      if (node && isElement$1(node)) {
        var contentEditable = node.getAttribute("data-mce-contenteditable");
        if (contentEditable && contentEditable !== "inherit") {
          return contentEditable;
        }
        return node.contentEditable !== "inherit" ? node.contentEditable : null;
      } else {
        return null;
      }
    };
    var getContentEditableParent = function(node) {
      var root = getRoot();
      var state = null;
      for (; node && node !== root; node = node.parentNode) {
        state = getContentEditable(node);
        if (state !== null) {
          break;
        }
      }
      return state;
    };
    var destroy2 = function() {
      if (boundEvents.length > 0) {
        var i = boundEvents.length;
        while (i--) {
          var item = boundEvents[i];
          events.unbind(item[0], item[1], item[2]);
        }
      }
      each$1(files, function(_, url) {
        styleSheetLoader.unload(url);
        delete files[url];
      });
      if (Sizzle.setDocument) {
        Sizzle.setDocument();
      }
    };
    var isChildOf = function(node, parent2) {
      while (node) {
        if (parent2 === node) {
          return true;
        }
        node = node.parentNode;
      }
      return false;
    };
    var dumpRng = function(r3) {
      return "startContainer: " + r3.startContainer.nodeName + ", startOffset: " + r3.startOffset + ", endContainer: " + r3.endContainer.nodeName + ", endOffset: " + r3.endOffset;
    };
    var self2 = {
      doc: doc2,
      settings,
      win,
      files,
      stdMode,
      boxModel,
      styleSheetLoader,
      boundEvents,
      styles,
      schema,
      events,
      isBlock: isBlock2,
      $,
      $$,
      root: null,
      clone: clone2,
      getRoot,
      getViewPort,
      getRect,
      getSize,
      getParent,
      getParents: getParents2,
      get: get2,
      getNext,
      getPrev,
      select: select2,
      is: is2,
      add: add2,
      create: create2,
      createHTML,
      createFragment: createFragment2,
      remove: remove2,
      setStyle,
      getStyle: getStyle2,
      setStyles,
      removeAllAttribs,
      setAttrib,
      setAttribs,
      getAttrib,
      getPos: getPos$1,
      parseStyle,
      serializeStyle,
      addStyle,
      loadCSS,
      addClass,
      removeClass,
      hasClass: hasClass2,
      toggleClass: toggleClass2,
      show,
      hide,
      isHidden,
      uniqueId: uniqueId2,
      setHTML,
      getOuterHTML,
      setOuterHTML,
      decode: decode2,
      encode,
      insertAfter: insertAfter2,
      replace,
      rename,
      findCommonAncestor,
      toHex: toHex2,
      run,
      getAttribs,
      isEmpty: isEmpty2,
      createRng,
      nodeIndex: findNodeIndex,
      split: split2,
      bind: bind2,
      unbind,
      fire,
      getContentEditable,
      getContentEditableParent,
      destroy: destroy2,
      isChildOf,
      dumpRng
    };
    var attrHooks2 = setupAttrHooks(styles, settings, function() {
      return self2;
    });
    return self2;
  };
  DOMUtils.DOM = DOMUtils(document);
  DOMUtils.nodeIndex = findNodeIndex;
  var DOM = DOMUtils.DOM;
  var each$6 = Tools.each, grep$2 = Tools.grep;
  var QUEUED = 0;
  var LOADING = 1;
  var LOADED = 2;
  var FAILED = 3;
  var ScriptLoader2 = function() {
    function ScriptLoader3(settings) {
      if (settings === void 0) {
        settings = {};
      }
      this.states = {};
      this.queue = [];
      this.scriptLoadedCallbacks = {};
      this.queueLoadedCallbacks = [];
      this.loading = 0;
      this.settings = settings;
    }
    ScriptLoader3.prototype._setReferrerPolicy = function(referrerPolicy) {
      this.settings.referrerPolicy = referrerPolicy;
    };
    ScriptLoader3.prototype.loadScript = function(url, success, failure) {
      var dom2 = DOM;
      var elm;
      var cleanup = function() {
        dom2.remove(id2);
        if (elm) {
          elm.onerror = elm.onload = elm = null;
        }
      };
      var done2 = function() {
        cleanup();
        success();
      };
      var error2 = function() {
        cleanup();
        if (isFunction2(failure)) {
          failure();
        } else {
          if (typeof console !== "undefined" && console.log) {
            console.log("Failed to load script: " + url);
          }
        }
      };
      var id2 = dom2.uniqueId();
      elm = document.createElement("script");
      elm.id = id2;
      elm.type = "text/javascript";
      elm.src = Tools._addCacheSuffix(url);
      if (this.settings.referrerPolicy) {
        dom2.setAttrib(elm, "referrerpolicy", this.settings.referrerPolicy);
      }
      elm.onload = done2;
      elm.onerror = error2;
      (document.getElementsByTagName("head")[0] || document.body).appendChild(elm);
    };
    ScriptLoader3.prototype.isDone = function(url) {
      return this.states[url] === LOADED;
    };
    ScriptLoader3.prototype.markDone = function(url) {
      this.states[url] = LOADED;
    };
    ScriptLoader3.prototype.add = function(url, success, scope, failure) {
      var state = this.states[url];
      this.queue.push(url);
      if (state === void 0) {
        this.states[url] = QUEUED;
      }
      if (success) {
        if (!this.scriptLoadedCallbacks[url]) {
          this.scriptLoadedCallbacks[url] = [];
        }
        this.scriptLoadedCallbacks[url].push({
          success,
          failure,
          scope: scope || this
        });
      }
    };
    ScriptLoader3.prototype.load = function(url, success, scope, failure) {
      return this.add(url, success, scope, failure);
    };
    ScriptLoader3.prototype.remove = function(url) {
      delete this.states[url];
      delete this.scriptLoadedCallbacks[url];
    };
    ScriptLoader3.prototype.loadQueue = function(success, scope, failure) {
      this.loadScripts(this.queue, success, scope, failure);
    };
    ScriptLoader3.prototype.loadScripts = function(scripts, success, scope, failure) {
      var self2 = this;
      var failures = [];
      var execCallbacks = function(name2, url) {
        each$6(self2.scriptLoadedCallbacks[url], function(callback) {
          if (isFunction2(callback[name2])) {
            callback[name2].call(callback.scope);
          }
        });
        self2.scriptLoadedCallbacks[url] = void 0;
      };
      self2.queueLoadedCallbacks.push({
        success,
        failure,
        scope: scope || this
      });
      var loadScripts2 = function() {
        var loadingScripts = grep$2(scripts);
        scripts.length = 0;
        each$6(loadingScripts, function(url) {
          if (self2.states[url] === LOADED) {
            execCallbacks("success", url);
            return;
          }
          if (self2.states[url] === FAILED) {
            execCallbacks("failure", url);
            return;
          }
          if (self2.states[url] !== LOADING) {
            self2.states[url] = LOADING;
            self2.loading++;
            self2.loadScript(url, function() {
              self2.states[url] = LOADED;
              self2.loading--;
              execCallbacks("success", url);
              loadScripts2();
            }, function() {
              self2.states[url] = FAILED;
              self2.loading--;
              failures.push(url);
              execCallbacks("failure", url);
              loadScripts2();
            });
          }
        });
        if (!self2.loading) {
          var notifyCallbacks = self2.queueLoadedCallbacks.slice(0);
          self2.queueLoadedCallbacks.length = 0;
          each$6(notifyCallbacks, function(callback) {
            if (failures.length === 0) {
              if (isFunction2(callback.success)) {
                callback.success.call(callback.scope);
              }
            } else {
              if (isFunction2(callback.failure)) {
                callback.failure.call(callback.scope, failures);
              }
            }
          });
        }
      };
      loadScripts2();
    };
    ScriptLoader3.ScriptLoader = new ScriptLoader3();
    return ScriptLoader3;
  }();
  var Cell = function(initial) {
    var value2 = initial;
    var get2 = function() {
      return value2;
    };
    var set2 = function(v2) {
      value2 = v2;
    };
    return {
      get: get2,
      set: set2
    };
  };
  var isRaw = function(str) {
    return isObject(str) && has(str, "raw");
  };
  var isTokenised = function(str) {
    return isArray(str) && str.length > 1;
  };
  var data = {};
  var currentCode = Cell("en");
  var getLanguageData = function() {
    return get$1(data, currentCode.get());
  };
  var getData = function() {
    return map$1(data, function(value2) {
      return __assign2({}, value2);
    });
  };
  var setCode = function(newCode) {
    if (newCode) {
      currentCode.set(newCode);
    }
  };
  var getCode = function() {
    return currentCode.get();
  };
  var add = function(code, items) {
    var langData = data[code];
    if (!langData) {
      data[code] = langData = {};
    }
    each$1(items, function(translation, name2) {
      langData[name2.toLowerCase()] = translation;
    });
  };
  var translate = function(text) {
    var langData = getLanguageData().getOr({});
    var toString = function(obj) {
      if (isFunction2(obj)) {
        return Object.prototype.toString.call(obj);
      }
      return !isEmpty2(obj) ? "" + obj : "";
    };
    var isEmpty2 = function(text2) {
      return text2 === "" || text2 === null || text2 === void 0;
    };
    var getLangData = function(text2) {
      var textstr = toString(text2);
      return get$1(langData, textstr.toLowerCase()).map(toString).getOr(textstr);
    };
    var removeContext = function(str) {
      return str.replace(/{context:\w+}$/, "");
    };
    if (isEmpty2(text)) {
      return "";
    }
    if (isRaw(text)) {
      return toString(text.raw);
    }
    if (isTokenised(text)) {
      var values_1 = text.slice(1);
      var substitued = getLangData(text[0]).replace(/\{([0-9]+)\}/g, function($1, $2) {
        return has(values_1, $2) ? toString(values_1[$2]) : $1;
      });
      return removeContext(substitued);
    }
    return removeContext(getLangData(text));
  };
  var isRtl = function() {
    return getLanguageData().bind(function(items) {
      return get$1(items, "_dir");
    }).exists(function(dir2) {
      return dir2 === "rtl";
    });
  };
  var hasCode = function(code) {
    return has(data, code);
  };
  var I18n = {
    getData,
    setCode,
    getCode,
    add,
    translate,
    isRtl,
    hasCode
  };
  var AddOnManager = function() {
    var items = [];
    var urls = {};
    var lookup = {};
    var _listeners = [];
    var runListeners = function(name2, state) {
      var matchedListeners = filter(_listeners, function(listener) {
        return listener.name === name2 && listener.state === state;
      });
      each(matchedListeners, function(listener) {
        return listener.callback();
      });
    };
    var get2 = function(name2) {
      if (lookup[name2]) {
        return lookup[name2].instance;
      }
      return void 0;
    };
    var dependencies = function(name2) {
      var result;
      if (lookup[name2]) {
        result = lookup[name2].dependencies;
      }
      return result || [];
    };
    var requireLangPack = function(name2, languages) {
      if (AddOnManager.languageLoad !== false) {
        waitFor(name2, function() {
          var language = I18n.getCode();
          var wrappedLanguages = "," + (languages || "") + ",";
          if (!language || languages && wrappedLanguages.indexOf("," + language + ",") === -1) {
            return;
          }
          ScriptLoader2.ScriptLoader.add(urls[name2] + "/langs/" + language + ".js");
        }, "loaded");
      }
    };
    var add2 = function(id2, addOn, dependencies2) {
      var addOnConstructor = addOn;
      items.push(addOnConstructor);
      lookup[id2] = {
        instance: addOnConstructor,
        dependencies: dependencies2
      };
      runListeners(id2, "added");
      return addOnConstructor;
    };
    var remove2 = function(name2) {
      delete urls[name2];
      delete lookup[name2];
    };
    var createUrl = function(baseUrl, dep) {
      if (typeof dep === "object") {
        return dep;
      }
      return typeof baseUrl === "string" ? {
        prefix: "",
        resource: dep,
        suffix: ""
      } : {
        prefix: baseUrl.prefix,
        resource: dep,
        suffix: baseUrl.suffix
      };
    };
    var addComponents = function(pluginName, scripts) {
      var pluginUrl = urls[pluginName];
      each(scripts, function(script) {
        ScriptLoader2.ScriptLoader.add(pluginUrl + "/" + script);
      });
    };
    var loadDependencies = function(name2, addOnUrl, success, scope) {
      var deps = dependencies(name2);
      each(deps, function(dep) {
        var newUrl = createUrl(addOnUrl, dep);
        load(newUrl.resource, newUrl, void 0, void 0);
      });
      if (success) {
        if (scope) {
          success.call(scope);
        } else {
          success.call(ScriptLoader2);
        }
      }
    };
    var load = function(name2, addOnUrl, success, scope, failure) {
      if (urls[name2]) {
        return;
      }
      var urlString = typeof addOnUrl === "string" ? addOnUrl : addOnUrl.prefix + addOnUrl.resource + addOnUrl.suffix;
      if (urlString.indexOf("/") !== 0 && urlString.indexOf("://") === -1) {
        urlString = AddOnManager.baseURL + "/" + urlString;
      }
      urls[name2] = urlString.substring(0, urlString.lastIndexOf("/"));
      var done2 = function() {
        runListeners(name2, "loaded");
        loadDependencies(name2, addOnUrl, success, scope);
      };
      if (lookup[name2]) {
        done2();
      } else {
        ScriptLoader2.ScriptLoader.add(urlString, done2, scope, failure);
      }
    };
    var waitFor = function(name2, callback, state) {
      if (state === void 0) {
        state = "added";
      }
      if (has(lookup, name2) && state === "added") {
        callback();
      } else if (has(urls, name2) && state === "loaded") {
        callback();
      } else {
        _listeners.push({
          name: name2,
          state,
          callback
        });
      }
    };
    return {
      items,
      urls,
      lookup,
      _listeners,
      get: get2,
      dependencies,
      requireLangPack,
      add: add2,
      remove: remove2,
      createUrl,
      addComponents,
      load,
      waitFor
    };
  };
  AddOnManager.languageLoad = true;
  AddOnManager.baseURL = "";
  AddOnManager.PluginManager = AddOnManager();
  AddOnManager.ThemeManager = AddOnManager();
  var first = function(fn, rate) {
    var timer = null;
    var cancel = function() {
      if (timer !== null) {
        clearTimeout(timer);
        timer = null;
      }
    };
    var throttle = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (timer === null) {
        timer = setTimeout(function() {
          fn.apply(null, args);
          timer = null;
        }, rate);
      }
    };
    return {
      cancel,
      throttle
    };
  };
  var last$2 = function(fn, rate) {
    var timer = null;
    var cancel = function() {
      if (timer !== null) {
        clearTimeout(timer);
        timer = null;
      }
    };
    var throttle = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (timer !== null) {
        clearTimeout(timer);
      }
      timer = setTimeout(function() {
        fn.apply(null, args);
        timer = null;
      }, rate);
    };
    return {
      cancel,
      throttle
    };
  };
  var read = function(element, attr) {
    var value2 = get$4(element, attr);
    return value2 === void 0 || value2 === "" ? [] : value2.split(" ");
  };
  var add$1 = function(element, attr, id2) {
    var old = read(element, attr);
    var nu2 = old.concat([id2]);
    set(element, attr, nu2.join(" "));
    return true;
  };
  var remove$2 = function(element, attr, id2) {
    var nu2 = filter(read(element, attr), function(v2) {
      return v2 !== id2;
    });
    if (nu2.length > 0) {
      set(element, attr, nu2.join(" "));
    } else {
      remove$1(element, attr);
    }
    return false;
  };
  var supports = function(element) {
    return element.dom.classList !== void 0;
  };
  var get$6 = function(element) {
    return read(element, "class");
  };
  var add$2 = function(element, clazz) {
    return add$1(element, "class", clazz);
  };
  var remove$3 = function(element, clazz) {
    return remove$2(element, "class", clazz);
  };
  var add$3 = function(element, clazz) {
    if (supports(element)) {
      element.dom.classList.add(clazz);
    } else {
      add$2(element, clazz);
    }
  };
  var cleanClass = function(element) {
    var classList = supports(element) ? element.dom.classList : get$6(element);
    if (classList.length === 0) {
      remove$1(element, "class");
    }
  };
  var remove$4 = function(element, clazz) {
    if (supports(element)) {
      var classList = element.dom.classList;
      classList.remove(clazz);
    } else {
      remove$3(element, clazz);
    }
    cleanClass(element);
  };
  var has$2 = function(element, clazz) {
    return supports(element) && element.dom.classList.contains(clazz);
  };
  var descendants = function(scope, predicate) {
    var result = [];
    each(children(scope), function(x2) {
      if (predicate(x2)) {
        result = result.concat([x2]);
      }
      result = result.concat(descendants(x2, predicate));
    });
    return result;
  };
  var descendants$1 = function(scope, selector) {
    return all(selector, scope);
  };
  var annotation = constant("mce-annotation");
  var dataAnnotation = constant("data-mce-annotation");
  var dataAnnotationId = constant("data-mce-annotation-uid");
  var identify = function(editor, annotationName) {
    var rng = editor.selection.getRng();
    var start2 = SugarElement.fromDom(rng.startContainer);
    var root = SugarElement.fromDom(editor.getBody());
    var selector = annotationName.fold(function() {
      return "." + annotation();
    }, function(an) {
      return "[" + dataAnnotation() + '="' + an + '"]';
    });
    var newStart = child(start2, rng.startOffset).getOr(start2);
    var closest2 = closest$1(newStart, selector, function(n2) {
      return eq$2(n2, root);
    });
    var getAttr = function(c, property) {
      if (has$1(c, property)) {
        return Optional.some(get$4(c, property));
      } else {
        return Optional.none();
      }
    };
    return closest2.bind(function(c) {
      return getAttr(c, "" + dataAnnotationId()).bind(function(uid) {
        return getAttr(c, "" + dataAnnotation()).map(function(name2) {
          var elements = findMarkers(editor, uid);
          return {
            uid,
            name: name2,
            elements
          };
        });
      });
    });
  };
  var isAnnotation = function(elem) {
    return isElement(elem) && has$2(elem, annotation());
  };
  var findMarkers = function(editor, uid) {
    var body = SugarElement.fromDom(editor.getBody());
    return descendants$1(body, "[" + dataAnnotationId() + '="' + uid + '"]');
  };
  var findAll = function(editor, name2) {
    var body = SugarElement.fromDom(editor.getBody());
    var markers = descendants$1(body, "[" + dataAnnotation() + '="' + name2 + '"]');
    var directory = {};
    each(markers, function(m2) {
      var uid = get$4(m2, dataAnnotationId());
      var nodesAlready = directory.hasOwnProperty(uid) ? directory[uid] : [];
      directory[uid] = nodesAlready.concat([m2]);
    });
    return directory;
  };
  var setup = function(editor, _registry) {
    var changeCallbacks = Cell({});
    var initData = function() {
      return {
        listeners: [],
        previous: Cell(Optional.none())
      };
    };
    var withCallbacks = function(name2, f) {
      updateCallbacks(name2, function(data2) {
        f(data2);
        return data2;
      });
    };
    var updateCallbacks = function(name2, f) {
      var callbackMap = changeCallbacks.get();
      var data2 = callbackMap.hasOwnProperty(name2) ? callbackMap[name2] : initData();
      var outputData = f(data2);
      callbackMap[name2] = outputData;
      changeCallbacks.set(callbackMap);
    };
    var fireCallbacks = function(name2, uid, elements) {
      withCallbacks(name2, function(data2) {
        each(data2.listeners, function(f) {
          return f(true, name2, {
            uid,
            nodes: map(elements, function(elem) {
              return elem.dom;
            })
          });
        });
      });
    };
    var fireNoAnnotation = function(name2) {
      withCallbacks(name2, function(data2) {
        each(data2.listeners, function(f) {
          return f(false, name2);
        });
      });
    };
    var onNodeChange = last$2(function() {
      var callbackMap = changeCallbacks.get();
      var annotations = sort$1(keys(callbackMap));
      each(annotations, function(name2) {
        updateCallbacks(name2, function(data2) {
          var prev = data2.previous.get();
          identify(editor, Optional.some(name2)).fold(function() {
            if (prev.isSome()) {
              fireNoAnnotation(name2);
              data2.previous.set(Optional.none());
            }
          }, function(_a) {
            var uid = _a.uid, name3 = _a.name, elements = _a.elements;
            if (!prev.is(uid)) {
              fireCallbacks(name3, uid, elements);
              data2.previous.set(Optional.some(uid));
            }
          });
          return {
            previous: data2.previous,
            listeners: data2.listeners
          };
        });
      });
    }, 30);
    editor.on("remove", function() {
      onNodeChange.cancel();
    });
    editor.on("NodeChange", function() {
      onNodeChange.throttle();
    });
    var addListener = function(name2, f) {
      updateCallbacks(name2, function(data2) {
        return {
          previous: data2.previous,
          listeners: data2.listeners.concat([f])
        };
      });
    };
    return { addListener };
  };
  var setup$1 = function(editor, registry2) {
    var identifyParserNode = function(span) {
      return Optional.from(span.attr(dataAnnotation())).bind(registry2.lookup);
    };
    editor.on("init", function() {
      editor.serializer.addNodeFilter("span", function(spans) {
        each(spans, function(span) {
          identifyParserNode(span).each(function(settings) {
            if (settings.persistent === false) {
              span.unwrap();
            }
          });
        });
      });
    });
  };
  var create$2 = function() {
    var annotations = {};
    var register2 = function(name2, settings) {
      annotations[name2] = {
        name: name2,
        settings
      };
    };
    var lookup = function(name2) {
      return annotations.hasOwnProperty(name2) ? Optional.from(annotations[name2]).map(function(a) {
        return a.settings;
      }) : Optional.none();
    };
    return {
      register: register2,
      lookup
    };
  };
  var unique2 = 0;
  var generate$1 = function(prefix) {
    var date = new Date();
    var time = date.getTime();
    var random = Math.floor(Math.random() * 1e9);
    unique2++;
    return prefix + "_" + random + unique2 + String(time);
  };
  var add$4 = function(element, classes) {
    each(classes, function(x2) {
      add$3(element, x2);
    });
  };
  var fromHtml$1 = function(html, scope) {
    var doc2 = scope || document;
    var div = doc2.createElement("div");
    div.innerHTML = html;
    return children(SugarElement.fromDom(div));
  };
  var get$7 = function(element) {
    return element.dom.innerHTML;
  };
  var set$1 = function(element, content) {
    var owner$12 = owner(element);
    var docDom = owner$12.dom;
    var fragment = SugarElement.fromDom(docDom.createDocumentFragment());
    var contentElements = fromHtml$1(content, docDom);
    append$1(fragment, contentElements);
    empty(element);
    append(element, fragment);
  };
  var clone$1 = function(original, isDeep) {
    return SugarElement.fromDom(original.dom.cloneNode(isDeep));
  };
  var shallow = function(original) {
    return clone$1(original, false);
  };
  var deep = function(original) {
    return clone$1(original, true);
  };
  var TextWalker = function(startNode, rootNode, isBoundary) {
    if (isBoundary === void 0) {
      isBoundary = never;
    }
    var walker = new DomTreeWalker(startNode, rootNode);
    var walk2 = function(direction) {
      var next;
      do {
        next = walker[direction]();
      } while (next && !isText$1(next) && !isBoundary(next));
      return Optional.from(next).filter(isText$1);
    };
    return {
      current: function() {
        return Optional.from(walker.current()).filter(isText$1);
      },
      next: function() {
        return walk2("next");
      },
      prev: function() {
        return walk2("prev");
      },
      prev2: function() {
        return walk2("prev2");
      }
    };
  };
  var TextSeeker = function(dom2, isBoundary) {
    var isBlockBoundary = isBoundary ? isBoundary : function(node) {
      return dom2.isBlock(node) || isBr(node) || isContentEditableFalse(node);
    };
    var walk2 = function(node, offset, walker, process2) {
      if (isText$1(node)) {
        var newOffset = process2(node, offset, node.data);
        if (newOffset !== -1) {
          return Optional.some({
            container: node,
            offset: newOffset
          });
        }
      }
      return walker().bind(function(next) {
        return walk2(next.container, next.offset, walker, process2);
      });
    };
    var backwards = function(node, offset, process2, root) {
      var walker = TextWalker(node, root, isBlockBoundary);
      return walk2(node, offset, function() {
        return walker.prev().map(function(prev) {
          return {
            container: prev,
            offset: prev.length
          };
        });
      }, process2).getOrNull();
    };
    var forwards = function(node, offset, process2, root) {
      var walker = TextWalker(node, root, isBlockBoundary);
      return walk2(node, offset, function() {
        return walker.next().map(function(next) {
          return {
            container: next,
            offset: 0
          };
        });
      }, process2).getOrNull();
    };
    return {
      backwards,
      forwards
    };
  };
  var cat = function(arr2) {
    var r3 = [];
    var push2 = function(x2) {
      r3.push(x2);
    };
    for (var i = 0; i < arr2.length; i++) {
      arr2[i].each(push2);
    }
    return r3;
  };
  var lift2 = function(oa2, ob2, f) {
    return oa2.isSome() && ob2.isSome() ? Optional.some(f(oa2.getOrDie(), ob2.getOrDie())) : Optional.none();
  };
  var lift3 = function(oa2, ob2, oc2, f) {
    return oa2.isSome() && ob2.isSome() && oc2.isSome() ? Optional.some(f(oa2.getOrDie(), ob2.getOrDie(), oc2.getOrDie())) : Optional.none();
  };
  var someIf = function(b, a) {
    return b ? Optional.some(a) : Optional.none();
  };
  var round = Math.round;
  var clone$2 = function(rect) {
    if (!rect) {
      return {
        left: 0,
        top: 0,
        bottom: 0,
        right: 0,
        width: 0,
        height: 0
      };
    }
    return {
      left: round(rect.left),
      top: round(rect.top),
      bottom: round(rect.bottom),
      right: round(rect.right),
      width: round(rect.width),
      height: round(rect.height)
    };
  };
  var collapse = function(rect, toStart) {
    rect = clone$2(rect);
    if (toStart) {
      rect.right = rect.left;
    } else {
      rect.left = rect.left + rect.width;
      rect.right = rect.left;
    }
    rect.width = 0;
    return rect;
  };
  var isEqual = function(rect1, rect2) {
    return rect1.left === rect2.left && rect1.top === rect2.top && rect1.bottom === rect2.bottom && rect1.right === rect2.right;
  };
  var isValidOverflow = function(overflowY, rect1, rect2) {
    return overflowY >= 0 && overflowY <= Math.min(rect1.height, rect2.height) / 2;
  };
  var isAbove = function(rect1, rect2) {
    var halfHeight = Math.min(rect2.height / 2, rect1.height / 2);
    if (rect1.bottom - halfHeight < rect2.top) {
      return true;
    }
    if (rect1.top > rect2.bottom) {
      return false;
    }
    return isValidOverflow(rect2.top - rect1.bottom, rect1, rect2);
  };
  var isBelow = function(rect1, rect2) {
    if (rect1.top > rect2.bottom) {
      return true;
    }
    if (rect1.bottom < rect2.top) {
      return false;
    }
    return isValidOverflow(rect2.bottom - rect1.top, rect1, rect2);
  };
  var containsXY = function(rect, clientX, clientY) {
    return clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;
  };
  var getSelectedNode = function(range2) {
    var startContainer = range2.startContainer, startOffset = range2.startOffset;
    if (startContainer.hasChildNodes() && range2.endOffset === startOffset + 1) {
      return startContainer.childNodes[startOffset];
    }
    return null;
  };
  var getNode = function(container, offset) {
    if (container.nodeType === 1 && container.hasChildNodes()) {
      if (offset >= container.childNodes.length) {
        offset = container.childNodes.length - 1;
      }
      container = container.childNodes[offset];
    }
    return container;
  };
  var extendingChars = new RegExp("[\u0300-\u036F\u0483-\u0487\u0488-\u0489\u0591-\u05BD\u05BF\u05C1-\u05C2\u05C4-\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7-\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962-\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2-\u09E3\u0A01-\u0A02\u0A3C\u0A41-\u0A42\u0A47-\u0A48\u0A4B-\u0A4D\u0A51\u0A70-\u0A71\u0A75\u0A81-\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7-\u0AC8\u0ACD\u0AE2-\u0AE3\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B57\u0B62-\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55-\u0C56\u0C62-\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC-\u0CCD\u0CD5-\u0CD6\u0CE2-\u0CE3\u0D01\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62-\u0D63\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB-\u0EBC\u0EC8-\u0ECD\u0F18-\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86-\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039-\u103A\u103D-\u103E\u1058-\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085-\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752-\u1753\u1772-\u1773\u17B4-\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u1922\u1927-\u1928\u1932\u1939-\u193B\u1A17-\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ABD\u1ABE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80-\u1B81\u1BA2-\u1BA5\u1BA8-\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8-\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8-\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u200C-\u200D\u20D0-\u20DC\u20DD-\u20E0\u20E1\u20E2-\u20E4\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u302E-\u302F\u3099-\u309A\uA66F\uA670-\uA672\uA674-\uA67D\uA69E-\uA69F\uA6F0-\uA6F1\uA802\uA806\uA80B\uA825-\uA826\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9E5\uAA29-\uAA2E\uAA31-\uAA32\uAA35-\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7-\uAAB8\uAABE-\uAABF\uAAC1\uAAEC-\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E-\uFF9F]");
  var isExtendingChar = function(ch2) {
    return typeof ch2 === "string" && ch2.charCodeAt(0) >= 768 && extendingChars.test(ch2);
  };
  var or = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return function(x2) {
      for (var i = 0; i < args.length; i++) {
        if (args[i](x2)) {
          return true;
        }
      }
      return false;
    };
  };
  var and = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return function(x2) {
      for (var i = 0; i < args.length; i++) {
        if (!args[i](x2)) {
          return false;
        }
      }
      return true;
    };
  };
  var isElement$3 = isElement$1;
  var isCaretCandidate$1 = isCaretCandidate;
  var isBlock$1 = matchStyleValues("display", "block table");
  var isFloated = matchStyleValues("float", "left right");
  var isValidElementCaretCandidate = and(isElement$3, isCaretCandidate$1, not(isFloated));
  var isNotPre = not(matchStyleValues("white-space", "pre pre-line pre-wrap"));
  var isText$4 = isText$1;
  var isBr$3 = isBr;
  var nodeIndex = DOMUtils.nodeIndex;
  var resolveIndex = getNode;
  var createRange = function(doc2) {
    return "createRange" in doc2 ? doc2.createRange() : DOMUtils.DOM.createRng();
  };
  var isWhiteSpace = function(chr) {
    return chr && /[\r\n\t ]/.test(chr);
  };
  var isRange = function(rng) {
    return !!rng.setStart && !!rng.setEnd;
  };
  var isHiddenWhiteSpaceRange = function(range2) {
    var container = range2.startContainer;
    var offset = range2.startOffset;
    var text;
    if (isWhiteSpace(range2.toString()) && isNotPre(container.parentNode) && isText$1(container)) {
      text = container.data;
      if (isWhiteSpace(text[offset - 1]) || isWhiteSpace(text[offset + 1])) {
        return true;
      }
    }
    return false;
  };
  var getBrClientRect = function(brNode) {
    var doc2 = brNode.ownerDocument;
    var rng = createRange(doc2);
    var nbsp$1 = doc2.createTextNode(nbsp);
    var parentNode = brNode.parentNode;
    parentNode.insertBefore(nbsp$1, brNode);
    rng.setStart(nbsp$1, 0);
    rng.setEnd(nbsp$1, 1);
    var clientRect = clone$2(rng.getBoundingClientRect());
    parentNode.removeChild(nbsp$1);
    return clientRect;
  };
  var getBoundingClientRectWebKitText = function(rng) {
    var sc2 = rng.startContainer;
    var ec2 = rng.endContainer;
    var so = rng.startOffset;
    var eo = rng.endOffset;
    if (sc2 === ec2 && isText$1(ec2) && so === 0 && eo === 1) {
      var newRng = rng.cloneRange();
      newRng.setEndAfter(ec2);
      return getBoundingClientRect(newRng);
    } else {
      return null;
    }
  };
  var isZeroRect = function(r3) {
    return r3.left === 0 && r3.right === 0 && r3.top === 0 && r3.bottom === 0;
  };
  var getBoundingClientRect = function(item) {
    var clientRect;
    var clientRects = item.getClientRects();
    if (clientRects.length > 0) {
      clientRect = clone$2(clientRects[0]);
    } else {
      clientRect = clone$2(item.getBoundingClientRect());
    }
    if (!isRange(item) && isBr$3(item) && isZeroRect(clientRect)) {
      return getBrClientRect(item);
    }
    if (isZeroRect(clientRect) && isRange(item)) {
      return getBoundingClientRectWebKitText(item);
    }
    return clientRect;
  };
  var collapseAndInflateWidth = function(clientRect, toStart) {
    var newClientRect = collapse(clientRect, toStart);
    newClientRect.width = 1;
    newClientRect.right = newClientRect.left + 1;
    return newClientRect;
  };
  var getCaretPositionClientRects = function(caretPosition) {
    var clientRects = [];
    var beforeNode, node;
    var addUniqueAndValidRect = function(clientRect) {
      if (clientRect.height === 0) {
        return;
      }
      if (clientRects.length > 0) {
        if (isEqual(clientRect, clientRects[clientRects.length - 1])) {
          return;
        }
      }
      clientRects.push(clientRect);
    };
    var addCharacterOffset = function(container, offset) {
      var range2 = createRange(container.ownerDocument);
      if (offset < container.data.length) {
        if (isExtendingChar(container.data[offset])) {
          return clientRects;
        }
        if (isExtendingChar(container.data[offset - 1])) {
          range2.setStart(container, offset);
          range2.setEnd(container, offset + 1);
          if (!isHiddenWhiteSpaceRange(range2)) {
            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(range2), false));
            return clientRects;
          }
        }
      }
      if (offset > 0) {
        range2.setStart(container, offset - 1);
        range2.setEnd(container, offset);
        if (!isHiddenWhiteSpaceRange(range2)) {
          addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(range2), false));
        }
      }
      if (offset < container.data.length) {
        range2.setStart(container, offset);
        range2.setEnd(container, offset + 1);
        if (!isHiddenWhiteSpaceRange(range2)) {
          addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(range2), true));
        }
      }
    };
    if (isText$4(caretPosition.container())) {
      addCharacterOffset(caretPosition.container(), caretPosition.offset());
      return clientRects;
    }
    if (isElement$3(caretPosition.container())) {
      if (caretPosition.isAtEnd()) {
        node = resolveIndex(caretPosition.container(), caretPosition.offset());
        if (isText$4(node)) {
          addCharacterOffset(node, node.data.length);
        }
        if (isValidElementCaretCandidate(node) && !isBr$3(node)) {
          addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(node), false));
        }
      } else {
        node = resolveIndex(caretPosition.container(), caretPosition.offset());
        if (isText$4(node)) {
          addCharacterOffset(node, 0);
        }
        if (isValidElementCaretCandidate(node) && caretPosition.isAtEnd()) {
          addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(node), false));
          return clientRects;
        }
        beforeNode = resolveIndex(caretPosition.container(), caretPosition.offset() - 1);
        if (isValidElementCaretCandidate(beforeNode) && !isBr$3(beforeNode)) {
          if (isBlock$1(beforeNode) || isBlock$1(node) || !isValidElementCaretCandidate(node)) {
            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(beforeNode), false));
          }
        }
        if (isValidElementCaretCandidate(node)) {
          addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(node), true));
        }
      }
    }
    return clientRects;
  };
  var CaretPosition = function(container, offset, clientRects) {
    var isAtStart = function() {
      if (isText$4(container)) {
        return offset === 0;
      }
      return offset === 0;
    };
    var isAtEnd = function() {
      if (isText$4(container)) {
        return offset >= container.data.length;
      }
      return offset >= container.childNodes.length;
    };
    var toRange = function() {
      var range2 = createRange(container.ownerDocument);
      range2.setStart(container, offset);
      range2.setEnd(container, offset);
      return range2;
    };
    var getClientRects2 = function() {
      if (!clientRects) {
        clientRects = getCaretPositionClientRects(CaretPosition(container, offset));
      }
      return clientRects;
    };
    var isVisible = function() {
      return getClientRects2().length > 0;
    };
    var isEqual2 = function(caretPosition) {
      return caretPosition && container === caretPosition.container() && offset === caretPosition.offset();
    };
    var getNode2 = function(before2) {
      return resolveIndex(container, before2 ? offset - 1 : offset);
    };
    return {
      container: constant(container),
      offset: constant(offset),
      toRange,
      getClientRects: getClientRects2,
      isVisible,
      isAtStart,
      isAtEnd,
      isEqual: isEqual2,
      getNode: getNode2
    };
  };
  CaretPosition.fromRangeStart = function(range2) {
    return CaretPosition(range2.startContainer, range2.startOffset);
  };
  CaretPosition.fromRangeEnd = function(range2) {
    return CaretPosition(range2.endContainer, range2.endOffset);
  };
  CaretPosition.after = function(node) {
    return CaretPosition(node.parentNode, nodeIndex(node) + 1);
  };
  CaretPosition.before = function(node) {
    return CaretPosition(node.parentNode, nodeIndex(node));
  };
  CaretPosition.isAbove = function(pos1, pos2) {
    return lift2(head(pos2.getClientRects()), last(pos1.getClientRects()), isAbove).getOr(false);
  };
  CaretPosition.isBelow = function(pos1, pos2) {
    return lift2(last(pos2.getClientRects()), head(pos1.getClientRects()), isBelow).getOr(false);
  };
  CaretPosition.isAtStart = function(pos) {
    return pos ? pos.isAtStart() : false;
  };
  CaretPosition.isAtEnd = function(pos) {
    return pos ? pos.isAtEnd() : false;
  };
  CaretPosition.isTextPosition = function(pos) {
    return pos ? isText$1(pos.container()) : false;
  };
  CaretPosition.isElementPosition = function(pos) {
    return CaretPosition.isTextPosition(pos) === false;
  };
  var trimEmptyTextNode = function(dom2, node) {
    if (isText$1(node) && node.data.length === 0) {
      dom2.remove(node);
    }
  };
  var insertNode = function(dom2, rng, node) {
    rng.insertNode(node);
    trimEmptyTextNode(dom2, node.previousSibling);
    trimEmptyTextNode(dom2, node.nextSibling);
  };
  var insertFragment = function(dom2, rng, frag) {
    var firstChild2 = Optional.from(frag.firstChild);
    var lastChild2 = Optional.from(frag.lastChild);
    rng.insertNode(frag);
    firstChild2.each(function(child2) {
      return trimEmptyTextNode(dom2, child2.previousSibling);
    });
    lastChild2.each(function(child2) {
      return trimEmptyTextNode(dom2, child2.nextSibling);
    });
  };
  var rangeInsertNode = function(dom2, rng, node) {
    if (isDocumentFragment$1(node)) {
      insertFragment(dom2, rng, node);
    } else {
      insertNode(dom2, rng, node);
    }
  };
  var isText$5 = isText$1;
  var isBogus$2 = isBogus;
  var nodeIndex$1 = DOMUtils.nodeIndex;
  var normalizedParent = function(node) {
    var parentNode = node.parentNode;
    if (isBogus$2(parentNode)) {
      return normalizedParent(parentNode);
    }
    return parentNode;
  };
  var getChildNodes = function(node) {
    if (!node) {
      return [];
    }
    return reduce(node.childNodes, function(result, node2) {
      if (isBogus$2(node2) && node2.nodeName !== "BR") {
        result = result.concat(getChildNodes(node2));
      } else {
        result.push(node2);
      }
      return result;
    }, []);
  };
  var normalizedTextOffset = function(node, offset) {
    while (node = node.previousSibling) {
      if (!isText$5(node)) {
        break;
      }
      offset += node.data.length;
    }
    return offset;
  };
  var equal$1 = function(a) {
    return function(b) {
      return a === b;
    };
  };
  var normalizedNodeIndex = function(node) {
    var nodes, index;
    nodes = getChildNodes(normalizedParent(node));
    index = findIndex$1(nodes, equal$1(node), node);
    nodes = nodes.slice(0, index + 1);
    var numTextFragments = reduce(nodes, function(result, node2, i) {
      if (isText$5(node2) && isText$5(nodes[i - 1])) {
        result++;
      }
      return result;
    }, 0);
    nodes = filter$2(nodes, matchNodeNames([node.nodeName]));
    index = findIndex$1(nodes, equal$1(node), node);
    return index - numTextFragments;
  };
  var createPathItem = function(node) {
    var name2;
    if (isText$5(node)) {
      name2 = "text()";
    } else {
      name2 = node.nodeName.toLowerCase();
    }
    return name2 + "[" + normalizedNodeIndex(node) + "]";
  };
  var parentsUntil = function(root, node, predicate) {
    var parents2 = [];
    for (node = node.parentNode; node !== root; node = node.parentNode) {
      if (predicate && predicate(node)) {
        break;
      }
      parents2.push(node);
    }
    return parents2;
  };
  var create$3 = function(root, caretPosition) {
    var container, offset, path = [], outputOffset, childNodes, parents2;
    container = caretPosition.container();
    offset = caretPosition.offset();
    if (isText$5(container)) {
      outputOffset = normalizedTextOffset(container, offset);
    } else {
      childNodes = container.childNodes;
      if (offset >= childNodes.length) {
        outputOffset = "after";
        offset = childNodes.length - 1;
      } else {
        outputOffset = "before";
      }
      container = childNodes[offset];
    }
    path.push(createPathItem(container));
    parents2 = parentsUntil(root, container);
    parents2 = filter$2(parents2, not(isBogus));
    path = path.concat(map$2(parents2, function(node) {
      return createPathItem(node);
    }));
    return path.reverse().join("/") + "," + outputOffset;
  };
  var resolvePathItem = function(node, name2, index) {
    var nodes = getChildNodes(node);
    nodes = filter$2(nodes, function(node2, index2) {
      return !isText$5(node2) || !isText$5(nodes[index2 - 1]);
    });
    nodes = filter$2(nodes, matchNodeNames([name2]));
    return nodes[index];
  };
  var findTextPosition = function(container, offset) {
    var node = container, targetOffset = 0, dataLen;
    while (isText$5(node)) {
      dataLen = node.data.length;
      if (offset >= targetOffset && offset <= targetOffset + dataLen) {
        container = node;
        offset = offset - targetOffset;
        break;
      }
      if (!isText$5(node.nextSibling)) {
        container = node;
        offset = dataLen;
        break;
      }
      targetOffset += dataLen;
      node = node.nextSibling;
    }
    if (isText$5(container) && offset > container.data.length) {
      offset = container.data.length;
    }
    return CaretPosition(container, offset);
  };
  var resolve$1 = function(root, path) {
    var offset;
    if (!path) {
      return null;
    }
    var parts = path.split(",");
    var paths = parts[0].split("/");
    offset = parts.length > 1 ? parts[1] : "before";
    var container = reduce(paths, function(result, value2) {
      var match2 = /([\w\-\(\)]+)\[([0-9]+)\]/.exec(value2);
      if (!match2) {
        return null;
      }
      if (match2[1] === "text()") {
        match2[1] = "#text";
      }
      return resolvePathItem(result, match2[1], parseInt(match2[2], 10));
    }, root);
    if (!container) {
      return null;
    }
    if (!isText$5(container)) {
      if (offset === "after") {
        offset = nodeIndex$1(container) + 1;
      } else {
        offset = nodeIndex$1(container);
      }
      return CaretPosition(container.parentNode, offset);
    }
    return findTextPosition(container, parseInt(offset, 10));
  };
  var isContentEditableFalse$2 = isContentEditableFalse;
  var getNormalizedTextOffset = function(trim2, container, offset) {
    var node, trimmedOffset;
    trimmedOffset = trim2(container.data.slice(0, offset)).length;
    for (node = container.previousSibling; node && isText$1(node); node = node.previousSibling) {
      trimmedOffset += trim2(node.data).length;
    }
    return trimmedOffset;
  };
  var getPoint = function(dom2, trim2, normalized, rng, start2) {
    var container = rng[start2 ? "startContainer" : "endContainer"];
    var offset = rng[start2 ? "startOffset" : "endOffset"];
    var point = [];
    var childNodes, after2 = 0;
    var root = dom2.getRoot();
    if (isText$1(container)) {
      point.push(normalized ? getNormalizedTextOffset(trim2, container, offset) : offset);
    } else {
      childNodes = container.childNodes;
      if (offset >= childNodes.length && childNodes.length) {
        after2 = 1;
        offset = Math.max(0, childNodes.length - 1);
      }
      point.push(dom2.nodeIndex(childNodes[offset], normalized) + after2);
    }
    for (; container && container !== root; container = container.parentNode) {
      point.push(dom2.nodeIndex(container, normalized));
    }
    return point;
  };
  var getLocation = function(trim2, selection, normalized, rng) {
    var dom2 = selection.dom, bookmark = {};
    bookmark.start = getPoint(dom2, trim2, normalized, rng, true);
    if (!selection.isCollapsed()) {
      bookmark.end = getPoint(dom2, trim2, normalized, rng, false);
    }
    return bookmark;
  };
  var findIndex$2 = function(dom2, name2, element) {
    var count2 = 0;
    Tools.each(dom2.select(name2), function(node) {
      if (node.getAttribute("data-mce-bogus") === "all") {
        return;
      }
      if (node === element) {
        return false;
      }
      count2++;
    });
    return count2;
  };
  var moveEndPoint = function(rng, start2) {
    var container, offset, childNodes;
    var prefix = start2 ? "start" : "end";
    container = rng[prefix + "Container"];
    offset = rng[prefix + "Offset"];
    if (isElement$1(container) && container.nodeName === "TR") {
      childNodes = container.childNodes;
      container = childNodes[Math.min(start2 ? offset : offset - 1, childNodes.length - 1)];
      if (container) {
        offset = start2 ? 0 : container.childNodes.length;
        rng["set" + (start2 ? "Start" : "End")](container, offset);
      }
    }
  };
  var normalizeTableCellSelection = function(rng) {
    moveEndPoint(rng, true);
    moveEndPoint(rng, false);
    return rng;
  };
  var findSibling = function(node, offset) {
    var sibling2;
    if (isElement$1(node)) {
      node = getNode(node, offset);
      if (isContentEditableFalse$2(node)) {
        return node;
      }
    }
    if (isCaretContainer(node)) {
      if (isText$1(node) && isCaretContainerBlock(node)) {
        node = node.parentNode;
      }
      sibling2 = node.previousSibling;
      if (isContentEditableFalse$2(sibling2)) {
        return sibling2;
      }
      sibling2 = node.nextSibling;
      if (isContentEditableFalse$2(sibling2)) {
        return sibling2;
      }
    }
  };
  var findAdjacentContentEditableFalseElm = function(rng) {
    return findSibling(rng.startContainer, rng.startOffset) || findSibling(rng.endContainer, rng.endOffset);
  };
  var getOffsetBookmark = function(trim2, normalized, selection) {
    var element = selection.getNode();
    var name2 = element ? element.nodeName : null;
    var rng = selection.getRng();
    if (isContentEditableFalse$2(element) || name2 === "IMG") {
      return {
        name: name2,
        index: findIndex$2(selection.dom, name2, element)
      };
    }
    var sibling2 = findAdjacentContentEditableFalseElm(rng);
    if (sibling2) {
      name2 = sibling2.tagName;
      return {
        name: name2,
        index: findIndex$2(selection.dom, name2, sibling2)
      };
    }
    return getLocation(trim2, selection, normalized, rng);
  };
  var getCaretBookmark = function(selection) {
    var rng = selection.getRng();
    return {
      start: create$3(selection.dom.getRoot(), CaretPosition.fromRangeStart(rng)),
      end: create$3(selection.dom.getRoot(), CaretPosition.fromRangeEnd(rng))
    };
  };
  var getRangeBookmark = function(selection) {
    return { rng: selection.getRng() };
  };
  var createBookmarkSpan = function(dom2, id2, filled) {
    var args = {
      "data-mce-type": "bookmark",
      id: id2,
      "style": "overflow:hidden;line-height:0px"
    };
    return filled ? dom2.create("span", args, "&#xFEFF;") : dom2.create("span", args);
  };
  var getPersistentBookmark = function(selection, filled) {
    var dom2 = selection.dom;
    var rng = selection.getRng();
    var id2 = dom2.uniqueId();
    var collapsed = selection.isCollapsed();
    var element = selection.getNode();
    var name2 = element.nodeName;
    if (name2 === "IMG") {
      return {
        name: name2,
        index: findIndex$2(dom2, name2, element)
      };
    }
    var rng2 = normalizeTableCellSelection(rng.cloneRange());
    if (!collapsed) {
      rng2.collapse(false);
      var endBookmarkNode = createBookmarkSpan(dom2, id2 + "_end", filled);
      rangeInsertNode(dom2, rng2, endBookmarkNode);
    }
    rng = normalizeTableCellSelection(rng);
    rng.collapse(true);
    var startBookmarkNode = createBookmarkSpan(dom2, id2 + "_start", filled);
    rangeInsertNode(dom2, rng, startBookmarkNode);
    selection.moveToBookmark({
      id: id2,
      keep: true
    });
    return { id: id2 };
  };
  var getBookmark = function(selection, type2, normalized) {
    if (type2 === 2) {
      return getOffsetBookmark(trim$2, normalized, selection);
    } else if (type2 === 3) {
      return getCaretBookmark(selection);
    } else if (type2) {
      return getRangeBookmark(selection);
    } else {
      return getPersistentBookmark(selection, false);
    }
  };
  var getUndoBookmark = curry(getOffsetBookmark, identity, true);
  var DOM$1 = DOMUtils.DOM;
  var defaultPreviewStyles = "font-family font-size font-weight font-style text-decoration text-transform color background-color border border-radius outline text-shadow";
  var getBodySetting = function(editor, name2, defaultValue) {
    var value2 = editor.getParam(name2, defaultValue);
    if (value2.indexOf("=") !== -1) {
      var bodyObj = editor.getParam(name2, "", "hash");
      return bodyObj.hasOwnProperty(editor.id) ? bodyObj[editor.id] : defaultValue;
    } else {
      return value2;
    }
  };
  var getIframeAttrs = function(editor) {
    return editor.getParam("iframe_attrs", {});
  };
  var getDocType = function(editor) {
    return editor.getParam("doctype", "<!DOCTYPE html>");
  };
  var getDocumentBaseUrl = function(editor) {
    return editor.getParam("document_base_url", "");
  };
  var getBodyId = function(editor) {
    return getBodySetting(editor, "body_id", "tinymce");
  };
  var getBodyClass = function(editor) {
    return getBodySetting(editor, "body_class", "");
  };
  var getContentSecurityPolicy = function(editor) {
    return editor.getParam("content_security_policy", "");
  };
  var shouldPutBrInPre = function(editor) {
    return editor.getParam("br_in_pre", true);
  };
  var getForcedRootBlock = function(editor) {
    if (editor.getParam("force_p_newlines", false)) {
      return "p";
    }
    var block = editor.getParam("forced_root_block", "p");
    if (block === false) {
      return "";
    } else if (block === true) {
      return "p";
    } else {
      return block;
    }
  };
  var getForcedRootBlockAttrs = function(editor) {
    return editor.getParam("forced_root_block_attrs", {});
  };
  var getBrNewLineSelector = function(editor) {
    return editor.getParam("br_newline_selector", ".mce-toc h2,figcaption,caption");
  };
  var getNoNewLineSelector = function(editor) {
    return editor.getParam("no_newline_selector", "");
  };
  var shouldKeepStyles = function(editor) {
    return editor.getParam("keep_styles", true);
  };
  var shouldEndContainerOnEmptyBlock = function(editor) {
    return editor.getParam("end_container_on_empty_block", false);
  };
  var getFontStyleValues = function(editor) {
    return Tools.explode(editor.getParam("font_size_style_values", "xx-small,x-small,small,medium,large,x-large,xx-large"));
  };
  var getFontSizeClasses = function(editor) {
    return Tools.explode(editor.getParam("font_size_classes", ""));
  };
  var getImagesDataImgFilter = function(editor) {
    return editor.getParam("images_dataimg_filter", always, "function");
  };
  var isAutomaticUploadsEnabled = function(editor) {
    return editor.getParam("automatic_uploads", true, "boolean");
  };
  var shouldReuseFileName = function(editor) {
    return editor.getParam("images_reuse_filename", false, "boolean");
  };
  var shouldReplaceBlobUris = function(editor) {
    return editor.getParam("images_replace_blob_uris", true, "boolean");
  };
  var getIconPackName = function(editor) {
    return editor.getParam("icons", "", "string");
  };
  var getIconsUrl = function(editor) {
    return editor.getParam("icons_url", "", "string");
  };
  var getImageUploadUrl = function(editor) {
    return editor.getParam("images_upload_url", "", "string");
  };
  var getImageUploadBasePath = function(editor) {
    return editor.getParam("images_upload_base_path", "", "string");
  };
  var getImagesUploadCredentials = function(editor) {
    return editor.getParam("images_upload_credentials", false, "boolean");
  };
  var getImagesUploadHandler = function(editor) {
    return editor.getParam("images_upload_handler", null, "function");
  };
  var shouldUseContentCssCors = function(editor) {
    return editor.getParam("content_css_cors", false, "boolean");
  };
  var getReferrerPolicy = function(editor) {
    return editor.getParam("referrer_policy", "", "string");
  };
  var getLanguageCode = function(editor) {
    return editor.getParam("language", "en", "string");
  };
  var getLanguageUrl = function(editor) {
    return editor.getParam("language_url", "", "string");
  };
  var shouldIndentUseMargin = function(editor) {
    return editor.getParam("indent_use_margin", false);
  };
  var getIndentation = function(editor) {
    return editor.getParam("indentation", "40px", "string");
  };
  var getContentCss = function(editor) {
    var contentCss = editor.getParam("content_css");
    if (isString(contentCss)) {
      return map(contentCss.split(","), trim);
    } else if (isArray(contentCss)) {
      return contentCss;
    } else if (contentCss === false || editor.inline) {
      return [];
    } else {
      return ["default"];
    }
  };
  var getFontCss = function(editor) {
    var fontCss = editor.getParam("font_css", []);
    return isArray(fontCss) ? fontCss : map(fontCss.split(","), trim);
  };
  var getDirectionality = function(editor) {
    return editor.getParam("directionality", I18n.isRtl() ? "rtl" : void 0);
  };
  var getInlineBoundarySelector = function(editor) {
    return editor.getParam("inline_boundaries_selector", "a[href],code,.mce-annotation", "string");
  };
  var getObjectResizing = function(editor) {
    var selector = editor.getParam("object_resizing");
    if (selector === false || Env.iOS) {
      return false;
    } else {
      return isString(selector) ? selector : "table,img,figure.image,div,video,iframe";
    }
  };
  var getResizeImgProportional = function(editor) {
    return editor.getParam("resize_img_proportional", true, "boolean");
  };
  var getPlaceholder = function(editor) {
    return editor.getParam("placeholder", DOM$1.getAttrib(editor.getElement(), "placeholder"), "string");
  };
  var getEventRoot = function(editor) {
    return editor.getParam("event_root");
  };
  var getServiceMessage = function(editor) {
    return editor.getParam("service_message");
  };
  var getTheme = function(editor) {
    return editor.getParam("theme");
  };
  var shouldValidate = function(editor) {
    return editor.getParam("validate");
  };
  var isInlineBoundariesEnabled = function(editor) {
    return editor.getParam("inline_boundaries") !== false;
  };
  var getFormats = function(editor) {
    return editor.getParam("formats");
  };
  var getPreviewStyles = function(editor) {
    var style = editor.getParam("preview_styles", defaultPreviewStyles);
    if (isString(style)) {
      return style;
    } else {
      return "";
    }
  };
  var canFormatEmptyLines = function(editor) {
    return editor.getParam("format_empty_lines", false, "boolean");
  };
  var getCustomUiSelector = function(editor) {
    return editor.getParam("custom_ui_selector", "", "string");
  };
  var getThemeUrl = function(editor) {
    return editor.getParam("theme_url");
  };
  var isInline$1 = function(editor) {
    return editor.getParam("inline");
  };
  var hasHiddenInput = function(editor) {
    return editor.getParam("hidden_input");
  };
  var shouldPatchSubmit = function(editor) {
    return editor.getParam("submit_patch");
  };
  var isEncodingXml = function(editor) {
    return editor.getParam("encoding") === "xml";
  };
  var shouldAddFormSubmitTrigger = function(editor) {
    return editor.getParam("add_form_submit_trigger");
  };
  var shouldAddUnloadTrigger = function(editor) {
    return editor.getParam("add_unload_trigger");
  };
  var hasForcedRootBlock = function(editor) {
    return getForcedRootBlock(editor) !== "";
  };
  var getCustomUndoRedoLevels = function(editor) {
    return editor.getParam("custom_undo_redo_levels", 0, "number");
  };
  var shouldDisableNodeChange = function(editor) {
    return editor.getParam("disable_nodechange");
  };
  var isReadOnly = function(editor) {
    return editor.getParam("readonly");
  };
  var hasContentCssCors = function(editor) {
    return editor.getParam("content_css_cors");
  };
  var getPlugins = function(editor) {
    return editor.getParam("plugins", "", "string");
  };
  var getExternalPlugins = function(editor) {
    return editor.getParam("external_plugins");
  };
  var shouldBlockUnsupportedDrop = function(editor) {
    return editor.getParam("block_unsupported_drop", true, "boolean");
  };
  var isVisualAidsEnabled = function(editor) {
    return editor.getParam("visual", true, "boolean");
  };
  var getVisualAidsTableClass = function(editor) {
    return editor.getParam("visual_table_class", "mce-item-table", "string");
  };
  var getVisualAidsAnchorClass = function(editor) {
    return editor.getParam("visual_anchor_class", "mce-item-anchor", "string");
  };
  var isElement$4 = isElement$1;
  var isText$6 = isText$1;
  var removeNode = function(node) {
    var parentNode = node.parentNode;
    if (parentNode) {
      parentNode.removeChild(node);
    }
  };
  var trimCount = function(text) {
    var trimmedText = trim$2(text);
    return {
      count: text.length - trimmedText.length,
      text: trimmedText
    };
  };
  var deleteZwspChars = function(caretContainer) {
    var idx;
    while ((idx = caretContainer.data.lastIndexOf(ZWSP)) !== -1) {
      caretContainer.deleteData(idx, 1);
    }
  };
  var removeUnchanged = function(caretContainer, pos) {
    remove$5(caretContainer);
    return pos;
  };
  var removeTextAndReposition = function(caretContainer, pos) {
    var before2 = trimCount(caretContainer.data.substr(0, pos.offset()));
    var after2 = trimCount(caretContainer.data.substr(pos.offset()));
    var text = before2.text + after2.text;
    if (text.length > 0) {
      deleteZwspChars(caretContainer);
      return CaretPosition(caretContainer, pos.offset() - before2.count);
    } else {
      return pos;
    }
  };
  var removeElementAndReposition = function(caretContainer, pos) {
    var parentNode = pos.container();
    var newPosition = indexOf(from$1(parentNode.childNodes), caretContainer).map(function(index) {
      return index < pos.offset() ? CaretPosition(parentNode, pos.offset() - 1) : pos;
    }).getOr(pos);
    remove$5(caretContainer);
    return newPosition;
  };
  var removeTextCaretContainer = function(caretContainer, pos) {
    return isText$6(caretContainer) && pos.container() === caretContainer ? removeTextAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);
  };
  var removeElementCaretContainer = function(caretContainer, pos) {
    return pos.container() === caretContainer.parentNode ? removeElementAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);
  };
  var removeAndReposition = function(container, pos) {
    return CaretPosition.isTextPosition(pos) ? removeTextCaretContainer(container, pos) : removeElementCaretContainer(container, pos);
  };
  var remove$5 = function(caretContainerNode) {
    if (isElement$4(caretContainerNode) && isCaretContainer(caretContainerNode)) {
      if (hasContent(caretContainerNode)) {
        caretContainerNode.removeAttribute("data-mce-caret");
      } else {
        removeNode(caretContainerNode);
      }
    }
    if (isText$6(caretContainerNode)) {
      deleteZwspChars(caretContainerNode);
      if (caretContainerNode.data.length === 0) {
        removeNode(caretContainerNode);
      }
    }
  };
  var browser$2 = detect$3().browser;
  var isContentEditableFalse$3 = isContentEditableFalse;
  var isMedia$1 = isMedia;
  var isTableCell$2 = isTableCell;
  var inlineFakeCaretSelector = "*[contentEditable=false],video,audio,embed,object";
  var getAbsoluteClientRect = function(root, element, before2) {
    var clientRect = collapse(element.getBoundingClientRect(), before2);
    var docElm, scrollX, scrollY, margin, rootRect;
    if (root.tagName === "BODY") {
      docElm = root.ownerDocument.documentElement;
      scrollX = root.scrollLeft || docElm.scrollLeft;
      scrollY = root.scrollTop || docElm.scrollTop;
    } else {
      rootRect = root.getBoundingClientRect();
      scrollX = root.scrollLeft - rootRect.left;
      scrollY = root.scrollTop - rootRect.top;
    }
    clientRect.left += scrollX;
    clientRect.right += scrollX;
    clientRect.top += scrollY;
    clientRect.bottom += scrollY;
    clientRect.width = 1;
    margin = element.offsetWidth - element.clientWidth;
    if (margin > 0) {
      if (before2) {
        margin *= -1;
      }
      clientRect.left += margin;
      clientRect.right += margin;
    }
    return clientRect;
  };
  var trimInlineCaretContainers = function(root) {
    var fakeCaretTargetNodes = descendants$1(SugarElement.fromDom(root), inlineFakeCaretSelector);
    for (var i = 0; i < fakeCaretTargetNodes.length; i++) {
      var node = fakeCaretTargetNodes[i].dom;
      var sibling2 = node.previousSibling;
      if (endsWithCaretContainer(sibling2)) {
        var data2 = sibling2.data;
        if (data2.length === 1) {
          sibling2.parentNode.removeChild(sibling2);
        } else {
          sibling2.deleteData(data2.length - 1, 1);
        }
      }
      sibling2 = node.nextSibling;
      if (startsWithCaretContainer(sibling2)) {
        var data2 = sibling2.data;
        if (data2.length === 1) {
          sibling2.parentNode.removeChild(sibling2);
        } else {
          sibling2.deleteData(0, 1);
        }
      }
    }
  };
  var FakeCaret = function(editor, root, isBlock2, hasFocus2) {
    var lastVisualCaret = Cell(Optional.none());
    var cursorInterval, caretContainerNode;
    var rootBlock = getForcedRootBlock(editor);
    var caretBlock = rootBlock.length > 0 ? rootBlock : "p";
    var show = function(before2, element) {
      var clientRect, rng;
      hide();
      if (isTableCell$2(element)) {
        return null;
      }
      if (isBlock2(element)) {
        caretContainerNode = insertBlock(caretBlock, element, before2);
        clientRect = getAbsoluteClientRect(root, element, before2);
        DomQuery(caretContainerNode).css("top", clientRect.top);
        var caret = DomQuery('<div class="mce-visual-caret" data-mce-bogus="all"></div>').css(clientRect).appendTo(root)[0];
        lastVisualCaret.set(Optional.some({
          caret,
          element,
          before: before2
        }));
        lastVisualCaret.get().each(function(caretState) {
          if (before2) {
            DomQuery(caretState.caret).addClass("mce-visual-caret-before");
          }
        });
        startBlink();
        rng = element.ownerDocument.createRange();
        rng.setStart(caretContainerNode, 0);
        rng.setEnd(caretContainerNode, 0);
      } else {
        caretContainerNode = insertInline(element, before2);
        rng = element.ownerDocument.createRange();
        if (isInlineFakeCaretTarget(caretContainerNode.nextSibling)) {
          rng.setStart(caretContainerNode, 0);
          rng.setEnd(caretContainerNode, 0);
        } else {
          rng.setStart(caretContainerNode, 1);
          rng.setEnd(caretContainerNode, 1);
        }
        return rng;
      }
      return rng;
    };
    var hide = function() {
      trimInlineCaretContainers(root);
      if (caretContainerNode) {
        remove$5(caretContainerNode);
        caretContainerNode = null;
      }
      lastVisualCaret.get().each(function(caretState) {
        DomQuery(caretState.caret).remove();
        lastVisualCaret.set(Optional.none());
      });
      if (cursorInterval) {
        Delay.clearInterval(cursorInterval);
        cursorInterval = null;
      }
    };
    var startBlink = function() {
      cursorInterval = Delay.setInterval(function() {
        if (hasFocus2()) {
          DomQuery("div.mce-visual-caret", root).toggleClass("mce-visual-caret-hidden");
        } else {
          DomQuery("div.mce-visual-caret", root).addClass("mce-visual-caret-hidden");
        }
      }, 500);
    };
    var reposition2 = function() {
      lastVisualCaret.get().each(function(caretState) {
        var clientRect = getAbsoluteClientRect(root, caretState.element, caretState.before);
        DomQuery(caretState.caret).css(__assign2({}, clientRect));
      });
    };
    var destroy2 = function() {
      return Delay.clearInterval(cursorInterval);
    };
    var getCss = function() {
      return ".mce-visual-caret {position: absolute;background-color: black;background-color: currentcolor;}.mce-visual-caret-hidden {display: none;}*[data-mce-caret] {position: absolute;left: -1000px;right: auto;top: 0;margin: 0;padding: 0;}";
    };
    return {
      show,
      hide,
      getCss,
      reposition: reposition2,
      destroy: destroy2
    };
  };
  var isFakeCaretTableBrowser = function() {
    return browser$2.isIE() || browser$2.isEdge() || browser$2.isFirefox();
  };
  var isInlineFakeCaretTarget = function(node) {
    return isContentEditableFalse$3(node) || isMedia$1(node);
  };
  var isFakeCaretTarget = function(node) {
    return isInlineFakeCaretTarget(node) || isTable(node) && isFakeCaretTableBrowser();
  };
  var isContentEditableFalse$4 = isContentEditableFalse;
  var isMedia$2 = isMedia;
  var isBlockLike = matchStyleValues("display", "block table table-cell table-caption list-item");
  var isCaretContainer$2 = isCaretContainer;
  var isCaretContainerBlock$1 = isCaretContainerBlock;
  var isElement$5 = isElement$1;
  var isCaretCandidate$2 = isCaretCandidate;
  var isForwards = function(direction) {
    return direction > 0;
  };
  var isBackwards = function(direction) {
    return direction < 0;
  };
  var skipCaretContainers = function(walk2, shallow2) {
    var node;
    while (node = walk2(shallow2)) {
      if (!isCaretContainerBlock$1(node)) {
        return node;
      }
    }
    return null;
  };
  var findNode = function(node, direction, predicateFn, rootNode, shallow2) {
    var walker = new DomTreeWalker(node, rootNode);
    var isCefOrCaretContainer = isContentEditableFalse$4(node) || isCaretContainerBlock$1(node);
    if (isBackwards(direction)) {
      if (isCefOrCaretContainer) {
        node = skipCaretContainers(walker.prev.bind(walker), true);
        if (predicateFn(node)) {
          return node;
        }
      }
      while (node = skipCaretContainers(walker.prev.bind(walker), shallow2)) {
        if (predicateFn(node)) {
          return node;
        }
      }
    }
    if (isForwards(direction)) {
      if (isCefOrCaretContainer) {
        node = skipCaretContainers(walker.next.bind(walker), true);
        if (predicateFn(node)) {
          return node;
        }
      }
      while (node = skipCaretContainers(walker.next.bind(walker), shallow2)) {
        if (predicateFn(node)) {
          return node;
        }
      }
    }
    return null;
  };
  var getParentBlock = function(node, rootNode) {
    while (node && node !== rootNode) {
      if (isBlockLike(node)) {
        return node;
      }
      node = node.parentNode;
    }
    return null;
  };
  var isInSameBlock = function(caretPosition1, caretPosition2, rootNode) {
    return getParentBlock(caretPosition1.container(), rootNode) === getParentBlock(caretPosition2.container(), rootNode);
  };
  var getChildNodeAtRelativeOffset = function(relativeOffset, caretPosition) {
    if (!caretPosition) {
      return null;
    }
    var container = caretPosition.container();
    var offset = caretPosition.offset();
    if (!isElement$5(container)) {
      return null;
    }
    return container.childNodes[offset + relativeOffset];
  };
  var beforeAfter = function(before2, node) {
    var range2 = node.ownerDocument.createRange();
    if (before2) {
      range2.setStartBefore(node);
      range2.setEndBefore(node);
    } else {
      range2.setStartAfter(node);
      range2.setEndAfter(node);
    }
    return range2;
  };
  var isNodesInSameBlock = function(root, node1, node2) {
    return getParentBlock(node1, root) === getParentBlock(node2, root);
  };
  var lean = function(left, root, node) {
    var sibling2, siblingName;
    if (left) {
      siblingName = "previousSibling";
    } else {
      siblingName = "nextSibling";
    }
    while (node && node !== root) {
      sibling2 = node[siblingName];
      if (isCaretContainer$2(sibling2)) {
        sibling2 = sibling2[siblingName];
      }
      if (isContentEditableFalse$4(sibling2) || isMedia$2(sibling2)) {
        if (isNodesInSameBlock(root, sibling2, node)) {
          return sibling2;
        }
        break;
      }
      if (isCaretCandidate$2(sibling2)) {
        break;
      }
      node = node.parentNode;
    }
    return null;
  };
  var before$2 = curry(beforeAfter, true);
  var after$1 = curry(beforeAfter, false);
  var normalizeRange = function(direction, root, range2) {
    var node, container, location;
    var leanLeft = curry(lean, true, root);
    var leanRight2 = curry(lean, false, root);
    container = range2.startContainer;
    var offset = range2.startOffset;
    if (isCaretContainerBlock(container)) {
      if (!isElement$5(container)) {
        container = container.parentNode;
      }
      location = container.getAttribute("data-mce-caret");
      if (location === "before") {
        node = container.nextSibling;
        if (isFakeCaretTarget(node)) {
          return before$2(node);
        }
      }
      if (location === "after") {
        node = container.previousSibling;
        if (isFakeCaretTarget(node)) {
          return after$1(node);
        }
      }
    }
    if (!range2.collapsed) {
      return range2;
    }
    if (isText$1(container)) {
      if (isCaretContainer$2(container)) {
        if (direction === 1) {
          node = leanRight2(container);
          if (node) {
            return before$2(node);
          }
          node = leanLeft(container);
          if (node) {
            return after$1(node);
          }
        }
        if (direction === -1) {
          node = leanLeft(container);
          if (node) {
            return after$1(node);
          }
          node = leanRight2(container);
          if (node) {
            return before$2(node);
          }
        }
        return range2;
      }
      if (endsWithCaretContainer(container) && offset >= container.data.length - 1) {
        if (direction === 1) {
          node = leanRight2(container);
          if (node) {
            return before$2(node);
          }
        }
        return range2;
      }
      if (startsWithCaretContainer(container) && offset <= 1) {
        if (direction === -1) {
          node = leanLeft(container);
          if (node) {
            return after$1(node);
          }
        }
        return range2;
      }
      if (offset === container.data.length) {
        node = leanRight2(container);
        if (node) {
          return before$2(node);
        }
        return range2;
      }
      if (offset === 0) {
        node = leanLeft(container);
        if (node) {
          return after$1(node);
        }
        return range2;
      }
    }
    return range2;
  };
  var getRelativeCefElm = function(forward, caretPosition) {
    return Optional.from(getChildNodeAtRelativeOffset(forward ? 0 : -1, caretPosition)).filter(isContentEditableFalse$4);
  };
  var getNormalizedRangeEndPoint = function(direction, root, range2) {
    var normalizedRange = normalizeRange(direction, root, range2);
    if (direction === -1) {
      return CaretPosition.fromRangeStart(normalizedRange);
    }
    return CaretPosition.fromRangeEnd(normalizedRange);
  };
  var getElementFromPosition = function(pos) {
    return Optional.from(pos.getNode()).map(SugarElement.fromDom);
  };
  var getElementFromPrevPosition = function(pos) {
    return Optional.from(pos.getNode(true)).map(SugarElement.fromDom);
  };
  var getVisualCaretPosition = function(walkFn, caretPosition) {
    while (caretPosition = walkFn(caretPosition)) {
      if (caretPosition.isVisible()) {
        return caretPosition;
      }
    }
    return caretPosition;
  };
  var isMoveInsideSameBlock = function(from2, to2) {
    var inSameBlock = isInSameBlock(from2, to2);
    if (!inSameBlock && isBr(from2.getNode())) {
      return true;
    }
    return inSameBlock;
  };
  var HDirection;
  (function(HDirection2) {
    HDirection2[HDirection2["Backwards"] = -1] = "Backwards";
    HDirection2[HDirection2["Forwards"] = 1] = "Forwards";
  })(HDirection || (HDirection = {}));
  var isContentEditableFalse$5 = isContentEditableFalse;
  var isText$7 = isText$1;
  var isElement$6 = isElement$1;
  var isBr$4 = isBr;
  var isCaretCandidate$3 = isCaretCandidate;
  var isAtomic$1 = isAtomic;
  var isEditableCaretCandidate$1 = isEditableCaretCandidate;
  var getParents = function(node, root) {
    var parents2 = [];
    while (node && node !== root) {
      parents2.push(node);
      node = node.parentNode;
    }
    return parents2;
  };
  var nodeAtIndex = function(container, offset) {
    if (container.hasChildNodes() && offset < container.childNodes.length) {
      return container.childNodes[offset];
    }
    return null;
  };
  var getCaretCandidatePosition = function(direction, node) {
    if (isForwards(direction)) {
      if (isCaretCandidate$3(node.previousSibling) && !isText$7(node.previousSibling)) {
        return CaretPosition.before(node);
      }
      if (isText$7(node)) {
        return CaretPosition(node, 0);
      }
    }
    if (isBackwards(direction)) {
      if (isCaretCandidate$3(node.nextSibling) && !isText$7(node.nextSibling)) {
        return CaretPosition.after(node);
      }
      if (isText$7(node)) {
        return CaretPosition(node, node.data.length);
      }
    }
    if (isBackwards(direction)) {
      if (isBr$4(node)) {
        return CaretPosition.before(node);
      }
      return CaretPosition.after(node);
    }
    return CaretPosition.before(node);
  };
  var moveForwardFromBr = function(root, nextNode) {
    var nextSibling2 = nextNode.nextSibling;
    if (nextSibling2 && isCaretCandidate$3(nextSibling2)) {
      if (isText$7(nextSibling2)) {
        return CaretPosition(nextSibling2, 0);
      } else {
        return CaretPosition.before(nextSibling2);
      }
    } else {
      return findCaretPosition(HDirection.Forwards, CaretPosition.after(nextNode), root);
    }
  };
  var findCaretPosition = function(direction, startPos, root) {
    var node, nextNode, innerNode;
    var caretPosition;
    if (!isElement$6(root) || !startPos) {
      return null;
    }
    if (startPos.isEqual(CaretPosition.after(root)) && root.lastChild) {
      caretPosition = CaretPosition.after(root.lastChild);
      if (isBackwards(direction) && isCaretCandidate$3(root.lastChild) && isElement$6(root.lastChild)) {
        return isBr$4(root.lastChild) ? CaretPosition.before(root.lastChild) : caretPosition;
      }
    } else {
      caretPosition = startPos;
    }
    var container = caretPosition.container();
    var offset = caretPosition.offset();
    if (isText$7(container)) {
      if (isBackwards(direction) && offset > 0) {
        return CaretPosition(container, --offset);
      }
      if (isForwards(direction) && offset < container.length) {
        return CaretPosition(container, ++offset);
      }
      node = container;
    } else {
      if (isBackwards(direction) && offset > 0) {
        nextNode = nodeAtIndex(container, offset - 1);
        if (isCaretCandidate$3(nextNode)) {
          if (!isAtomic$1(nextNode)) {
            innerNode = findNode(nextNode, direction, isEditableCaretCandidate$1, nextNode);
            if (innerNode) {
              if (isText$7(innerNode)) {
                return CaretPosition(innerNode, innerNode.data.length);
              }
              return CaretPosition.after(innerNode);
            }
          }
          if (isText$7(nextNode)) {
            return CaretPosition(nextNode, nextNode.data.length);
          }
          return CaretPosition.before(nextNode);
        }
      }
      if (isForwards(direction) && offset < container.childNodes.length) {
        nextNode = nodeAtIndex(container, offset);
        if (isCaretCandidate$3(nextNode)) {
          if (isBr$4(nextNode)) {
            return moveForwardFromBr(root, nextNode);
          }
          if (!isAtomic$1(nextNode)) {
            innerNode = findNode(nextNode, direction, isEditableCaretCandidate$1, nextNode);
            if (innerNode) {
              if (isText$7(innerNode)) {
                return CaretPosition(innerNode, 0);
              }
              return CaretPosition.before(innerNode);
            }
          }
          if (isText$7(nextNode)) {
            return CaretPosition(nextNode, 0);
          }
          return CaretPosition.after(nextNode);
        }
      }
      node = nextNode ? nextNode : caretPosition.getNode();
    }
    if (isForwards(direction) && caretPosition.isAtEnd() || isBackwards(direction) && caretPosition.isAtStart()) {
      node = findNode(node, direction, always, root, true);
      if (isEditableCaretCandidate$1(node, root)) {
        return getCaretCandidatePosition(direction, node);
      }
    }
    nextNode = findNode(node, direction, isEditableCaretCandidate$1, root);
    var rootContentEditableFalseElm = last$1(filter(getParents(container, root), isContentEditableFalse$5));
    if (rootContentEditableFalseElm && (!nextNode || !rootContentEditableFalseElm.contains(nextNode))) {
      if (isForwards(direction)) {
        caretPosition = CaretPosition.after(rootContentEditableFalseElm);
      } else {
        caretPosition = CaretPosition.before(rootContentEditableFalseElm);
      }
      return caretPosition;
    }
    if (nextNode) {
      return getCaretCandidatePosition(direction, nextNode);
    }
    return null;
  };
  var CaretWalker = function(root) {
    return {
      next: function(caretPosition) {
        return findCaretPosition(HDirection.Forwards, caretPosition, root);
      },
      prev: function(caretPosition) {
        return findCaretPosition(HDirection.Backwards, caretPosition, root);
      }
    };
  };
  var walkToPositionIn = function(forward, root, start2) {
    var position = forward ? CaretPosition.before(start2) : CaretPosition.after(start2);
    return fromPosition(forward, root, position);
  };
  var afterElement = function(node) {
    return isBr(node) ? CaretPosition.before(node) : CaretPosition.after(node);
  };
  var isBeforeOrStart = function(position) {
    if (CaretPosition.isTextPosition(position)) {
      return position.offset() === 0;
    } else {
      return isCaretCandidate(position.getNode());
    }
  };
  var isAfterOrEnd = function(position) {
    if (CaretPosition.isTextPosition(position)) {
      var container = position.container();
      return position.offset() === container.data.length;
    } else {
      return isCaretCandidate(position.getNode(true));
    }
  };
  var isBeforeAfterSameElement = function(from2, to2) {
    return !CaretPosition.isTextPosition(from2) && !CaretPosition.isTextPosition(to2) && from2.getNode() === to2.getNode(true);
  };
  var isAtBr = function(position) {
    return !CaretPosition.isTextPosition(position) && isBr(position.getNode());
  };
  var shouldSkipPosition = function(forward, from2, to2) {
    if (forward) {
      return !isBeforeAfterSameElement(from2, to2) && !isAtBr(from2) && isAfterOrEnd(from2) && isBeforeOrStart(to2);
    } else {
      return !isBeforeAfterSameElement(to2, from2) && isBeforeOrStart(from2) && isAfterOrEnd(to2);
    }
  };
  var fromPosition = function(forward, root, pos) {
    var walker = CaretWalker(root);
    return Optional.from(forward ? walker.next(pos) : walker.prev(pos));
  };
  var navigate = function(forward, root, from2) {
    return fromPosition(forward, root, from2).bind(function(to2) {
      if (isInSameBlock(from2, to2, root) && shouldSkipPosition(forward, from2, to2)) {
        return fromPosition(forward, root, to2);
      } else {
        return Optional.some(to2);
      }
    });
  };
  var navigateIgnore = function(forward, root, from2, ignoreFilter) {
    return navigate(forward, root, from2).bind(function(pos) {
      return ignoreFilter(pos) ? navigateIgnore(forward, root, pos, ignoreFilter) : Optional.some(pos);
    });
  };
  var positionIn = function(forward, element) {
    var startNode = forward ? element.firstChild : element.lastChild;
    if (isText$1(startNode)) {
      return Optional.some(CaretPosition(startNode, forward ? 0 : startNode.data.length));
    } else if (startNode) {
      if (isCaretCandidate(startNode)) {
        return Optional.some(forward ? CaretPosition.before(startNode) : afterElement(startNode));
      } else {
        return walkToPositionIn(forward, element, startNode);
      }
    } else {
      return Optional.none();
    }
  };
  var nextPosition = curry(fromPosition, true);
  var prevPosition = curry(fromPosition, false);
  var firstPositionIn = curry(positionIn, true);
  var lastPositionIn = curry(positionIn, false);
  var CARET_ID = "_mce_caret";
  var isCaretNode = function(node) {
    return isElement$1(node) && node.id === CARET_ID;
  };
  var getParentCaretContainer = function(body, node) {
    while (node && node !== body) {
      if (node.id === CARET_ID) {
        return node;
      }
      node = node.parentNode;
    }
    return null;
  };
  var isStringPathBookmark = function(bookmark) {
    return isString(bookmark.start);
  };
  var isRangeBookmark = function(bookmark) {
    return bookmark.hasOwnProperty("rng");
  };
  var isIdBookmark = function(bookmark) {
    return bookmark.hasOwnProperty("id");
  };
  var isIndexBookmark = function(bookmark) {
    return bookmark.hasOwnProperty("name");
  };
  var isPathBookmark = function(bookmark) {
    return Tools.isArray(bookmark.start);
  };
  var addBogus = function(dom2, node) {
    if (isElement$1(node) && dom2.isBlock(node) && !node.innerHTML && !Env.ie) {
      node.innerHTML = '<br data-mce-bogus="1" />';
    }
    return node;
  };
  var resolveCaretPositionBookmark = function(dom2, bookmark) {
    var pos;
    var rng = dom2.createRng();
    pos = resolve$1(dom2.getRoot(), bookmark.start);
    rng.setStart(pos.container(), pos.offset());
    pos = resolve$1(dom2.getRoot(), bookmark.end);
    rng.setEnd(pos.container(), pos.offset());
    return rng;
  };
  var insertZwsp = function(node, rng) {
    var textNode = node.ownerDocument.createTextNode(ZWSP);
    node.appendChild(textNode);
    rng.setStart(textNode, 0);
    rng.setEnd(textNode, 0);
  };
  var isEmpty$1 = function(node) {
    return node.hasChildNodes() === false;
  };
  var tryFindRangePosition = function(node, rng) {
    return lastPositionIn(node).fold(never, function(pos) {
      rng.setStart(pos.container(), pos.offset());
      rng.setEnd(pos.container(), pos.offset());
      return true;
    });
  };
  var padEmptyCaretContainer = function(root, node, rng) {
    if (isEmpty$1(node) && getParentCaretContainer(root, node)) {
      insertZwsp(node, rng);
      return true;
    } else {
      return false;
    }
  };
  var setEndPoint = function(dom2, start2, bookmark, rng) {
    var point = bookmark[start2 ? "start" : "end"];
    var i, node, offset, children2;
    var root = dom2.getRoot();
    if (point) {
      offset = point[0];
      for (node = root, i = point.length - 1; i >= 1; i--) {
        children2 = node.childNodes;
        if (padEmptyCaretContainer(root, node, rng)) {
          return true;
        }
        if (point[i] > children2.length - 1) {
          if (padEmptyCaretContainer(root, node, rng)) {
            return true;
          }
          return tryFindRangePosition(node, rng);
        }
        node = children2[point[i]];
      }
      if (node.nodeType === 3) {
        offset = Math.min(point[0], node.nodeValue.length);
      }
      if (node.nodeType === 1) {
        offset = Math.min(point[0], node.childNodes.length);
      }
      if (start2) {
        rng.setStart(node, offset);
      } else {
        rng.setEnd(node, offset);
      }
    }
    return true;
  };
  var isValidTextNode = function(node) {
    return isText$1(node) && node.data.length > 0;
  };
  var restoreEndPoint = function(dom2, suffix, bookmark) {
    var marker = dom2.get(bookmark.id + "_" + suffix), node, idx, next, prev;
    var keep = bookmark.keep;
    var container, offset;
    if (marker) {
      node = marker.parentNode;
      if (suffix === "start") {
        if (!keep) {
          idx = dom2.nodeIndex(marker);
        } else {
          if (marker.hasChildNodes()) {
            node = marker.firstChild;
            idx = 1;
          } else if (isValidTextNode(marker.nextSibling)) {
            node = marker.nextSibling;
            idx = 0;
          } else if (isValidTextNode(marker.previousSibling)) {
            node = marker.previousSibling;
            idx = marker.previousSibling.data.length;
          } else {
            node = marker.parentNode;
            idx = dom2.nodeIndex(marker) + 1;
          }
        }
        container = node;
        offset = idx;
      } else {
        if (!keep) {
          idx = dom2.nodeIndex(marker);
        } else {
          if (marker.hasChildNodes()) {
            node = marker.firstChild;
            idx = 1;
          } else if (isValidTextNode(marker.previousSibling)) {
            node = marker.previousSibling;
            idx = marker.previousSibling.data.length;
          } else {
            node = marker.parentNode;
            idx = dom2.nodeIndex(marker);
          }
        }
        container = node;
        offset = idx;
      }
      if (!keep) {
        prev = marker.previousSibling;
        next = marker.nextSibling;
        Tools.each(Tools.grep(marker.childNodes), function(node2) {
          if (isText$1(node2)) {
            node2.nodeValue = node2.nodeValue.replace(/\uFEFF/g, "");
          }
        });
        while (marker = dom2.get(bookmark.id + "_" + suffix)) {
          dom2.remove(marker, true);
        }
        if (prev && next && prev.nodeType === next.nodeType && isText$1(prev) && !Env.opera) {
          idx = prev.nodeValue.length;
          prev.appendData(next.nodeValue);
          dom2.remove(next);
          container = prev;
          offset = idx;
        }
      }
      return Optional.some(CaretPosition(container, offset));
    } else {
      return Optional.none();
    }
  };
  var resolvePaths = function(dom2, bookmark) {
    var rng = dom2.createRng();
    if (setEndPoint(dom2, true, bookmark, rng) && setEndPoint(dom2, false, bookmark, rng)) {
      return Optional.some(rng);
    } else {
      return Optional.none();
    }
  };
  var resolveId = function(dom2, bookmark) {
    var startPos = restoreEndPoint(dom2, "start", bookmark);
    var endPos = restoreEndPoint(dom2, "end", bookmark);
    return lift2(startPos, endPos.or(startPos), function(spos, epos) {
      var rng = dom2.createRng();
      rng.setStart(addBogus(dom2, spos.container()), spos.offset());
      rng.setEnd(addBogus(dom2, epos.container()), epos.offset());
      return rng;
    });
  };
  var resolveIndex$1 = function(dom2, bookmark) {
    return Optional.from(dom2.select(bookmark.name)[bookmark.index]).map(function(elm) {
      var rng = dom2.createRng();
      rng.selectNode(elm);
      return rng;
    });
  };
  var resolve$2 = function(selection, bookmark) {
    var dom2 = selection.dom;
    if (bookmark) {
      if (isPathBookmark(bookmark)) {
        return resolvePaths(dom2, bookmark);
      } else if (isStringPathBookmark(bookmark)) {
        return Optional.some(resolveCaretPositionBookmark(dom2, bookmark));
      } else if (isIdBookmark(bookmark)) {
        return resolveId(dom2, bookmark);
      } else if (isIndexBookmark(bookmark)) {
        return resolveIndex$1(dom2, bookmark);
      } else if (isRangeBookmark(bookmark)) {
        return Optional.some(bookmark.rng);
      }
    }
    return Optional.none();
  };
  var getBookmark$1 = function(selection, type2, normalized) {
    return getBookmark(selection, type2, normalized);
  };
  var moveToBookmark = function(selection, bookmark) {
    resolve$2(selection, bookmark).each(function(rng) {
      selection.setRng(rng);
    });
  };
  var isBookmarkNode$1 = function(node) {
    return isElement$1(node) && node.tagName === "SPAN" && node.getAttribute("data-mce-type") === "bookmark";
  };
  var is$2 = function(expected) {
    return function(actual) {
      return expected === actual;
    };
  };
  var isNbsp = is$2(nbsp);
  var isWhiteSpace$1 = function(chr) {
    return chr !== "" && " \f\n\r	\v".indexOf(chr) !== -1;
  };
  var isContent$1 = function(chr) {
    return !isWhiteSpace$1(chr) && !isNbsp(chr);
  };
  var isNode = function(node) {
    return !!node.nodeType;
  };
  var isInlineBlock = function(node) {
    return node && /^(IMG)$/.test(node.nodeName);
  };
  var moveStart = function(dom2, selection, rng) {
    var offset = rng.startOffset;
    var container = rng.startContainer, walker, node, nodes;
    if (rng.startContainer === rng.endContainer) {
      if (isInlineBlock(rng.startContainer.childNodes[rng.startOffset])) {
        return;
      }
    }
    if (container.nodeType === 1) {
      nodes = container.childNodes;
      if (offset < nodes.length) {
        container = nodes[offset];
        walker = new DomTreeWalker(container, dom2.getParent(container, dom2.isBlock));
      } else {
        container = nodes[nodes.length - 1];
        walker = new DomTreeWalker(container, dom2.getParent(container, dom2.isBlock));
        walker.next(true);
      }
      for (node = walker.current(); node; node = walker.next()) {
        if (node.nodeType === 3 && !isWhiteSpaceNode(node)) {
          rng.setStart(node, 0);
          selection.setRng(rng);
          return;
        }
      }
    }
  };
  var getNonWhiteSpaceSibling = function(node, next, inc) {
    if (node) {
      var nextName = next ? "nextSibling" : "previousSibling";
      for (node = inc ? node : node[nextName]; node; node = node[nextName]) {
        if (node.nodeType === 1 || !isWhiteSpaceNode(node)) {
          return node;
        }
      }
    }
  };
  var isTextBlock$1 = function(editor, name2) {
    if (isNode(name2)) {
      name2 = name2.nodeName;
    }
    return !!editor.schema.getTextBlockElements()[name2.toLowerCase()];
  };
  var isValid = function(ed2, parent2, child2) {
    return ed2.schema.isValidChild(parent2, child2);
  };
  var isWhiteSpaceNode = function(node, allowSpaces) {
    if (allowSpaces === void 0) {
      allowSpaces = false;
    }
    if (isNonNullable(node) && isText$1(node)) {
      var data2 = allowSpaces ? node.data.replace(/ /g, "\xA0") : node.data;
      return isWhitespaceText(data2);
    } else {
      return false;
    }
  };
  var isEmptyTextNode = function(node) {
    return isNonNullable(node) && isText$1(node) && node.length === 0;
  };
  var replaceVars = function(value2, vars) {
    if (typeof value2 !== "string") {
      value2 = value2(vars);
    } else if (vars) {
      value2 = value2.replace(/%(\w+)/g, function(str, name2) {
        return vars[name2] || str;
      });
    }
    return value2;
  };
  var isEq = function(str1, str2) {
    str1 = str1 || "";
    str2 = str2 || "";
    str1 = "" + (str1.nodeName || str1);
    str2 = "" + (str2.nodeName || str2);
    return str1.toLowerCase() === str2.toLowerCase();
  };
  var normalizeStyleValue = function(dom2, value2, name2) {
    if (name2 === "color" || name2 === "backgroundColor") {
      value2 = dom2.toHex(value2);
    }
    if (name2 === "fontWeight" && value2 === 700) {
      value2 = "bold";
    }
    if (name2 === "fontFamily") {
      value2 = value2.replace(/[\'\"]/g, "").replace(/,\s+/g, ",");
    }
    return "" + value2;
  };
  var getStyle = function(dom2, node, name2) {
    return normalizeStyleValue(dom2, dom2.getStyle(node, name2), name2);
  };
  var getTextDecoration = function(dom2, node) {
    var decoration;
    dom2.getParent(node, function(n2) {
      decoration = dom2.getStyle(n2, "text-decoration");
      return decoration && decoration !== "none";
    });
    return decoration;
  };
  var getParents$1 = function(dom2, node, selector) {
    return dom2.getParents(node, selector, dom2.getRoot());
  };
  var isVariableFormatName = function(editor, formatName) {
    var hasVariableValues = function(format) {
      var isVariableValue = function(val) {
        return val.length > 1 && val.charAt(0) === "%";
      };
      return exists([
        "styles",
        "attributes"
      ], function(key) {
        return get$1(format, key).exists(function(field) {
          var fieldValues = isArray(field) ? field : values(field);
          return exists(fieldValues, isVariableValue);
        });
      });
    };
    return exists(editor.formatter.get(formatName), hasVariableValues);
  };
  var areSimilarFormats = function(editor, formatName, otherFormatName) {
    var validKeys = [
      "inline",
      "block",
      "selector",
      "attributes",
      "styles",
      "classes"
    ];
    var filterObj = function(format) {
      return filter$1(format, function(_, key) {
        return exists(validKeys, function(validKey) {
          return validKey === key;
        });
      });
    };
    return exists(editor.formatter.get(formatName), function(fmt1) {
      var filteredFmt1 = filterObj(fmt1);
      return exists(editor.formatter.get(otherFormatName), function(fmt2) {
        var filteredFmt2 = filterObj(fmt2);
        return equal(filteredFmt1, filteredFmt2);
      });
    });
  };
  var isBlockFormat = function(format) {
    return hasNonNullableKey(format, "block");
  };
  var isSelectorFormat = function(format) {
    return hasNonNullableKey(format, "selector");
  };
  var isInlineFormat = function(format) {
    return hasNonNullableKey(format, "inline");
  };
  var hasBlockChildren = function(dom2, elm) {
    return exists(elm.childNodes, dom2.isBlock);
  };
  var isBookmarkNode$2 = isBookmarkNode$1;
  var getParents$2 = getParents$1;
  var isWhiteSpaceNode$1 = isWhiteSpaceNode;
  var isTextBlock$2 = isTextBlock$1;
  var isBogusBr = function(node) {
    return isBr(node) && node.getAttribute("data-mce-bogus") && !node.nextSibling;
  };
  var findParentContentEditable = function(dom2, node) {
    var parent2 = node;
    while (parent2) {
      if (isElement$1(parent2) && dom2.getContentEditable(parent2)) {
        return dom2.getContentEditable(parent2) === "false" ? parent2 : node;
      }
      parent2 = parent2.parentNode;
    }
    return node;
  };
  var walkText = function(start2, node, offset, predicate) {
    var str = node.data;
    for (var i = offset; start2 ? i >= 0 : i < str.length; start2 ? i-- : i++) {
      if (predicate(str.charAt(i))) {
        return start2 ? i + 1 : i;
      }
    }
    return -1;
  };
  var findSpace = function(start2, node, offset) {
    return walkText(start2, node, offset, function(c) {
      return isNbsp(c) || isWhiteSpace$1(c);
    });
  };
  var findContent = function(start2, node, offset) {
    return walkText(start2, node, offset, isContent$1);
  };
  var findWordEndPoint = function(dom2, body, container, offset, start2, includeTrailingSpaces) {
    var lastTextNode;
    var rootNode = dom2.getParent(container, dom2.isBlock) || body;
    var walk2 = function(container2, offset2, pred) {
      var textSeeker = TextSeeker(dom2);
      var walker = start2 ? textSeeker.backwards : textSeeker.forwards;
      return Optional.from(walker(container2, offset2, function(text, textOffset) {
        if (isBookmarkNode$2(text.parentNode)) {
          return -1;
        } else {
          lastTextNode = text;
          return pred(start2, text, textOffset);
        }
      }, rootNode));
    };
    var spaceResult = walk2(container, offset, findSpace);
    return spaceResult.bind(function(result) {
      return includeTrailingSpaces ? walk2(result.container, result.offset + (start2 ? -1 : 0), findContent) : Optional.some(result);
    }).orThunk(function() {
      return lastTextNode ? Optional.some({
        container: lastTextNode,
        offset: start2 ? 0 : lastTextNode.length
      }) : Optional.none();
    });
  };
  var findSelectorEndPoint = function(dom2, format, rng, container, siblingName) {
    if (isText$1(container) && container.nodeValue.length === 0 && container[siblingName]) {
      container = container[siblingName];
    }
    var parents2 = getParents$2(dom2, container);
    for (var i = 0; i < parents2.length; i++) {
      for (var y2 = 0; y2 < format.length; y2++) {
        var curFormat = format[y2];
        if ("collapsed" in curFormat && curFormat.collapsed !== rng.collapsed) {
          continue;
        }
        if (dom2.is(parents2[i], curFormat.selector)) {
          return parents2[i];
        }
      }
    }
    return container;
  };
  var findBlockEndPoint = function(editor, format, container, siblingName) {
    var node;
    var dom2 = editor.dom;
    var root = dom2.getRoot();
    if (!format[0].wrapper) {
      node = dom2.getParent(container, format[0].block, root);
    }
    if (!node) {
      var scopeRoot = dom2.getParent(container, "LI,TD,TH");
      node = dom2.getParent(isText$1(container) ? container.parentNode : container, function(node2) {
        return node2 !== root && isTextBlock$2(editor, node2);
      }, scopeRoot);
    }
    if (node && format[0].wrapper) {
      node = getParents$2(dom2, node, "ul,ol").reverse()[0] || node;
    }
    if (!node) {
      node = container;
      while (node[siblingName] && !dom2.isBlock(node[siblingName])) {
        node = node[siblingName];
        if (isEq(node, "br")) {
          break;
        }
      }
    }
    return node || container;
  };
  var isAtBlockBoundary = function(dom2, root, container, siblingName) {
    var parent2 = container.parentNode;
    if (isNonNullable(container[siblingName])) {
      return false;
    } else if (parent2 === root || isNullable(parent2) || dom2.isBlock(parent2)) {
      return true;
    } else {
      return isAtBlockBoundary(dom2, root, parent2, siblingName);
    }
  };
  var findParentContainer = function(dom2, format, container, offset, start2) {
    var parent2 = container;
    var sibling2;
    var siblingName = start2 ? "previousSibling" : "nextSibling";
    var root = dom2.getRoot();
    if (isText$1(container) && !isWhiteSpaceNode$1(container)) {
      if (start2 ? offset > 0 : offset < container.data.length) {
        return container;
      }
    }
    while (true) {
      if (!format[0].block_expand && dom2.isBlock(parent2)) {
        return parent2;
      }
      for (sibling2 = parent2[siblingName]; sibling2; sibling2 = sibling2[siblingName]) {
        var allowSpaces = isText$1(sibling2) && !isAtBlockBoundary(dom2, root, sibling2, siblingName);
        if (!isBookmarkNode$2(sibling2) && !isBogusBr(sibling2) && !isWhiteSpaceNode$1(sibling2, allowSpaces)) {
          return parent2;
        }
      }
      if (parent2 === root || parent2.parentNode === root) {
        container = parent2;
        break;
      }
      parent2 = parent2.parentNode;
    }
    return container;
  };
  var isSelfOrParentBookmark = function(container) {
    return isBookmarkNode$2(container.parentNode) || isBookmarkNode$2(container);
  };
  var expandRng = function(editor, rng, format, includeTrailingSpace) {
    if (includeTrailingSpace === void 0) {
      includeTrailingSpace = false;
    }
    var startContainer = rng.startContainer, startOffset = rng.startOffset, endContainer = rng.endContainer, endOffset = rng.endOffset;
    var dom2 = editor.dom;
    if (isElement$1(startContainer) && startContainer.hasChildNodes()) {
      startContainer = getNode(startContainer, startOffset);
      if (isText$1(startContainer)) {
        startOffset = 0;
      }
    }
    if (isElement$1(endContainer) && endContainer.hasChildNodes()) {
      endContainer = getNode(endContainer, rng.collapsed ? endOffset : endOffset - 1);
      if (isText$1(endContainer)) {
        endOffset = endContainer.nodeValue.length;
      }
    }
    startContainer = findParentContentEditable(dom2, startContainer);
    endContainer = findParentContentEditable(dom2, endContainer);
    if (isSelfOrParentBookmark(startContainer)) {
      startContainer = isBookmarkNode$2(startContainer) ? startContainer : startContainer.parentNode;
      if (rng.collapsed) {
        startContainer = startContainer.previousSibling || startContainer;
      } else {
        startContainer = startContainer.nextSibling || startContainer;
      }
      if (isText$1(startContainer)) {
        startOffset = rng.collapsed ? startContainer.length : 0;
      }
    }
    if (isSelfOrParentBookmark(endContainer)) {
      endContainer = isBookmarkNode$2(endContainer) ? endContainer : endContainer.parentNode;
      if (rng.collapsed) {
        endContainer = endContainer.nextSibling || endContainer;
      } else {
        endContainer = endContainer.previousSibling || endContainer;
      }
      if (isText$1(endContainer)) {
        endOffset = rng.collapsed ? 0 : endContainer.length;
      }
    }
    if (rng.collapsed) {
      var startPoint = findWordEndPoint(dom2, editor.getBody(), startContainer, startOffset, true, includeTrailingSpace);
      startPoint.each(function(_a) {
        var container = _a.container, offset = _a.offset;
        startContainer = container;
        startOffset = offset;
      });
      var endPoint = findWordEndPoint(dom2, editor.getBody(), endContainer, endOffset, false, includeTrailingSpace);
      endPoint.each(function(_a) {
        var container = _a.container, offset = _a.offset;
        endContainer = container;
        endOffset = offset;
      });
    }
    if (format[0].inline || format[0].block_expand) {
      if (!format[0].inline || (!isText$1(startContainer) || startOffset === 0)) {
        startContainer = findParentContainer(dom2, format, startContainer, startOffset, true);
      }
      if (!format[0].inline || (!isText$1(endContainer) || endOffset === endContainer.nodeValue.length)) {
        endContainer = findParentContainer(dom2, format, endContainer, endOffset, false);
      }
    }
    if (format[0].selector && format[0].expand !== false && !format[0].inline) {
      startContainer = findSelectorEndPoint(dom2, format, rng, startContainer, "previousSibling");
      endContainer = findSelectorEndPoint(dom2, format, rng, endContainer, "nextSibling");
    }
    if (format[0].block || format[0].selector) {
      startContainer = findBlockEndPoint(editor, format, startContainer, "previousSibling");
      endContainer = findBlockEndPoint(editor, format, endContainer, "nextSibling");
      if (format[0].block) {
        if (!dom2.isBlock(startContainer)) {
          startContainer = findParentContainer(dom2, format, startContainer, startOffset, true);
        }
        if (!dom2.isBlock(endContainer)) {
          endContainer = findParentContainer(dom2, format, endContainer, endOffset, false);
        }
      }
    }
    if (isElement$1(startContainer)) {
      startOffset = dom2.nodeIndex(startContainer);
      startContainer = startContainer.parentNode;
    }
    if (isElement$1(endContainer)) {
      endOffset = dom2.nodeIndex(endContainer) + 1;
      endContainer = endContainer.parentNode;
    }
    return {
      startContainer,
      startOffset,
      endContainer,
      endOffset
    };
  };
  var clampToExistingChildren = function(container, index) {
    var childNodes = container.childNodes;
    if (index >= childNodes.length) {
      index = childNodes.length - 1;
    } else if (index < 0) {
      index = 0;
    }
    return childNodes[index] || container;
  };
  var getEndChild = function(container, index) {
    return clampToExistingChildren(container, index - 1);
  };
  var walk$1 = function(dom2, rng, callback) {
    var startContainer = rng.startContainer;
    var startOffset = rng.startOffset;
    var endContainer = rng.endContainer;
    var endOffset = rng.endOffset;
    var exclude = function(nodes) {
      var node2;
      node2 = nodes[0];
      if (node2.nodeType === 3 && node2 === startContainer && startOffset >= node2.nodeValue.length) {
        nodes.splice(0, 1);
      }
      node2 = nodes[nodes.length - 1];
      if (endOffset === 0 && nodes.length > 0 && node2 === endContainer && node2.nodeType === 3) {
        nodes.splice(nodes.length - 1, 1);
      }
      return nodes;
    };
    var collectSiblings = function(node2, name2, endNode) {
      var siblings3 = [];
      for (; node2 && node2 !== endNode; node2 = node2[name2]) {
        siblings3.push(node2);
      }
      return siblings3;
    };
    var findEndPoint = function(node2, root) {
      do {
        if (node2.parentNode === root) {
          return node2;
        }
        node2 = node2.parentNode;
      } while (node2);
    };
    var walkBoundary = function(startNode, endNode, next) {
      var siblingName = next ? "nextSibling" : "previousSibling";
      for (var node2 = startNode, parent_1 = node2.parentNode; node2 && node2 !== endNode; node2 = parent_1) {
        parent_1 = node2.parentNode;
        var siblings_1 = collectSiblings(node2 === startNode ? node2 : node2[siblingName], siblingName);
        if (siblings_1.length) {
          if (!next) {
            siblings_1.reverse();
          }
          callback(exclude(siblings_1));
        }
      }
    };
    if (startContainer.nodeType === 1 && startContainer.hasChildNodes()) {
      startContainer = clampToExistingChildren(startContainer, startOffset);
    }
    if (endContainer.nodeType === 1 && endContainer.hasChildNodes()) {
      endContainer = getEndChild(endContainer, endOffset);
    }
    if (startContainer === endContainer) {
      return callback(exclude([startContainer]));
    }
    var ancestor2 = dom2.findCommonAncestor(startContainer, endContainer);
    for (var node = startContainer; node; node = node.parentNode) {
      if (node === endContainer) {
        return walkBoundary(startContainer, ancestor2, true);
      }
      if (node === ancestor2) {
        break;
      }
    }
    for (var node = endContainer; node; node = node.parentNode) {
      if (node === startContainer) {
        return walkBoundary(endContainer, ancestor2);
      }
      if (node === ancestor2) {
        break;
      }
    }
    var startPoint = findEndPoint(startContainer, ancestor2) || startContainer;
    var endPoint = findEndPoint(endContainer, ancestor2) || endContainer;
    walkBoundary(startContainer, startPoint, true);
    var siblings2 = collectSiblings(startPoint === startContainer ? startPoint : startPoint.nextSibling, "nextSibling", endPoint === endContainer ? endPoint.nextSibling : endPoint);
    if (siblings2.length) {
      callback(exclude(siblings2));
    }
    walkBoundary(endContainer, endPoint);
  };
  var getRanges = function(selection) {
    var ranges = [];
    if (selection) {
      for (var i = 0; i < selection.rangeCount; i++) {
        ranges.push(selection.getRangeAt(i));
      }
    }
    return ranges;
  };
  var getSelectedNodes = function(ranges) {
    return bind(ranges, function(range2) {
      var node = getSelectedNode(range2);
      return node ? [SugarElement.fromDom(node)] : [];
    });
  };
  var hasMultipleRanges = function(selection) {
    return getRanges(selection).length > 1;
  };
  var getCellsFromRanges = function(ranges) {
    return filter(getSelectedNodes(ranges), isTableCell$1);
  };
  var getCellsFromElement = function(elm) {
    return descendants$1(elm, "td[data-mce-selected],th[data-mce-selected]");
  };
  var getCellsFromElementOrRanges = function(ranges, element) {
    var selectedCells = getCellsFromElement(element);
    return selectedCells.length > 0 ? selectedCells : getCellsFromRanges(ranges);
  };
  var getCellsFromEditor = function(editor) {
    return getCellsFromElementOrRanges(getRanges(editor.selection.getSel()), SugarElement.fromDom(editor.getBody()));
  };
  var getStartNode = function(rng) {
    var sc2 = rng.startContainer, so = rng.startOffset;
    if (isText$1(sc2)) {
      return so === 0 ? Optional.some(SugarElement.fromDom(sc2)) : Optional.none();
    } else {
      return Optional.from(sc2.childNodes[so]).map(SugarElement.fromDom);
    }
  };
  var getEndNode = function(rng) {
    var ec2 = rng.endContainer, eo = rng.endOffset;
    if (isText$1(ec2)) {
      return eo === ec2.data.length ? Optional.some(SugarElement.fromDom(ec2)) : Optional.none();
    } else {
      return Optional.from(ec2.childNodes[eo - 1]).map(SugarElement.fromDom);
    }
  };
  var getFirstChildren = function(node) {
    return firstChild(node).fold(constant([node]), function(child2) {
      return [node].concat(getFirstChildren(child2));
    });
  };
  var getLastChildren = function(node) {
    return lastChild(node).fold(constant([node]), function(child2) {
      if (name(child2) === "br") {
        return prevSibling(child2).map(function(sibling2) {
          return [node].concat(getLastChildren(sibling2));
        }).getOr([]);
      } else {
        return [node].concat(getLastChildren(child2));
      }
    });
  };
  var hasAllContentsSelected = function(elm, rng) {
    return lift2(getStartNode(rng), getEndNode(rng), function(startNode, endNode) {
      var start2 = find(getFirstChildren(elm), curry(eq$2, startNode));
      var end2 = find(getLastChildren(elm), curry(eq$2, endNode));
      return start2.isSome() && end2.isSome();
    }).getOr(false);
  };
  var moveEndPoint$1 = function(dom2, rng, node, start2) {
    var root = node, walker = new DomTreeWalker(node, root);
    var moveCaretBeforeOnEnterElementsMap = filter$1(dom2.schema.getMoveCaretBeforeOnEnterElements(), function(_, name2) {
      return !contains([
        "td",
        "th",
        "table"
      ], name2.toLowerCase());
    });
    do {
      if (isText$1(node) && Tools.trim(node.nodeValue).length !== 0) {
        if (start2) {
          rng.setStart(node, 0);
        } else {
          rng.setEnd(node, node.nodeValue.length);
        }
        return;
      }
      if (moveCaretBeforeOnEnterElementsMap[node.nodeName]) {
        if (start2) {
          rng.setStartBefore(node);
        } else {
          if (node.nodeName === "BR") {
            rng.setEndBefore(node);
          } else {
            rng.setEndAfter(node);
          }
        }
        return;
      }
    } while (node = start2 ? walker.next() : walker.prev());
    if (root.nodeName === "BODY") {
      if (start2) {
        rng.setStart(root, 0);
      } else {
        rng.setEnd(root, root.childNodes.length);
      }
    }
  };
  var hasAnyRanges = function(editor) {
    var sel = editor.selection.getSel();
    return sel && sel.rangeCount > 0;
  };
  var runOnRanges = function(editor, executor) {
    var fakeSelectionNodes = getCellsFromEditor(editor);
    if (fakeSelectionNodes.length > 0) {
      each(fakeSelectionNodes, function(elem) {
        var node = elem.dom;
        var fakeNodeRng = editor.dom.createRng();
        fakeNodeRng.setStartBefore(node);
        fakeNodeRng.setEndAfter(node);
        executor(fakeNodeRng, true);
      });
    } else {
      executor(editor.selection.getRng(), false);
    }
  };
  var preserve = function(selection, fillBookmark, executor) {
    var bookmark = getPersistentBookmark(selection, fillBookmark);
    executor(bookmark);
    selection.moveToBookmark(bookmark);
  };
  var NodeValue = function(is2, name2) {
    var get2 = function(element) {
      if (!is2(element)) {
        throw new Error("Can only get " + name2 + " value of a " + name2 + " node");
      }
      return getOption(element).getOr("");
    };
    var getOption = function(element) {
      return is2(element) ? Optional.from(element.dom.nodeValue) : Optional.none();
    };
    var set2 = function(element, value2) {
      if (!is2(element)) {
        throw new Error("Can only set raw " + name2 + " value of a " + name2 + " node");
      }
      element.dom.nodeValue = value2;
    };
    return {
      get: get2,
      getOption,
      set: set2
    };
  };
  var api = NodeValue(isText, "text");
  var get$8 = function(element) {
    return api.get(element);
  };
  var isZeroWidth = function(elem) {
    return isText(elem) && get$8(elem) === ZWSP;
  };
  var context = function(editor, elem, wrapName, nodeName) {
    return parent(elem).fold(function() {
      return "skipping";
    }, function(parent2) {
      if (nodeName === "br" || isZeroWidth(elem)) {
        return "valid";
      } else if (isAnnotation(elem)) {
        return "existing";
      } else if (isCaretNode(elem.dom)) {
        return "caret";
      } else if (!isValid(editor, wrapName, nodeName) || !isValid(editor, name(parent2), wrapName)) {
        return "invalid-child";
      } else {
        return "valid";
      }
    });
  };
  var applyWordGrab = function(editor, rng) {
    var r3 = expandRng(editor, rng, [{ inline: true }]);
    rng.setStart(r3.startContainer, r3.startOffset);
    rng.setEnd(r3.endContainer, r3.endOffset);
    editor.selection.setRng(rng);
  };
  var makeAnnotation = function(eDoc, _a, annotationName, decorate) {
    var _b = _a.uid, uid = _b === void 0 ? generate$1("mce-annotation") : _b, data2 = __rest(_a, ["uid"]);
    var master = SugarElement.fromTag("span", eDoc);
    add$3(master, annotation());
    set(master, "" + dataAnnotationId(), uid);
    set(master, "" + dataAnnotation(), annotationName);
    var _c = decorate(uid, data2), _d = _c.attributes, attributes2 = _d === void 0 ? {} : _d, _e = _c.classes, classes = _e === void 0 ? [] : _e;
    setAll(master, attributes2);
    add$4(master, classes);
    return master;
  };
  var annotate = function(editor, rng, annotationName, decorate, data2) {
    var newWrappers = [];
    var master = makeAnnotation(editor.getDoc(), data2, annotationName, decorate);
    var wrapper = Cell(Optional.none());
    var finishWrapper = function() {
      wrapper.set(Optional.none());
    };
    var getOrOpenWrapper = function() {
      return wrapper.get().getOrThunk(function() {
        var nu2 = shallow(master);
        newWrappers.push(nu2);
        wrapper.set(Optional.some(nu2));
        return nu2;
      });
    };
    var processElements = function(elems) {
      each(elems, processElement);
    };
    var processElement = function(elem) {
      var ctx = context(editor, elem, "span", name(elem));
      switch (ctx) {
        case "invalid-child": {
          finishWrapper();
          var children$1 = children(elem);
          processElements(children$1);
          finishWrapper();
          break;
        }
        case "valid": {
          var w = getOrOpenWrapper();
          wrap(elem, w);
          break;
        }
      }
    };
    var processNodes = function(nodes) {
      var elems = map(nodes, SugarElement.fromDom);
      processElements(elems);
    };
    walk$1(editor.dom, rng, function(nodes) {
      finishWrapper();
      processNodes(nodes);
    });
    return newWrappers;
  };
  var annotateWithBookmark = function(editor, name2, settings, data2) {
    editor.undoManager.transact(function() {
      var selection = editor.selection;
      var initialRng = selection.getRng();
      var hasFakeSelection = getCellsFromEditor(editor).length > 0;
      if (initialRng.collapsed && !hasFakeSelection) {
        applyWordGrab(editor, initialRng);
      }
      if (selection.getRng().collapsed && !hasFakeSelection) {
        var wrapper = makeAnnotation(editor.getDoc(), data2, name2, settings.decorate);
        set$1(wrapper, nbsp);
        selection.getRng().insertNode(wrapper.dom);
        selection.select(wrapper.dom);
      } else {
        preserve(selection, false, function() {
          runOnRanges(editor, function(selectionRng) {
            annotate(editor, selectionRng, name2, settings.decorate, data2);
          });
        });
      }
    });
  };
  var Annotator = function(editor) {
    var registry2 = create$2();
    setup$1(editor, registry2);
    var changes = setup(editor);
    return {
      register: function(name2, settings) {
        registry2.register(name2, settings);
      },
      annotate: function(name2, data2) {
        registry2.lookup(name2).each(function(settings) {
          annotateWithBookmark(editor, name2, settings, data2);
        });
      },
      annotationChanged: function(name2, callback) {
        changes.addListener(name2, callback);
      },
      remove: function(name2) {
        identify(editor, Optional.some(name2)).each(function(_a) {
          var elements = _a.elements;
          each(elements, unwrap);
        });
      },
      getAll: function(name2) {
        var directory = findAll(editor, name2);
        return map$1(directory, function(elems) {
          return map(elems, function(elem) {
            return elem.dom;
          });
        });
      }
    };
  };
  var BookmarkManager = function(selection) {
    return {
      getBookmark: curry(getBookmark$1, selection),
      moveToBookmark: curry(moveToBookmark, selection)
    };
  };
  BookmarkManager.isBookmarkNode = isBookmarkNode$1;
  var getContentEditableRoot = function(root, node) {
    while (node && node !== root) {
      if (isContentEditableTrue(node) || isContentEditableFalse(node)) {
        return node;
      }
      node = node.parentNode;
    }
    return null;
  };
  var isXYWithinRange = function(clientX, clientY, range2) {
    if (range2.collapsed) {
      return false;
    }
    if (Env.browser.isIE() && range2.startOffset === range2.endOffset - 1 && range2.startContainer === range2.endContainer) {
      var elm = range2.startContainer.childNodes[range2.startOffset];
      if (isElement$1(elm)) {
        return exists(elm.getClientRects(), function(rect) {
          return containsXY(rect, clientX, clientY);
        });
      }
    }
    return exists(range2.getClientRects(), function(rect) {
      return containsXY(rect, clientX, clientY);
    });
  };
  var firePreProcess = function(editor, args) {
    return editor.fire("PreProcess", args);
  };
  var firePostProcess = function(editor, args) {
    return editor.fire("PostProcess", args);
  };
  var fireRemove = function(editor) {
    return editor.fire("remove");
  };
  var fireDetach = function(editor) {
    return editor.fire("detach");
  };
  var fireSwitchMode = function(editor, mode) {
    return editor.fire("SwitchMode", { mode });
  };
  var fireObjectResizeStart = function(editor, target, width, height, origin) {
    editor.fire("ObjectResizeStart", {
      target,
      width,
      height,
      origin
    });
  };
  var fireObjectResized = function(editor, target, width, height, origin) {
    editor.fire("ObjectResized", {
      target,
      width,
      height,
      origin
    });
  };
  var firePreInit = function(editor) {
    return editor.fire("PreInit");
  };
  var firePostRender = function(editor) {
    return editor.fire("PostRender");
  };
  var fireInit = function(editor) {
    return editor.fire("Init");
  };
  var firePlaceholderToggle = function(editor, state) {
    return editor.fire("PlaceholderToggle", { state });
  };
  var fireError = function(editor, errorType, error2) {
    return editor.fire(errorType, error2);
  };
  var VK = {
    BACKSPACE: 8,
    DELETE: 46,
    DOWN: 40,
    ENTER: 13,
    LEFT: 37,
    RIGHT: 39,
    SPACEBAR: 32,
    TAB: 9,
    UP: 38,
    PAGE_UP: 33,
    PAGE_DOWN: 34,
    END: 35,
    HOME: 36,
    modifierPressed: function(e) {
      return e.shiftKey || e.ctrlKey || e.altKey || VK.metaKeyPressed(e);
    },
    metaKeyPressed: function(e) {
      return Env.mac ? e.metaKey : e.ctrlKey && !e.altKey;
    }
  };
  var isContentEditableFalse$6 = isContentEditableFalse;
  var ControlSelection = function(selection, editor) {
    var elementSelectionAttr = "data-mce-selected";
    var dom2 = editor.dom, each$22 = Tools.each;
    var selectedElm, selectedElmGhost, resizeHelper, selectedHandle, resizeBackdrop;
    var startX, startY, selectedElmX, selectedElmY, startW, startH, ratio, resizeStarted;
    var width, height;
    var editableDoc = editor.getDoc(), rootDocument = document;
    var abs = Math.abs, round2 = Math.round, rootElement = editor.getBody();
    var startScrollWidth, startScrollHeight;
    var resizeHandles = {
      nw: [
        0,
        0,
        -1,
        -1
      ],
      ne: [
        1,
        0,
        1,
        -1
      ],
      se: [
        1,
        1,
        1,
        1
      ],
      sw: [
        0,
        1,
        -1,
        1
      ]
    };
    var isImage = function(elm) {
      return elm && (elm.nodeName === "IMG" || editor.dom.is(elm, "figure.image"));
    };
    var isMedia$12 = function(elm) {
      return isMedia(elm) || dom2.hasClass(elm, "mce-preview-object");
    };
    var isEventOnImageOutsideRange = function(evt, range2) {
      if (evt.type === "longpress" || evt.type.indexOf("touch") === 0) {
        var touch = evt.touches[0];
        return isImage(evt.target) && !isXYWithinRange(touch.clientX, touch.clientY, range2);
      } else {
        return isImage(evt.target) && !isXYWithinRange(evt.clientX, evt.clientY, range2);
      }
    };
    var contextMenuSelectImage = function(evt) {
      var target = evt.target;
      if (isEventOnImageOutsideRange(evt, editor.selection.getRng()) && !evt.isDefaultPrevented()) {
        editor.selection.select(target);
      }
    };
    var getResizeTargets = function(elm) {
      if (dom2.is(elm, "figure.image")) {
        return [elm.querySelector("img")];
      } else if (dom2.hasClass(elm, "mce-preview-object") && isNonNullable(elm.firstElementChild)) {
        return [
          elm,
          elm.firstElementChild
        ];
      } else {
        return [elm];
      }
    };
    var isResizable = function(elm) {
      var selector = getObjectResizing(editor);
      if (!selector) {
        return false;
      }
      if (elm.getAttribute("data-mce-resize") === "false") {
        return false;
      }
      if (elm === editor.getBody()) {
        return false;
      }
      if (dom2.hasClass(elm, "mce-preview-object")) {
        return is$1(SugarElement.fromDom(elm.firstElementChild), selector);
      } else {
        return is$1(SugarElement.fromDom(elm), selector);
      }
    };
    var createGhostElement = function(elm) {
      if (isMedia$12(elm)) {
        return dom2.create("img", { src: Env.transparentSrc });
      } else {
        return elm.cloneNode(true);
      }
    };
    var setSizeProp = function(element, name2, value2) {
      if (isNonNullable(value2)) {
        var targets = getResizeTargets(element);
        each(targets, function(target) {
          if (target.style[name2] || !editor.schema.isValid(target.nodeName.toLowerCase(), name2)) {
            dom2.setStyle(target, name2, value2);
          } else {
            dom2.setAttrib(target, name2, "" + value2);
          }
        });
      }
    };
    var setGhostElmSize = function(ghostElm, width2, height2) {
      setSizeProp(ghostElm, "width", width2);
      setSizeProp(ghostElm, "height", height2);
    };
    var resizeGhostElement = function(e) {
      var deltaX, deltaY, proportional;
      var resizeHelperX, resizeHelperY;
      deltaX = e.screenX - startX;
      deltaY = e.screenY - startY;
      width = deltaX * selectedHandle[2] + startW;
      height = deltaY * selectedHandle[3] + startH;
      width = width < 5 ? 5 : width;
      height = height < 5 ? 5 : height;
      if ((isImage(selectedElm) || isMedia$12(selectedElm)) && getResizeImgProportional(editor) !== false) {
        proportional = !VK.modifierPressed(e);
      } else {
        proportional = VK.modifierPressed(e);
      }
      if (proportional) {
        if (abs(deltaX) > abs(deltaY)) {
          height = round2(width * ratio);
          width = round2(height / ratio);
        } else {
          width = round2(height / ratio);
          height = round2(width * ratio);
        }
      }
      setGhostElmSize(selectedElmGhost, width, height);
      resizeHelperX = selectedHandle.startPos.x + deltaX;
      resizeHelperY = selectedHandle.startPos.y + deltaY;
      resizeHelperX = resizeHelperX > 0 ? resizeHelperX : 0;
      resizeHelperY = resizeHelperY > 0 ? resizeHelperY : 0;
      dom2.setStyles(resizeHelper, {
        left: resizeHelperX,
        top: resizeHelperY,
        display: "block"
      });
      resizeHelper.innerHTML = width + " &times; " + height;
      if (selectedHandle[2] < 0 && selectedElmGhost.clientWidth <= width) {
        dom2.setStyle(selectedElmGhost, "left", selectedElmX + (startW - width));
      }
      if (selectedHandle[3] < 0 && selectedElmGhost.clientHeight <= height) {
        dom2.setStyle(selectedElmGhost, "top", selectedElmY + (startH - height));
      }
      deltaX = rootElement.scrollWidth - startScrollWidth;
      deltaY = rootElement.scrollHeight - startScrollHeight;
      if (deltaX + deltaY !== 0) {
        dom2.setStyles(resizeHelper, {
          left: resizeHelperX - deltaX,
          top: resizeHelperY - deltaY
        });
      }
      if (!resizeStarted) {
        fireObjectResizeStart(editor, selectedElm, startW, startH, "corner-" + selectedHandle.name);
        resizeStarted = true;
      }
    };
    var endGhostResize = function() {
      var wasResizeStarted = resizeStarted;
      resizeStarted = false;
      if (wasResizeStarted) {
        setSizeProp(selectedElm, "width", width);
        setSizeProp(selectedElm, "height", height);
      }
      dom2.unbind(editableDoc, "mousemove", resizeGhostElement);
      dom2.unbind(editableDoc, "mouseup", endGhostResize);
      if (rootDocument !== editableDoc) {
        dom2.unbind(rootDocument, "mousemove", resizeGhostElement);
        dom2.unbind(rootDocument, "mouseup", endGhostResize);
      }
      dom2.remove(selectedElmGhost);
      dom2.remove(resizeHelper);
      dom2.remove(resizeBackdrop);
      showResizeRect(selectedElm);
      if (wasResizeStarted) {
        fireObjectResized(editor, selectedElm, width, height, "corner-" + selectedHandle.name);
        dom2.setAttrib(selectedElm, "style", dom2.getAttrib(selectedElm, "style"));
      }
      editor.nodeChanged();
    };
    var showResizeRect = function(targetElm) {
      unbindResizeHandleEvents();
      var position = dom2.getPos(targetElm, rootElement);
      var selectedElmX2 = position.x;
      var selectedElmY2 = position.y;
      var rect = targetElm.getBoundingClientRect();
      var targetWidth = rect.width || rect.right - rect.left;
      var targetHeight = rect.height || rect.bottom - rect.top;
      if (selectedElm !== targetElm) {
        hideResizeRect();
        selectedElm = targetElm;
        width = height = 0;
      }
      var e = editor.fire("ObjectSelected", { target: targetElm });
      var selectedValue = dom2.getAttrib(selectedElm, elementSelectionAttr, "1");
      if (isResizable(targetElm) && !e.isDefaultPrevented()) {
        each$22(resizeHandles, function(handle2, name2) {
          var handleElm;
          var startDrag = function(e2) {
            var target = getResizeTargets(selectedElm)[0];
            startX = e2.screenX;
            startY = e2.screenY;
            startW = target.clientWidth;
            startH = target.clientHeight;
            ratio = startH / startW;
            selectedHandle = handle2;
            selectedHandle.name = name2;
            selectedHandle.startPos = {
              x: targetWidth * handle2[0] + selectedElmX2,
              y: targetHeight * handle2[1] + selectedElmY2
            };
            startScrollWidth = rootElement.scrollWidth;
            startScrollHeight = rootElement.scrollHeight;
            resizeBackdrop = dom2.add(rootElement, "div", { class: "mce-resize-backdrop" });
            dom2.setStyles(resizeBackdrop, {
              position: "fixed",
              left: "0",
              top: "0",
              width: "100%",
              height: "100%"
            });
            selectedElmGhost = createGhostElement(selectedElm);
            dom2.addClass(selectedElmGhost, "mce-clonedresizable");
            dom2.setAttrib(selectedElmGhost, "data-mce-bogus", "all");
            selectedElmGhost.contentEditable = "false";
            dom2.setStyles(selectedElmGhost, {
              left: selectedElmX2,
              top: selectedElmY2,
              margin: 0
            });
            setGhostElmSize(selectedElmGhost, targetWidth, targetHeight);
            selectedElmGhost.removeAttribute(elementSelectionAttr);
            rootElement.appendChild(selectedElmGhost);
            dom2.bind(editableDoc, "mousemove", resizeGhostElement);
            dom2.bind(editableDoc, "mouseup", endGhostResize);
            if (rootDocument !== editableDoc) {
              dom2.bind(rootDocument, "mousemove", resizeGhostElement);
              dom2.bind(rootDocument, "mouseup", endGhostResize);
            }
            resizeHelper = dom2.add(rootElement, "div", {
              "class": "mce-resize-helper",
              "data-mce-bogus": "all"
            }, startW + " &times; " + startH);
          };
          handleElm = dom2.get("mceResizeHandle" + name2);
          if (handleElm) {
            dom2.remove(handleElm);
          }
          handleElm = dom2.add(rootElement, "div", {
            "id": "mceResizeHandle" + name2,
            "data-mce-bogus": "all",
            "class": "mce-resizehandle",
            "unselectable": true,
            "style": "cursor:" + name2 + "-resize; margin:0; padding:0"
          });
          if (Env.ie === 11) {
            handleElm.contentEditable = false;
          }
          dom2.bind(handleElm, "mousedown", function(e2) {
            e2.stopImmediatePropagation();
            e2.preventDefault();
            startDrag(e2);
          });
          handle2.elm = handleElm;
          dom2.setStyles(handleElm, {
            left: targetWidth * handle2[0] + selectedElmX2 - handleElm.offsetWidth / 2,
            top: targetHeight * handle2[1] + selectedElmY2 - handleElm.offsetHeight / 2
          });
        });
      } else {
        hideResizeRect();
      }
      if (!dom2.getAttrib(selectedElm, elementSelectionAttr)) {
        selectedElm.setAttribute(elementSelectionAttr, selectedValue);
      }
    };
    var hideResizeRect = function() {
      unbindResizeHandleEvents();
      if (selectedElm) {
        selectedElm.removeAttribute(elementSelectionAttr);
      }
      each$1(resizeHandles, function(value2, name2) {
        var handleElm = dom2.get("mceResizeHandle" + name2);
        if (handleElm) {
          dom2.unbind(handleElm);
          dom2.remove(handleElm);
        }
      });
    };
    var updateResizeRect = function(e) {
      var startElm, controlElm;
      var isChildOrEqual = function(node, parent2) {
        if (node) {
          do {
            if (node === parent2) {
              return true;
            }
          } while (node = node.parentNode);
        }
      };
      if (resizeStarted || editor.removed) {
        return;
      }
      each$22(dom2.select("img[data-mce-selected],hr[data-mce-selected]"), function(img) {
        img.removeAttribute(elementSelectionAttr);
      });
      controlElm = e.type === "mousedown" ? e.target : selection.getNode();
      controlElm = dom2.$(controlElm).closest("table,img,figure.image,hr,video,tp-tabs,tp-collapse,tp-buttons,span.mce-preview-object")[0];
      if (isChildOrEqual(controlElm, rootElement)) {
        disableGeckoResize();
        startElm = selection.getStart(true);
        if (isChildOrEqual(startElm, controlElm) && isChildOrEqual(selection.getEnd(true), controlElm)) {
          showResizeRect(controlElm);
          return;
        }
      }
      hideResizeRect();
    };
    var isWithinContentEditableFalse = function(elm) {
      return isContentEditableFalse$6(getContentEditableRoot(editor.getBody(), elm));
    };
    var unbindResizeHandleEvents = function() {
      each$1(resizeHandles, function(handle2) {
        if (handle2.elm) {
          dom2.unbind(handle2.elm);
          delete handle2.elm;
        }
      });
    };
    var disableGeckoResize = function() {
      try {
        editor.getDoc().execCommand("enableObjectResizing", false, "false");
      } catch (ex) {
      }
    };
    editor.on("init", function() {
      disableGeckoResize();
      if (Env.browser.isIE() || Env.browser.isEdge()) {
        editor.on("mousedown click", function(e) {
          var target = e.target, nodeName = target.nodeName;
          if (!resizeStarted && /^(TABLE|IMG|HR)$/.test(nodeName) && !isWithinContentEditableFalse(target)) {
            if (e.button !== 2) {
              editor.selection.select(target, nodeName === "TABLE");
            }
            if (e.type === "mousedown") {
              editor.nodeChanged();
            }
          }
        });
        var handleMSControlSelect_1 = function(e) {
          var delayedSelect = function(node) {
            Delay.setEditorTimeout(editor, function() {
              return editor.selection.select(node);
            });
          };
          if (isWithinContentEditableFalse(e.target) || isMedia(e.target)) {
            e.preventDefault();
            delayedSelect(e.target);
            return;
          }
          if (/^(TABLE|IMG|HR)$/.test(e.target.nodeName)) {
            e.preventDefault();
            if (e.target.tagName === "IMG") {
              delayedSelect(e.target);
            }
          }
        };
        dom2.bind(rootElement, "mscontrolselect", handleMSControlSelect_1);
        editor.on("remove", function() {
          return dom2.unbind(rootElement, "mscontrolselect", handleMSControlSelect_1);
        });
      }
      var throttledUpdateResizeRect = Delay.throttle(function(e) {
        if (!editor.composing) {
          updateResizeRect(e);
        }
      });
      editor.on("nodechange ResizeEditor ResizeWindow ResizeContent drop FullscreenStateChanged", throttledUpdateResizeRect);
      editor.on("keyup compositionend", function(e) {
        if (selectedElm && selectedElm.nodeName === "TABLE") {
          throttledUpdateResizeRect(e);
        }
      });
      editor.on("hide blur", hideResizeRect);
      editor.on("contextmenu longpress", contextMenuSelectImage, true);
    });
    editor.on("remove", unbindResizeHandleEvents);
    var destroy2 = function() {
      selectedElm = selectedElmGhost = resizeBackdrop = null;
    };
    return {
      isResizable,
      showResizeRect,
      hideResizeRect,
      updateResizeRect,
      destroy: destroy2
    };
  };
  var hasCeProperty = function(node) {
    return isContentEditableTrue(node) || isContentEditableFalse(node);
  };
  var findParent = function(node, rootNode, predicate) {
    while (node && node !== rootNode) {
      if (predicate(node)) {
        return node;
      }
      node = node.parentNode;
    }
    return null;
  };
  var findClosestIeRange = function(clientX, clientY, doc2) {
    var rects;
    var element = doc2.elementFromPoint(clientX, clientY);
    var rng = doc2.body.createTextRange();
    if (!element || element.tagName === "HTML") {
      element = doc2.body;
    }
    rng.moveToElementText(element);
    rects = Tools.toArray(rng.getClientRects());
    rects = rects.sort(function(a, b) {
      a = Math.abs(Math.max(a.top - clientY, a.bottom - clientY));
      b = Math.abs(Math.max(b.top - clientY, b.bottom - clientY));
      return a - b;
    });
    if (rects.length > 0) {
      clientY = (rects[0].bottom + rects[0].top) / 2;
      try {
        rng.moveToPoint(clientX, clientY);
        rng.collapse(true);
        return rng;
      } catch (ex) {
      }
    }
    return null;
  };
  var moveOutOfContentEditableFalse = function(rng, rootNode) {
    var parentElement = rng && rng.parentElement ? rng.parentElement() : null;
    return isContentEditableFalse(findParent(parentElement, rootNode, hasCeProperty)) ? null : rng;
  };
  var fromPoint$1 = function(clientX, clientY, doc2) {
    var rng, point;
    var pointDoc = doc2;
    if (pointDoc.caretPositionFromPoint) {
      point = pointDoc.caretPositionFromPoint(clientX, clientY);
      if (point) {
        rng = doc2.createRange();
        rng.setStart(point.offsetNode, point.offset);
        rng.collapse(true);
      }
    } else if (doc2.caretRangeFromPoint) {
      rng = doc2.caretRangeFromPoint(clientX, clientY);
    } else if (pointDoc.body.createTextRange) {
      rng = pointDoc.body.createTextRange();
      try {
        rng.moveToPoint(clientX, clientY);
        rng.collapse(true);
      } catch (ex) {
        rng = findClosestIeRange(clientX, clientY, doc2);
      }
      return moveOutOfContentEditableFalse(rng, doc2.body);
    }
    return rng;
  };
  var isEq$1 = function(rng1, rng2) {
    return rng1 && rng2 && (rng1.startContainer === rng2.startContainer && rng1.startOffset === rng2.startOffset) && (rng1.endContainer === rng2.endContainer && rng1.endOffset === rng2.endOffset);
  };
  var findParent$1 = function(node, rootNode, predicate) {
    while (node && node !== rootNode) {
      if (predicate(node)) {
        return node;
      }
      node = node.parentNode;
    }
    return null;
  };
  var hasParent = function(node, rootNode, predicate) {
    return findParent$1(node, rootNode, predicate) !== null;
  };
  var hasParentWithName = function(node, rootNode, name2) {
    return hasParent(node, rootNode, function(node2) {
      return node2.nodeName === name2;
    });
  };
  var isTable$3 = function(node) {
    return node && node.nodeName === "TABLE";
  };
  var isTableCell$3 = function(node) {
    return node && /^(TD|TH|CAPTION)$/.test(node.nodeName);
  };
  var isCeFalseCaretContainer = function(node, rootNode) {
    return isCaretContainer(node) && hasParent(node, rootNode, isCaretNode) === false;
  };
  var hasBrBeforeAfter = function(dom2, node, left) {
    var walker = new DomTreeWalker(node, dom2.getParent(node.parentNode, dom2.isBlock) || dom2.getRoot());
    while (node = walker[left ? "prev" : "next"]()) {
      if (isBr(node)) {
        return true;
      }
    }
  };
  var isPrevNode = function(node, name2) {
    return node.previousSibling && node.previousSibling.nodeName === name2;
  };
  var hasContentEditableFalseParent = function(body, node) {
    while (node && node !== body) {
      if (isContentEditableFalse(node)) {
        return true;
      }
      node = node.parentNode;
    }
    return false;
  };
  var findTextNodeRelative = function(dom2, isAfterNode, collapsed, left, startNode) {
    var lastInlineElement;
    var body = dom2.getRoot();
    var node;
    var nonEmptyElementsMap = dom2.schema.getNonEmptyElements();
    var parentBlockContainer = dom2.getParent(startNode.parentNode, dom2.isBlock) || body;
    if (left && isBr(startNode) && isAfterNode && dom2.isEmpty(parentBlockContainer)) {
      return Optional.some(CaretPosition(startNode.parentNode, dom2.nodeIndex(startNode)));
    }
    var walker = new DomTreeWalker(startNode, parentBlockContainer);
    while (node = walker[left ? "prev" : "next"]()) {
      if (dom2.getContentEditableParent(node) === "false" || isCeFalseCaretContainer(node, body)) {
        return Optional.none();
      }
      if (isText$1(node) && node.nodeValue.length > 0) {
        if (hasParentWithName(node, body, "A") === false) {
          return Optional.some(CaretPosition(node, left ? node.nodeValue.length : 0));
        }
        return Optional.none();
      }
      if (dom2.isBlock(node) || nonEmptyElementsMap[node.nodeName.toLowerCase()]) {
        return Optional.none();
      }
      lastInlineElement = node;
    }
    if (collapsed && lastInlineElement) {
      return Optional.some(CaretPosition(lastInlineElement, 0));
    }
    return Optional.none();
  };
  var normalizeEndPoint = function(dom2, collapsed, start2, rng) {
    var container, offset;
    var body = dom2.getRoot();
    var node;
    var directionLeft, normalized = false;
    container = rng[(start2 ? "start" : "end") + "Container"];
    offset = rng[(start2 ? "start" : "end") + "Offset"];
    var isAfterNode = isElement$1(container) && offset === container.childNodes.length;
    var nonEmptyElementsMap = dom2.schema.getNonEmptyElements();
    directionLeft = start2;
    if (isCaretContainer(container)) {
      return Optional.none();
    }
    if (isElement$1(container) && offset > container.childNodes.length - 1) {
      directionLeft = false;
    }
    if (isDocument$1(container)) {
      container = body;
      offset = 0;
    }
    if (container === body) {
      if (directionLeft) {
        node = container.childNodes[offset > 0 ? offset - 1 : 0];
        if (node) {
          if (isCaretContainer(node)) {
            return Optional.none();
          }
          if (nonEmptyElementsMap[node.nodeName] || isTable$3(node)) {
            return Optional.none();
          }
        }
      }
      if (container.hasChildNodes()) {
        offset = Math.min(!directionLeft && offset > 0 ? offset - 1 : offset, container.childNodes.length - 1);
        container = container.childNodes[offset];
        offset = isText$1(container) && isAfterNode ? container.data.length : 0;
        if (!collapsed && container === body.lastChild && isTable$3(container)) {
          return Optional.none();
        }
        if (hasContentEditableFalseParent(body, container) || isCaretContainer(container)) {
          return Optional.none();
        }
        if (container.hasChildNodes() && isTable$3(container) === false) {
          node = container;
          var walker = new DomTreeWalker(container, body);
          do {
            if (isContentEditableFalse(node) || isCaretContainer(node)) {
              normalized = false;
              break;
            }
            if (isText$1(node) && node.nodeValue.length > 0) {
              offset = directionLeft ? 0 : node.nodeValue.length;
              container = node;
              normalized = true;
              break;
            }
            if (nonEmptyElementsMap[node.nodeName.toLowerCase()] && !isTableCell$3(node)) {
              offset = dom2.nodeIndex(node);
              container = node.parentNode;
              if (!directionLeft) {
                offset++;
              }
              normalized = true;
              break;
            }
          } while (node = directionLeft ? walker.next() : walker.prev());
        }
      }
    }
    if (collapsed) {
      if (isText$1(container) && offset === 0) {
        findTextNodeRelative(dom2, isAfterNode, collapsed, true, container).each(function(pos) {
          container = pos.container();
          offset = pos.offset();
          normalized = true;
        });
      }
      if (isElement$1(container)) {
        node = container.childNodes[offset];
        if (!node) {
          node = container.childNodes[offset - 1];
        }
        if (node && isBr(node) && !isPrevNode(node, "A") && !hasBrBeforeAfter(dom2, node, false) && !hasBrBeforeAfter(dom2, node, true)) {
          findTextNodeRelative(dom2, isAfterNode, collapsed, true, node).each(function(pos) {
            container = pos.container();
            offset = pos.offset();
            normalized = true;
          });
        }
      }
    }
    if (directionLeft && !collapsed && isText$1(container) && offset === container.nodeValue.length) {
      findTextNodeRelative(dom2, isAfterNode, collapsed, false, container).each(function(pos) {
        container = pos.container();
        offset = pos.offset();
        normalized = true;
      });
    }
    return normalized ? Optional.some(CaretPosition(container, offset)) : Optional.none();
  };
  var normalize = function(dom2, rng) {
    var collapsed = rng.collapsed, normRng = rng.cloneRange();
    var startPos = CaretPosition.fromRangeStart(rng);
    normalizeEndPoint(dom2, collapsed, true, normRng).each(function(pos) {
      if (!collapsed || !CaretPosition.isAbove(startPos, pos)) {
        normRng.setStart(pos.container(), pos.offset());
      }
    });
    if (!collapsed) {
      normalizeEndPoint(dom2, collapsed, false, normRng).each(function(pos) {
        normRng.setEnd(pos.container(), pos.offset());
      });
    }
    if (collapsed) {
      normRng.collapse(true);
    }
    return isEq$1(rng, normRng) ? Optional.none() : Optional.some(normRng);
  };
  var splitText = function(node, offset) {
    return node.splitText(offset);
  };
  var split$1 = function(rng) {
    var startContainer = rng.startContainer, startOffset = rng.startOffset, endContainer = rng.endContainer, endOffset = rng.endOffset;
    if (startContainer === endContainer && isText$1(startContainer)) {
      if (startOffset > 0 && startOffset < startContainer.nodeValue.length) {
        endContainer = splitText(startContainer, startOffset);
        startContainer = endContainer.previousSibling;
        if (endOffset > startOffset) {
          endOffset = endOffset - startOffset;
          startContainer = endContainer = splitText(endContainer, endOffset).previousSibling;
          endOffset = endContainer.nodeValue.length;
          startOffset = 0;
        } else {
          endOffset = 0;
        }
      }
    } else {
      if (isText$1(startContainer) && startOffset > 0 && startOffset < startContainer.nodeValue.length) {
        startContainer = splitText(startContainer, startOffset);
        startOffset = 0;
      }
      if (isText$1(endContainer) && endOffset > 0 && endOffset < endContainer.nodeValue.length) {
        endContainer = splitText(endContainer, endOffset).previousSibling;
        endOffset = endContainer.nodeValue.length;
      }
    }
    return {
      startContainer,
      startOffset,
      endContainer,
      endOffset
    };
  };
  var RangeUtils = function(dom2) {
    var walk2 = function(rng, callback) {
      return walk$1(dom2, rng, callback);
    };
    var split2 = split$1;
    var normalize$12 = function(rng) {
      return normalize(dom2, rng).fold(never, function(normalizedRng) {
        rng.setStart(normalizedRng.startContainer, normalizedRng.startOffset);
        rng.setEnd(normalizedRng.endContainer, normalizedRng.endOffset);
        return true;
      });
    };
    return {
      walk: walk2,
      split: split2,
      normalize: normalize$12
    };
  };
  RangeUtils.compareRanges = isEq$1;
  RangeUtils.getCaretRangeFromPoint = fromPoint$1;
  RangeUtils.getSelectedNode = getSelectedNode;
  RangeUtils.getNode = getNode;
  var Dimension = function(name2, getOffset) {
    var set2 = function(element, h) {
      if (!isNumber(h) && !h.match(/^[0-9]+$/)) {
        throw new Error(name2 + ".set accepts only positive integer values. Value was " + h);
      }
      var dom2 = element.dom;
      if (isSupported$1(dom2)) {
        dom2.style[name2] = h + "px";
      }
    };
    var get2 = function(element) {
      var r3 = getOffset(element);
      if (r3 <= 0 || r3 === null) {
        var css = get$5(element, name2);
        return parseFloat(css) || 0;
      }
      return r3;
    };
    var getOuter = get2;
    var aggregate = function(element, properties) {
      return foldl(properties, function(acc, property) {
        var val = get$5(element, property);
        var value2 = val === void 0 ? 0 : parseInt(val, 10);
        return isNaN(value2) ? acc : acc + value2;
      }, 0);
    };
    var max2 = function(element, value2, properties) {
      var cumulativeInclusions = aggregate(element, properties);
      var absoluteMax = value2 > cumulativeInclusions ? value2 - cumulativeInclusions : 0;
      return absoluteMax;
    };
    return {
      set: set2,
      get: get2,
      getOuter,
      aggregate,
      max: max2
    };
  };
  var api$1 = Dimension("height", function(element) {
    var dom2 = element.dom;
    return inBody(element) ? dom2.getBoundingClientRect().height : dom2.offsetHeight;
  });
  var get$9 = function(element) {
    return api$1.get(element);
  };
  var walkUp = function(navigation, doc2) {
    var frame = navigation.view(doc2);
    return frame.fold(constant([]), function(f) {
      var parent2 = navigation.owner(f);
      var rest = walkUp(navigation, parent2);
      return [f].concat(rest);
    });
  };
  var pathTo = function(element, navigation) {
    var d = navigation.owner(element);
    return walkUp(navigation, d);
  };
  var view = function(doc2) {
    var _a;
    var element = doc2.dom === document ? Optional.none() : Optional.from((_a = doc2.dom.defaultView) === null || _a === void 0 ? void 0 : _a.frameElement);
    return element.map(SugarElement.fromDom);
  };
  var owner$1 = function(element) {
    return documentOrOwner(element);
  };
  var Navigation = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    view,
    owner: owner$1
  });
  var find$2 = function(element) {
    var doc2 = SugarElement.fromDom(document);
    var scroll = get$2(doc2);
    var frames = pathTo(element, Navigation);
    var offset = viewport(element);
    var r3 = foldr(frames, function(b, a) {
      var loc = viewport(a);
      return {
        left: b.left + loc.left,
        top: b.top + loc.top
      };
    }, {
      left: 0,
      top: 0
    });
    return SugarPosition(r3.left + offset.left + scroll.left, r3.top + offset.top + scroll.top);
  };
  var excludeFromDescend = function(element) {
    return name(element) === "textarea";
  };
  var fireScrollIntoViewEvent = function(editor, data2) {
    var scrollEvent = editor.fire("ScrollIntoView", data2);
    return scrollEvent.isDefaultPrevented();
  };
  var fireAfterScrollIntoViewEvent = function(editor, data2) {
    editor.fire("AfterScrollIntoView", data2);
  };
  var descend = function(element, offset) {
    var children$1 = children(element);
    if (children$1.length === 0 || excludeFromDescend(element)) {
      return {
        element,
        offset
      };
    } else if (offset < children$1.length && !excludeFromDescend(children$1[offset])) {
      return {
        element: children$1[offset],
        offset: 0
      };
    } else {
      var last2 = children$1[children$1.length - 1];
      if (excludeFromDescend(last2)) {
        return {
          element,
          offset
        };
      } else {
        if (name(last2) === "img") {
          return {
            element: last2,
            offset: 1
          };
        } else if (isText(last2)) {
          return {
            element: last2,
            offset: get$8(last2).length
          };
        } else {
          return {
            element: last2,
            offset: children(last2).length
          };
        }
      }
    }
  };
  var markerInfo = function(element, cleanupFun) {
    var pos = absolute(element);
    var height = get$9(element);
    return {
      element,
      bottom: pos.top + height,
      height,
      pos,
      cleanup: cleanupFun
    };
  };
  var createMarker = function(element, offset) {
    var startPoint = descend(element, offset);
    var span = SugarElement.fromHtml('<span data-mce-bogus="all">' + ZWSP + "</span>");
    before(startPoint.element, span);
    return markerInfo(span, function() {
      return remove(span);
    });
  };
  var elementMarker = function(element) {
    return markerInfo(SugarElement.fromDom(element), noop);
  };
  var withMarker = function(editor, f, rng, alignToTop) {
    preserveWith(editor, function(_s, _e) {
      return applyWithMarker(editor, f, rng, alignToTop);
    }, rng);
  };
  var withScrollEvents = function(editor, doc2, f, marker, alignToTop) {
    var data2 = {
      elm: marker.element.dom,
      alignToTop
    };
    if (fireScrollIntoViewEvent(editor, data2)) {
      return;
    }
    var scrollTop = get$2(doc2).top;
    f(doc2, scrollTop, marker, alignToTop);
    fireAfterScrollIntoViewEvent(editor, data2);
  };
  var applyWithMarker = function(editor, f, rng, alignToTop) {
    var body = SugarElement.fromDom(editor.getBody());
    var doc2 = SugarElement.fromDom(editor.getDoc());
    reflow(body);
    var marker = createMarker(SugarElement.fromDom(rng.startContainer), rng.startOffset);
    withScrollEvents(editor, doc2, f, marker, alignToTop);
    marker.cleanup();
  };
  var withElement = function(editor, element, f, alignToTop) {
    var doc2 = SugarElement.fromDom(editor.getDoc());
    withScrollEvents(editor, doc2, f, elementMarker(element), alignToTop);
  };
  var preserveWith = function(editor, f, rng) {
    var startElement = rng.startContainer;
    var startOffset = rng.startOffset;
    var endElement = rng.endContainer;
    var endOffset = rng.endOffset;
    f(SugarElement.fromDom(startElement), SugarElement.fromDom(endElement));
    var newRng = editor.dom.createRng();
    newRng.setStart(startElement, startOffset);
    newRng.setEnd(endElement, endOffset);
    editor.selection.setRng(rng);
  };
  var scrollToMarker = function(marker, viewHeight, alignToTop, doc2) {
    var pos = marker.pos;
    if (alignToTop) {
      to(pos.left, pos.top, doc2);
    } else {
      var y2 = pos.top - viewHeight + marker.height;
      to(pos.left, y2, doc2);
    }
  };
  var intoWindowIfNeeded = function(doc2, scrollTop, viewHeight, marker, alignToTop) {
    var viewportBottom = viewHeight + scrollTop;
    var markerTop = marker.pos.top;
    var markerBottom = marker.bottom;
    var largerThanViewport = markerBottom - markerTop >= viewHeight;
    if (markerTop < scrollTop) {
      scrollToMarker(marker, viewHeight, alignToTop !== false, doc2);
    } else if (markerTop > viewportBottom) {
      var align = largerThanViewport ? alignToTop !== false : alignToTop === true;
      scrollToMarker(marker, viewHeight, align, doc2);
    } else if (markerBottom > viewportBottom && !largerThanViewport) {
      scrollToMarker(marker, viewHeight, alignToTop === true, doc2);
    }
  };
  var intoWindow = function(doc2, scrollTop, marker, alignToTop) {
    var viewHeight = doc2.dom.defaultView.innerHeight;
    intoWindowIfNeeded(doc2, scrollTop, viewHeight, marker, alignToTop);
  };
  var intoFrame = function(doc2, scrollTop, marker, alignToTop) {
    var frameViewHeight = doc2.dom.defaultView.innerHeight;
    intoWindowIfNeeded(doc2, scrollTop, frameViewHeight, marker, alignToTop);
    var op = find$2(marker.element);
    var viewportBounds = getBounds(window);
    if (op.top < viewportBounds.y) {
      intoView(marker.element, alignToTop !== false);
    } else if (op.top > viewportBounds.bottom) {
      intoView(marker.element, alignToTop === true);
    }
  };
  var rangeIntoWindow = function(editor, rng, alignToTop) {
    return withMarker(editor, intoWindow, rng, alignToTop);
  };
  var elementIntoWindow = function(editor, element, alignToTop) {
    return withElement(editor, element, intoWindow, alignToTop);
  };
  var rangeIntoFrame = function(editor, rng, alignToTop) {
    return withMarker(editor, intoFrame, rng, alignToTop);
  };
  var elementIntoFrame = function(editor, element, alignToTop) {
    return withElement(editor, element, intoFrame, alignToTop);
  };
  var scrollElementIntoView = function(editor, element, alignToTop) {
    var scroller = editor.inline ? elementIntoWindow : elementIntoFrame;
    scroller(editor, element, alignToTop);
  };
  var scrollRangeIntoView = function(editor, rng, alignToTop) {
    var scroller = editor.inline ? rangeIntoWindow : rangeIntoFrame;
    scroller(editor, rng, alignToTop);
  };
  var getDocument = function() {
    return SugarElement.fromDom(document);
  };
  var focus = function(element) {
    return element.dom.focus();
  };
  var hasFocus = function(element) {
    var root = getRootNode(element).dom;
    return element.dom === root.activeElement;
  };
  var active = function(root) {
    if (root === void 0) {
      root = getDocument();
    }
    return Optional.from(root.dom.activeElement).map(SugarElement.fromDom);
  };
  var search = function(element) {
    return active(getRootNode(element)).filter(function(e) {
      return element.dom.contains(e.dom);
    });
  };
  var create$4 = function(start2, soffset, finish, foffset) {
    return {
      start: start2,
      soffset,
      finish,
      foffset
    };
  };
  var SimRange = { create: create$4 };
  var adt = Adt.generate([
    { before: ["element"] },
    {
      on: [
        "element",
        "offset"
      ]
    },
    { after: ["element"] }
  ]);
  var cata = function(subject, onBefore, onOn, onAfter) {
    return subject.fold(onBefore, onOn, onAfter);
  };
  var getStart = function(situ) {
    return situ.fold(identity, identity, identity);
  };
  var before$3 = adt.before;
  var on = adt.on;
  var after$2 = adt.after;
  var Situ = {
    before: before$3,
    on,
    after: after$2,
    cata,
    getStart
  };
  var adt$1 = Adt.generate([
    { domRange: ["rng"] },
    {
      relative: [
        "startSitu",
        "finishSitu"
      ]
    },
    {
      exact: [
        "start",
        "soffset",
        "finish",
        "foffset"
      ]
    }
  ]);
  var exactFromRange = function(simRange) {
    return adt$1.exact(simRange.start, simRange.soffset, simRange.finish, simRange.foffset);
  };
  var getStart$1 = function(selection) {
    return selection.match({
      domRange: function(rng) {
        return SugarElement.fromDom(rng.startContainer);
      },
      relative: function(startSitu, _finishSitu) {
        return Situ.getStart(startSitu);
      },
      exact: function(start2, _soffset, _finish, _foffset) {
        return start2;
      }
    });
  };
  var domRange = adt$1.domRange;
  var relative = adt$1.relative;
  var exact = adt$1.exact;
  var getWin = function(selection) {
    var start2 = getStart$1(selection);
    return defaultView(start2);
  };
  var range = SimRange.create;
  var SimSelection = {
    domRange,
    relative,
    exact,
    exactFromRange,
    getWin,
    range
  };
  var browser$3 = detect$3().browser;
  var clamp = function(offset, element) {
    var max2 = isText(element) ? get$8(element).length : children(element).length + 1;
    if (offset > max2) {
      return max2;
    } else if (offset < 0) {
      return 0;
    }
    return offset;
  };
  var normalizeRng = function(rng) {
    return SimSelection.range(rng.start, clamp(rng.soffset, rng.start), rng.finish, clamp(rng.foffset, rng.finish));
  };
  var isOrContains = function(root, elm) {
    return !isRestrictedNode(elm.dom) && (contains$2(root, elm) || eq$2(root, elm));
  };
  var isRngInRoot = function(root) {
    return function(rng) {
      return isOrContains(root, rng.start) && isOrContains(root, rng.finish);
    };
  };
  var shouldStore = function(editor) {
    return editor.inline === true || browser$3.isIE();
  };
  var nativeRangeToSelectionRange = function(r3) {
    return SimSelection.range(SugarElement.fromDom(r3.startContainer), r3.startOffset, SugarElement.fromDom(r3.endContainer), r3.endOffset);
  };
  var readRange = function(win) {
    var selection = win.getSelection();
    var rng = !selection || selection.rangeCount === 0 ? Optional.none() : Optional.from(selection.getRangeAt(0));
    return rng.map(nativeRangeToSelectionRange);
  };
  var getBookmark$2 = function(root) {
    var win = defaultView(root);
    return readRange(win.dom).filter(isRngInRoot(root));
  };
  var validate = function(root, bookmark) {
    return Optional.from(bookmark).filter(isRngInRoot(root)).map(normalizeRng);
  };
  var bookmarkToNativeRng = function(bookmark) {
    var rng = document.createRange();
    try {
      rng.setStart(bookmark.start.dom, bookmark.soffset);
      rng.setEnd(bookmark.finish.dom, bookmark.foffset);
      return Optional.some(rng);
    } catch (_) {
      return Optional.none();
    }
  };
  var store = function(editor) {
    var newBookmark = shouldStore(editor) ? getBookmark$2(SugarElement.fromDom(editor.getBody())) : Optional.none();
    editor.bookmark = newBookmark.isSome() ? newBookmark : editor.bookmark;
  };
  var storeNative = function(editor, rng) {
    var root = SugarElement.fromDom(editor.getBody());
    var range2 = shouldStore(editor) ? Optional.from(rng) : Optional.none();
    var newBookmark = range2.map(nativeRangeToSelectionRange).filter(isRngInRoot(root));
    editor.bookmark = newBookmark.isSome() ? newBookmark : editor.bookmark;
  };
  var getRng = function(editor) {
    var bookmark = editor.bookmark ? editor.bookmark : Optional.none();
    return bookmark.bind(function(x2) {
      return validate(SugarElement.fromDom(editor.getBody()), x2);
    }).bind(bookmarkToNativeRng);
  };
  var restore = function(editor) {
    getRng(editor).each(function(rng) {
      return editor.selection.setRng(rng);
    });
  };
  var isEditorUIElement = function(elm) {
    var className = elm.className.toString();
    return className.indexOf("tox-") !== -1 || className.indexOf("mce-") !== -1;
  };
  var FocusManager = { isEditorUIElement };
  var isManualNodeChange = function(e) {
    return e.type === "nodechange" && e.selectionChange;
  };
  var registerPageMouseUp = function(editor, throttledStore) {
    var mouseUpPage = function() {
      throttledStore.throttle();
    };
    DOMUtils.DOM.bind(document, "mouseup", mouseUpPage);
    editor.on("remove", function() {
      DOMUtils.DOM.unbind(document, "mouseup", mouseUpPage);
    });
  };
  var registerFocusOut = function(editor) {
    editor.on("focusout", function() {
      store(editor);
    });
  };
  var registerMouseUp = function(editor, throttledStore) {
    editor.on("mouseup touchend", function(_e) {
      throttledStore.throttle();
    });
  };
  var registerEditorEvents = function(editor, throttledStore) {
    var browser2 = detect$3().browser;
    if (browser2.isIE()) {
      registerFocusOut(editor);
    } else {
      registerMouseUp(editor, throttledStore);
    }
    editor.on("keyup NodeChange", function(e) {
      if (!isManualNodeChange(e)) {
        store(editor);
      }
    });
  };
  var register = function(editor) {
    var throttledStore = first(function() {
      store(editor);
    }, 0);
    editor.on("init", function() {
      if (editor.inline) {
        registerPageMouseUp(editor, throttledStore);
      }
      registerEditorEvents(editor, throttledStore);
    });
    editor.on("remove", function() {
      throttledStore.cancel();
    });
  };
  var documentFocusInHandler;
  var DOM$2 = DOMUtils.DOM;
  var isEditorUIElement$1 = function(elm) {
    return FocusManager.isEditorUIElement(elm);
  };
  var isEditorContentAreaElement = function(elm) {
    var classList = elm.classList;
    if (classList !== void 0) {
      return classList.contains("tox-edit-area") || classList.contains("tox-edit-area__iframe") || classList.contains("mce-content-body");
    } else {
      return false;
    }
  };
  var isUIElement = function(editor, elm) {
    var customSelector = getCustomUiSelector(editor);
    var parent2 = DOM$2.getParent(elm, function(elm2) {
      return isEditorUIElement$1(elm2) || (customSelector ? editor.dom.is(elm2, customSelector) : false);
    });
    return parent2 !== null;
  };
  var getActiveElement = function(editor) {
    try {
      var root = getRootNode(SugarElement.fromDom(editor.getElement()));
      return active(root).fold(function() {
        return document.body;
      }, function(x2) {
        return x2.dom;
      });
    } catch (ex) {
      return document.body;
    }
  };
  var registerEvents = function(editorManager, e) {
    var editor = e.editor;
    register(editor);
    editor.on("focusin", function() {
      var focusedEditor = editorManager.focusedEditor;
      if (focusedEditor !== editor) {
        if (focusedEditor) {
          focusedEditor.fire("blur", { focusedEditor: editor });
        }
        editorManager.setActive(editor);
        editorManager.focusedEditor = editor;
        editor.fire("focus", { blurredEditor: focusedEditor });
        editor.focus(true);
      }
    });
    editor.on("focusout", function() {
      Delay.setEditorTimeout(editor, function() {
        var focusedEditor = editorManager.focusedEditor;
        if (!isUIElement(editor, getActiveElement(editor)) && focusedEditor === editor) {
          editor.fire("blur", { focusedEditor: null });
          editorManager.focusedEditor = null;
        }
      });
    });
    if (!documentFocusInHandler) {
      documentFocusInHandler = function(e2) {
        var activeEditor = editorManager.activeEditor;
        if (activeEditor) {
          getOriginalEventTarget(e2).each(function(target) {
            if (target.ownerDocument === document) {
              if (target !== document.body && !isUIElement(activeEditor, target) && editorManager.focusedEditor === activeEditor) {
                activeEditor.fire("blur", { focusedEditor: null });
                editorManager.focusedEditor = null;
              }
            }
          });
        }
      };
      DOM$2.bind(document, "focusin", documentFocusInHandler);
    }
  };
  var unregisterDocumentEvents = function(editorManager, e) {
    if (editorManager.focusedEditor === e.editor) {
      editorManager.focusedEditor = null;
    }
    if (!editorManager.activeEditor) {
      DOM$2.unbind(document, "focusin", documentFocusInHandler);
      documentFocusInHandler = null;
    }
  };
  var setup$2 = function(editorManager) {
    editorManager.on("AddEditor", curry(registerEvents, editorManager));
    editorManager.on("RemoveEditor", curry(unregisterDocumentEvents, editorManager));
  };
  var getContentEditableHost = function(editor, node) {
    return editor.dom.getParent(node, function(node2) {
      return editor.dom.getContentEditable(node2) === "true";
    });
  };
  var getCollapsedNode = function(rng) {
    return rng.collapsed ? Optional.from(getNode(rng.startContainer, rng.startOffset)).map(SugarElement.fromDom) : Optional.none();
  };
  var getFocusInElement = function(root, rng) {
    return getCollapsedNode(rng).bind(function(node) {
      if (isTableSection(node)) {
        return Optional.some(node);
      } else if (contains$2(root, node) === false) {
        return Optional.some(root);
      } else {
        return Optional.none();
      }
    });
  };
  var normalizeSelection = function(editor, rng) {
    getFocusInElement(SugarElement.fromDom(editor.getBody()), rng).bind(function(elm) {
      return firstPositionIn(elm.dom);
    }).fold(function() {
      editor.selection.normalize();
      return;
    }, function(caretPos) {
      return editor.selection.setRng(caretPos.toRange());
    });
  };
  var focusBody = function(body) {
    if (body.setActive) {
      try {
        body.setActive();
      } catch (ex) {
        body.focus();
      }
    } else {
      body.focus();
    }
  };
  var hasElementFocus = function(elm) {
    return hasFocus(elm) || search(elm).isSome();
  };
  var hasIframeFocus = function(editor) {
    return editor.iframeElement && hasFocus(SugarElement.fromDom(editor.iframeElement));
  };
  var hasInlineFocus = function(editor) {
    var rawBody = editor.getBody();
    return rawBody && hasElementFocus(SugarElement.fromDom(rawBody));
  };
  var hasUiFocus = function(editor) {
    var dos = getRootNode(SugarElement.fromDom(editor.getElement()));
    return active(dos).filter(function(elem) {
      return !isEditorContentAreaElement(elem.dom) && isUIElement(editor, elem.dom);
    }).isSome();
  };
  var hasFocus$1 = function(editor) {
    return editor.inline ? hasInlineFocus(editor) : hasIframeFocus(editor);
  };
  var hasEditorOrUiFocus = function(editor) {
    return hasFocus$1(editor) || hasUiFocus(editor);
  };
  var focusEditor = function(editor) {
    var selection = editor.selection;
    var body = editor.getBody();
    var rng = selection.getRng();
    editor.quirks.refreshContentEditable();
    if (editor.bookmark !== void 0 && hasFocus$1(editor) === false) {
      getRng(editor).each(function(bookmarkRng) {
        editor.selection.setRng(bookmarkRng);
        rng = bookmarkRng;
      });
    }
    var contentEditableHost = getContentEditableHost(editor, selection.getNode());
    if (editor.$.contains(body, contentEditableHost)) {
      focusBody(contentEditableHost);
      normalizeSelection(editor, rng);
      activateEditor(editor);
      return;
    }
    if (!editor.inline) {
      if (!Env.opera) {
        focusBody(body);
      }
      editor.getWin().focus();
    }
    if (Env.gecko || editor.inline) {
      focusBody(body);
      normalizeSelection(editor, rng);
    }
    activateEditor(editor);
  };
  var activateEditor = function(editor) {
    return editor.editorManager.setActive(editor);
  };
  var focus$1 = function(editor, skipFocus) {
    if (editor.removed) {
      return;
    }
    skipFocus ? activateEditor(editor) : focusEditor(editor);
  };
  var getEndpointElement = function(root, rng, start2, real, resolve2) {
    var container = start2 ? rng.startContainer : rng.endContainer;
    var offset = start2 ? rng.startOffset : rng.endOffset;
    return Optional.from(container).map(SugarElement.fromDom).map(function(elm) {
      return !real || !rng.collapsed ? child(elm, resolve2(elm, offset)).getOr(elm) : elm;
    }).bind(function(elm) {
      return isElement(elm) ? Optional.some(elm) : parent(elm).filter(isElement);
    }).map(function(elm) {
      return elm.dom;
    }).getOr(root);
  };
  var getStart$2 = function(root, rng, real) {
    return getEndpointElement(root, rng, true, real, function(elm, offset) {
      return Math.min(childNodesCount(elm), offset);
    });
  };
  var getEnd = function(root, rng, real) {
    return getEndpointElement(root, rng, false, real, function(elm, offset) {
      return offset > 0 ? offset - 1 : offset;
    });
  };
  var skipEmptyTextNodes = function(node, forwards) {
    var orig = node;
    while (node && isText$1(node) && node.length === 0) {
      node = forwards ? node.nextSibling : node.previousSibling;
    }
    return node || orig;
  };
  var getNode$1 = function(root, rng) {
    var elm, startContainer, endContainer;
    if (!rng) {
      return root;
    }
    startContainer = rng.startContainer;
    endContainer = rng.endContainer;
    var startOffset = rng.startOffset;
    var endOffset = rng.endOffset;
    elm = rng.commonAncestorContainer;
    if (!rng.collapsed) {
      if (startContainer === endContainer) {
        if (endOffset - startOffset < 2) {
          if (startContainer.hasChildNodes()) {
            elm = startContainer.childNodes[startOffset];
          }
        }
      }
      if (startContainer.nodeType === 3 && endContainer.nodeType === 3) {
        if (startContainer.length === startOffset) {
          startContainer = skipEmptyTextNodes(startContainer.nextSibling, true);
        } else {
          startContainer = startContainer.parentNode;
        }
        if (endOffset === 0) {
          endContainer = skipEmptyTextNodes(endContainer.previousSibling, false);
        } else {
          endContainer = endContainer.parentNode;
        }
        if (startContainer && startContainer === endContainer) {
          return startContainer;
        }
      }
    }
    if (elm && elm.nodeType === 3) {
      return elm.parentNode;
    }
    return elm;
  };
  var getSelectedBlocks = function(dom2, rng, startElm, endElm) {
    var node;
    var selectedBlocks = [];
    var root = dom2.getRoot();
    startElm = dom2.getParent(startElm || getStart$2(root, rng, rng.collapsed), dom2.isBlock);
    endElm = dom2.getParent(endElm || getEnd(root, rng, rng.collapsed), dom2.isBlock);
    if (startElm && startElm !== root) {
      selectedBlocks.push(startElm);
    }
    if (startElm && endElm && startElm !== endElm) {
      node = startElm;
      var walker = new DomTreeWalker(startElm, root);
      while ((node = walker.next()) && node !== endElm) {
        if (dom2.isBlock(node)) {
          selectedBlocks.push(node);
        }
      }
    }
    if (endElm && startElm !== endElm && endElm !== root) {
      selectedBlocks.push(endElm);
    }
    return selectedBlocks;
  };
  var select$1 = function(dom2, node, content) {
    return Optional.from(node).map(function(node2) {
      var idx = dom2.nodeIndex(node2);
      var rng = dom2.createRng();
      rng.setStart(node2.parentNode, idx);
      rng.setEnd(node2.parentNode, idx + 1);
      if (content) {
        moveEndPoint$1(dom2, rng, node2, true);
        moveEndPoint$1(dom2, rng, node2, false);
      }
      return rng;
    });
  };
  var processRanges = function(editor, ranges) {
    return map(ranges, function(range2) {
      var evt = editor.fire("GetSelectionRange", { range: range2 });
      return evt.range !== range2 ? evt.range : range2;
    });
  };
  var typeLookup = {
    "#text": 3,
    "#comment": 8,
    "#cdata": 4,
    "#pi": 7,
    "#doctype": 10,
    "#document-fragment": 11
  };
  var walk$2 = function(node, root, prev) {
    var startName = prev ? "lastChild" : "firstChild";
    var siblingName = prev ? "prev" : "next";
    if (node[startName]) {
      return node[startName];
    }
    if (node !== root) {
      var sibling2 = node[siblingName];
      if (sibling2) {
        return sibling2;
      }
      for (var parent_1 = node.parent; parent_1 && parent_1 !== root; parent_1 = parent_1.parent) {
        sibling2 = parent_1[siblingName];
        if (sibling2) {
          return sibling2;
        }
      }
    }
  };
  var isEmptyTextNode$1 = function(node) {
    if (!isWhitespaceText(node.value)) {
      return false;
    }
    var parentNode = node.parent;
    if (parentNode && (parentNode.name !== "span" || parentNode.attr("style")) && /^[ ]+$/.test(node.value)) {
      return false;
    }
    return true;
  };
  var isNonEmptyElement = function(node) {
    var isNamedAnchor2 = node.name === "a" && !node.attr("href") && node.attr("id");
    return node.attr("name") || node.attr("id") && !node.firstChild || node.attr("data-mce-bookmark") || isNamedAnchor2;
  };
  var AstNode = function() {
    function AstNode2(name2, type2) {
      this.name = name2;
      this.type = type2;
      if (type2 === 1) {
        this.attributes = [];
        this.attributes.map = {};
      }
    }
    AstNode2.create = function(name2, attrs) {
      var node = new AstNode2(name2, typeLookup[name2] || 1);
      if (attrs) {
        each$1(attrs, function(value2, attrName) {
          node.attr(attrName, value2);
        });
      }
      return node;
    };
    AstNode2.prototype.replace = function(node) {
      var self2 = this;
      if (node.parent) {
        node.remove();
      }
      self2.insert(node, self2);
      self2.remove();
      return self2;
    };
    AstNode2.prototype.attr = function(name2, value2) {
      var self2 = this;
      var attrs;
      if (typeof name2 !== "string") {
        if (name2 !== void 0 && name2 !== null) {
          each$1(name2, function(value3, key) {
            self2.attr(key, value3);
          });
        }
        return self2;
      }
      if (attrs = self2.attributes) {
        if (value2 !== void 0) {
          if (value2 === null) {
            if (name2 in attrs.map) {
              delete attrs.map[name2];
              var i = attrs.length;
              while (i--) {
                if (attrs[i].name === name2) {
                  attrs.splice(i, 1);
                  return self2;
                }
              }
            }
            return self2;
          }
          if (name2 in attrs.map) {
            var i = attrs.length;
            while (i--) {
              if (attrs[i].name === name2) {
                attrs[i].value = value2;
                break;
              }
            }
          } else {
            attrs.push({
              name: name2,
              value: value2
            });
          }
          attrs.map[name2] = value2;
          return self2;
        }
        return attrs.map[name2];
      }
    };
    AstNode2.prototype.clone = function() {
      var self2 = this;
      var clone2 = new AstNode2(self2.name, self2.type);
      var selfAttrs;
      if (selfAttrs = self2.attributes) {
        var cloneAttrs = [];
        cloneAttrs.map = {};
        for (var i = 0, l2 = selfAttrs.length; i < l2; i++) {
          var selfAttr = selfAttrs[i];
          if (selfAttr.name !== "id") {
            cloneAttrs[cloneAttrs.length] = {
              name: selfAttr.name,
              value: selfAttr.value
            };
            cloneAttrs.map[selfAttr.name] = selfAttr.value;
          }
        }
        clone2.attributes = cloneAttrs;
      }
      clone2.value = self2.value;
      clone2.shortEnded = self2.shortEnded;
      return clone2;
    };
    AstNode2.prototype.wrap = function(wrapper) {
      var self2 = this;
      self2.parent.insert(wrapper, self2);
      wrapper.append(self2);
      return self2;
    };
    AstNode2.prototype.unwrap = function() {
      var self2 = this;
      for (var node = self2.firstChild; node; ) {
        var next = node.next;
        self2.insert(node, self2, true);
        node = next;
      }
      self2.remove();
    };
    AstNode2.prototype.remove = function() {
      var self2 = this, parent2 = self2.parent, next = self2.next, prev = self2.prev;
      if (parent2) {
        if (parent2.firstChild === self2) {
          parent2.firstChild = next;
          if (next) {
            next.prev = null;
          }
        } else {
          prev.next = next;
        }
        if (parent2.lastChild === self2) {
          parent2.lastChild = prev;
          if (prev) {
            prev.next = null;
          }
        } else {
          next.prev = prev;
        }
        self2.parent = self2.next = self2.prev = null;
      }
      return self2;
    };
    AstNode2.prototype.append = function(node) {
      var self2 = this;
      if (node.parent) {
        node.remove();
      }
      var last2 = self2.lastChild;
      if (last2) {
        last2.next = node;
        node.prev = last2;
        self2.lastChild = node;
      } else {
        self2.lastChild = self2.firstChild = node;
      }
      node.parent = self2;
      return node;
    };
    AstNode2.prototype.insert = function(node, refNode, before2) {
      if (node.parent) {
        node.remove();
      }
      var parent2 = refNode.parent || this;
      if (before2) {
        if (refNode === parent2.firstChild) {
          parent2.firstChild = node;
        } else {
          refNode.prev.next = node;
        }
        node.prev = refNode.prev;
        node.next = refNode;
        refNode.prev = node;
      } else {
        if (refNode === parent2.lastChild) {
          parent2.lastChild = node;
        } else {
          refNode.next.prev = node;
        }
        node.next = refNode.next;
        node.prev = refNode;
        refNode.next = node;
      }
      node.parent = parent2;
      return node;
    };
    AstNode2.prototype.getAll = function(name2) {
      var self2 = this;
      var collection = [];
      for (var node = self2.firstChild; node; node = walk$2(node, self2)) {
        if (node.name === name2) {
          collection.push(node);
        }
      }
      return collection;
    };
    AstNode2.prototype.empty = function() {
      var self2 = this;
      if (self2.firstChild) {
        var nodes = [];
        for (var node = self2.firstChild; node; node = walk$2(node, self2)) {
          nodes.push(node);
        }
        var i = nodes.length;
        while (i--) {
          var node = nodes[i];
          node.parent = node.firstChild = node.lastChild = node.next = node.prev = null;
        }
      }
      self2.firstChild = self2.lastChild = null;
      return self2;
    };
    AstNode2.prototype.isEmpty = function(elements, whitespace2, predicate) {
      if (whitespace2 === void 0) {
        whitespace2 = {};
      }
      var self2 = this;
      var node = self2.firstChild;
      if (isNonEmptyElement(self2)) {
        return false;
      }
      if (node) {
        do {
          if (node.type === 1) {
            if (node.attr("data-mce-bogus")) {
              continue;
            }
            if (elements[node.name]) {
              return false;
            }
            if (isNonEmptyElement(node)) {
              return false;
            }
          }
          if (node.type === 8) {
            return false;
          }
          if (node.type === 3 && !isEmptyTextNode$1(node)) {
            return false;
          }
          if (node.type === 3 && node.parent && whitespace2[node.parent.name] && isWhitespaceText(node.value)) {
            return false;
          }
          if (predicate && predicate(node)) {
            return false;
          }
        } while (node = walk$2(node, self2));
      }
      return true;
    };
    AstNode2.prototype.walk = function(prev) {
      return walk$2(this, null, prev);
    };
    return AstNode2;
  }();
  var extractBase64DataUris = function(html) {
    var dataImageUri = /data:[^;]+;base64,([a-z0-9\+\/=]+)/gi;
    var chunks = [];
    var uris = {};
    var prefix = generate$1("img");
    var matches2;
    var index = 0;
    var count2 = 0;
    while (matches2 = dataImageUri.exec(html)) {
      var uri = matches2[0];
      var imageId = prefix + "_" + count2++;
      uris[imageId] = uri;
      if (index < matches2.index) {
        chunks.push(html.substr(index, matches2.index - index));
      }
      chunks.push(imageId);
      index = matches2.index + uri.length;
    }
    var re2 = new RegExp(prefix + "_[0-9]+", "g");
    if (index === 0) {
      return {
        prefix,
        uris,
        html,
        re: re2
      };
    } else {
      if (index < html.length) {
        chunks.push(html.substr(index));
      }
      return {
        prefix,
        uris,
        html: chunks.join(""),
        re: re2
      };
    }
  };
  var restoreDataUris = function(html, result) {
    return html.replace(result.re, function(imageId) {
      return get$1(result.uris, imageId).getOr(imageId);
    });
  };
  var parseDataUri = function(uri) {
    var matches2 = /data:([^;]+);base64,([a-z0-9\+\/=]+)/i.exec(uri);
    if (matches2) {
      return Optional.some({
        type: matches2[1],
        data: decodeURIComponent(matches2[2])
      });
    } else {
      return Optional.none();
    }
  };
  var safeSvgDataUrlElements = [
    "img",
    "video"
  ];
  var isValidPrefixAttrName = function(name2) {
    return name2.indexOf("data-") === 0 || name2.indexOf("aria-") === 0;
  };
  var blockSvgDataUris = function(allowSvgDataUrls, tagName) {
    var allowed = isNullable(allowSvgDataUrls) ? contains(safeSvgDataUrlElements, tagName) : allowSvgDataUrls;
    return !allowed;
  };
  var isInvalidUri = function(settings, uri, tagName) {
    if (settings.allow_html_data_urls) {
      return false;
    } else if (/^data:image\//i.test(uri)) {
      return blockSvgDataUris(settings.allow_svg_data_urls, tagName) && /^data:image\/svg\+xml/i.test(uri);
    } else {
      return /^data:/i.test(uri);
    }
  };
  var findEndTagIndex = function(schema, html, startIndex) {
    var count2 = 1, index, matches2;
    var shortEndedElements = schema.getShortEndedElements();
    var tokenRegExp = /<([!?\/])?([A-Za-z0-9\-_:.]+)(\s(?:[^'">]+(?:"[^"]*"|'[^']*'))*[^"'>]*(?:"[^">]*|'[^'>]*)?|\s*|\/)>/g;
    tokenRegExp.lastIndex = index = startIndex;
    while (matches2 = tokenRegExp.exec(html)) {
      index = tokenRegExp.lastIndex;
      if (matches2[1] === "/") {
        count2--;
      } else if (!matches2[1]) {
        if (matches2[2] in shortEndedElements) {
          continue;
        }
        count2++;
      }
      if (count2 === 0) {
        break;
      }
    }
    return index;
  };
  var isConditionalComment = function(html, startIndex) {
    return /^\s*\[if [\w\W]+\]>.*<!\[endif\](--!?)?>/.test(html.substr(startIndex));
  };
  var findCommentEndIndex = function(html, isBogus2, startIndex) {
    if (startIndex === void 0) {
      startIndex = 0;
    }
    var lcHtml = html.toLowerCase();
    if (lcHtml.indexOf("[if ", startIndex) !== -1 && isConditionalComment(lcHtml, startIndex)) {
      var endIfIndex = lcHtml.indexOf("[endif]", startIndex);
      return lcHtml.indexOf(">", endIfIndex);
    } else {
      if (isBogus2) {
        var endIndex = lcHtml.indexOf(">", startIndex);
        return endIndex !== -1 ? endIndex : lcHtml.length;
      } else {
        var endCommentRegexp = /--!?>/g;
        endCommentRegexp.lastIndex = startIndex;
        var match2 = endCommentRegexp.exec(html);
        return match2 ? match2.index + match2[0].length : lcHtml.length;
      }
    }
  };
  var checkBogusAttribute = function(regExp, attrString) {
    var matches2 = regExp.exec(attrString);
    if (matches2) {
      var name_1 = matches2[1];
      var value2 = matches2[2];
      return typeof name_1 === "string" && name_1.toLowerCase() === "data-mce-bogus" ? value2 : null;
    } else {
      return null;
    }
  };
  var SaxParser = function(settings, schema) {
    if (schema === void 0) {
      schema = Schema();
    }
    settings = settings || {};
    if (settings.fix_self_closing !== false) {
      settings.fix_self_closing = true;
    }
    var comment = settings.comment ? settings.comment : noop;
    var cdata = settings.cdata ? settings.cdata : noop;
    var text = settings.text ? settings.text : noop;
    var start2 = settings.start ? settings.start : noop;
    var end2 = settings.end ? settings.end : noop;
    var pi2 = settings.pi ? settings.pi : noop;
    var doctype = settings.doctype ? settings.doctype : noop;
    var parseInternal = function(base64Extract, format) {
      if (format === void 0) {
        format = "html";
      }
      var html = base64Extract.html;
      var matches2, index = 0, value2, endRegExp;
      var stack = [];
      var attrList, i, textData, name2;
      var isInternalElement, isShortEnded;
      var elementRule, isValidElement, attr, attribsValue, validAttributesMap, validAttributePatterns;
      var attributesRequired, attributesDefault, attributesForced;
      var anyAttributesRequired, attrValue, idCount = 0;
      var decode2 = Entities.decode;
      var filteredUrlAttrs = Tools.makeMap("src,href,data,background,action,formaction,poster,xlink:href");
      var scriptUriRegExp = /((java|vb)script|mhtml):/i;
      var parsingMode = format === "html" ? 0 : 1;
      var processEndTag = function(name3) {
        var pos, i2;
        pos = stack.length;
        while (pos--) {
          if (stack[pos].name === name3) {
            break;
          }
        }
        if (pos >= 0) {
          for (i2 = stack.length - 1; i2 >= pos; i2--) {
            name3 = stack[i2];
            if (name3.valid) {
              end2(name3.name);
            }
          }
          stack.length = pos;
        }
      };
      var processText = function(value3, raw) {
        return text(restoreDataUris(value3, base64Extract), raw);
      };
      var processComment = function(value3) {
        if (value3 === "") {
          return;
        }
        if (value3.charAt(0) === ">") {
          value3 = " " + value3;
        }
        if (!settings.allow_conditional_comments && value3.substr(0, 3).toLowerCase() === "[if") {
          value3 = " " + value3;
        }
        comment(restoreDataUris(value3, base64Extract));
      };
      var processAttr = function(value3) {
        return restoreDataUris(value3, base64Extract);
      };
      var processMalformedComment = function(value3, startIndex) {
        var startTag = value3 || "";
        var isBogus2 = !startsWith(startTag, "--");
        var endIndex = findCommentEndIndex(html, isBogus2, startIndex);
        value3 = html.substr(startIndex, endIndex - startIndex);
        processComment(isBogus2 ? startTag + value3 : value3);
        return endIndex + 1;
      };
      var parseAttribute = function(tagName, name3, value3, val2, val3) {
        var attrRule, i2;
        var trimRegExp = /[\s\u0000-\u001F]+/g;
        name3 = name3.toLowerCase();
        value3 = processAttr(name3 in fillAttrsMap ? name3 : decode2(value3 || val2 || val3 || ""));
        if (validate2 && !isInternalElement && isValidPrefixAttrName(name3) === false) {
          attrRule = validAttributesMap[name3];
          if (!attrRule && validAttributePatterns) {
            i2 = validAttributePatterns.length;
            while (i2--) {
              attrRule = validAttributePatterns[i2];
              if (attrRule.pattern.test(name3)) {
                break;
              }
            }
            if (i2 === -1) {
              attrRule = null;
            }
          }
          if (!attrRule) {
            return;
          }
          if (attrRule.validValues && !(value3 in attrRule.validValues)) {
            return;
          }
        }
        if (filteredUrlAttrs[name3] && !settings.allow_script_urls) {
          var uri = value3.replace(trimRegExp, "");
          try {
            uri = decodeURIComponent(uri);
          } catch (ex) {
            uri = unescape(uri);
          }
          if (scriptUriRegExp.test(uri)) {
            return;
          }
          if (isInvalidUri(settings, uri, tagName)) {
            return;
          }
        }
        if (isInternalElement && (name3 in filteredUrlAttrs || name3.indexOf("on") === 0)) {
          return;
        }
        attrList.map[name3] = value3;
        attrList.push({
          name: name3,
          value: value3
        });
      };
      var tokenRegExp = new RegExp(`<(?:(?:!--([\\w\\W]*?)--!?>)|(?:!\\[CDATA\\[([\\w\\W]*?)\\]\\]>)|(?:![Dd][Oo][Cc][Tt][Yy][Pp][Ee]([\\w\\W]*?)>)|(?:!(--)?)|(?:\\?([^\\s\\/<>]+) ?([\\w\\W]*?)[?/]>)|(?:\\/([A-Za-z][A-Za-z0-9\\-_\\:\\.]*)>)|(?:([A-Za-z][A-Za-z0-9\\-_:.]*)(\\s(?:[^'">]+(?:"[^"]*"|'[^']*'))*[^"'>]*(?:"[^">]*|'[^'>]*)?|\\s*|\\/)>))`, "g");
      var attrRegExp = /([\w:\-]+)(?:\s*=\s*(?:(?:\"((?:[^\"])*)\")|(?:\'((?:[^\'])*)\')|([^>\s]+)))?/g;
      var shortEndedElements = schema.getShortEndedElements();
      var selfClosing = settings.self_closing_elements || schema.getSelfClosingElements();
      var fillAttrsMap = schema.getBoolAttrs();
      var validate2 = settings.validate;
      var removeInternalElements = settings.remove_internals;
      var fixSelfClosing = settings.fix_self_closing;
      var specialElements = schema.getSpecialElements();
      var processHtml = html + ">";
      while (matches2 = tokenRegExp.exec(processHtml)) {
        var matchText = matches2[0];
        if (index < matches2.index) {
          processText(decode2(html.substr(index, matches2.index - index)));
        }
        if (value2 = matches2[7]) {
          value2 = value2.toLowerCase();
          if (value2.charAt(0) === ":") {
            value2 = value2.substr(1);
          }
          processEndTag(value2);
        } else if (value2 = matches2[8]) {
          if (matches2.index + matchText.length > html.length) {
            processText(decode2(html.substr(matches2.index)));
            index = matches2.index + matchText.length;
            continue;
          }
          value2 = value2.toLowerCase();
          if (value2.charAt(0) === ":") {
            value2 = value2.substr(1);
          }
          isShortEnded = value2 in shortEndedElements;
          if (fixSelfClosing && selfClosing[value2] && stack.length > 0 && stack[stack.length - 1].name === value2) {
            processEndTag(value2);
          }
          var bogusValue = checkBogusAttribute(attrRegExp, matches2[9]);
          if (bogusValue !== null) {
            if (bogusValue === "all") {
              index = findEndTagIndex(schema, html, tokenRegExp.lastIndex);
              tokenRegExp.lastIndex = index;
              continue;
            }
            isValidElement = false;
          }
          if (!validate2 || (elementRule = schema.getElementRule(value2))) {
            isValidElement = true;
            if (validate2) {
              validAttributesMap = elementRule.attributes;
              validAttributePatterns = elementRule.attributePatterns;
            }
            if (attribsValue = matches2[9]) {
              isInternalElement = attribsValue.indexOf("data-mce-type") !== -1;
              if (isInternalElement && removeInternalElements) {
                isValidElement = false;
              }
              attrList = [];
              attrList.map = {};
              attribsValue.replace(attrRegExp, function(match2, name3, val, val2, val3) {
                parseAttribute(value2, name3, val, val2, val3);
                return "";
              });
            } else {
              attrList = [];
              attrList.map = {};
            }
            if (validate2 && !isInternalElement) {
              attributesRequired = elementRule.attributesRequired;
              attributesDefault = elementRule.attributesDefault;
              attributesForced = elementRule.attributesForced;
              anyAttributesRequired = elementRule.removeEmptyAttrs;
              if (anyAttributesRequired && !attrList.length) {
                isValidElement = false;
              }
              if (attributesForced) {
                i = attributesForced.length;
                while (i--) {
                  attr = attributesForced[i];
                  name2 = attr.name;
                  attrValue = attr.value;
                  if (attrValue === "{$uid}") {
                    attrValue = "mce_" + idCount++;
                  }
                  attrList.map[name2] = attrValue;
                  attrList.push({
                    name: name2,
                    value: attrValue
                  });
                }
              }
              if (attributesDefault) {
                i = attributesDefault.length;
                while (i--) {
                  attr = attributesDefault[i];
                  name2 = attr.name;
                  if (!(name2 in attrList.map)) {
                    attrValue = attr.value;
                    if (attrValue === "{$uid}") {
                      attrValue = "mce_" + idCount++;
                    }
                    attrList.map[name2] = attrValue;
                    attrList.push({
                      name: name2,
                      value: attrValue
                    });
                  }
                }
              }
              if (attributesRequired) {
                i = attributesRequired.length;
                while (i--) {
                  if (attributesRequired[i] in attrList.map) {
                    break;
                  }
                }
                if (i === -1) {
                  isValidElement = false;
                }
              }
              if (attr = attrList.map["data-mce-bogus"]) {
                if (attr === "all") {
                  index = findEndTagIndex(schema, html, tokenRegExp.lastIndex);
                  tokenRegExp.lastIndex = index;
                  continue;
                }
                isValidElement = false;
              }
            }
            if (isValidElement) {
              start2(value2, attrList, isShortEnded);
            }
          } else {
            isValidElement = false;
          }
          if (endRegExp = specialElements[value2]) {
            endRegExp.lastIndex = index = matches2.index + matchText.length;
            if (matches2 = endRegExp.exec(html)) {
              if (isValidElement) {
                textData = html.substr(index, matches2.index - index);
              }
              index = matches2.index + matches2[0].length;
            } else {
              textData = html.substr(index);
              index = html.length;
            }
            if (isValidElement) {
              if (textData.length > 0) {
                processText(textData, true);
              }
              end2(value2);
            }
            tokenRegExp.lastIndex = index;
            continue;
          }
          if (!isShortEnded) {
            if (!attribsValue || attribsValue.indexOf("/") !== attribsValue.length - 1) {
              stack.push({
                name: value2,
                valid: isValidElement
              });
            } else if (isValidElement) {
              end2(value2);
            }
          }
        } else if (value2 = matches2[1]) {
          processComment(value2);
        } else if (value2 = matches2[2]) {
          var isValidCdataSection = parsingMode === 1 || settings.preserve_cdata || stack.length > 0 && schema.isValidChild(stack[stack.length - 1].name, "#cdata");
          if (isValidCdataSection) {
            cdata(value2);
          } else {
            index = processMalformedComment("", matches2.index + 2);
            tokenRegExp.lastIndex = index;
            continue;
          }
        } else if (value2 = matches2[3]) {
          doctype(value2);
        } else if ((value2 = matches2[4]) || matchText === "<!") {
          index = processMalformedComment(value2, matches2.index + matchText.length);
          tokenRegExp.lastIndex = index;
          continue;
        } else if (value2 = matches2[5]) {
          if (parsingMode === 1) {
            pi2(value2, matches2[6]);
          } else {
            index = processMalformedComment("?", matches2.index + 2);
            tokenRegExp.lastIndex = index;
            continue;
          }
        }
        index = matches2.index + matchText.length;
      }
      if (index < html.length) {
        processText(decode2(html.substr(index)));
      }
      for (i = stack.length - 1; i >= 0; i--) {
        value2 = stack[i];
        if (value2.valid) {
          end2(value2.name);
        }
      }
    };
    var parse = function(html, format) {
      if (format === void 0) {
        format = "html";
      }
      parseInternal(extractBase64DataUris(html), format);
    };
    return { parse };
  };
  SaxParser.findEndTag = findEndTagIndex;
  var trimHtml = function(tempAttrs, html) {
    var trimContentRegExp = new RegExp(["\\s?(" + tempAttrs.join("|") + ')="[^"]+"'].join("|"), "gi");
    return html.replace(trimContentRegExp, "");
  };
  var trimInternal = function(serializer, html) {
    var content = html;
    var bogusAllRegExp = /<(\w+) [^>]*data-mce-bogus="all"[^>]*>/g;
    var endTagIndex, index, matchLength, matches2;
    var schema = serializer.schema;
    content = trimHtml(serializer.getTempAttrs(), content);
    var shortEndedElements = schema.getShortEndedElements();
    while (matches2 = bogusAllRegExp.exec(content)) {
      index = bogusAllRegExp.lastIndex;
      matchLength = matches2[0].length;
      if (shortEndedElements[matches2[1]]) {
        endTagIndex = index;
      } else {
        endTagIndex = SaxParser.findEndTag(schema, content, index);
      }
      content = content.substring(0, index - matchLength) + content.substring(endTagIndex);
      bogusAllRegExp.lastIndex = index - matchLength;
    }
    return trim$2(content);
  };
  var trimExternal = trimInternal;
  var trimEmptyContents = function(editor, html) {
    var blockName = getForcedRootBlock(editor);
    var emptyRegExp = new RegExp("^(<" + blockName + "[^>]*>(&nbsp;|&#160;|\\s|\xA0|<br \\/>|)<\\/" + blockName + ">[\r\n]*|<br \\/>[\r\n]*)$");
    return html.replace(emptyRegExp, "");
  };
  var getContentFromBody = function(editor, args, format, body) {
    var content;
    args.format = format;
    args.get = true;
    args.getInner = true;
    if (!args.no_events) {
      editor.fire("BeforeGetContent", args);
    }
    if (args.format === "raw") {
      content = Tools.trim(trimExternal(editor.serializer, body.innerHTML));
    } else if (args.format === "text") {
      content = editor.dom.isEmpty(body) ? "" : trim$2(body.innerText || body.textContent);
    } else if (args.format === "tree") {
      content = editor.serializer.serialize(body, args);
    } else {
      content = trimEmptyContents(editor, editor.serializer.serialize(body, args));
    }
    if (!contains([
      "text",
      "tree"
    ], args.format) && !isWsPreserveElement(SugarElement.fromDom(body))) {
      args.content = Tools.trim(content);
    } else {
      args.content = content;
    }
    if (!args.no_events) {
      editor.fire("GetContent", args);
    }
    return args.content;
  };
  var getContentInternal = function(editor, args, format) {
    return Optional.from(editor.getBody()).fold(constant(args.format === "tree" ? new AstNode("body", 11) : ""), function(body) {
      return getContentFromBody(editor, args, format, body);
    });
  };
  var each$7 = Tools.each;
  var ElementUtils = function(dom2) {
    var compare = function(node1, node2) {
      if (node1.nodeName !== node2.nodeName) {
        return false;
      }
      var getAttribs = function(node) {
        var attribs = {};
        each$7(dom2.getAttribs(node), function(attr) {
          var name2 = attr.nodeName.toLowerCase();
          if (name2.indexOf("_") !== 0 && name2 !== "style" && name2.indexOf("data-") !== 0) {
            attribs[name2] = dom2.getAttrib(node, name2);
          }
        });
        return attribs;
      };
      var compareObjects = function(obj1, obj2) {
        var value2, name2;
        for (name2 in obj1) {
          if (obj1.hasOwnProperty(name2)) {
            value2 = obj2[name2];
            if (typeof value2 === "undefined") {
              return false;
            }
            if (obj1[name2] !== value2) {
              return false;
            }
            delete obj2[name2];
          }
        }
        for (name2 in obj2) {
          if (obj2.hasOwnProperty(name2)) {
            return false;
          }
        }
        return true;
      };
      if (!compareObjects(getAttribs(node1), getAttribs(node2))) {
        return false;
      }
      if (!compareObjects(dom2.parseStyle(dom2.getAttrib(node1, "style")), dom2.parseStyle(dom2.getAttrib(node2, "style")))) {
        return false;
      }
      return !isBookmarkNode$1(node1) && !isBookmarkNode$1(node2);
    };
    return { compare };
  };
  var makeMap$3 = Tools.makeMap;
  var Writer = function(settings) {
    var html = [];
    settings = settings || {};
    var indent = settings.indent;
    var indentBefore = makeMap$3(settings.indent_before || "");
    var indentAfter = makeMap$3(settings.indent_after || "");
    var encode = Entities.getEncodeFunc(settings.entity_encoding || "raw", settings.entities);
    var htmlOutput = settings.element_format === "html";
    return {
      start: function(name2, attrs, empty2) {
        var i, l2, attr, value2;
        if (indent && indentBefore[name2] && html.length > 0) {
          value2 = html[html.length - 1];
          if (value2.length > 0 && value2 !== "\n") {
            html.push("\n");
          }
        }
        html.push("<", name2);
        if (attrs) {
          for (i = 0, l2 = attrs.length; i < l2; i++) {
            attr = attrs[i];
            html.push(" ", attr.name, '="', encode(attr.value, true), '"');
          }
        }
        if (!empty2 || htmlOutput) {
          html[html.length] = ">";
        } else {
          html[html.length] = " />";
        }
        if (empty2 && indent && indentAfter[name2] && html.length > 0) {
          value2 = html[html.length - 1];
          if (value2.length > 0 && value2 !== "\n") {
            html.push("\n");
          }
        }
      },
      end: function(name2) {
        var value2;
        html.push("</", name2, ">");
        if (indent && indentAfter[name2] && html.length > 0) {
          value2 = html[html.length - 1];
          if (value2.length > 0 && value2 !== "\n") {
            html.push("\n");
          }
        }
      },
      text: function(text, raw) {
        if (text.length > 0) {
          html[html.length] = raw ? text : encode(text);
        }
      },
      cdata: function(text) {
        html.push("<![CDATA[", text, "]]>");
      },
      comment: function(text) {
        html.push("<!--", text, "-->");
      },
      pi: function(name2, text) {
        if (text) {
          html.push("<?", name2, " ", encode(text), "?>");
        } else {
          html.push("<?", name2, "?>");
        }
        if (indent) {
          html.push("\n");
        }
      },
      doctype: function(text) {
        html.push("<!DOCTYPE", text, ">", indent ? "\n" : "");
      },
      reset: function() {
        html.length = 0;
      },
      getContent: function() {
        return html.join("").replace(/\n$/, "");
      }
    };
  };
  var HtmlSerializer = function(settings, schema) {
    if (schema === void 0) {
      schema = Schema();
    }
    var writer = Writer(settings);
    settings = settings || {};
    settings.validate = "validate" in settings ? settings.validate : true;
    var serialize2 = function(node) {
      var validate2 = settings.validate;
      var handlers = {
        3: function(node2) {
          writer.text(node2.value, node2.raw);
        },
        8: function(node2) {
          writer.comment(node2.value);
        },
        7: function(node2) {
          writer.pi(node2.name, node2.value);
        },
        10: function(node2) {
          writer.doctype(node2.value);
        },
        4: function(node2) {
          writer.cdata(node2.value);
        },
        11: function(node2) {
          if (node2 = node2.firstChild) {
            do {
              walk2(node2);
            } while (node2 = node2.next);
          }
        }
      };
      writer.reset();
      var walk2 = function(node2) {
        var handler = handlers[node2.type];
        var name2, isEmpty2, attrs, attrName, attrValue, sortedAttrs, i, l2, elementRule;
        if (!handler) {
          name2 = node2.name;
          isEmpty2 = node2.shortEnded;
          attrs = node2.attributes;
          if (validate2 && attrs && attrs.length > 1) {
            sortedAttrs = [];
            sortedAttrs.map = {};
            elementRule = schema.getElementRule(node2.name);
            if (elementRule) {
              for (i = 0, l2 = elementRule.attributesOrder.length; i < l2; i++) {
                attrName = elementRule.attributesOrder[i];
                if (attrName in attrs.map) {
                  attrValue = attrs.map[attrName];
                  sortedAttrs.map[attrName] = attrValue;
                  sortedAttrs.push({
                    name: attrName,
                    value: attrValue
                  });
                }
              }
              for (i = 0, l2 = attrs.length; i < l2; i++) {
                attrName = attrs[i].name;
                if (!(attrName in sortedAttrs.map)) {
                  attrValue = attrs.map[attrName];
                  sortedAttrs.map[attrName] = attrValue;
                  sortedAttrs.push({
                    name: attrName,
                    value: attrValue
                  });
                }
              }
              attrs = sortedAttrs;
            }
          }
          writer.start(node2.name, attrs, isEmpty2);
          if (!isEmpty2) {
            if (node2 = node2.firstChild) {
              do {
                walk2(node2);
              } while (node2 = node2.next);
            }
            writer.end(name2);
          }
        } else {
          handler(node2);
        }
      };
      if (node.type === 1 && !settings.inner) {
        walk2(node);
      } else {
        handlers[11](node);
      }
      return writer.getContent();
    };
    return { serialize: serialize2 };
  };
  var nonInheritableStyles = /* @__PURE__ */ new Set();
  (function() {
    var nonInheritableStylesArr = [
      "margin",
      "margin-left",
      "margin-right",
      "margin-top",
      "margin-bottom",
      "padding",
      "padding-left",
      "padding-right",
      "padding-top",
      "padding-bottom",
      "border",
      "border-width",
      "border-style",
      "border-color",
      "background",
      "background-attachment",
      "background-clip",
      "background-color",
      "background-image",
      "background-origin",
      "background-position",
      "background-repeat",
      "background-size",
      "float",
      "position",
      "left",
      "right",
      "top",
      "bottom",
      "z-index",
      "display",
      "transform",
      "width",
      "max-width",
      "min-width",
      "height",
      "max-height",
      "min-height",
      "overflow",
      "overflow-x",
      "overflow-y",
      "text-overflow",
      "vertical-align",
      "transition",
      "transition-delay",
      "transition-duration",
      "transition-property",
      "transition-timing-function"
    ];
    each(nonInheritableStylesArr, function(style) {
      nonInheritableStyles.add(style);
    });
  })();
  var shorthandStyleProps = [
    "font",
    "text-decoration",
    "text-emphasis"
  ];
  var getStyleProps = function(dom2, node) {
    return keys(dom2.parseStyle(dom2.getAttrib(node, "style")));
  };
  var isNonInheritableStyle = function(style) {
    return nonInheritableStyles.has(style);
  };
  var hasInheritableStyles = function(dom2, node) {
    return forall(getStyleProps(dom2, node), function(style) {
      return !isNonInheritableStyle(style);
    });
  };
  var getLonghandStyleProps = function(styles) {
    return filter(styles, function(style) {
      return exists(shorthandStyleProps, function(prop) {
        return startsWith(style, prop);
      });
    });
  };
  var hasStyleConflict = function(dom2, node, parentNode) {
    var nodeStyleProps = getStyleProps(dom2, node);
    var parentNodeStyleProps = getStyleProps(dom2, parentNode);
    var valueMismatch = function(prop) {
      var nodeValue = dom2.getStyle(node, prop);
      var parentValue = dom2.getStyle(parentNode, prop);
      return isNotEmpty(nodeValue) && isNotEmpty(parentValue) && nodeValue !== parentValue;
    };
    return exists(nodeStyleProps, function(nodeStyleProp) {
      var propExists = function(props) {
        return exists(props, function(prop) {
          return prop === nodeStyleProp;
        });
      };
      if (!propExists(parentNodeStyleProps) && propExists(shorthandStyleProps)) {
        var longhandProps = getLonghandStyleProps(parentNodeStyleProps);
        return exists(longhandProps, valueMismatch);
      } else {
        return valueMismatch(nodeStyleProp);
      }
    });
  };
  var isChar = function(forward, predicate, pos) {
    return Optional.from(pos.container()).filter(isText$1).exists(function(text) {
      var delta = forward ? 0 : -1;
      return predicate(text.data.charAt(pos.offset() + delta));
    });
  };
  var isBeforeSpace = curry(isChar, true, isWhiteSpace$1);
  var isAfterSpace = curry(isChar, false, isWhiteSpace$1);
  var isEmptyText = function(pos) {
    var container = pos.container();
    return isText$1(container) && (container.data.length === 0 || isZwsp$1(container.data) && BookmarkManager.isBookmarkNode(container.parentNode));
  };
  var matchesElementPosition = function(before2, predicate) {
    return function(pos) {
      return Optional.from(getChildNodeAtRelativeOffset(before2 ? 0 : -1, pos)).filter(predicate).isSome();
    };
  };
  var isImageBlock = function(node) {
    return isImg(node) && get$5(SugarElement.fromDom(node), "display") === "block";
  };
  var isCefNode = function(node) {
    return isContentEditableFalse(node) && !isBogusAll(node);
  };
  var isBeforeImageBlock = matchesElementPosition(true, isImageBlock);
  var isAfterImageBlock = matchesElementPosition(false, isImageBlock);
  var isBeforeMedia = matchesElementPosition(true, isMedia);
  var isAfterMedia = matchesElementPosition(false, isMedia);
  var isBeforeTable = matchesElementPosition(true, isTable);
  var isAfterTable = matchesElementPosition(false, isTable);
  var isBeforeContentEditableFalse = matchesElementPosition(true, isCefNode);
  var isAfterContentEditableFalse = matchesElementPosition(false, isCefNode);
  var getLastChildren$1 = function(elm) {
    var children2 = [];
    var rawNode = elm.dom;
    while (rawNode) {
      children2.push(SugarElement.fromDom(rawNode));
      rawNode = rawNode.lastChild;
    }
    return children2;
  };
  var removeTrailingBr = function(elm) {
    var allBrs = descendants$1(elm, "br");
    var brs = filter(getLastChildren$1(elm).slice(-1), isBr$1);
    if (allBrs.length === brs.length) {
      each(brs, remove);
    }
  };
  var fillWithPaddingBr = function(elm) {
    empty(elm);
    append(elm, SugarElement.fromHtml('<br data-mce-bogus="1">'));
  };
  var trimBlockTrailingBr = function(elm) {
    lastChild(elm).each(function(lastChild2) {
      prevSibling(lastChild2).each(function(lastChildPrevSibling) {
        if (isBlock(elm) && isBr$1(lastChild2) && isBlock(lastChildPrevSibling)) {
          remove(lastChild2);
        }
      });
    });
  };
  var dropLast = function(xs) {
    return xs.slice(0, -1);
  };
  var parentsUntil$1 = function(start2, root, predicate) {
    if (contains$2(root, start2)) {
      return dropLast(parents(start2, function(elm) {
        return predicate(elm) || eq$2(elm, root);
      }));
    } else {
      return [];
    }
  };
  var parents$1 = function(start2, root) {
    return parentsUntil$1(start2, root, never);
  };
  var parentsAndSelf = function(start2, root) {
    return [start2].concat(parents$1(start2, root));
  };
  var navigateIgnoreEmptyTextNodes = function(forward, root, from2) {
    return navigateIgnore(forward, root, from2, isEmptyText);
  };
  var getClosestBlock = function(root, pos) {
    return find(parentsAndSelf(SugarElement.fromDom(pos.container()), root), isBlock);
  };
  var isAtBeforeAfterBlockBoundary = function(forward, root, pos) {
    return navigateIgnoreEmptyTextNodes(forward, root.dom, pos).forall(function(newPos) {
      return getClosestBlock(root, pos).fold(function() {
        return isInSameBlock(newPos, pos, root.dom) === false;
      }, function(fromBlock) {
        return isInSameBlock(newPos, pos, root.dom) === false && contains$2(fromBlock, SugarElement.fromDom(newPos.container()));
      });
    });
  };
  var isAtBlockBoundary$1 = function(forward, root, pos) {
    return getClosestBlock(root, pos).fold(function() {
      return navigateIgnoreEmptyTextNodes(forward, root.dom, pos).forall(function(newPos) {
        return isInSameBlock(newPos, pos, root.dom) === false;
      });
    }, function(parent2) {
      return navigateIgnoreEmptyTextNodes(forward, parent2.dom, pos).isNone();
    });
  };
  var isAtStartOfBlock = curry(isAtBlockBoundary$1, false);
  var isAtEndOfBlock = curry(isAtBlockBoundary$1, true);
  var isBeforeBlock = curry(isAtBeforeAfterBlockBoundary, false);
  var isAfterBlock = curry(isAtBeforeAfterBlockBoundary, true);
  var isBr$5 = function(pos) {
    return getElementFromPosition(pos).exists(isBr$1);
  };
  var findBr = function(forward, root, pos) {
    var parentBlocks = filter(parentsAndSelf(SugarElement.fromDom(pos.container()), root), isBlock);
    var scope = head(parentBlocks).getOr(root);
    return fromPosition(forward, scope.dom, pos).filter(isBr$5);
  };
  var isBeforeBr = function(root, pos) {
    return getElementFromPosition(pos).exists(isBr$1) || findBr(true, root, pos).isSome();
  };
  var isAfterBr = function(root, pos) {
    return getElementFromPrevPosition(pos).exists(isBr$1) || findBr(false, root, pos).isSome();
  };
  var findPreviousBr = curry(findBr, false);
  var findNextBr = curry(findBr, true);
  var isInMiddleOfText = function(pos) {
    return CaretPosition.isTextPosition(pos) && !pos.isAtStart() && !pos.isAtEnd();
  };
  var getClosestBlock$1 = function(root, pos) {
    var parentBlocks = filter(parentsAndSelf(SugarElement.fromDom(pos.container()), root), isBlock);
    return head(parentBlocks).getOr(root);
  };
  var hasSpaceBefore = function(root, pos) {
    if (isInMiddleOfText(pos)) {
      return isAfterSpace(pos);
    } else {
      return isAfterSpace(pos) || prevPosition(getClosestBlock$1(root, pos).dom, pos).exists(isAfterSpace);
    }
  };
  var hasSpaceAfter = function(root, pos) {
    if (isInMiddleOfText(pos)) {
      return isBeforeSpace(pos);
    } else {
      return isBeforeSpace(pos) || nextPosition(getClosestBlock$1(root, pos).dom, pos).exists(isBeforeSpace);
    }
  };
  var isPreValue = function(value2) {
    return contains([
      "pre",
      "pre-wrap"
    ], value2);
  };
  var isInPre = function(pos) {
    return getElementFromPosition(pos).bind(function(elm) {
      return closest(elm, isElement);
    }).exists(function(elm) {
      return isPreValue(get$5(elm, "white-space"));
    });
  };
  var isAtBeginningOfBody = function(root, pos) {
    return prevPosition(root.dom, pos).isNone();
  };
  var isAtEndOfBody = function(root, pos) {
    return nextPosition(root.dom, pos).isNone();
  };
  var isAtLineBoundary = function(root, pos) {
    return isAtBeginningOfBody(root, pos) || isAtEndOfBody(root, pos) || isAtStartOfBlock(root, pos) || isAtEndOfBlock(root, pos) || isAfterBr(root, pos) || isBeforeBr(root, pos);
  };
  var needsToHaveNbsp = function(root, pos) {
    if (isInPre(pos)) {
      return false;
    } else {
      return isAtLineBoundary(root, pos) || hasSpaceBefore(root, pos) || hasSpaceAfter(root, pos);
    }
  };
  var needsToBeNbspLeft = function(root, pos) {
    if (isInPre(pos)) {
      return false;
    } else {
      return isAtStartOfBlock(root, pos) || isBeforeBlock(root, pos) || isAfterBr(root, pos) || hasSpaceBefore(root, pos);
    }
  };
  var leanRight = function(pos) {
    var container = pos.container();
    var offset = pos.offset();
    if (isText$1(container) && offset < container.data.length) {
      return CaretPosition(container, offset + 1);
    } else {
      return pos;
    }
  };
  var needsToBeNbspRight = function(root, pos) {
    if (isInPre(pos)) {
      return false;
    } else {
      return isAtEndOfBlock(root, pos) || isAfterBlock(root, pos) || isBeforeBr(root, pos) || hasSpaceAfter(root, pos);
    }
  };
  var needsToBeNbsp = function(root, pos) {
    return needsToBeNbspLeft(root, pos) || needsToBeNbspRight(root, leanRight(pos));
  };
  var isNbspAt = function(text, offset) {
    return isNbsp(text.charAt(offset));
  };
  var hasNbsp = function(pos) {
    var container = pos.container();
    return isText$1(container) && contains$1(container.data, nbsp);
  };
  var normalizeNbspMiddle = function(text) {
    var chars = text.split("");
    return map(chars, function(chr, i) {
      if (isNbsp(chr) && i > 0 && i < chars.length - 1 && isContent$1(chars[i - 1]) && isContent$1(chars[i + 1])) {
        return " ";
      } else {
        return chr;
      }
    }).join("");
  };
  var normalizeNbspAtStart = function(root, node) {
    var text = node.data;
    var firstPos = CaretPosition(node, 0);
    if (isNbspAt(text, 0) && !needsToBeNbsp(root, firstPos)) {
      node.data = " " + text.slice(1);
      return true;
    } else {
      return false;
    }
  };
  var normalizeNbspInMiddleOfTextNode = function(node) {
    var text = node.data;
    var newText = normalizeNbspMiddle(text);
    if (newText !== text) {
      node.data = newText;
      return true;
    } else {
      return false;
    }
  };
  var normalizeNbspAtEnd = function(root, node) {
    var text = node.data;
    var lastPos = CaretPosition(node, text.length - 1);
    if (isNbspAt(text, text.length - 1) && !needsToBeNbsp(root, lastPos)) {
      node.data = text.slice(0, -1) + " ";
      return true;
    } else {
      return false;
    }
  };
  var normalizeNbsps = function(root, pos) {
    return Optional.some(pos).filter(hasNbsp).bind(function(pos2) {
      var container = pos2.container();
      var normalized = normalizeNbspAtStart(root, container) || normalizeNbspInMiddleOfTextNode(container) || normalizeNbspAtEnd(root, container);
      return normalized ? Optional.some(pos2) : Optional.none();
    });
  };
  var normalizeNbspsInEditor = function(editor) {
    var root = SugarElement.fromDom(editor.getBody());
    if (editor.selection.isCollapsed()) {
      normalizeNbsps(root, CaretPosition.fromRangeStart(editor.selection.getRng())).each(function(pos) {
        editor.selection.setRng(pos.toRange());
      });
    }
  };
  var normalizeContent = function(content, isStartOfContent, isEndOfContent) {
    var result = foldl(content, function(acc, c) {
      if (isWhiteSpace$1(c) || isNbsp(c)) {
        if (acc.previousCharIsSpace || acc.str === "" && isStartOfContent || acc.str.length === content.length - 1 && isEndOfContent) {
          return {
            previousCharIsSpace: false,
            str: acc.str + nbsp
          };
        } else {
          return {
            previousCharIsSpace: true,
            str: acc.str + " "
          };
        }
      } else {
        return {
          previousCharIsSpace: false,
          str: acc.str + c
        };
      }
    }, {
      previousCharIsSpace: false,
      str: ""
    });
    return result.str;
  };
  var normalize$1 = function(node, offset, count2) {
    if (count2 === 0) {
      return;
    }
    var elm = SugarElement.fromDom(node);
    var root = ancestor(elm, isBlock).getOr(elm);
    var whitespace2 = node.data.slice(offset, offset + count2);
    var isEndOfContent = offset + count2 >= node.data.length && needsToBeNbspRight(root, CaretPosition(node, node.data.length));
    var isStartOfContent = offset === 0 && needsToBeNbspLeft(root, CaretPosition(node, 0));
    node.replaceData(offset, count2, normalizeContent(whitespace2, isStartOfContent, isEndOfContent));
  };
  var normalizeWhitespaceAfter = function(node, offset) {
    var content = node.data.slice(offset);
    var whitespaceCount = content.length - lTrim(content).length;
    return normalize$1(node, offset, whitespaceCount);
  };
  var normalizeWhitespaceBefore = function(node, offset) {
    var content = node.data.slice(0, offset);
    var whitespaceCount = content.length - rTrim(content).length;
    return normalize$1(node, offset - whitespaceCount, whitespaceCount);
  };
  var mergeTextNodes = function(prevNode, nextNode, normalizeWhitespace, mergeToPrev) {
    if (mergeToPrev === void 0) {
      mergeToPrev = true;
    }
    var whitespaceOffset = rTrim(prevNode.data).length;
    var newNode = mergeToPrev ? prevNode : nextNode;
    var removeNode2 = mergeToPrev ? nextNode : prevNode;
    if (mergeToPrev) {
      newNode.appendData(removeNode2.data);
    } else {
      newNode.insertData(0, removeNode2.data);
    }
    remove(SugarElement.fromDom(removeNode2));
    if (normalizeWhitespace) {
      normalizeWhitespaceAfter(newNode, whitespaceOffset);
    }
    return newNode;
  };
  var needsReposition = function(pos, elm) {
    var container = pos.container();
    var offset = pos.offset();
    return CaretPosition.isTextPosition(pos) === false && container === elm.parentNode && offset > CaretPosition.before(elm).offset();
  };
  var reposition = function(elm, pos) {
    return needsReposition(pos, elm) ? CaretPosition(pos.container(), pos.offset() - 1) : pos;
  };
  var beforeOrStartOf = function(node) {
    return isText$1(node) ? CaretPosition(node, 0) : CaretPosition.before(node);
  };
  var afterOrEndOf = function(node) {
    return isText$1(node) ? CaretPosition(node, node.data.length) : CaretPosition.after(node);
  };
  var getPreviousSiblingCaretPosition = function(elm) {
    if (isCaretCandidate(elm.previousSibling)) {
      return Optional.some(afterOrEndOf(elm.previousSibling));
    } else {
      return elm.previousSibling ? lastPositionIn(elm.previousSibling) : Optional.none();
    }
  };
  var getNextSiblingCaretPosition = function(elm) {
    if (isCaretCandidate(elm.nextSibling)) {
      return Optional.some(beforeOrStartOf(elm.nextSibling));
    } else {
      return elm.nextSibling ? firstPositionIn(elm.nextSibling) : Optional.none();
    }
  };
  var findCaretPositionBackwardsFromElm = function(rootElement, elm) {
    var startPosition = CaretPosition.before(elm.previousSibling ? elm.previousSibling : elm.parentNode);
    return prevPosition(rootElement, startPosition).fold(function() {
      return nextPosition(rootElement, CaretPosition.after(elm));
    }, Optional.some);
  };
  var findCaretPositionForwardsFromElm = function(rootElement, elm) {
    return nextPosition(rootElement, CaretPosition.after(elm)).fold(function() {
      return prevPosition(rootElement, CaretPosition.before(elm));
    }, Optional.some);
  };
  var findCaretPositionBackwards = function(rootElement, elm) {
    return getPreviousSiblingCaretPosition(elm).orThunk(function() {
      return getNextSiblingCaretPosition(elm);
    }).orThunk(function() {
      return findCaretPositionBackwardsFromElm(rootElement, elm);
    });
  };
  var findCaretPositionForward = function(rootElement, elm) {
    return getNextSiblingCaretPosition(elm).orThunk(function() {
      return getPreviousSiblingCaretPosition(elm);
    }).orThunk(function() {
      return findCaretPositionForwardsFromElm(rootElement, elm);
    });
  };
  var findCaretPosition$1 = function(forward, rootElement, elm) {
    return forward ? findCaretPositionForward(rootElement, elm) : findCaretPositionBackwards(rootElement, elm);
  };
  var findCaretPosOutsideElmAfterDelete = function(forward, rootElement, elm) {
    return findCaretPosition$1(forward, rootElement, elm).map(curry(reposition, elm));
  };
  var setSelection = function(editor, forward, pos) {
    pos.fold(function() {
      editor.focus();
    }, function(pos2) {
      editor.selection.setRng(pos2.toRange(), forward);
    });
  };
  var eqRawNode = function(rawNode) {
    return function(elm) {
      return elm.dom === rawNode;
    };
  };
  var isBlock$2 = function(editor, elm) {
    return elm && has(editor.schema.getBlockElements(), name(elm));
  };
  var paddEmptyBlock = function(elm) {
    if (isEmpty(elm)) {
      var br = SugarElement.fromHtml('<br data-mce-bogus="1">');
      empty(elm);
      append(elm, br);
      return Optional.some(CaretPosition.before(br.dom));
    } else {
      return Optional.none();
    }
  };
  var deleteNormalized = function(elm, afterDeletePosOpt, normalizeWhitespace) {
    var prevTextOpt = prevSibling(elm).filter(isText);
    var nextTextOpt = nextSibling(elm).filter(isText);
    remove(elm);
    return lift3(prevTextOpt, nextTextOpt, afterDeletePosOpt, function(prev, next, pos) {
      var prevNode = prev.dom, nextNode = next.dom;
      var offset = prevNode.data.length;
      mergeTextNodes(prevNode, nextNode, normalizeWhitespace);
      return pos.container() === nextNode ? CaretPosition(prevNode, offset) : pos;
    }).orThunk(function() {
      if (normalizeWhitespace) {
        prevTextOpt.each(function(elm2) {
          return normalizeWhitespaceBefore(elm2.dom, elm2.dom.length);
        });
        nextTextOpt.each(function(elm2) {
          return normalizeWhitespaceAfter(elm2.dom, 0);
        });
      }
      return afterDeletePosOpt;
    });
  };
  var isInlineElement = function(editor, element) {
    return has(editor.schema.getTextInlineElements(), name(element));
  };
  var deleteElement = function(editor, forward, elm, moveCaret2) {
    if (moveCaret2 === void 0) {
      moveCaret2 = true;
    }
    var afterDeletePos = findCaretPosOutsideElmAfterDelete(forward, editor.getBody(), elm.dom);
    var parentBlock = ancestor(elm, curry(isBlock$2, editor), eqRawNode(editor.getBody()));
    var normalizedAfterDeletePos = deleteNormalized(elm, afterDeletePos, isInlineElement(editor, elm));
    if (editor.dom.isEmpty(editor.getBody())) {
      editor.setContent("");
      editor.selection.setCursorLocation();
    } else {
      parentBlock.bind(paddEmptyBlock).fold(function() {
        if (moveCaret2) {
          setSelection(editor, forward, normalizedAfterDeletePos);
        }
      }, function(paddPos) {
        if (moveCaret2) {
          setSelection(editor, forward, Optional.some(paddPos));
        }
      });
    }
  };
  var tableCellRng = function(start2, end2) {
    return {
      start: start2,
      end: end2
    };
  };
  var tableSelection = function(rng, table, cells) {
    return {
      rng,
      table,
      cells
    };
  };
  var deleteAction = Adt.generate([
    { removeTable: ["element"] },
    { emptyCells: ["cells"] },
    {
      deleteCellSelection: [
        "rng",
        "cell"
      ]
    }
  ]);
  var isRootFromElement = function(root) {
    return function(cur) {
      return eq$2(root, cur);
    };
  };
  var getClosestCell = function(container, isRoot) {
    return closest$1(SugarElement.fromDom(container), "td,th", isRoot);
  };
  var getClosestTable = function(cell, isRoot) {
    return ancestor$1(cell, "table", isRoot);
  };
  var isExpandedCellRng = function(cellRng) {
    return !eq$2(cellRng.start, cellRng.end);
  };
  var getTableFromCellRng = function(cellRng, isRoot) {
    return getClosestTable(cellRng.start, isRoot).bind(function(startParentTable) {
      return getClosestTable(cellRng.end, isRoot).bind(function(endParentTable) {
        return someIf(eq$2(startParentTable, endParentTable), startParentTable);
      });
    });
  };
  var isSingleCellTable = function(cellRng, isRoot) {
    return !isExpandedCellRng(cellRng) && getTableFromCellRng(cellRng, isRoot).exists(function(table) {
      var rows = table.dom.rows;
      return rows.length === 1 && rows[0].cells.length === 1;
    });
  };
  var getTableCells = function(table) {
    return descendants$1(table, "td,th");
  };
  var getCellRng = function(rng, isRoot) {
    var startCell = getClosestCell(rng.startContainer, isRoot);
    var endCell = getClosestCell(rng.endContainer, isRoot);
    return lift2(startCell, endCell, tableCellRng);
  };
  var getCellRangeFromStartTable = function(cellRng, isRoot) {
    return getClosestTable(cellRng.start, isRoot).bind(function(table) {
      return last(getTableCells(table)).map(function(endCell) {
        return tableCellRng(cellRng.start, endCell);
      });
    });
  };
  var partialSelection = function(isRoot, rng) {
    var startCell = getClosestCell(rng.startContainer, isRoot);
    var endCell = getClosestCell(rng.endContainer, isRoot);
    return rng.collapsed ? Optional.none() : lift2(startCell, endCell, tableCellRng).fold(function() {
      return startCell.fold(function() {
        return endCell.bind(function(endCell2) {
          return getClosestTable(endCell2, isRoot).bind(function(table) {
            return head(getTableCells(table)).map(function(startCell2) {
              return tableCellRng(startCell2, endCell2);
            });
          });
        });
      }, function(startCell2) {
        return getClosestTable(startCell2, isRoot).bind(function(table) {
          return last(getTableCells(table)).map(function(endCell2) {
            return tableCellRng(startCell2, endCell2);
          });
        });
      });
    }, function(cellRng) {
      return isWithinSameTable(isRoot, cellRng) ? Optional.none() : getCellRangeFromStartTable(cellRng, isRoot);
    });
  };
  var isWithinSameTable = function(isRoot, cellRng) {
    return getTableFromCellRng(cellRng, isRoot).isSome();
  };
  var getTableSelectionFromCellRng = function(cellRng, isRoot) {
    return getTableFromCellRng(cellRng, isRoot).map(function(table) {
      return tableSelection(cellRng, table, getTableCells(table));
    });
  };
  var getTableSelection = function(optCellRng, rng, isRoot) {
    return optCellRng.filter(function(cellRng) {
      return isExpandedCellRng(cellRng) && isWithinSameTable(isRoot, cellRng);
    }).orThunk(function() {
      return partialSelection(isRoot, rng);
    }).bind(function(cRng) {
      return getTableSelectionFromCellRng(cRng, isRoot);
    });
  };
  var getCellIndex = function(cells, cell) {
    return findIndex(cells, function(x2) {
      return eq$2(x2, cell);
    });
  };
  var getSelectedCells = function(tableSelection2) {
    return lift2(getCellIndex(tableSelection2.cells, tableSelection2.rng.start), getCellIndex(tableSelection2.cells, tableSelection2.rng.end), function(startIndex, endIndex) {
      return tableSelection2.cells.slice(startIndex, endIndex + 1);
    });
  };
  var isSingleCellTableContentSelected = function(optCellRng, rng, isRoot) {
    return optCellRng.filter(function(cellRng) {
      return isSingleCellTable(cellRng, isRoot) && hasAllContentsSelected(cellRng.start, rng);
    }).map(function(cellRng) {
      return cellRng.start;
    });
  };
  var getAction = function(tableSelection2) {
    return getSelectedCells(tableSelection2).map(function(selected) {
      var cells = tableSelection2.cells;
      return selected.length === cells.length ? deleteAction.removeTable(tableSelection2.table) : deleteAction.emptyCells(selected);
    });
  };
  var getActionFromRange = function(root, rng) {
    var isRoot = isRootFromElement(root);
    var optCellRng = getCellRng(rng, isRoot);
    return isSingleCellTableContentSelected(optCellRng, rng, isRoot).map(function(cell) {
      return deleteAction.deleteCellSelection(rng, cell);
    }).orThunk(function() {
      return getTableSelection(optCellRng, rng, isRoot).bind(getAction);
    });
  };
  var freefallRtl = function(root) {
    var child2 = isComment(root) ? prevSibling(root) : lastChild(root);
    return child2.bind(freefallRtl).orThunk(function() {
      return Optional.some(root);
    });
  };
  var emptyCells = function(editor, cells) {
    each(cells, fillWithPaddingBr);
    editor.selection.setCursorLocation(cells[0].dom, 0);
    return true;
  };
  var deleteCellContents = function(editor, rng, cell) {
    rng.deleteContents();
    var lastNode = freefallRtl(cell).getOr(cell);
    var lastBlock = SugarElement.fromDom(editor.dom.getParent(lastNode.dom, editor.dom.isBlock));
    if (isEmpty(lastBlock)) {
      fillWithPaddingBr(lastBlock);
      editor.selection.setCursorLocation(lastBlock.dom, 0);
    }
    if (!eq$2(cell, lastBlock)) {
      var additionalCleanupNodes = parent(lastBlock).is(cell) ? [] : siblings(lastBlock);
      each(additionalCleanupNodes.concat(children(cell)), function(node) {
        if (!eq$2(node, lastBlock) && !contains$2(node, lastBlock)) {
          remove(node);
        }
      });
    }
    return true;
  };
  var deleteTableElement = function(editor, table) {
    deleteElement(editor, false, table);
    return true;
  };
  var deleteCellRange = function(editor, rootElm, rng) {
    return getActionFromRange(rootElm, rng).map(function(action2) {
      return action2.fold(curry(deleteTableElement, editor), curry(emptyCells, editor), curry(deleteCellContents, editor));
    });
  };
  var deleteCaptionRange = function(editor, caption) {
    return emptyElement(editor, caption);
  };
  var deleteTableRange = function(editor, rootElm, rng, startElm) {
    return getParentCaption(rootElm, startElm).fold(function() {
      return deleteCellRange(editor, rootElm, rng);
    }, function(caption) {
      return deleteCaptionRange(editor, caption);
    }).getOr(false);
  };
  var deleteRange = function(editor, startElm) {
    var rootNode = SugarElement.fromDom(editor.getBody());
    var rng = editor.selection.getRng();
    var selectedCells = getCellsFromEditor(editor);
    return selectedCells.length !== 0 ? emptyCells(editor, selectedCells) : deleteTableRange(editor, rootNode, rng, startElm);
  };
  var getParentCell = function(rootElm, elm) {
    return find(parentsAndSelf(elm, rootElm), isTableCell$1);
  };
  var getParentCaption = function(rootElm, elm) {
    return find(parentsAndSelf(elm, rootElm), function(elm2) {
      return name(elm2) === "caption";
    });
  };
  var deleteBetweenCells = function(editor, rootElm, forward, fromCell, from2) {
    return navigate(forward, editor.getBody(), from2).bind(function(to2) {
      return getParentCell(rootElm, SugarElement.fromDom(to2.getNode())).map(function(toCell) {
        return eq$2(toCell, fromCell) === false;
      });
    });
  };
  var emptyElement = function(editor, elm) {
    fillWithPaddingBr(elm);
    editor.selection.setCursorLocation(elm.dom, 0);
    return Optional.some(true);
  };
  var isDeleteOfLastCharPos = function(fromCaption, forward, from2, to2) {
    return firstPositionIn(fromCaption.dom).bind(function(first2) {
      return lastPositionIn(fromCaption.dom).map(function(last2) {
        return forward ? from2.isEqual(first2) && to2.isEqual(last2) : from2.isEqual(last2) && to2.isEqual(first2);
      });
    }).getOr(true);
  };
  var emptyCaretCaption = function(editor, elm) {
    return emptyElement(editor, elm);
  };
  var validateCaretCaption = function(rootElm, fromCaption, to2) {
    return getParentCaption(rootElm, SugarElement.fromDom(to2.getNode())).map(function(toCaption) {
      return eq$2(toCaption, fromCaption) === false;
    });
  };
  var deleteCaretInsideCaption = function(editor, rootElm, forward, fromCaption, from2) {
    return navigate(forward, editor.getBody(), from2).bind(function(to2) {
      return isDeleteOfLastCharPos(fromCaption, forward, from2, to2) ? emptyCaretCaption(editor, fromCaption) : validateCaretCaption(rootElm, fromCaption, to2);
    }).or(Optional.some(true));
  };
  var deleteCaretCells = function(editor, forward, rootElm, startElm) {
    var from2 = CaretPosition.fromRangeStart(editor.selection.getRng());
    return getParentCell(rootElm, startElm).bind(function(fromCell) {
      return isEmpty(fromCell) ? emptyElement(editor, fromCell) : deleteBetweenCells(editor, rootElm, forward, fromCell, from2);
    }).getOr(false);
  };
  var deleteCaretCaption = function(editor, forward, rootElm, fromCaption) {
    var from2 = CaretPosition.fromRangeStart(editor.selection.getRng());
    return isEmpty(fromCaption) ? emptyElement(editor, fromCaption) : deleteCaretInsideCaption(editor, rootElm, forward, fromCaption, from2);
  };
  var isNearTable = function(forward, pos) {
    return forward ? isBeforeTable(pos) : isAfterTable(pos);
  };
  var isBeforeOrAfterTable = function(editor, forward) {
    var fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());
    return isNearTable(forward, fromPos) || fromPosition(forward, editor.getBody(), fromPos).exists(function(pos) {
      return isNearTable(forward, pos);
    });
  };
  var deleteCaret = function(editor, forward, startElm) {
    var rootElm = SugarElement.fromDom(editor.getBody());
    return getParentCaption(rootElm, startElm).fold(function() {
      return deleteCaretCells(editor, forward, rootElm, startElm) || isBeforeOrAfterTable(editor, forward);
    }, function(fromCaption) {
      return deleteCaretCaption(editor, forward, rootElm, fromCaption).getOr(false);
    });
  };
  var backspaceDelete = function(editor, forward) {
    var startElm = SugarElement.fromDom(editor.selection.getStart(true));
    var cells = getCellsFromEditor(editor);
    return editor.selection.isCollapsed() && cells.length === 0 ? deleteCaret(editor, forward, startElm) : deleteRange(editor, startElm);
  };
  var createRange$1 = function(sc2, so, ec2, eo) {
    var rng = document.createRange();
    rng.setStart(sc2, so);
    rng.setEnd(ec2, eo);
    return rng;
  };
  var normalizeBlockSelectionRange = function(rng) {
    var startPos = CaretPosition.fromRangeStart(rng);
    var endPos = CaretPosition.fromRangeEnd(rng);
    var rootNode = rng.commonAncestorContainer;
    return fromPosition(false, rootNode, endPos).map(function(newEndPos) {
      if (!isInSameBlock(startPos, endPos, rootNode) && isInSameBlock(startPos, newEndPos, rootNode)) {
        return createRange$1(startPos.container(), startPos.offset(), newEndPos.container(), newEndPos.offset());
      } else {
        return rng;
      }
    }).getOr(rng);
  };
  var normalize$2 = function(rng) {
    return rng.collapsed ? rng : normalizeBlockSelectionRange(rng);
  };
  var hasOnlyOneChild = function(node) {
    return node.firstChild && node.firstChild === node.lastChild;
  };
  var isPaddingNode = function(node) {
    return node.name === "br" || node.value === nbsp;
  };
  var isPaddedEmptyBlock = function(schema, node) {
    var blockElements = schema.getBlockElements();
    return blockElements[node.name] && hasOnlyOneChild(node) && isPaddingNode(node.firstChild);
  };
  var isEmptyFragmentElement = function(schema, node) {
    var nonEmptyElements = schema.getNonEmptyElements();
    return node && (node.isEmpty(nonEmptyElements) || isPaddedEmptyBlock(schema, node));
  };
  var isListFragment = function(schema, fragment) {
    var firstChild2 = fragment.firstChild;
    var lastChild2 = fragment.lastChild;
    if (firstChild2 && firstChild2.name === "meta") {
      firstChild2 = firstChild2.next;
    }
    if (lastChild2 && lastChild2.attr("id") === "mce_marker") {
      lastChild2 = lastChild2.prev;
    }
    if (isEmptyFragmentElement(schema, lastChild2)) {
      lastChild2 = lastChild2.prev;
    }
    if (!firstChild2 || firstChild2 !== lastChild2) {
      return false;
    }
    return firstChild2.name === "ul" || firstChild2.name === "ol";
  };
  var cleanupDomFragment = function(domFragment) {
    var firstChild2 = domFragment.firstChild;
    var lastChild2 = domFragment.lastChild;
    if (firstChild2 && firstChild2.nodeName === "META") {
      firstChild2.parentNode.removeChild(firstChild2);
    }
    if (lastChild2 && lastChild2.id === "mce_marker") {
      lastChild2.parentNode.removeChild(lastChild2);
    }
    return domFragment;
  };
  var toDomFragment = function(dom2, serializer, fragment) {
    var html = serializer.serialize(fragment);
    var domFragment = dom2.createFragment(html);
    return cleanupDomFragment(domFragment);
  };
  var listItems$1 = function(elm) {
    return Tools.grep(elm.childNodes, function(child2) {
      return child2.nodeName === "LI";
    });
  };
  var isPadding = function(node) {
    return node.data === nbsp || isBr(node);
  };
  var isListItemPadded = function(node) {
    return node && node.firstChild && node.firstChild === node.lastChild && isPadding(node.firstChild);
  };
  var isEmptyOrPadded = function(elm) {
    return !elm.firstChild || isListItemPadded(elm);
  };
  var trimListItems = function(elms) {
    return elms.length > 0 && isEmptyOrPadded(elms[elms.length - 1]) ? elms.slice(0, -1) : elms;
  };
  var getParentLi = function(dom2, node) {
    var parentBlock = dom2.getParent(node, dom2.isBlock);
    return parentBlock && parentBlock.nodeName === "LI" ? parentBlock : null;
  };
  var isParentBlockLi = function(dom2, node) {
    return !!getParentLi(dom2, node);
  };
  var getSplit = function(parentNode, rng) {
    var beforeRng = rng.cloneRange();
    var afterRng = rng.cloneRange();
    beforeRng.setStartBefore(parentNode);
    afterRng.setEndAfter(parentNode);
    return [
      beforeRng.cloneContents(),
      afterRng.cloneContents()
    ];
  };
  var findFirstIn = function(node, rootNode) {
    var caretPos = CaretPosition.before(node);
    var caretWalker = CaretWalker(rootNode);
    var newCaretPos = caretWalker.next(caretPos);
    return newCaretPos ? newCaretPos.toRange() : null;
  };
  var findLastOf = function(node, rootNode) {
    var caretPos = CaretPosition.after(node);
    var caretWalker = CaretWalker(rootNode);
    var newCaretPos = caretWalker.prev(caretPos);
    return newCaretPos ? newCaretPos.toRange() : null;
  };
  var insertMiddle = function(target, elms, rootNode, rng) {
    var parts = getSplit(target, rng);
    var parentElm = target.parentNode;
    parentElm.insertBefore(parts[0], target);
    Tools.each(elms, function(li2) {
      parentElm.insertBefore(li2, target);
    });
    parentElm.insertBefore(parts[1], target);
    parentElm.removeChild(target);
    return findLastOf(elms[elms.length - 1], rootNode);
  };
  var insertBefore = function(target, elms, rootNode) {
    var parentElm = target.parentNode;
    Tools.each(elms, function(elm) {
      parentElm.insertBefore(elm, target);
    });
    return findFirstIn(target, rootNode);
  };
  var insertAfter = function(target, elms, rootNode, dom2) {
    dom2.insertAfter(elms.reverse(), target);
    return findLastOf(elms[0], rootNode);
  };
  var insertAtCaret = function(serializer, dom2, rng, fragment) {
    var domFragment = toDomFragment(dom2, serializer, fragment);
    var liTarget = getParentLi(dom2, rng.startContainer);
    var liElms = trimListItems(listItems$1(domFragment.firstChild));
    var BEGINNING = 1, END = 2;
    var rootNode = dom2.getRoot();
    var isAt = function(location) {
      var caretPos = CaretPosition.fromRangeStart(rng);
      var caretWalker = CaretWalker(dom2.getRoot());
      var newPos = location === BEGINNING ? caretWalker.prev(caretPos) : caretWalker.next(caretPos);
      return newPos ? getParentLi(dom2, newPos.getNode()) !== liTarget : true;
    };
    if (isAt(BEGINNING)) {
      return insertBefore(liTarget, liElms, rootNode);
    } else if (isAt(END)) {
      return insertAfter(liTarget, liElms, rootNode, dom2);
    }
    return insertMiddle(liTarget, liElms, rootNode, rng);
  };
  var trimOrPadLeftRight = function(dom2, rng, html) {
    var root = SugarElement.fromDom(dom2.getRoot());
    if (needsToBeNbspLeft(root, CaretPosition.fromRangeStart(rng))) {
      html = html.replace(/^ /, "&nbsp;");
    } else {
      html = html.replace(/^&nbsp;/, " ");
    }
    if (needsToBeNbspRight(root, CaretPosition.fromRangeEnd(rng))) {
      html = html.replace(/(&nbsp;| )(<br( \/)>)?$/, "&nbsp;");
    } else {
      html = html.replace(/&nbsp;(<br( \/)?>)?$/, " ");
    }
    return html;
  };
  var isTableCell$4 = isTableCell;
  var isTableCellContentSelected = function(dom2, rng, cell) {
    if (cell !== null) {
      var endCell = dom2.getParent(rng.endContainer, isTableCell$4);
      return cell === endCell && hasAllContentsSelected(SugarElement.fromDom(cell), rng);
    } else {
      return false;
    }
  };
  var validInsertion = function(editor, value2, parentNode) {
    if (parentNode.getAttribute("data-mce-bogus") === "all") {
      parentNode.parentNode.insertBefore(editor.dom.createFragment(value2), parentNode);
    } else {
      var node = parentNode.firstChild;
      var node2 = parentNode.lastChild;
      if (!node || node === node2 && node.nodeName === "BR") {
        editor.dom.setHTML(parentNode, value2);
      } else {
        editor.selection.setContent(value2);
      }
    }
  };
  var trimBrsFromTableCell = function(dom2, elm) {
    Optional.from(dom2.getParent(elm, "td,th")).map(SugarElement.fromDom).each(trimBlockTrailingBr);
  };
  var reduceInlineTextElements = function(editor, merge2) {
    var textInlineElements = editor.schema.getTextInlineElements();
    var dom2 = editor.dom;
    if (merge2) {
      var root_1 = editor.getBody();
      var elementUtils_1 = ElementUtils(dom2);
      Tools.each(dom2.select("*[data-mce-fragment]"), function(node) {
        var isInline2 = isNonNullable(textInlineElements[node.nodeName.toLowerCase()]);
        if (isInline2 && hasInheritableStyles(dom2, node)) {
          for (var parentNode = node.parentNode; isNonNullable(parentNode) && parentNode !== root_1; parentNode = parentNode.parentNode) {
            var styleConflict = hasStyleConflict(dom2, node, parentNode);
            if (styleConflict) {
              break;
            }
            if (elementUtils_1.compare(parentNode, node)) {
              dom2.remove(node, true);
              break;
            }
          }
        }
      });
    }
  };
  var markFragmentElements = function(fragment) {
    var node = fragment;
    while (node = node.walk()) {
      if (node.type === 1) {
        node.attr("data-mce-fragment", "1");
      }
    }
  };
  var unmarkFragmentElements = function(elm) {
    Tools.each(elm.getElementsByTagName("*"), function(elm2) {
      elm2.removeAttribute("data-mce-fragment");
    });
  };
  var isPartOfFragment = function(node) {
    return !!node.getAttribute("data-mce-fragment");
  };
  var canHaveChildren = function(editor, node) {
    return node && !editor.schema.getShortEndedElements()[node.nodeName];
  };
  var moveSelectionToMarker = function(editor, marker) {
    var nextRng;
    var dom2 = editor.dom, selection = editor.selection;
    var node2;
    var getContentEditableFalseParent = function(node3) {
      var root = editor.getBody();
      for (; node3 && node3 !== root; node3 = node3.parentNode) {
        if (dom2.getContentEditable(node3) === "false") {
          return node3;
        }
      }
      return null;
    };
    if (!marker) {
      return;
    }
    selection.scrollIntoView(marker);
    var parentEditableFalseElm = getContentEditableFalseParent(marker);
    if (parentEditableFalseElm) {
      dom2.remove(marker);
      selection.select(parentEditableFalseElm);
      return;
    }
    var rng = dom2.createRng();
    var node = marker.previousSibling;
    if (node && node.nodeType === 3) {
      rng.setStart(node, node.nodeValue.length);
      if (!Env.ie) {
        node2 = marker.nextSibling;
        if (node2 && node2.nodeType === 3) {
          node.appendData(node2.data);
          node2.parentNode.removeChild(node2);
        }
      }
    } else {
      rng.setStartBefore(marker);
      rng.setEndBefore(marker);
    }
    var findNextCaretRng = function(rng2) {
      var caretPos = CaretPosition.fromRangeStart(rng2);
      var caretWalker = CaretWalker(editor.getBody());
      caretPos = caretWalker.next(caretPos);
      if (caretPos) {
        return caretPos.toRange();
      }
    };
    var parentBlock = dom2.getParent(marker, dom2.isBlock);
    dom2.remove(marker);
    if (parentBlock && dom2.isEmpty(parentBlock)) {
      editor.$(parentBlock).empty();
      rng.setStart(parentBlock, 0);
      rng.setEnd(parentBlock, 0);
      if (!isTableCell$4(parentBlock) && !isPartOfFragment(parentBlock) && (nextRng = findNextCaretRng(rng))) {
        rng = nextRng;
        dom2.remove(parentBlock);
      } else {
        dom2.add(parentBlock, dom2.create("br", { "data-mce-bogus": "1" }));
      }
    }
    selection.setRng(rng);
  };
  var deleteSelectedContent = function(editor) {
    var dom2 = editor.dom;
    var rng = normalize$2(editor.selection.getRng());
    editor.selection.setRng(rng);
    var startCell = dom2.getParent(rng.startContainer, isTableCell$4);
    if (isTableCellContentSelected(dom2, rng, startCell)) {
      deleteCellContents(editor, rng, SugarElement.fromDom(startCell));
    } else {
      editor.getDoc().execCommand("Delete", false, null);
    }
  };
  var insertHtmlAtCaret = function(editor, value2, details) {
    var parentNode, rootNode, args;
    var marker, rng, node;
    var selection = editor.selection, dom2 = editor.dom;
    if (/^ | $/.test(value2)) {
      value2 = trimOrPadLeftRight(dom2, selection.getRng(), value2);
    }
    var parser = editor.parser;
    var merge2 = details.merge;
    var serializer = HtmlSerializer({ validate: shouldValidate(editor) }, editor.schema);
    var bookmarkHtml = '<span id="mce_marker" data-mce-type="bookmark">&#xFEFF;</span>';
    args = {
      content: value2,
      format: "html",
      selection: true,
      paste: details.paste
    };
    args = editor.fire("BeforeSetContent", args);
    if (args.isDefaultPrevented()) {
      editor.fire("SetContent", {
        content: args.content,
        format: "html",
        selection: true,
        paste: details.paste
      });
      return;
    }
    value2 = args.content;
    if (value2.indexOf("{$caret}") === -1) {
      value2 += "{$caret}";
    }
    value2 = value2.replace(/\{\$caret\}/, bookmarkHtml);
    rng = selection.getRng();
    var caretElement = rng.startContainer || (rng.parentElement ? rng.parentElement() : null);
    var body = editor.getBody();
    if (caretElement === body && selection.isCollapsed()) {
      if (dom2.isBlock(body.firstChild) && canHaveChildren(editor, body.firstChild) && dom2.isEmpty(body.firstChild)) {
        rng = dom2.createRng();
        rng.setStart(body.firstChild, 0);
        rng.setEnd(body.firstChild, 0);
        selection.setRng(rng);
      }
    }
    if (!selection.isCollapsed()) {
      deleteSelectedContent(editor);
    }
    parentNode = selection.getNode();
    var parserArgs = {
      context: parentNode.nodeName.toLowerCase(),
      data: details.data,
      insert: true
    };
    var fragment = parser.parse(value2, parserArgs);
    if (details.paste === true && isListFragment(editor.schema, fragment) && isParentBlockLi(dom2, parentNode)) {
      rng = insertAtCaret(serializer, dom2, selection.getRng(), fragment);
      selection.setRng(rng);
      editor.fire("SetContent", args);
      return;
    }
    markFragmentElements(fragment);
    node = fragment.lastChild;
    if (node.attr("id") === "mce_marker") {
      marker = node;
      for (node = node.prev; node; node = node.walk(true)) {
        if (node.type === 3 || !dom2.isBlock(node.name)) {
          if (editor.schema.isValidChild(node.parent.name, "span")) {
            node.parent.insert(marker, node, node.name === "br");
          }
          break;
        }
      }
    }
    editor._selectionOverrides.showBlockCaretContainer(parentNode);
    if (!parserArgs.invalid) {
      value2 = serializer.serialize(fragment);
      validInsertion(editor, value2, parentNode);
    } else {
      editor.selection.setContent(bookmarkHtml);
      parentNode = selection.getNode();
      rootNode = editor.getBody();
      if (parentNode.nodeType === 9) {
        parentNode = node = rootNode;
      } else {
        node = parentNode;
      }
      while (node !== rootNode) {
        parentNode = node;
        node = node.parentNode;
      }
      value2 = parentNode === rootNode ? rootNode.innerHTML : dom2.getOuterHTML(parentNode);
      value2 = serializer.serialize(parser.parse(value2.replace(/<span (id="mce_marker"|id=mce_marker).+?<\/span>/i, function() {
        return serializer.serialize(fragment);
      })));
      if (parentNode === rootNode) {
        dom2.setHTML(rootNode, value2);
      } else {
        dom2.setOuterHTML(parentNode, value2);
      }
    }
    reduceInlineTextElements(editor, merge2);
    moveSelectionToMarker(editor, dom2.get("mce_marker"));
    unmarkFragmentElements(editor.getBody());
    trimBrsFromTableCell(dom2, selection.getStart());
    editor.fire("SetContent", args);
    editor.addVisual();
  };
  var traverse = function(node, fn) {
    fn(node);
    if (node.firstChild) {
      traverse(node.firstChild, fn);
    }
    if (node.next) {
      traverse(node.next, fn);
    }
  };
  var findMatchingNodes = function(nodeFilters, attributeFilters, node) {
    var nodeMatches = {};
    var attrMatches = {};
    var matches2 = [];
    if (node.firstChild) {
      traverse(node.firstChild, function(node2) {
        each(nodeFilters, function(filter2) {
          if (filter2.name === node2.name) {
            if (nodeMatches[filter2.name]) {
              nodeMatches[filter2.name].nodes.push(node2);
            } else {
              nodeMatches[filter2.name] = {
                filter: filter2,
                nodes: [node2]
              };
            }
          }
        });
        each(attributeFilters, function(filter2) {
          if (typeof node2.attr(filter2.name) === "string") {
            if (attrMatches[filter2.name]) {
              attrMatches[filter2.name].nodes.push(node2);
            } else {
              attrMatches[filter2.name] = {
                filter: filter2,
                nodes: [node2]
              };
            }
          }
        });
      });
    }
    for (var name_1 in nodeMatches) {
      if (nodeMatches.hasOwnProperty(name_1)) {
        matches2.push(nodeMatches[name_1]);
      }
    }
    for (var name_2 in attrMatches) {
      if (attrMatches.hasOwnProperty(name_2)) {
        matches2.push(attrMatches[name_2]);
      }
    }
    return matches2;
  };
  var filter$3 = function(nodeFilters, attributeFilters, node) {
    var matches2 = findMatchingNodes(nodeFilters, attributeFilters, node);
    each(matches2, function(match2) {
      each(match2.filter.callbacks, function(callback) {
        callback(match2.nodes, match2.filter.name, {});
      });
    });
  };
  var defaultFormat = "html";
  var isTreeNode = function(content) {
    return content instanceof AstNode;
  };
  var moveSelection = function(editor) {
    if (hasFocus$1(editor)) {
      firstPositionIn(editor.getBody()).each(function(pos) {
        var node = pos.getNode();
        var caretPos = isTable(node) ? firstPositionIn(node).getOr(pos) : pos;
        editor.selection.setRng(caretPos.toRange());
      });
    }
  };
  var setEditorHtml = function(editor, html) {
    editor.dom.setHTML(editor.getBody(), html);
    moveSelection(editor);
  };
  var setContentString = function(editor, body, content, args) {
    var forcedRootBlockName, padd;
    if (content.length === 0 || /^\s+$/.test(content)) {
      padd = '<br data-mce-bogus="1">';
      if (body.nodeName === "TABLE") {
        content = "<tr><td>" + padd + "</td></tr>";
      } else if (/^(UL|OL)$/.test(body.nodeName)) {
        content = "<li>" + padd + "</li>";
      }
      forcedRootBlockName = getForcedRootBlock(editor);
      if (forcedRootBlockName && editor.schema.isValidChild(body.nodeName.toLowerCase(), forcedRootBlockName.toLowerCase())) {
        content = padd;
        content = editor.dom.createHTML(forcedRootBlockName, getForcedRootBlockAttrs(editor), content);
      } else if (!content) {
        content = '<br data-mce-bogus="1">';
      }
      setEditorHtml(editor, content);
      editor.fire("SetContent", args);
    } else {
      if (args.format !== "raw") {
        content = HtmlSerializer({ validate: editor.validate }, editor.schema).serialize(editor.parser.parse(content, {
          isRootContent: true,
          insert: true
        }));
      }
      args.content = isWsPreserveElement(SugarElement.fromDom(body)) ? content : Tools.trim(content);
      setEditorHtml(editor, args.content);
      if (!args.no_events) {
        editor.fire("SetContent", args);
      }
    }
    return args.content;
  };
  var setContentTree = function(editor, body, content, args) {
    filter$3(editor.parser.getNodeFilters(), editor.parser.getAttributeFilters(), content);
    var html = HtmlSerializer({ validate: editor.validate }, editor.schema).serialize(content);
    args.content = isWsPreserveElement(SugarElement.fromDom(body)) ? html : Tools.trim(html);
    setEditorHtml(editor, args.content);
    if (!args.no_events) {
      editor.fire("SetContent", args);
    }
    return content;
  };
  var setContentInternal = function(editor, content, args) {
    args.format = args.format ? args.format : defaultFormat;
    args.set = true;
    args.content = isTreeNode(content) ? "" : content;
    if (!args.no_events) {
      editor.fire("BeforeSetContent", args);
    }
    if (!isTreeNode(content)) {
      content = args.content;
    }
    return Optional.from(editor.getBody()).fold(constant(content), function(body) {
      return isTreeNode(content) ? setContentTree(editor, body, content, args) : setContentString(editor, body, content, args);
    });
  };
  var sibling$2 = function(scope, predicate) {
    return sibling(scope, predicate).isSome();
  };
  var ensureIsRoot = function(isRoot) {
    return isFunction2(isRoot) ? isRoot : never;
  };
  var ancestor$3 = function(scope, transform, isRoot) {
    var element = scope.dom;
    var stop2 = ensureIsRoot(isRoot);
    while (element.parentNode) {
      element = element.parentNode;
      var el = SugarElement.fromDom(element);
      var transformed = transform(el);
      if (transformed.isSome()) {
        return transformed;
      } else if (stop2(el)) {
        break;
      }
    }
    return Optional.none();
  };
  var closest$2 = function(scope, transform, isRoot) {
    var current = transform(scope);
    var stop2 = ensureIsRoot(isRoot);
    return current.orThunk(function() {
      return stop2(scope) ? Optional.none() : ancestor$3(scope, transform, stop2);
    });
  };
  var isEq$2 = isEq;
  var matchesUnInheritedFormatSelector = function(ed2, node, name2) {
    var formatList = ed2.formatter.get(name2);
    if (formatList) {
      for (var i = 0; i < formatList.length; i++) {
        if (formatList[i].inherit === false && ed2.dom.is(node, formatList[i].selector)) {
          return true;
        }
      }
    }
    return false;
  };
  var matchParents = function(editor, node, name2, vars) {
    var root = editor.dom.getRoot();
    if (node === root) {
      return false;
    }
    node = editor.dom.getParent(node, function(node2) {
      if (matchesUnInheritedFormatSelector(editor, node2, name2)) {
        return true;
      }
      return node2.parentNode === root || !!matchNode(editor, node2, name2, vars, true);
    });
    return matchNode(editor, node, name2, vars);
  };
  var matchName = function(dom2, node, format) {
    if (isEq$2(node, format.inline)) {
      return true;
    }
    if (isEq$2(node, format.block)) {
      return true;
    }
    if (format.selector) {
      return node.nodeType === 1 && dom2.is(node, format.selector);
    }
  };
  var matchItems = function(dom2, node, format, itemName, similar, vars) {
    var key, value2;
    var items = format[itemName];
    var i;
    if (format.onmatch) {
      return format.onmatch(node, format, itemName);
    }
    if (items) {
      if (typeof items.length === "undefined") {
        for (key in items) {
          if (items.hasOwnProperty(key)) {
            if (itemName === "attributes") {
              value2 = dom2.getAttrib(node, key);
            } else {
              value2 = getStyle(dom2, node, key);
            }
            if (similar && !value2 && !format.exact) {
              return;
            }
            if ((!similar || format.exact) && !isEq$2(value2, normalizeStyleValue(dom2, replaceVars(items[key], vars), key))) {
              return;
            }
          }
        }
      } else {
        for (i = 0; i < items.length; i++) {
          if (itemName === "attributes" ? dom2.getAttrib(node, items[i]) : getStyle(dom2, node, items[i])) {
            return format;
          }
        }
      }
    }
    return format;
  };
  var matchNode = function(ed2, node, name2, vars, similar) {
    var formatList = ed2.formatter.get(name2);
    var format, i, x2, classes;
    var dom2 = ed2.dom;
    if (formatList && node) {
      for (i = 0; i < formatList.length; i++) {
        format = formatList[i];
        if (matchName(ed2.dom, node, format) && matchItems(dom2, node, format, "attributes", similar, vars) && matchItems(dom2, node, format, "styles", similar, vars)) {
          if (classes = format.classes) {
            for (x2 = 0; x2 < classes.length; x2++) {
              if (!ed2.dom.hasClass(node, replaceVars(classes[x2], vars))) {
                return;
              }
            }
          }
          return format;
        }
      }
    }
  };
  var match = function(editor, name2, vars, node) {
    if (node) {
      return matchParents(editor, node, name2, vars);
    }
    node = editor.selection.getNode();
    if (matchParents(editor, node, name2, vars)) {
      return true;
    }
    var startNode = editor.selection.getStart();
    if (startNode !== node) {
      if (matchParents(editor, startNode, name2, vars)) {
        return true;
      }
    }
    return false;
  };
  var matchAll = function(editor, names, vars) {
    var matchedFormatNames = [];
    var checkedMap = {};
    var startElement = editor.selection.getStart();
    editor.dom.getParent(startElement, function(node) {
      for (var i = 0; i < names.length; i++) {
        var name_1 = names[i];
        if (!checkedMap[name_1] && matchNode(editor, node, name_1, vars)) {
          checkedMap[name_1] = true;
          matchedFormatNames.push(name_1);
        }
      }
    }, editor.dom.getRoot());
    return matchedFormatNames;
  };
  var closest$3 = function(editor, names) {
    var isRoot = function(elm) {
      return eq$2(elm, SugarElement.fromDom(editor.getBody()));
    };
    var match2 = function(elm, name2) {
      return matchNode(editor, elm.dom, name2) ? Optional.some(name2) : Optional.none();
    };
    return Optional.from(editor.selection.getStart(true)).bind(function(rawElm) {
      return closest$2(SugarElement.fromDom(rawElm), function(elm) {
        return findMap(names, function(name2) {
          return match2(elm, name2);
        });
      }, isRoot);
    }).getOrNull();
  };
  var canApply = function(editor, name2) {
    var formatList = editor.formatter.get(name2);
    var startNode, parents2, i, x2, selector;
    var dom2 = editor.dom;
    if (formatList) {
      startNode = editor.selection.getStart();
      parents2 = getParents$1(dom2, startNode);
      for (x2 = formatList.length - 1; x2 >= 0; x2--) {
        selector = formatList[x2].selector;
        if (!selector || formatList[x2].defaultBlock) {
          return true;
        }
        for (i = parents2.length - 1; i >= 0; i--) {
          if (dom2.is(parents2[i], selector)) {
            return true;
          }
        }
      }
    }
    return false;
  };
  var matchAllOnNode = function(editor, node, formatNames) {
    return foldl(formatNames, function(acc, name2) {
      var matchSimilar = isVariableFormatName(editor, name2);
      if (editor.formatter.matchNode(node, name2, {}, matchSimilar)) {
        return acc.concat([name2]);
      } else {
        return acc;
      }
    }, []);
  };
  var ZWSP$1 = ZWSP, CARET_ID$1 = "_mce_caret";
  var importNode = function(ownerDocument, node) {
    return ownerDocument.importNode(node, true);
  };
  var getEmptyCaretContainers = function(node) {
    var nodes = [];
    while (node) {
      if (node.nodeType === 3 && node.nodeValue !== ZWSP$1 || node.childNodes.length > 1) {
        return [];
      }
      if (node.nodeType === 1) {
        nodes.push(node);
      }
      node = node.firstChild;
    }
    return nodes;
  };
  var isCaretContainerEmpty = function(node) {
    return getEmptyCaretContainers(node).length > 0;
  };
  var findFirstTextNode = function(node) {
    if (node) {
      var walker = new DomTreeWalker(node, node);
      for (node = walker.current(); node; node = walker.next()) {
        if (isText$1(node)) {
          return node;
        }
      }
    }
    return null;
  };
  var createCaretContainer = function(fill) {
    var caretContainer = SugarElement.fromTag("span");
    setAll(caretContainer, {
      "id": CARET_ID$1,
      "data-mce-bogus": "1",
      "data-mce-type": "format-caret"
    });
    if (fill) {
      append(caretContainer, SugarElement.fromText(ZWSP$1));
    }
    return caretContainer;
  };
  var trimZwspFromCaretContainer = function(caretContainerNode) {
    var textNode = findFirstTextNode(caretContainerNode);
    if (textNode && textNode.nodeValue.charAt(0) === ZWSP$1) {
      textNode.deleteData(0, 1);
    }
    return textNode;
  };
  var removeCaretContainerNode = function(editor, node, moveCaret2) {
    if (moveCaret2 === void 0) {
      moveCaret2 = true;
    }
    var dom2 = editor.dom, selection = editor.selection;
    if (isCaretContainerEmpty(node)) {
      deleteElement(editor, false, SugarElement.fromDom(node), moveCaret2);
    } else {
      var rng = selection.getRng();
      var block = dom2.getParent(node, dom2.isBlock);
      var startContainer = rng.startContainer;
      var startOffset = rng.startOffset;
      var endContainer = rng.endContainer;
      var endOffset = rng.endOffset;
      var textNode = trimZwspFromCaretContainer(node);
      dom2.remove(node, true);
      if (startContainer === textNode && startOffset > 0) {
        rng.setStart(textNode, startOffset - 1);
      }
      if (endContainer === textNode && endOffset > 0) {
        rng.setEnd(textNode, endOffset - 1);
      }
      if (block && dom2.isEmpty(block)) {
        fillWithPaddingBr(SugarElement.fromDom(block));
      }
      selection.setRng(rng);
    }
  };
  var removeCaretContainer = function(editor, node, moveCaret2) {
    if (moveCaret2 === void 0) {
      moveCaret2 = true;
    }
    var dom2 = editor.dom, selection = editor.selection;
    if (!node) {
      node = getParentCaretContainer(editor.getBody(), selection.getStart());
      if (!node) {
        while (node = dom2.get(CARET_ID$1)) {
          removeCaretContainerNode(editor, node, false);
        }
      }
    } else {
      removeCaretContainerNode(editor, node, moveCaret2);
    }
  };
  var insertCaretContainerNode = function(editor, caretContainer, formatNode) {
    var dom2 = editor.dom, block = dom2.getParent(formatNode, curry(isTextBlock$1, editor));
    if (block && dom2.isEmpty(block)) {
      formatNode.parentNode.replaceChild(caretContainer, formatNode);
    } else {
      removeTrailingBr(SugarElement.fromDom(formatNode));
      if (dom2.isEmpty(formatNode)) {
        formatNode.parentNode.replaceChild(caretContainer, formatNode);
      } else {
        dom2.insertAfter(caretContainer, formatNode);
      }
    }
  };
  var appendNode = function(parentNode, node) {
    parentNode.appendChild(node);
    return node;
  };
  var insertFormatNodesIntoCaretContainer = function(formatNodes, caretContainer) {
    var innerMostFormatNode = foldr(formatNodes, function(parentNode, formatNode) {
      return appendNode(parentNode, formatNode.cloneNode(false));
    }, caretContainer);
    return appendNode(innerMostFormatNode, innerMostFormatNode.ownerDocument.createTextNode(ZWSP$1));
  };
  var cleanFormatNode = function(editor, caretContainer, formatNode, name2, vars, similar) {
    var formatter = editor.formatter;
    var dom2 = editor.dom;
    var validFormats = filter(keys(formatter.get()), function(formatName) {
      return formatName !== name2 && !contains$1(formatName, "removeformat");
    });
    var matchedFormats = matchAllOnNode(editor, formatNode, validFormats);
    var uniqueFormats = filter(matchedFormats, function(fmtName) {
      return !areSimilarFormats(editor, fmtName, name2);
    });
    if (uniqueFormats.length > 0) {
      var clonedFormatNode = formatNode.cloneNode(false);
      dom2.add(caretContainer, clonedFormatNode);
      formatter.remove(name2, vars, clonedFormatNode, similar);
      dom2.remove(clonedFormatNode);
      return Optional.some(clonedFormatNode);
    } else {
      return Optional.none();
    }
  };
  var applyCaretFormat = function(editor, name2, vars) {
    var caretContainer, textNode;
    var selection = editor.selection;
    var selectionRng = selection.getRng();
    var offset = selectionRng.startOffset;
    var container = selectionRng.startContainer;
    var text = container.nodeValue;
    caretContainer = getParentCaretContainer(editor.getBody(), selection.getStart());
    if (caretContainer) {
      textNode = findFirstTextNode(caretContainer);
    }
    var wordcharRegex = /[^\s\u00a0\u00ad\u200b\ufeff]/;
    if (text && offset > 0 && offset < text.length && wordcharRegex.test(text.charAt(offset)) && wordcharRegex.test(text.charAt(offset - 1))) {
      var bookmark = selection.getBookmark();
      selectionRng.collapse(true);
      var rng = expandRng(editor, selectionRng, editor.formatter.get(name2));
      rng = split$1(rng);
      editor.formatter.apply(name2, vars, rng);
      selection.moveToBookmark(bookmark);
    } else {
      if (!caretContainer || textNode.nodeValue !== ZWSP$1) {
        caretContainer = importNode(editor.getDoc(), createCaretContainer(true).dom);
        textNode = caretContainer.firstChild;
        selectionRng.insertNode(caretContainer);
        offset = 1;
        editor.formatter.apply(name2, vars, caretContainer);
      } else {
        editor.formatter.apply(name2, vars, caretContainer);
      }
      selection.setCursorLocation(textNode, offset);
    }
  };
  var removeCaretFormat = function(editor, name2, vars, similar) {
    var dom2 = editor.dom;
    var selection = editor.selection;
    var hasContentAfter, node, formatNode;
    var parents2 = [];
    var rng = selection.getRng();
    var container = rng.startContainer;
    var offset = rng.startOffset;
    node = container;
    if (container.nodeType === 3) {
      if (offset !== container.nodeValue.length) {
        hasContentAfter = true;
      }
      node = node.parentNode;
    }
    while (node) {
      if (matchNode(editor, node, name2, vars, similar)) {
        formatNode = node;
        break;
      }
      if (node.nextSibling) {
        hasContentAfter = true;
      }
      parents2.push(node);
      node = node.parentNode;
    }
    if (!formatNode) {
      return;
    }
    if (hasContentAfter) {
      var bookmark = selection.getBookmark();
      rng.collapse(true);
      var expandedRng = expandRng(editor, rng, editor.formatter.get(name2), true);
      expandedRng = split$1(expandedRng);
      editor.formatter.remove(name2, vars, expandedRng, similar);
      selection.moveToBookmark(bookmark);
    } else {
      var caretContainer = getParentCaretContainer(editor.getBody(), formatNode);
      var newCaretContainer = createCaretContainer(false).dom;
      insertCaretContainerNode(editor, newCaretContainer, caretContainer !== null ? caretContainer : formatNode);
      var cleanedFormatNode = cleanFormatNode(editor, newCaretContainer, formatNode, name2, vars, similar);
      var caretTextNode = insertFormatNodesIntoCaretContainer(parents2.concat(cleanedFormatNode.toArray()), newCaretContainer);
      removeCaretContainerNode(editor, caretContainer, false);
      selection.setCursorLocation(caretTextNode, 1);
      if (dom2.isEmpty(formatNode)) {
        dom2.remove(formatNode);
      }
    }
  };
  var disableCaretContainer = function(editor, keyCode) {
    var selection = editor.selection, body = editor.getBody();
    removeCaretContainer(editor, null, false);
    if ((keyCode === 8 || keyCode === 46) && selection.isCollapsed() && selection.getStart().innerHTML === ZWSP$1) {
      removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()));
    }
    if (keyCode === 37 || keyCode === 39) {
      removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()));
    }
  };
  var setup$3 = function(editor) {
    editor.on("mouseup keydown", function(e) {
      disableCaretContainer(editor, e.keyCode);
    });
  };
  var replaceWithCaretFormat = function(targetNode, formatNodes) {
    var caretContainer = createCaretContainer(false);
    var innerMost = insertFormatNodesIntoCaretContainer(formatNodes, caretContainer.dom);
    before(SugarElement.fromDom(targetNode), caretContainer);
    remove(SugarElement.fromDom(targetNode));
    return CaretPosition(innerMost, 0);
  };
  var isFormatElement = function(editor, element) {
    var inlineElements = editor.schema.getTextInlineElements();
    return inlineElements.hasOwnProperty(name(element)) && !isCaretNode(element.dom) && !isBogus(element.dom);
  };
  var isEmptyCaretFormatElement = function(element) {
    return isCaretNode(element.dom) && isCaretContainerEmpty(element.dom);
  };
  var postProcessHooks = {};
  var filter$4 = filter$2;
  var each$8 = each$2;
  var addPostProcessHook = function(name2, hook) {
    var hooks = postProcessHooks[name2];
    if (!hooks) {
      postProcessHooks[name2] = [];
    }
    postProcessHooks[name2].push(hook);
  };
  var postProcess = function(name2, editor) {
    each$8(postProcessHooks[name2], function(hook) {
      hook(editor);
    });
  };
  addPostProcessHook("pre", function(editor) {
    var rng = editor.selection.getRng();
    var blocks2;
    var hasPreSibling = function(pre) {
      return isPre(pre.previousSibling) && indexOf$1(blocks2, pre.previousSibling) !== -1;
    };
    var joinPre = function(pre1, pre2) {
      DomQuery(pre2).remove();
      DomQuery(pre1).append("<br><br>").append(pre2.childNodes);
    };
    var isPre = matchNodeNames(["pre"]);
    if (!rng.collapsed) {
      blocks2 = editor.selection.getSelectedBlocks();
      each$8(filter$4(filter$4(blocks2, isPre), hasPreSibling), function(pre) {
        joinPre(pre.previousSibling, pre);
      });
    }
  });
  var each$9 = Tools.each;
  var isElementNode = function(node) {
    return isElement$1(node) && !isBookmarkNode$1(node) && !isCaretNode(node) && !isBogus(node);
  };
  var findElementSibling = function(node, siblingName) {
    var sibling2;
    for (sibling2 = node; sibling2; sibling2 = sibling2[siblingName]) {
      if (isText$1(sibling2) && sibling2.nodeValue.length !== 0) {
        return node;
      }
      if (isElement$1(sibling2) && !isBookmarkNode$1(sibling2)) {
        return sibling2;
      }
    }
    return node;
  };
  var mergeSiblingsNodes = function(dom2, prev, next) {
    var sibling2, tmpSibling;
    var elementUtils = ElementUtils(dom2);
    if (prev && next) {
      prev = findElementSibling(prev, "previousSibling");
      next = findElementSibling(next, "nextSibling");
      if (elementUtils.compare(prev, next)) {
        for (sibling2 = prev.nextSibling; sibling2 && sibling2 !== next; ) {
          tmpSibling = sibling2;
          sibling2 = sibling2.nextSibling;
          prev.appendChild(tmpSibling);
        }
        dom2.remove(next);
        Tools.each(Tools.grep(next.childNodes), function(node) {
          prev.appendChild(node);
        });
        return prev;
      }
    }
    return next;
  };
  var mergeSiblings = function(dom2, format, vars, node) {
    if (node && format.merge_siblings !== false) {
      var newNode = mergeSiblingsNodes(dom2, getNonWhiteSpaceSibling(node), node);
      mergeSiblingsNodes(dom2, newNode, getNonWhiteSpaceSibling(newNode, true));
    }
  };
  var clearChildStyles = function(dom2, format, node) {
    if (format.clear_child_styles) {
      var selector = format.links ? "*:not(a)" : "*";
      each$9(dom2.select(selector, node), function(node2) {
        if (isElementNode(node2)) {
          each$9(format.styles, function(value2, name2) {
            dom2.setStyle(node2, name2, "");
          });
        }
      });
    }
  };
  var processChildElements = function(node, filter2, process2) {
    each$9(node.childNodes, function(node2) {
      if (isElementNode(node2)) {
        if (filter2(node2)) {
          process2(node2);
        }
        if (node2.hasChildNodes()) {
          processChildElements(node2, filter2, process2);
        }
      }
    });
  };
  var unwrapEmptySpan = function(dom2, node) {
    if (node.nodeName === "SPAN" && dom2.getAttribs(node).length === 0) {
      dom2.remove(node, true);
    }
  };
  var hasStyle = function(dom2, name2) {
    return function(node) {
      return !!(node && getStyle(dom2, node, name2));
    };
  };
  var applyStyle = function(dom2, name2, value2) {
    return function(node) {
      dom2.setStyle(node, name2, value2);
      if (node.getAttribute("style") === "") {
        node.removeAttribute("style");
      }
      unwrapEmptySpan(dom2, node);
    };
  };
  var removeResult = Adt.generate([
    { keep: [] },
    { rename: ["name"] },
    { removed: [] }
  ]);
  var MCE_ATTR_RE = /^(src|href|style)$/;
  var each$a = Tools.each;
  var isEq$3 = isEq;
  var isTableCellOrRow = function(node) {
    return /^(TR|TH|TD)$/.test(node.nodeName);
  };
  var isChildOfInlineParent = function(dom2, node, parent2) {
    return dom2.isChildOf(node, parent2) && node !== parent2 && !dom2.isBlock(parent2);
  };
  var getContainer = function(ed2, rng, start2) {
    var container, offset;
    container = rng[start2 ? "startContainer" : "endContainer"];
    offset = rng[start2 ? "startOffset" : "endOffset"];
    if (isElement$1(container)) {
      var lastIdx = container.childNodes.length - 1;
      if (!start2 && offset) {
        offset--;
      }
      container = container.childNodes[offset > lastIdx ? lastIdx : offset];
    }
    if (isText$1(container) && start2 && offset >= container.nodeValue.length) {
      container = new DomTreeWalker(container, ed2.getBody()).next() || container;
    }
    if (isText$1(container) && !start2 && offset === 0) {
      container = new DomTreeWalker(container, ed2.getBody()).prev() || container;
    }
    return container;
  };
  var normalizeTableSelection = function(node, start2) {
    var prop = start2 ? "firstChild" : "lastChild";
    if (isTableCellOrRow(node) && node[prop]) {
      var childNode = node[prop];
      if (node.nodeName === "TR") {
        return childNode[prop] || childNode;
      } else {
        return childNode;
      }
    }
    return node;
  };
  var wrap$2 = function(dom2, node, name2, attrs) {
    var wrapper = dom2.create(name2, attrs);
    node.parentNode.insertBefore(wrapper, node);
    wrapper.appendChild(node);
    return wrapper;
  };
  var wrapWithSiblings = function(dom2, node, next, name2, attrs) {
    var start2 = SugarElement.fromDom(node);
    var wrapper = SugarElement.fromDom(dom2.create(name2, attrs));
    var siblings2 = next ? nextSiblings(start2) : prevSiblings(start2);
    append$1(wrapper, siblings2);
    if (next) {
      before(start2, wrapper);
      prepend(wrapper, start2);
    } else {
      after(start2, wrapper);
      append(wrapper, start2);
    }
    return wrapper.dom;
  };
  var matchName$1 = function(dom2, node, format) {
    if (isEq$3(node, format.inline)) {
      return true;
    }
    if (isEq$3(node, format.block)) {
      return true;
    }
    if (format.selector) {
      return isElement$1(node) && dom2.is(node, format.selector);
    }
  };
  var isColorFormatAndAnchor = function(node, format) {
    return format.links && node.nodeName === "A";
  };
  var find$3 = function(dom2, node, next, inc) {
    node = getNonWhiteSpaceSibling(node, next, inc);
    return !node || (node.nodeName === "BR" || dom2.isBlock(node));
  };
  var removeNode$1 = function(ed2, node, format) {
    var parentNode = node.parentNode;
    var rootBlockElm;
    var dom2 = ed2.dom, forcedRootBlock = getForcedRootBlock(ed2);
    if (format.block) {
      if (!forcedRootBlock) {
        if (dom2.isBlock(node) && !dom2.isBlock(parentNode)) {
          if (!find$3(dom2, node, false) && !find$3(dom2, node.firstChild, true, true)) {
            node.insertBefore(dom2.create("br"), node.firstChild);
          }
          if (!find$3(dom2, node, true) && !find$3(dom2, node.lastChild, false, true)) {
            node.appendChild(dom2.create("br"));
          }
        }
      } else {
        if (parentNode === dom2.getRoot()) {
          if (!format.list_block || !isEq$3(node, format.list_block)) {
            each(from$1(node.childNodes), function(node2) {
              if (isValid(ed2, forcedRootBlock, node2.nodeName.toLowerCase())) {
                if (!rootBlockElm) {
                  rootBlockElm = wrap$2(dom2, node2, forcedRootBlock);
                  dom2.setAttribs(rootBlockElm, ed2.settings.forced_root_block_attrs);
                } else {
                  rootBlockElm.appendChild(node2);
                }
              } else {
                rootBlockElm = 0;
              }
            });
          }
        }
      }
    }
    if (format.selector && format.inline && !isEq$3(format.inline, node)) {
      return;
    }
    dom2.remove(node, true);
  };
  var removeFormatInternal = function(ed2, format, vars, node, compareNode) {
    var stylesModified;
    var dom2 = ed2.dom;
    if (!matchName$1(dom2, node, format) && !isColorFormatAndAnchor(node, format)) {
      return removeResult.keep();
    }
    var elm = node;
    if (format.inline && format.remove === "all" && isArray(format.preserve_attributes)) {
      var attrsToPreserve = filter(dom2.getAttribs(elm), function(attr) {
        return contains(format.preserve_attributes, attr.name.toLowerCase());
      });
      dom2.removeAllAttribs(elm);
      each(attrsToPreserve, function(attr) {
        return dom2.setAttrib(elm, attr.name, attr.value);
      });
      if (attrsToPreserve.length > 0) {
        return removeResult.rename("span");
      }
    }
    if (format.remove !== "all") {
      each$a(format.styles, function(value2, name2) {
        value2 = normalizeStyleValue(dom2, replaceVars(value2, vars), name2 + "");
        if (isNumber(name2)) {
          name2 = value2;
          compareNode = null;
        }
        if (format.remove_similar || (!compareNode || isEq$3(getStyle(dom2, compareNode, name2), value2))) {
          dom2.setStyle(elm, name2, "");
        }
        stylesModified = true;
      });
      if (stylesModified && dom2.getAttrib(elm, "style") === "") {
        elm.removeAttribute("style");
        elm.removeAttribute("data-mce-style");
      }
      each$a(format.attributes, function(value2, name2) {
        var valueOut;
        value2 = replaceVars(value2, vars);
        if (isNumber(name2)) {
          name2 = value2;
          compareNode = null;
        }
        if (format.remove_similar || (!compareNode || isEq$3(dom2.getAttrib(compareNode, name2), value2))) {
          if (name2 === "class") {
            value2 = dom2.getAttrib(elm, name2);
            if (value2) {
              valueOut = "";
              each(value2.split(/\s+/), function(cls) {
                if (/mce\-\w+/.test(cls)) {
                  valueOut += (valueOut ? " " : "") + cls;
                }
              });
              if (valueOut) {
                dom2.setAttrib(elm, name2, valueOut);
                return;
              }
            }
          }
          if (MCE_ATTR_RE.test(name2)) {
            elm.removeAttribute("data-mce-" + name2);
          }
          if (name2 === "style" && matchNodeNames(["li"])(elm) && dom2.getStyle(elm, "list-style-type") === "none") {
            elm.removeAttribute(name2);
            dom2.setStyle(elm, "list-style-type", "none");
            return;
          }
          if (name2 === "class") {
            elm.removeAttribute("className");
          }
          elm.removeAttribute(name2);
        }
      });
      each$a(format.classes, function(value2) {
        value2 = replaceVars(value2, vars);
        if (!compareNode || dom2.hasClass(compareNode, value2)) {
          dom2.removeClass(elm, value2);
        }
      });
      var attrs = dom2.getAttribs(elm);
      for (var i = 0; i < attrs.length; i++) {
        var attrName = attrs[i].nodeName;
        if (attrName.indexOf("_") !== 0 && attrName.indexOf("data-") !== 0) {
          return removeResult.keep();
        }
      }
    }
    if (format.remove !== "none") {
      removeNode$1(ed2, elm, format);
      return removeResult.removed();
    }
    return removeResult.keep();
  };
  var removeFormat = function(ed2, format, vars, node, compareNode) {
    return removeFormatInternal(ed2, format, vars, node, compareNode).fold(never, function(newName) {
      ed2.dom.rename(node, newName);
      return true;
    }, always);
  };
  var findFormatRoot = function(editor, container, name2, vars, similar) {
    var formatRoot;
    each(getParents$1(editor.dom, container.parentNode).reverse(), function(parent2) {
      if (!formatRoot && parent2.id !== "_start" && parent2.id !== "_end") {
        var format = matchNode(editor, parent2, name2, vars, similar);
        if (format && format.split !== false) {
          formatRoot = parent2;
        }
      }
    });
    return formatRoot;
  };
  var removeFormatFromClone = function(editor, format, vars, clone2) {
    return removeFormatInternal(editor, format, vars, clone2, clone2).fold(constant(clone2), function(newName) {
      var fragment = editor.dom.createFragment();
      fragment.appendChild(clone2);
      return editor.dom.rename(clone2, newName);
    }, constant(null));
  };
  var wrapAndSplit = function(editor, formatList, formatRoot, container, target, split2, format, vars) {
    var clone2, lastClone, firstClone;
    var dom2 = editor.dom;
    if (formatRoot) {
      var formatRootParent = formatRoot.parentNode;
      for (var parent_1 = container.parentNode; parent_1 && parent_1 !== formatRootParent; parent_1 = parent_1.parentNode) {
        clone2 = dom2.clone(parent_1, false);
        for (var i = 0; i < formatList.length; i++) {
          clone2 = removeFormatFromClone(editor, formatList[i], vars, clone2);
          if (clone2 === null) {
            break;
          }
        }
        if (clone2) {
          if (lastClone) {
            clone2.appendChild(lastClone);
          }
          if (!firstClone) {
            firstClone = clone2;
          }
          lastClone = clone2;
        }
      }
      if (split2 && (!format.mixed || !dom2.isBlock(formatRoot))) {
        container = dom2.split(formatRoot, container);
      }
      if (lastClone) {
        target.parentNode.insertBefore(lastClone, target);
        firstClone.appendChild(target);
        if (format.inline) {
          mergeSiblings(dom2, format, vars, lastClone);
        }
      }
    }
    return container;
  };
  var remove$6 = function(ed2, name2, vars, node, similar) {
    var formatList = ed2.formatter.get(name2);
    var format = formatList[0];
    var contentEditable = true;
    var dom2 = ed2.dom;
    var selection = ed2.selection;
    var splitToFormatRoot = function(container) {
      var formatRoot = findFormatRoot(ed2, container, name2, vars, similar);
      return wrapAndSplit(ed2, formatList, formatRoot, container, container, true, format, vars);
    };
    var isRemoveBookmarkNode = function(node2) {
      return isBookmarkNode$1(node2) && isElement$1(node2) && (node2.id === "_start" || node2.id === "_end");
    };
    var process2 = function(node2) {
      var lastContentEditable, hasContentEditableState2;
      var parentNode = node2.parentNode;
      if (isText$1(node2) && hasBlockChildren(dom2, parentNode)) {
        removeFormat(ed2, format, vars, parentNode, parentNode);
      }
      if (isElement$1(node2) && dom2.getContentEditable(node2)) {
        lastContentEditable = contentEditable;
        contentEditable = dom2.getContentEditable(node2) === "true";
        hasContentEditableState2 = true;
      }
      var children2 = from$1(node2.childNodes);
      if (contentEditable && !hasContentEditableState2) {
        for (var i2 = 0; i2 < formatList.length; i2++) {
          if (removeFormat(ed2, formatList[i2], vars, node2, node2)) {
            break;
          }
        }
      }
      if (format.deep) {
        if (children2.length) {
          for (var i2 = 0; i2 < children2.length; i2++) {
            process2(children2[i2]);
          }
          if (hasContentEditableState2) {
            contentEditable = lastContentEditable;
          }
        }
      }
    };
    var unwrap2 = function(start2) {
      var node2 = dom2.get(start2 ? "_start" : "_end");
      var out = node2[start2 ? "firstChild" : "lastChild"];
      if (isRemoveBookmarkNode(out)) {
        out = out[start2 ? "firstChild" : "lastChild"];
      }
      if (isText$1(out) && out.data.length === 0) {
        out = start2 ? node2.previousSibling || node2.nextSibling : node2.nextSibling || node2.previousSibling;
      }
      dom2.remove(node2, true);
      return out;
    };
    var removeRngStyle = function(rng2) {
      var startContainer, endContainer;
      var expandedRng = expandRng(ed2, rng2, formatList, rng2.collapsed);
      if (format.split) {
        expandedRng = split$1(expandedRng);
        startContainer = getContainer(ed2, expandedRng, true);
        endContainer = getContainer(ed2, expandedRng);
        if (startContainer !== endContainer) {
          startContainer = normalizeTableSelection(startContainer, true);
          endContainer = normalizeTableSelection(endContainer, false);
          if (isChildOfInlineParent(dom2, startContainer, endContainer)) {
            var marker = Optional.from(startContainer.firstChild).getOr(startContainer);
            splitToFormatRoot(wrapWithSiblings(dom2, marker, true, "span", {
              "id": "_start",
              "data-mce-type": "bookmark"
            }));
            unwrap2(true);
            return;
          }
          if (isChildOfInlineParent(dom2, endContainer, startContainer)) {
            var marker = Optional.from(endContainer.lastChild).getOr(endContainer);
            splitToFormatRoot(wrapWithSiblings(dom2, marker, false, "span", {
              "id": "_end",
              "data-mce-type": "bookmark"
            }));
            unwrap2(false);
            return;
          }
          startContainer = wrap$2(dom2, startContainer, "span", {
            "id": "_start",
            "data-mce-type": "bookmark"
          });
          endContainer = wrap$2(dom2, endContainer, "span", {
            "id": "_end",
            "data-mce-type": "bookmark"
          });
          var newRng = dom2.createRng();
          newRng.setStartAfter(startContainer);
          newRng.setEndBefore(endContainer);
          walk$1(dom2, newRng, function(nodes) {
            each(nodes, function(n2) {
              if (!isBookmarkNode$1(n2) && !isBookmarkNode$1(n2.parentNode)) {
                splitToFormatRoot(n2);
              }
            });
          });
          splitToFormatRoot(startContainer);
          splitToFormatRoot(endContainer);
          startContainer = unwrap2(true);
          endContainer = unwrap2();
        } else {
          startContainer = endContainer = splitToFormatRoot(startContainer);
        }
        expandedRng.startContainer = startContainer.parentNode ? startContainer.parentNode : startContainer;
        expandedRng.startOffset = dom2.nodeIndex(startContainer);
        expandedRng.endContainer = endContainer.parentNode ? endContainer.parentNode : endContainer;
        expandedRng.endOffset = dom2.nodeIndex(endContainer) + 1;
      }
      walk$1(dom2, expandedRng, function(nodes) {
        each(nodes, function(node2) {
          process2(node2);
          var textDecorations = [
            "underline",
            "line-through",
            "overline"
          ];
          each(textDecorations, function(decoration) {
            if (isElement$1(node2) && ed2.dom.getStyle(node2, "text-decoration") === decoration && node2.parentNode && getTextDecoration(dom2, node2.parentNode) === decoration) {
              removeFormat(ed2, {
                deep: false,
                exact: true,
                inline: "span",
                styles: { textDecoration: decoration }
              }, null, node2);
            }
          });
        });
      });
    };
    if (node) {
      if (isNode(node)) {
        var rng = dom2.createRng();
        rng.setStartBefore(node);
        rng.setEndAfter(node);
        removeRngStyle(rng);
      } else {
        removeRngStyle(node);
      }
      return;
    }
    if (dom2.getContentEditable(selection.getNode()) === "false") {
      node = selection.getNode();
      for (var i = 0; i < formatList.length; i++) {
        if (formatList[i].ceFalseOverride) {
          if (removeFormat(ed2, formatList[i], vars, node, node)) {
            break;
          }
        }
      }
      return;
    }
    if (!selection.isCollapsed() || !format.inline || getCellsFromEditor(ed2).length) {
      preserve(selection, true, function() {
        runOnRanges(ed2, removeRngStyle);
      });
      if (format.inline && match(ed2, name2, vars, selection.getStart())) {
        moveStart(dom2, selection, selection.getRng());
      }
      ed2.nodeChanged();
    } else {
      removeCaretFormat(ed2, name2, vars, similar);
    }
  };
  var each$b = Tools.each;
  var mergeTextDecorationsAndColor = function(dom2, format, vars, node) {
    var processTextDecorationsAndColor = function(n2) {
      if (n2.nodeType === 1 && n2.parentNode && n2.parentNode.nodeType === 1) {
        var textDecoration = getTextDecoration(dom2, n2.parentNode);
        if (dom2.getStyle(n2, "color") && textDecoration) {
          dom2.setStyle(n2, "text-decoration", textDecoration);
        } else if (dom2.getStyle(n2, "text-decoration") === textDecoration) {
          dom2.setStyle(n2, "text-decoration", null);
        }
      }
    };
    if (format.styles && (format.styles.color || format.styles.textDecoration)) {
      Tools.walk(node, processTextDecorationsAndColor, "childNodes");
      processTextDecorationsAndColor(node);
    }
  };
  var mergeBackgroundColorAndFontSize = function(dom2, format, vars, node) {
    if (format.styles && format.styles.backgroundColor) {
      processChildElements(node, hasStyle(dom2, "fontSize"), applyStyle(dom2, "backgroundColor", replaceVars(format.styles.backgroundColor, vars)));
    }
  };
  var mergeSubSup = function(dom2, format, vars, node) {
    if (format.inline === "sub" || format.inline === "sup") {
      processChildElements(node, hasStyle(dom2, "fontSize"), applyStyle(dom2, "fontSize", ""));
      dom2.remove(dom2.select(format.inline === "sup" ? "sub" : "sup", node), true);
    }
  };
  var mergeWithChildren = function(editor, formatList, vars, node) {
    each$b(formatList, function(format) {
      each$b(editor.dom.select(format.inline, node), function(child2) {
        if (!isElementNode(child2)) {
          return;
        }
        removeFormat(editor, format, vars, child2, format.exact ? child2 : null);
      });
      clearChildStyles(editor.dom, format, node);
    });
  };
  var mergeWithParents = function(editor, format, name2, vars, node) {
    if (matchNode(editor, node.parentNode, name2, vars)) {
      if (removeFormat(editor, format, vars, node)) {
        return;
      }
    }
    if (format.merge_with_parents) {
      editor.dom.getParent(node.parentNode, function(parent2) {
        if (matchNode(editor, parent2, name2, vars)) {
          removeFormat(editor, format, vars, node);
          return true;
        }
      });
    }
  };
  var each$c = Tools.each;
  var hasFormatProperty = function(format, prop) {
    return hasNonNullableKey(format, prop);
  };
  var isElementNode$1 = function(node) {
    return node && node.nodeType === 1 && !isBookmarkNode$1(node) && !isCaretNode(node) && !isBogus(node);
  };
  var canFormatBR = function(editor, format, node, parentName) {
    if (canFormatEmptyLines(editor) && isInlineFormat(format)) {
      var validBRParentElements = __assign2(__assign2({}, editor.schema.getTextBlockElements()), {
        td: {},
        th: {},
        li: {},
        dt: {},
        dd: {},
        figcaption: {},
        caption: {},
        details: {},
        summary: {}
      });
      var hasCaretNodeSibling = sibling$2(SugarElement.fromDom(node), function(sibling2) {
        return isCaretNode(sibling2.dom);
      });
      return hasNonNullableKey(validBRParentElements, parentName) && isEmpty(SugarElement.fromDom(node.parentNode), false) && !hasCaretNodeSibling;
    } else {
      return false;
    }
  };
  var applyFormat = function(ed2, name2, vars, node) {
    var formatList = ed2.formatter.get(name2);
    var format = formatList[0];
    var isCollapsed = !node && ed2.selection.isCollapsed();
    var dom2 = ed2.dom;
    var selection = ed2.selection;
    var setElementFormat = function(elm, fmt) {
      fmt = fmt || format;
      if (elm) {
        if (fmt.onformat) {
          fmt.onformat(elm, fmt, vars, node);
        }
        each$c(fmt.styles, function(value2, name3) {
          dom2.setStyle(elm, name3, replaceVars(value2, vars));
        });
        if (fmt.styles) {
          var styleVal = dom2.getAttrib(elm, "style");
          if (styleVal) {
            dom2.setAttrib(elm, "data-mce-style", styleVal);
          }
        }
        each$c(fmt.attributes, function(value2, name3) {
          dom2.setAttrib(elm, name3, replaceVars(value2, vars));
        });
        each$c(fmt.classes, function(value2) {
          value2 = replaceVars(value2, vars);
          if (!dom2.hasClass(elm, value2)) {
            dom2.addClass(elm, value2);
          }
        });
      }
    };
    var applyNodeStyle = function(formatList2, node2) {
      var found = false;
      if (!isSelectorFormat(format)) {
        return false;
      }
      each$c(formatList2, function(format2) {
        if ("collapsed" in format2 && format2.collapsed !== isCollapsed) {
          return;
        }
        if (dom2.is(node2, format2.selector) && !isCaretNode(node2)) {
          setElementFormat(node2, format2);
          found = true;
          return false;
        }
      });
      return found;
    };
    var applyRngStyle = function(dom3, rng2, bookmark, nodeSpecific) {
      var newWrappers = [];
      var contentEditable = true;
      var wrapName = format.inline || format.block;
      var wrapElm = dom3.create(wrapName);
      setElementFormat(wrapElm);
      walk$1(dom3, rng2, function(nodes) {
        var currentWrapElm;
        var process2 = function(node2) {
          var hasContentEditableState2 = false;
          var lastContentEditable = contentEditable;
          var nodeName = node2.nodeName.toLowerCase();
          var parentName = node2.parentNode.nodeName.toLowerCase();
          if (isElement$1(node2) && dom3.getContentEditable(node2)) {
            lastContentEditable = contentEditable;
            contentEditable = dom3.getContentEditable(node2) === "true";
            hasContentEditableState2 = true;
          }
          if (isBr(node2) && !canFormatBR(ed2, format, node2, parentName)) {
            currentWrapElm = null;
            if (isBlockFormat(format)) {
              dom3.remove(node2);
            }
            return;
          }
          if (format.wrapper && matchNode(ed2, node2, name2, vars)) {
            currentWrapElm = null;
            return;
          }
          if (contentEditable && !hasContentEditableState2 && isBlockFormat(format) && !format.wrapper && isTextBlock$1(ed2, nodeName) && isValid(ed2, parentName, wrapName)) {
            var elm = dom3.rename(node2, wrapName);
            setElementFormat(elm);
            newWrappers.push(elm);
            currentWrapElm = null;
            return;
          }
          if (isSelectorFormat(format)) {
            var found = applyNodeStyle(formatList, node2);
            if (isText$1(node2) && hasBlockChildren(dom3, node2.parentNode)) {
              applyNodeStyle(formatList, node2.parentNode);
            }
            if (!hasFormatProperty(format, "inline") || found) {
              currentWrapElm = null;
              return;
            }
          }
          if (contentEditable && !hasContentEditableState2 && isValid(ed2, wrapName, nodeName) && isValid(ed2, parentName, wrapName) && !(!nodeSpecific && node2.nodeType === 3 && node2.nodeValue.length === 1 && node2.nodeValue.charCodeAt(0) === 65279) && !isCaretNode(node2) && (!hasFormatProperty(format, "inline") || !dom3.isBlock(node2))) {
            if (!currentWrapElm) {
              currentWrapElm = dom3.clone(wrapElm, false);
              node2.parentNode.insertBefore(currentWrapElm, node2);
              newWrappers.push(currentWrapElm);
            }
            currentWrapElm.appendChild(node2);
          } else {
            currentWrapElm = null;
            each$c(Tools.grep(node2.childNodes), process2);
            if (hasContentEditableState2) {
              contentEditable = lastContentEditable;
            }
            currentWrapElm = null;
          }
        };
        each$c(nodes, process2);
      });
      if (format.links === true) {
        each$c(newWrappers, function(node2) {
          var process2 = function(node3) {
            if (node3.nodeName === "A") {
              setElementFormat(node3, format);
            }
            each$c(Tools.grep(node3.childNodes), process2);
          };
          process2(node2);
        });
      }
      each$c(newWrappers, function(node2) {
        var getChildCount = function(node3) {
          var count2 = 0;
          each$c(node3.childNodes, function(node4) {
            if (!isEmptyTextNode(node4) && !isBookmarkNode$1(node4)) {
              count2++;
            }
          });
          return count2;
        };
        var getChildElementNode = function(root) {
          var child2 = false;
          each$c(root.childNodes, function(node3) {
            if (isElementNode$1(node3)) {
              child2 = node3;
              return false;
            }
          });
          return child2;
        };
        var mergeStyles = function(node3) {
          var clone2;
          var child2 = getChildElementNode(node3);
          if (child2 && !isBookmarkNode$1(child2) && matchName(dom3, child2, format)) {
            clone2 = dom3.clone(child2, false);
            setElementFormat(clone2);
            dom3.replace(clone2, node3, true);
            dom3.remove(child2, true);
          }
          return clone2 || node3;
        };
        var childCount = getChildCount(node2);
        if ((newWrappers.length > 1 || !dom3.isBlock(node2)) && childCount === 0) {
          dom3.remove(node2, true);
          return;
        }
        if (isInlineFormat(format) || format.wrapper) {
          if (!format.exact && childCount === 1) {
            node2 = mergeStyles(node2);
          }
          mergeWithChildren(ed2, formatList, vars, node2);
          mergeWithParents(ed2, format, name2, vars, node2);
          mergeBackgroundColorAndFontSize(dom3, format, vars, node2);
          mergeTextDecorationsAndColor(dom3, format, vars, node2);
          mergeSubSup(dom3, format, vars, node2);
          mergeSiblings(dom3, format, vars, node2);
        }
      });
    };
    if (dom2.getContentEditable(selection.getNode()) === "false") {
      node = selection.getNode();
      for (var i = 0, l2 = formatList.length; i < l2; i++) {
        var formatItem = formatList[i];
        if (formatItem.ceFalseOverride && isSelectorFormat(formatItem) && dom2.is(node, formatItem.selector)) {
          setElementFormat(node, formatItem);
          return;
        }
      }
      return;
    }
    if (format) {
      if (node) {
        if (isNode(node)) {
          if (!applyNodeStyle(formatList, node)) {
            var rng = dom2.createRng();
            rng.setStartBefore(node);
            rng.setEndAfter(node);
            applyRngStyle(dom2, expandRng(ed2, rng, formatList), null, true);
          }
        } else {
          applyRngStyle(dom2, node, null, true);
        }
      } else {
        if (!isCollapsed || !isInlineFormat(format) || getCellsFromEditor(ed2).length) {
          var curSelNode = selection.getNode();
          var firstFormat = formatList[0];
          if (!ed2.settings.forced_root_block && firstFormat.defaultBlock && !dom2.getParent(curSelNode, dom2.isBlock)) {
            applyFormat(ed2, firstFormat.defaultBlock);
          }
          selection.setRng(normalize$2(selection.getRng()));
          preserve(selection, true, function(bookmark) {
            runOnRanges(ed2, function(selectionRng, fake) {
              var expandedRng = fake ? selectionRng : expandRng(ed2, selectionRng, formatList);
              applyRngStyle(dom2, expandedRng);
            });
          });
          moveStart(dom2, selection, selection.getRng());
          ed2.nodeChanged();
        } else {
          applyCaretFormat(ed2, name2, vars);
        }
      }
      postProcess(name2, ed2);
    }
  };
  var setup$4 = function(registeredFormatListeners, editor) {
    var currentFormats = Cell({});
    registeredFormatListeners.set({});
    editor.on("NodeChange", function(e) {
      updateAndFireChangeCallbacks(editor, e.element, currentFormats, registeredFormatListeners.get());
    });
  };
  var updateAndFireChangeCallbacks = function(editor, elm, currentFormats, formatChangeData) {
    var formatsList = keys(currentFormats.get());
    var newFormats = {};
    var matchedFormats = {};
    var parents2 = filter(getParents$1(editor.dom, elm), function(node) {
      return node.nodeType === 1 && !node.getAttribute("data-mce-bogus");
    });
    each$1(formatChangeData, function(data2, format) {
      Tools.each(parents2, function(node) {
        if (editor.formatter.matchNode(node, format, {}, data2.similar)) {
          if (formatsList.indexOf(format) === -1) {
            each(data2.callbacks, function(callback) {
              callback(true, {
                node,
                format,
                parents: parents2
              });
            });
            newFormats[format] = data2.callbacks;
          }
          matchedFormats[format] = data2.callbacks;
          return false;
        }
        if (matchesUnInheritedFormatSelector(editor, node, format)) {
          return false;
        }
      });
    });
    var remainingFormats = filterRemainingFormats(currentFormats.get(), matchedFormats, elm, parents2);
    currentFormats.set(__assign2(__assign2({}, newFormats), remainingFormats));
  };
  var filterRemainingFormats = function(currentFormats, matchedFormats, elm, parents2) {
    return bifilter(currentFormats, function(callbacks, format) {
      if (!has(matchedFormats, format)) {
        each(callbacks, function(callback) {
          callback(false, {
            node: elm,
            format,
            parents: parents2
          });
        });
        return false;
      } else {
        return true;
      }
    }).t;
  };
  var addListeners = function(registeredFormatListeners, formats, callback, similar) {
    var formatChangeItems = registeredFormatListeners.get();
    each(formats.split(","), function(format) {
      if (!formatChangeItems[format]) {
        formatChangeItems[format] = {
          similar,
          callbacks: []
        };
      }
      formatChangeItems[format].callbacks.push(callback);
    });
    registeredFormatListeners.set(formatChangeItems);
  };
  var removeListeners = function(registeredFormatListeners, formats, callback) {
    var formatChangeItems = registeredFormatListeners.get();
    each(formats.split(","), function(format) {
      formatChangeItems[format].callbacks = filter(formatChangeItems[format].callbacks, function(c) {
        return c !== callback;
      });
      if (formatChangeItems[format].callbacks.length === 0) {
        delete formatChangeItems[format];
      }
    });
    registeredFormatListeners.set(formatChangeItems);
  };
  var formatChangedInternal = function(editor, registeredFormatListeners, formats, callback, similar) {
    if (registeredFormatListeners.get() === null) {
      setup$4(registeredFormatListeners, editor);
    }
    addListeners(registeredFormatListeners, formats, callback, similar);
    return {
      unbind: function() {
        return removeListeners(registeredFormatListeners, formats, callback);
      }
    };
  };
  var toggle = function(editor, name2, vars, node) {
    var fmt = editor.formatter.get(name2);
    if (match(editor, name2, vars, node) && (!("toggle" in fmt[0]) || fmt[0].toggle)) {
      remove$6(editor, name2, vars, node);
    } else {
      applyFormat(editor, name2, vars, node);
    }
  };
  var fromElements = function(elements, scope) {
    var doc2 = scope || document;
    var fragment = doc2.createDocumentFragment();
    each(elements, function(element) {
      fragment.appendChild(element.dom);
    });
    return SugarElement.fromDom(fragment);
  };
  var tableModel = function(element, width, rows) {
    return {
      element,
      width,
      rows
    };
  };
  var tableRow = function(element, cells) {
    return {
      element,
      cells
    };
  };
  var cellPosition = function(x2, y2) {
    return {
      x: x2,
      y: y2
    };
  };
  var getSpan = function(td2, key) {
    var value2 = parseInt(get$4(td2, key), 10);
    return isNaN(value2) ? 1 : value2;
  };
  var fillout = function(table, x2, y2, tr, td2) {
    var rowspan = getSpan(td2, "rowspan");
    var colspan = getSpan(td2, "colspan");
    var rows = table.rows;
    for (var y22 = y2; y22 < y2 + rowspan; y22++) {
      if (!rows[y22]) {
        rows[y22] = tableRow(deep(tr), []);
      }
      for (var x22 = x2; x22 < x2 + colspan; x22++) {
        var cells = rows[y22].cells;
        cells[x22] = y22 === y2 && x22 === x2 ? td2 : shallow(td2);
      }
    }
  };
  var cellExists = function(table, x2, y2) {
    var rows = table.rows;
    var cells = rows[y2] ? rows[y2].cells : [];
    return !!cells[x2];
  };
  var skipCellsX = function(table, x2, y2) {
    while (cellExists(table, x2, y2)) {
      x2++;
    }
    return x2;
  };
  var getWidth = function(rows) {
    return foldl(rows, function(acc, row) {
      return row.cells.length > acc ? row.cells.length : acc;
    }, 0);
  };
  var findElementPos = function(table, element) {
    var rows = table.rows;
    for (var y2 = 0; y2 < rows.length; y2++) {
      var cells = rows[y2].cells;
      for (var x2 = 0; x2 < cells.length; x2++) {
        if (eq$2(cells[x2], element)) {
          return Optional.some(cellPosition(x2, y2));
        }
      }
    }
    return Optional.none();
  };
  var extractRows = function(table, sx, sy, ex, ey) {
    var newRows = [];
    var rows = table.rows;
    for (var y2 = sy; y2 <= ey; y2++) {
      var cells = rows[y2].cells;
      var slice2 = sx < ex ? cells.slice(sx, ex + 1) : cells.slice(ex, sx + 1);
      newRows.push(tableRow(rows[y2].element, slice2));
    }
    return newRows;
  };
  var subTable = function(table, startPos, endPos) {
    var sx = startPos.x, sy = startPos.y;
    var ex = endPos.x, ey = endPos.y;
    var newRows = sy < ey ? extractRows(table, sx, sy, ex, ey) : extractRows(table, sx, ey, ex, sy);
    return tableModel(table.element, getWidth(newRows), newRows);
  };
  var createDomTable = function(table, rows) {
    var tableElement = shallow(table.element);
    var tableBody = SugarElement.fromTag("tbody");
    append$1(tableBody, rows);
    append(tableElement, tableBody);
    return tableElement;
  };
  var modelRowsToDomRows = function(table) {
    return map(table.rows, function(row) {
      var cells = map(row.cells, function(cell) {
        var td2 = deep(cell);
        remove$1(td2, "colspan");
        remove$1(td2, "rowspan");
        return td2;
      });
      var tr = shallow(row.element);
      append$1(tr, cells);
      return tr;
    });
  };
  var fromDom$1 = function(tableElm) {
    var table = tableModel(shallow(tableElm), 0, []);
    each(descendants$1(tableElm, "tr"), function(tr, y2) {
      each(descendants$1(tr, "td,th"), function(td2, x2) {
        fillout(table, skipCellsX(table, x2, y2), y2, tr, td2);
      });
    });
    return tableModel(table.element, getWidth(table.rows), table.rows);
  };
  var toDom = function(table) {
    return createDomTable(table, modelRowsToDomRows(table));
  };
  var subsection = function(table, startElement, endElement) {
    return findElementPos(table, startElement).bind(function(startPos) {
      return findElementPos(table, endElement).map(function(endPos) {
        return subTable(table, startPos, endPos);
      });
    });
  };
  var findParentListContainer = function(parents2) {
    return find(parents2, function(elm) {
      return name(elm) === "ul" || name(elm) === "ol";
    });
  };
  var getFullySelectedListWrappers = function(parents2, rng) {
    return find(parents2, function(elm) {
      return name(elm) === "li" && hasAllContentsSelected(elm, rng);
    }).fold(constant([]), function(_li) {
      return findParentListContainer(parents2).map(function(listCont) {
        var listElm = SugarElement.fromTag(name(listCont));
        var listStyles = filter$1(getAllRaw(listCont), function(_style, name2) {
          return startsWith(name2, "list-style");
        });
        setAll$1(listElm, listStyles);
        return [
          SugarElement.fromTag("li"),
          listElm
        ];
      }).getOr([]);
    });
  };
  var wrap$3 = function(innerElm, elms) {
    var wrapped = foldl(elms, function(acc, elm) {
      append(elm, acc);
      return elm;
    }, innerElm);
    return elms.length > 0 ? fromElements([wrapped]) : wrapped;
  };
  var directListWrappers = function(commonAnchorContainer) {
    if (isListItem(commonAnchorContainer)) {
      return parent(commonAnchorContainer).filter(isList).fold(constant([]), function(listElm) {
        return [
          commonAnchorContainer,
          listElm
        ];
      });
    } else {
      return isList(commonAnchorContainer) ? [commonAnchorContainer] : [];
    }
  };
  var getWrapElements = function(rootNode, rng) {
    var commonAnchorContainer = SugarElement.fromDom(rng.commonAncestorContainer);
    var parents2 = parentsAndSelf(commonAnchorContainer, rootNode);
    var wrapElements = filter(parents2, function(elm) {
      return isInline(elm) || isHeading(elm);
    });
    var listWrappers = getFullySelectedListWrappers(parents2, rng);
    var allWrappers = wrapElements.concat(listWrappers.length ? listWrappers : directListWrappers(commonAnchorContainer));
    return map(allWrappers, shallow);
  };
  var emptyFragment = function() {
    return fromElements([]);
  };
  var getFragmentFromRange = function(rootNode, rng) {
    return wrap$3(SugarElement.fromDom(rng.cloneContents()), getWrapElements(rootNode, rng));
  };
  var getParentTable = function(rootElm, cell) {
    return ancestor$1(cell, "table", curry(eq$2, rootElm));
  };
  var getTableFragment = function(rootNode, selectedTableCells) {
    return getParentTable(rootNode, selectedTableCells[0]).bind(function(tableElm) {
      var firstCell = selectedTableCells[0];
      var lastCell = selectedTableCells[selectedTableCells.length - 1];
      var fullTableModel = fromDom$1(tableElm);
      return subsection(fullTableModel, firstCell, lastCell).map(function(sectionedTableModel) {
        return fromElements([toDom(sectionedTableModel)]);
      });
    }).getOrThunk(emptyFragment);
  };
  var getSelectionFragment = function(rootNode, ranges) {
    return ranges.length > 0 && ranges[0].collapsed ? emptyFragment() : getFragmentFromRange(rootNode, ranges[0]);
  };
  var read$1 = function(rootNode, ranges) {
    var selectedCells = getCellsFromElementOrRanges(ranges, rootNode);
    return selectedCells.length > 0 ? getTableFragment(rootNode, selectedCells) : getSelectionFragment(rootNode, ranges);
  };
  var trimLeadingCollapsibleText = function(text) {
    return text.replace(/^[ \f\n\r\t\v]+/, "");
  };
  var isCollapsibleWhitespace = function(text, index) {
    return index >= 0 && index < text.length && isWhiteSpace$1(text.charAt(index));
  };
  var getInnerText = function(bin, shouldTrim) {
    var text = trim$2(bin.innerText);
    return shouldTrim ? trimLeadingCollapsibleText(text) : text;
  };
  var getContextNodeName = function(parentBlockOpt) {
    return parentBlockOpt.map(function(block) {
      return block.nodeName;
    }).getOr("div").toLowerCase();
  };
  var getTextContent = function(editor) {
    return Optional.from(editor.selection.getRng()).map(function(rng) {
      var parentBlockOpt = Optional.from(editor.dom.getParent(rng.commonAncestorContainer, editor.dom.isBlock));
      var body = editor.getBody();
      var contextNodeName = getContextNodeName(parentBlockOpt);
      var shouldTrimSpaces = Env.browser.isIE() && contextNodeName !== "pre";
      var bin = editor.dom.add(body, contextNodeName, {
        "data-mce-bogus": "all",
        "style": "overflow: hidden; opacity: 0;"
      }, rng.cloneContents());
      var text = getInnerText(bin, shouldTrimSpaces);
      var nonRenderedText = trim$2(bin.textContent);
      editor.dom.remove(bin);
      if (isCollapsibleWhitespace(nonRenderedText, 0) || isCollapsibleWhitespace(nonRenderedText, nonRenderedText.length - 1)) {
        var parentBlock = parentBlockOpt.getOr(body);
        var parentBlockText = getInnerText(parentBlock, shouldTrimSpaces);
        var textIndex = parentBlockText.indexOf(text);
        if (textIndex === -1) {
          return text;
        } else {
          var hasProceedingSpace = isCollapsibleWhitespace(parentBlockText, textIndex - 1);
          var hasTrailingSpace = isCollapsibleWhitespace(parentBlockText, textIndex + text.length);
          return (hasProceedingSpace ? " " : "") + text + (hasTrailingSpace ? " " : "");
        }
      } else {
        return text;
      }
    }).getOr("");
  };
  var getSerializedContent = function(editor, args) {
    var rng = editor.selection.getRng(), tmpElm = editor.dom.create("body");
    var sel = editor.selection.getSel();
    var ranges = processRanges(editor, getRanges(sel));
    var fragment = args.contextual ? read$1(SugarElement.fromDom(editor.getBody()), ranges).dom : rng.cloneContents();
    if (fragment) {
      tmpElm.appendChild(fragment);
    }
    return editor.selection.serializer.serialize(tmpElm, args);
  };
  var getSelectedContentInternal = function(editor, format, args) {
    if (args === void 0) {
      args = {};
    }
    args.get = true;
    args.format = format;
    args.selection = true;
    args = editor.fire("BeforeGetContent", args);
    if (args.isDefaultPrevented()) {
      editor.fire("GetContent", args);
      return args.content;
    }
    if (args.format === "text") {
      return getTextContent(editor);
    } else {
      args.getInner = true;
      var content = getSerializedContent(editor, args);
      if (args.format === "tree") {
        return content;
      } else {
        args.content = editor.selection.isCollapsed() ? "" : content;
        editor.fire("GetContent", args);
        return args.content;
      }
    }
  };
  var KEEP = 0, INSERT = 1, DELETE = 2;
  var diff = function(left, right) {
    var size = left.length + right.length + 2;
    var vDown = new Array(size);
    var vUp = new Array(size);
    var snake = function(start2, end2, diag) {
      return {
        start: start2,
        end: end2,
        diag
      };
    };
    var buildScript = function(start1, end1, start2, end2, script2) {
      var middle = getMiddleSnake(start1, end1, start2, end2);
      if (middle === null || middle.start === end1 && middle.diag === end1 - end2 || middle.end === start1 && middle.diag === start1 - start2) {
        var i = start1;
        var j = start2;
        while (i < end1 || j < end2) {
          if (i < end1 && j < end2 && left[i] === right[j]) {
            script2.push([
              KEEP,
              left[i]
            ]);
            ++i;
            ++j;
          } else {
            if (end1 - start1 > end2 - start2) {
              script2.push([
                DELETE,
                left[i]
              ]);
              ++i;
            } else {
              script2.push([
                INSERT,
                right[j]
              ]);
              ++j;
            }
          }
        }
      } else {
        buildScript(start1, middle.start, start2, middle.start - middle.diag, script2);
        for (var i2 = middle.start; i2 < middle.end; ++i2) {
          script2.push([
            KEEP,
            left[i2]
          ]);
        }
        buildScript(middle.end, end1, middle.end - middle.diag, end2, script2);
      }
    };
    var buildSnake = function(start2, diag, end1, end2) {
      var end3 = start2;
      while (end3 - diag < end2 && end3 < end1 && left[end3] === right[end3 - diag]) {
        ++end3;
      }
      return snake(start2, end3, diag);
    };
    var getMiddleSnake = function(start1, end1, start2, end2) {
      var m2 = end1 - start1;
      var n2 = end2 - start2;
      if (m2 === 0 || n2 === 0) {
        return null;
      }
      var delta = m2 - n2;
      var sum = n2 + m2;
      var offset = (sum % 2 === 0 ? sum : sum + 1) / 2;
      vDown[1 + offset] = start1;
      vUp[1 + offset] = end1 + 1;
      var d, k, i, x2, y2;
      for (d = 0; d <= offset; ++d) {
        for (k = -d; k <= d; k += 2) {
          i = k + offset;
          if (k === -d || k !== d && vDown[i - 1] < vDown[i + 1]) {
            vDown[i] = vDown[i + 1];
          } else {
            vDown[i] = vDown[i - 1] + 1;
          }
          x2 = vDown[i];
          y2 = x2 - start1 + start2 - k;
          while (x2 < end1 && y2 < end2 && left[x2] === right[y2]) {
            vDown[i] = ++x2;
            ++y2;
          }
          if (delta % 2 !== 0 && delta - d <= k && k <= delta + d) {
            if (vUp[i - delta] <= vDown[i]) {
              return buildSnake(vUp[i - delta], k + start1 - start2, end1, end2);
            }
          }
        }
        for (k = delta - d; k <= delta + d; k += 2) {
          i = k + offset - delta;
          if (k === delta - d || k !== delta + d && vUp[i + 1] <= vUp[i - 1]) {
            vUp[i] = vUp[i + 1] - 1;
          } else {
            vUp[i] = vUp[i - 1];
          }
          x2 = vUp[i] - 1;
          y2 = x2 - start1 + start2 - k;
          while (x2 >= start1 && y2 >= start2 && left[x2] === right[y2]) {
            vUp[i] = x2--;
            y2--;
          }
          if (delta % 2 === 0 && -d <= k && k <= d) {
            if (vUp[i] <= vDown[i + delta]) {
              return buildSnake(vUp[i], k + start1 - start2, end1, end2);
            }
          }
        }
      }
    };
    var script = [];
    buildScript(0, left.length, 0, right.length, script);
    return script;
  };
  var getOuterHtml = function(elm) {
    if (isElement$1(elm)) {
      return elm.outerHTML;
    } else if (isText$1(elm)) {
      return Entities.encodeRaw(elm.data, false);
    } else if (isComment$1(elm)) {
      return "<!--" + elm.data + "-->";
    }
    return "";
  };
  var createFragment$1 = function(html) {
    var node;
    var container = document.createElement("div");
    var frag = document.createDocumentFragment();
    if (html) {
      container.innerHTML = html;
    }
    while (node = container.firstChild) {
      frag.appendChild(node);
    }
    return frag;
  };
  var insertAt = function(elm, html, index) {
    var fragment = createFragment$1(html);
    if (elm.hasChildNodes() && index < elm.childNodes.length) {
      var target = elm.childNodes[index];
      target.parentNode.insertBefore(fragment, target);
    } else {
      elm.appendChild(fragment);
    }
  };
  var removeAt = function(elm, index) {
    if (elm.hasChildNodes() && index < elm.childNodes.length) {
      var target = elm.childNodes[index];
      target.parentNode.removeChild(target);
    }
  };
  var applyDiff = function(diff2, elm) {
    var index = 0;
    each(diff2, function(action2) {
      if (action2[0] === KEEP) {
        index++;
      } else if (action2[0] === INSERT) {
        insertAt(elm, action2[1], index);
        index++;
      } else if (action2[0] === DELETE) {
        removeAt(elm, index);
      }
    });
  };
  var read$2 = function(elm) {
    return filter(map(from$1(elm.childNodes), getOuterHtml), function(item) {
      return item.length > 0;
    });
  };
  var write = function(fragments, elm) {
    var currentFragments = map(from$1(elm.childNodes), getOuterHtml);
    applyDiff(diff(currentFragments, fragments), elm);
    return elm;
  };
  var undoLevelDocument = Cell(Optional.none());
  var lazyTempDocument = function() {
    return undoLevelDocument.get().getOrThunk(function() {
      var doc2 = document.implementation.createHTMLDocument("undo");
      undoLevelDocument.set(Optional.some(doc2));
      return doc2;
    });
  };
  var hasIframes = function(html) {
    return html.indexOf("</iframe>") !== -1;
  };
  var createFragmentedLevel = function(fragments) {
    return {
      type: "fragmented",
      fragments,
      content: "",
      bookmark: null,
      beforeBookmark: null
    };
  };
  var createCompleteLevel = function(content) {
    return {
      type: "complete",
      fragments: null,
      content,
      bookmark: null,
      beforeBookmark: null
    };
  };
  var createFromEditor = function(editor) {
    var fragments = read$2(editor.getBody());
    var trimmedFragments = bind(fragments, function(html) {
      var trimmed = trimInternal(editor.serializer, html);
      return trimmed.length > 0 ? [trimmed] : [];
    });
    var content = trimmedFragments.join("");
    return hasIframes(content) ? createFragmentedLevel(trimmedFragments) : createCompleteLevel(content);
  };
  var applyToEditor = function(editor, level, before2) {
    if (level.type === "fragmented") {
      write(level.fragments, editor.getBody());
    } else {
      editor.setContent(level.content, { format: "raw" });
    }
    editor.selection.moveToBookmark(before2 ? level.beforeBookmark : level.bookmark);
  };
  var getLevelContent = function(level) {
    return level.type === "fragmented" ? level.fragments.join("") : level.content;
  };
  var getCleanLevelContent = function(level) {
    var elm = SugarElement.fromTag("body", lazyTempDocument());
    set$1(elm, getLevelContent(level));
    each(descendants$1(elm, "*[data-mce-bogus]"), unwrap);
    return get$7(elm);
  };
  var hasEqualContent = function(level1, level2) {
    return getLevelContent(level1) === getLevelContent(level2);
  };
  var hasEqualCleanedContent = function(level1, level2) {
    return getCleanLevelContent(level1) === getCleanLevelContent(level2);
  };
  var isEq$4 = function(level1, level2) {
    if (!level1 || !level2) {
      return false;
    } else if (hasEqualContent(level1, level2)) {
      return true;
    } else {
      return hasEqualCleanedContent(level1, level2);
    }
  };
  var isUnlocked = function(locks) {
    return locks.get() === 0;
  };
  var setTyping = function(undoManager, typing, locks) {
    if (isUnlocked(locks)) {
      undoManager.typing = typing;
    }
  };
  var endTyping = function(undoManager, locks) {
    if (undoManager.typing) {
      setTyping(undoManager, false, locks);
      undoManager.add();
    }
  };
  var endTypingLevelIgnoreLocks = function(undoManager) {
    if (undoManager.typing) {
      undoManager.typing = false;
      undoManager.add();
    }
  };
  var beforeChange = function(editor, locks, beforeBookmark) {
    if (isUnlocked(locks)) {
      beforeBookmark.set(Optional.some(getUndoBookmark(editor.selection)));
    }
  };
  var addUndoLevel = function(editor, undoManager, index, locks, beforeBookmark, level, event) {
    var currentLevel = createFromEditor(editor);
    level = level || {};
    level = Tools.extend(level, currentLevel);
    if (isUnlocked(locks) === false || editor.removed) {
      return null;
    }
    var lastLevel = undoManager.data[index.get()];
    if (editor.fire("BeforeAddUndo", {
      level,
      lastLevel,
      originalEvent: event
    }).isDefaultPrevented()) {
      return null;
    }
    if (lastLevel && isEq$4(lastLevel, level)) {
      return null;
    }
    if (undoManager.data[index.get()]) {
      beforeBookmark.get().each(function(bm) {
        undoManager.data[index.get()].beforeBookmark = bm;
      });
    }
    var customUndoRedoLevels = getCustomUndoRedoLevels(editor);
    if (customUndoRedoLevels) {
      if (undoManager.data.length > customUndoRedoLevels) {
        for (var i = 0; i < undoManager.data.length - 1; i++) {
          undoManager.data[i] = undoManager.data[i + 1];
        }
        undoManager.data.length--;
        index.set(undoManager.data.length);
      }
    }
    level.bookmark = getUndoBookmark(editor.selection);
    if (index.get() < undoManager.data.length - 1) {
      undoManager.data.length = index.get() + 1;
    }
    undoManager.data.push(level);
    index.set(undoManager.data.length - 1);
    var args = {
      level,
      lastLevel,
      originalEvent: event
    };
    if (index.get() > 0) {
      editor.setDirty(true);
      editor.fire("AddUndo", args);
      editor.fire("change", args);
    } else {
      editor.fire("AddUndo", args);
    }
    return level;
  };
  var clear = function(editor, undoManager, index) {
    undoManager.data = [];
    index.set(0);
    undoManager.typing = false;
    editor.fire("ClearUndos");
  };
  var extra = function(editor, undoManager, index, callback1, callback2) {
    if (undoManager.transact(callback1)) {
      var bookmark = undoManager.data[index.get()].bookmark;
      var lastLevel = undoManager.data[index.get() - 1];
      applyToEditor(editor, lastLevel, true);
      if (undoManager.transact(callback2)) {
        undoManager.data[index.get() - 1].beforeBookmark = bookmark;
      }
    }
  };
  var redo = function(editor, index, data2) {
    var level;
    if (index.get() < data2.length - 1) {
      index.set(index.get() + 1);
      level = data2[index.get()];
      applyToEditor(editor, level, false);
      editor.setDirty(true);
      editor.fire("Redo", { level });
    }
    return level;
  };
  var undo = function(editor, undoManager, locks, index) {
    var level;
    if (undoManager.typing) {
      undoManager.add();
      undoManager.typing = false;
      setTyping(undoManager, false, locks);
    }
    if (index.get() > 0) {
      index.set(index.get() - 1);
      level = undoManager.data[index.get()];
      applyToEditor(editor, level, true);
      editor.setDirty(true);
      editor.fire("Undo", { level });
    }
    return level;
  };
  var reset = function(undoManager) {
    undoManager.clear();
    undoManager.add();
  };
  var hasUndo = function(editor, undoManager, index) {
    return index.get() > 0 || undoManager.typing && undoManager.data[0] && !isEq$4(createFromEditor(editor), undoManager.data[0]);
  };
  var hasRedo = function(undoManager, index) {
    return index.get() < undoManager.data.length - 1 && !undoManager.typing;
  };
  var transact = function(undoManager, locks, callback) {
    endTyping(undoManager, locks);
    undoManager.beforeChange();
    undoManager.ignore(callback);
    return undoManager.add();
  };
  var ignore = function(locks, callback) {
    try {
      locks.set(locks.get() + 1);
      callback();
    } finally {
      locks.set(locks.get() - 1);
    }
  };
  var addVisualInternal = function(editor, elm) {
    var dom2 = editor.dom;
    var scope = isNonNullable(elm) ? elm : editor.getBody();
    if (isUndefined(editor.hasVisual)) {
      editor.hasVisual = isVisualAidsEnabled(editor);
    }
    each(dom2.select("table,a", scope), function(matchedElm) {
      switch (matchedElm.nodeName) {
        case "TABLE":
          var cls = getVisualAidsTableClass(editor);
          var value2 = dom2.getAttrib(matchedElm, "border");
          if ((!value2 || value2 === "0") && editor.hasVisual) {
            dom2.addClass(matchedElm, cls);
          } else {
            dom2.removeClass(matchedElm, cls);
          }
          break;
        case "A":
          if (!dom2.getAttrib(matchedElm, "href")) {
            var value_1 = dom2.getAttrib(matchedElm, "name") || matchedElm.id;
            var cls_1 = getVisualAidsAnchorClass(editor);
            if (value_1 && editor.hasVisual) {
              dom2.addClass(matchedElm, cls_1);
            } else {
              dom2.removeClass(matchedElm, cls_1);
            }
          }
          break;
      }
    });
    editor.fire("VisualAid", {
      element: elm,
      hasVisual: editor.hasVisual
    });
  };
  var makePlainAdaptor = function(editor) {
    return {
      undoManager: {
        beforeChange: function(locks, beforeBookmark) {
          return beforeChange(editor, locks, beforeBookmark);
        },
        addUndoLevel: function(undoManager, index, locks, beforeBookmark, level, event) {
          return addUndoLevel(editor, undoManager, index, locks, beforeBookmark, level, event);
        },
        undo: function(undoManager, locks, index) {
          return undo(editor, undoManager, locks, index);
        },
        redo: function(index, data2) {
          return redo(editor, index, data2);
        },
        clear: function(undoManager, index) {
          return clear(editor, undoManager, index);
        },
        reset: function(undoManager) {
          return reset(undoManager);
        },
        hasUndo: function(undoManager, index) {
          return hasUndo(editor, undoManager, index);
        },
        hasRedo: function(undoManager, index) {
          return hasRedo(undoManager, index);
        },
        transact: function(undoManager, locks, callback) {
          return transact(undoManager, locks, callback);
        },
        ignore: function(locks, callback) {
          return ignore(locks, callback);
        },
        extra: function(undoManager, index, callback1, callback2) {
          return extra(editor, undoManager, index, callback1, callback2);
        }
      },
      formatter: {
        match: function(name2, vars, node) {
          return match(editor, name2, vars, node);
        },
        matchAll: function(names, vars) {
          return matchAll(editor, names, vars);
        },
        matchNode: function(node, name2, vars, similar) {
          return matchNode(editor, node, name2, vars, similar);
        },
        canApply: function(name2) {
          return canApply(editor, name2);
        },
        closest: function(names) {
          return closest$3(editor, names);
        },
        apply: function(name2, vars, node) {
          return applyFormat(editor, name2, vars, node);
        },
        remove: function(name2, vars, node, similar) {
          return remove$6(editor, name2, vars, node, similar);
        },
        toggle: function(name2, vars, node) {
          return toggle(editor, name2, vars, node);
        },
        formatChanged: function(registeredFormatListeners, formats, callback, similar) {
          return formatChangedInternal(editor, registeredFormatListeners, formats, callback, similar);
        }
      },
      editor: {
        getContent: function(args, format) {
          return getContentInternal(editor, args, format);
        },
        setContent: function(content, args) {
          return setContentInternal(editor, content, args);
        },
        insertContent: function(value2, details) {
          return insertHtmlAtCaret(editor, value2, details);
        },
        addVisual: function(elm) {
          return addVisualInternal(editor, elm);
        }
      },
      selection: {
        getContent: function(format, args) {
          return getSelectedContentInternal(editor, format, args);
        }
      },
      raw: {
        getModel: function() {
          return Optional.none();
        }
      }
    };
  };
  var makeRtcAdaptor = function(rtcEditor) {
    var defaultVars = function(vars) {
      return isObject(vars) ? vars : {};
    };
    var unsupported = die("Unimplemented feature for rtc");
    var undoManager = rtcEditor.undoManager, formatter = rtcEditor.formatter, editor = rtcEditor.editor, selection = rtcEditor.selection, raw = rtcEditor.raw;
    var ignore2 = noop;
    return {
      undoManager: {
        beforeChange: ignore2,
        addUndoLevel: unsupported,
        undo: function() {
          return undoManager.undo();
        },
        redo: function() {
          return undoManager.redo();
        },
        clear: function() {
          return undoManager.clear();
        },
        reset: function() {
          return undoManager.reset();
        },
        hasUndo: function() {
          return undoManager.hasUndo();
        },
        hasRedo: function() {
          return undoManager.hasRedo();
        },
        transact: function(_undoManager, _locks, fn) {
          return undoManager.transact(fn);
        },
        ignore: function(_locks, callback) {
          return undoManager.ignore(callback);
        },
        extra: function(_undoManager, _index, callback1, callback2) {
          return undoManager.extra(callback1, callback2);
        }
      },
      formatter: {
        match: function(name2, vars, _node) {
          return formatter.match(name2, defaultVars(vars));
        },
        matchAll: unsupported,
        matchNode: unsupported,
        canApply: function(name2) {
          return formatter.canApply(name2);
        },
        closest: function(names) {
          return formatter.closest(names);
        },
        apply: function(name2, vars, _node) {
          return formatter.apply(name2, defaultVars(vars));
        },
        remove: function(name2, vars, _node, _similar) {
          return formatter.remove(name2, defaultVars(vars));
        },
        toggle: function(name2, vars, _node) {
          return formatter.toggle(name2, defaultVars(vars));
        },
        formatChanged: function(_rfl, formats, callback, similar) {
          return formatter.formatChanged(formats, callback, similar);
        }
      },
      editor: {
        getContent: function(args, _format) {
          return editor.getContent(args);
        },
        setContent: function(content, args) {
          return editor.setContent(content, args);
        },
        insertContent: function(content, _details) {
          return editor.insertContent(content);
        },
        addVisual: ignore2
      },
      selection: {
        getContent: function(_format, args) {
          return selection.getContent(args);
        }
      },
      raw: {
        getModel: function() {
          return Optional.some(raw.getRawModel());
        }
      }
    };
  };
  var makeNoopAdaptor = function() {
    var nul = constant(null);
    var empty2 = constant("");
    return {
      undoManager: {
        beforeChange: noop,
        addUndoLevel: nul,
        undo: nul,
        redo: nul,
        clear: noop,
        reset: noop,
        hasUndo: never,
        hasRedo: never,
        transact: nul,
        ignore: noop,
        extra: noop
      },
      formatter: {
        match: never,
        matchAll: constant([]),
        matchNode: never,
        canApply: never,
        closest: empty2,
        apply: noop,
        remove: noop,
        toggle: noop,
        formatChanged: constant({ unbind: noop })
      },
      editor: {
        getContent: empty2,
        setContent: empty2,
        insertContent: noop,
        addVisual: noop
      },
      selection: { getContent: empty2 },
      raw: { getModel: constant(Optional.none()) }
    };
  };
  var isRtc = function(editor) {
    return has(editor.plugins, "rtc");
  };
  var getRtcSetup = function(editor) {
    return get$1(editor.plugins, "rtc").bind(function(rtcPlugin) {
      return Optional.from(rtcPlugin.setup);
    });
  };
  var setup$5 = function(editor) {
    var editorCast = editor;
    return getRtcSetup(editor).fold(function() {
      editorCast.rtcInstance = makePlainAdaptor(editor);
      return Optional.none();
    }, function(setup2) {
      return Optional.some(setup2().then(function(rtcEditor) {
        editorCast.rtcInstance = makeRtcAdaptor(rtcEditor);
        return rtcEditor.rtc.isRemote;
      }, function(err) {
        editorCast.rtcInstance = makeNoopAdaptor();
        return promiseObj.reject(err);
      }));
    });
  };
  var getRtcInstanceWithFallback = function(editor) {
    return editor.rtcInstance ? editor.rtcInstance : makePlainAdaptor(editor);
  };
  var getRtcInstanceWithError = function(editor) {
    var rtcInstance = editor.rtcInstance;
    if (!rtcInstance) {
      throw new Error("Failed to get RTC instance not yet initialized.");
    } else {
      return rtcInstance;
    }
  };
  var beforeChange$1 = function(editor, locks, beforeBookmark) {
    getRtcInstanceWithError(editor).undoManager.beforeChange(locks, beforeBookmark);
  };
  var addUndoLevel$1 = function(editor, undoManager, index, locks, beforeBookmark, level, event) {
    return getRtcInstanceWithError(editor).undoManager.addUndoLevel(undoManager, index, locks, beforeBookmark, level, event);
  };
  var undo$1 = function(editor, undoManager, locks, index) {
    return getRtcInstanceWithError(editor).undoManager.undo(undoManager, locks, index);
  };
  var redo$1 = function(editor, index, data2) {
    return getRtcInstanceWithError(editor).undoManager.redo(index, data2);
  };
  var clear$1 = function(editor, undoManager, index) {
    getRtcInstanceWithError(editor).undoManager.clear(undoManager, index);
  };
  var reset$1 = function(editor, undoManager) {
    getRtcInstanceWithError(editor).undoManager.reset(undoManager);
  };
  var hasUndo$1 = function(editor, undoManager, index) {
    return getRtcInstanceWithError(editor).undoManager.hasUndo(undoManager, index);
  };
  var hasRedo$1 = function(editor, undoManager, index) {
    return getRtcInstanceWithError(editor).undoManager.hasRedo(undoManager, index);
  };
  var transact$1 = function(editor, undoManager, locks, callback) {
    return getRtcInstanceWithError(editor).undoManager.transact(undoManager, locks, callback);
  };
  var ignore$1 = function(editor, locks, callback) {
    getRtcInstanceWithError(editor).undoManager.ignore(locks, callback);
  };
  var extra$1 = function(editor, undoManager, index, callback1, callback2) {
    getRtcInstanceWithError(editor).undoManager.extra(undoManager, index, callback1, callback2);
  };
  var matchFormat = function(editor, name2, vars, node) {
    return getRtcInstanceWithError(editor).formatter.match(name2, vars, node);
  };
  var matchAllFormats = function(editor, names, vars) {
    return getRtcInstanceWithError(editor).formatter.matchAll(names, vars);
  };
  var matchNodeFormat = function(editor, node, name2, vars, similar) {
    return getRtcInstanceWithError(editor).formatter.matchNode(node, name2, vars, similar);
  };
  var canApplyFormat = function(editor, name2) {
    return getRtcInstanceWithError(editor).formatter.canApply(name2);
  };
  var closestFormat = function(editor, names) {
    return getRtcInstanceWithError(editor).formatter.closest(names);
  };
  var applyFormat$1 = function(editor, name2, vars, node) {
    getRtcInstanceWithError(editor).formatter.apply(name2, vars, node);
  };
  var removeFormat$1 = function(editor, name2, vars, node, similar) {
    getRtcInstanceWithError(editor).formatter.remove(name2, vars, node, similar);
  };
  var toggleFormat = function(editor, name2, vars, node) {
    getRtcInstanceWithError(editor).formatter.toggle(name2, vars, node);
  };
  var formatChanged = function(editor, registeredFormatListeners, formats, callback, similar) {
    if (similar === void 0) {
      similar = false;
    }
    return getRtcInstanceWithError(editor).formatter.formatChanged(registeredFormatListeners, formats, callback, similar);
  };
  var getContent = function(editor, args, format) {
    return getRtcInstanceWithFallback(editor).editor.getContent(args, format);
  };
  var setContent = function(editor, content, args) {
    return getRtcInstanceWithFallback(editor).editor.setContent(content, args);
  };
  var insertContent = function(editor, value2, details) {
    return getRtcInstanceWithFallback(editor).editor.insertContent(value2, details);
  };
  var getSelectedContent = function(editor, format, args) {
    return getRtcInstanceWithError(editor).selection.getContent(format, args);
  };
  var addVisual = function(editor, elm) {
    return getRtcInstanceWithError(editor).editor.addVisual(elm);
  };
  var getContent$1 = function(editor, args) {
    if (args === void 0) {
      args = {};
    }
    var format = args.format ? args.format : "html";
    return getSelectedContent(editor, format, args);
  };
  var removeEmpty = function(text) {
    if (text.dom.length === 0) {
      remove(text);
      return Optional.none();
    } else {
      return Optional.some(text);
    }
  };
  var walkPastBookmark = function(node, start2) {
    return node.filter(function(elm) {
      return BookmarkManager.isBookmarkNode(elm.dom);
    }).bind(start2 ? nextSibling : prevSibling);
  };
  var merge = function(outer, inner, rng, start2) {
    var outerElm = outer.dom;
    var innerElm = inner.dom;
    var oldLength = start2 ? outerElm.length : innerElm.length;
    if (start2) {
      mergeTextNodes(outerElm, innerElm, false, !start2);
      rng.setStart(innerElm, oldLength);
    } else {
      mergeTextNodes(innerElm, outerElm, false, !start2);
      rng.setEnd(innerElm, oldLength);
    }
  };
  var normalizeTextIfRequired = function(inner, start2) {
    parent(inner).each(function(root) {
      var text = inner.dom;
      if (start2 && needsToBeNbspLeft(root, CaretPosition(text, 0))) {
        normalizeWhitespaceAfter(text, 0);
      } else if (!start2 && needsToBeNbspRight(root, CaretPosition(text, text.length))) {
        normalizeWhitespaceBefore(text, text.length);
      }
    });
  };
  var mergeAndNormalizeText = function(outerNode, innerNode, rng, start2) {
    outerNode.bind(function(outer) {
      var normalizer = start2 ? normalizeWhitespaceBefore : normalizeWhitespaceAfter;
      normalizer(outer.dom, start2 ? outer.dom.length : 0);
      return innerNode.filter(isText).map(function(inner) {
        return merge(outer, inner, rng, start2);
      });
    }).orThunk(function() {
      var innerTextNode = walkPastBookmark(innerNode, start2).or(innerNode).filter(isText);
      return innerTextNode.map(function(inner) {
        return normalizeTextIfRequired(inner, start2);
      });
    });
  };
  var rngSetContent = function(rng, fragment) {
    var firstChild2 = Optional.from(fragment.firstChild).map(SugarElement.fromDom);
    var lastChild2 = Optional.from(fragment.lastChild).map(SugarElement.fromDom);
    rng.deleteContents();
    rng.insertNode(fragment);
    var prevText = firstChild2.bind(prevSibling).filter(isText).bind(removeEmpty);
    var nextText = lastChild2.bind(nextSibling).filter(isText).bind(removeEmpty);
    mergeAndNormalizeText(prevText, firstChild2, rng, true);
    mergeAndNormalizeText(nextText, lastChild2, rng, false);
    rng.collapse(false);
  };
  var setupArgs = function(args, content) {
    return __assign2(__assign2({ format: "html" }, args), {
      set: true,
      selection: true,
      content
    });
  };
  var cleanContent = function(editor, args) {
    if (args.format !== "raw") {
      var rng = editor.selection.getRng();
      var contextBlock = editor.dom.getParent(rng.commonAncestorContainer, editor.dom.isBlock);
      var contextArgs = contextBlock ? { context: contextBlock.nodeName.toLowerCase() } : {};
      var node = editor.parser.parse(args.content, __assign2(__assign2({
        isRootContent: true,
        forced_root_block: false
      }, contextArgs), args));
      return HtmlSerializer({ validate: editor.validate }, editor.schema).serialize(node);
    } else {
      return args.content;
    }
  };
  var setContent$1 = function(editor, content, args) {
    if (args === void 0) {
      args = {};
    }
    var contentArgs = setupArgs(args, content);
    if (!contentArgs.no_events) {
      contentArgs = editor.fire("BeforeSetContent", contentArgs);
      if (contentArgs.isDefaultPrevented()) {
        editor.fire("SetContent", contentArgs);
        return;
      }
    }
    args.content = cleanContent(editor, contentArgs);
    var rng = editor.selection.getRng();
    rngSetContent(rng, rng.createContextualFragment(args.content));
    editor.selection.setRng(rng);
    scrollRangeIntoView(editor, rng);
    if (!contentArgs.no_events) {
      editor.fire("SetContent", contentArgs);
    }
  };
  var deleteFromCallbackMap = function(callbackMap, selector, callback) {
    if (callbackMap && callbackMap.hasOwnProperty(selector)) {
      var newCallbacks = filter(callbackMap[selector], function(cb2) {
        return cb2 !== callback;
      });
      if (newCallbacks.length === 0) {
        delete callbackMap[selector];
      } else {
        callbackMap[selector] = newCallbacks;
      }
    }
  };
  function SelectorChanged(dom2, editor) {
    var selectorChangedData;
    var currentSelectors;
    return {
      selectorChangedWithUnbind: function(selector, callback) {
        if (!selectorChangedData) {
          selectorChangedData = {};
          currentSelectors = {};
          editor.on("NodeChange", function(e) {
            var node = e.element, parents2 = dom2.getParents(node, null, dom2.getRoot()), matchedSelectors = {};
            Tools.each(selectorChangedData, function(callbacks, selector2) {
              Tools.each(parents2, function(node2) {
                if (dom2.is(node2, selector2)) {
                  if (!currentSelectors[selector2]) {
                    Tools.each(callbacks, function(callback2) {
                      callback2(true, {
                        node: node2,
                        selector: selector2,
                        parents: parents2
                      });
                    });
                    currentSelectors[selector2] = callbacks;
                  }
                  matchedSelectors[selector2] = callbacks;
                  return false;
                }
              });
            });
            Tools.each(currentSelectors, function(callbacks, selector2) {
              if (!matchedSelectors[selector2]) {
                delete currentSelectors[selector2];
                Tools.each(callbacks, function(callback2) {
                  callback2(false, {
                    node,
                    selector: selector2,
                    parents: parents2
                  });
                });
              }
            });
          });
        }
        if (!selectorChangedData[selector]) {
          selectorChangedData[selector] = [];
        }
        selectorChangedData[selector].push(callback);
        return {
          unbind: function() {
            deleteFromCallbackMap(selectorChangedData, selector, callback);
            deleteFromCallbackMap(currentSelectors, selector, callback);
          }
        };
      }
    };
  }
  var isNativeIeSelection = function(rng) {
    return !!rng.select;
  };
  var isAttachedToDom = function(node) {
    return !!(node && node.ownerDocument) && contains$2(SugarElement.fromDom(node.ownerDocument), SugarElement.fromDom(node));
  };
  var isValidRange = function(rng) {
    if (!rng) {
      return false;
    } else if (isNativeIeSelection(rng)) {
      return true;
    } else {
      return isAttachedToDom(rng.startContainer) && isAttachedToDom(rng.endContainer);
    }
  };
  var EditorSelection = function(dom2, win, serializer, editor) {
    var selectedRange;
    var explicitRange;
    var selectorChangedWithUnbind = SelectorChanged(dom2, editor).selectorChangedWithUnbind;
    var setCursorLocation = function(node, offset) {
      var rng = dom2.createRng();
      if (isNonNullable(node) && isNonNullable(offset)) {
        rng.setStart(node, offset);
        rng.setEnd(node, offset);
        setRng(rng);
        collapse2(false);
      } else {
        moveEndPoint$1(dom2, rng, editor.getBody(), true);
        setRng(rng);
      }
    };
    var getContent2 = function(args) {
      return getContent$1(editor, args);
    };
    var setContent2 = function(content, args) {
      return setContent$1(editor, content, args);
    };
    var getStart2 = function(real) {
      return getStart$2(editor.getBody(), getRng$1(), real);
    };
    var getEnd$1 = function(real) {
      return getEnd(editor.getBody(), getRng$1(), real);
    };
    var getBookmark2 = function(type2, normalized) {
      return bookmarkManager.getBookmark(type2, normalized);
    };
    var moveToBookmark2 = function(bookmark) {
      return bookmarkManager.moveToBookmark(bookmark);
    };
    var select2 = function(node, content) {
      select$1(dom2, node, content).each(setRng);
      return node;
    };
    var isCollapsed = function() {
      var rng = getRng$1(), sel = getSel();
      if (!rng || rng.item) {
        return false;
      }
      if (rng.compareEndPoints) {
        return rng.compareEndPoints("StartToEnd", rng) === 0;
      }
      return !sel || rng.collapsed;
    };
    var collapse2 = function(toStart) {
      var rng = getRng$1();
      rng.collapse(!!toStart);
      setRng(rng);
    };
    var getSel = function() {
      return win.getSelection ? win.getSelection() : win.document.selection;
    };
    var getRng$1 = function() {
      var selection, rng, elm;
      var tryCompareBoundaryPoints = function(how, sourceRange, destinationRange) {
        try {
          return sourceRange.compareBoundaryPoints(how, destinationRange);
        } catch (ex) {
          return -1;
        }
      };
      var doc2 = win.document;
      if (editor.bookmark !== void 0 && hasFocus$1(editor) === false) {
        var bookmark = getRng(editor);
        if (bookmark.isSome()) {
          return bookmark.map(function(r3) {
            return processRanges(editor, [r3])[0];
          }).getOr(doc2.createRange());
        }
      }
      try {
        if ((selection = getSel()) && !isRestrictedNode(selection.anchorNode)) {
          if (selection.rangeCount > 0) {
            rng = selection.getRangeAt(0);
          } else {
            rng = selection.createRange ? selection.createRange() : doc2.createRange();
          }
          rng = processRanges(editor, [rng])[0];
        }
      } catch (ex) {
      }
      if (!rng) {
        rng = doc2.createRange ? doc2.createRange() : doc2.body.createTextRange();
      }
      if (rng.setStart && rng.startContainer.nodeType === 9 && rng.collapsed) {
        elm = dom2.getRoot();
        rng.setStart(elm, 0);
        rng.setEnd(elm, 0);
      }
      if (selectedRange && explicitRange) {
        if (tryCompareBoundaryPoints(rng.START_TO_START, rng, selectedRange) === 0 && tryCompareBoundaryPoints(rng.END_TO_END, rng, selectedRange) === 0) {
          rng = explicitRange;
        } else {
          selectedRange = null;
          explicitRange = null;
        }
      }
      return rng;
    };
    var setRng = function(rng, forward) {
      var node;
      if (!isValidRange(rng)) {
        return;
      }
      var ieRange = isNativeIeSelection(rng) ? rng : null;
      if (ieRange) {
        explicitRange = null;
        try {
          ieRange.select();
        } catch (ex) {
        }
        return;
      }
      var sel = getSel();
      var evt = editor.fire("SetSelectionRange", {
        range: rng,
        forward
      });
      rng = evt.range;
      if (sel) {
        explicitRange = rng;
        try {
          sel.removeAllRanges();
          sel.addRange(rng);
        } catch (ex) {
        }
        if (forward === false && sel.extend) {
          sel.collapse(rng.endContainer, rng.endOffset);
          sel.extend(rng.startContainer, rng.startOffset);
        }
        selectedRange = sel.rangeCount > 0 ? sel.getRangeAt(0) : null;
      }
      if (!rng.collapsed && rng.startContainer === rng.endContainer && sel.setBaseAndExtent && !Env.ie) {
        if (rng.endOffset - rng.startOffset < 2) {
          if (rng.startContainer.hasChildNodes()) {
            node = rng.startContainer.childNodes[rng.startOffset];
            if (node && node.tagName === "IMG") {
              sel.setBaseAndExtent(rng.startContainer, rng.startOffset, rng.endContainer, rng.endOffset);
              if (sel.anchorNode !== rng.startContainer || sel.focusNode !== rng.endContainer) {
                sel.setBaseAndExtent(node, 0, node, 1);
              }
            }
          }
        }
      }
      editor.fire("AfterSetSelectionRange", {
        range: rng,
        forward
      });
    };
    var setNode = function(elm) {
      setContent2(dom2.getOuterHTML(elm));
      return elm;
    };
    var getNode2 = function() {
      return getNode$1(editor.getBody(), getRng$1());
    };
    var getSelectedBlocks$1 = function(startElm, endElm) {
      return getSelectedBlocks(dom2, getRng$1(), startElm, endElm);
    };
    var isForward = function() {
      var sel = getSel();
      var anchorNode = sel === null || sel === void 0 ? void 0 : sel.anchorNode;
      var focusNode = sel === null || sel === void 0 ? void 0 : sel.focusNode;
      if (!sel || !anchorNode || !focusNode || isRestrictedNode(anchorNode) || isRestrictedNode(focusNode)) {
        return true;
      }
      var anchorRange = dom2.createRng();
      anchorRange.setStart(anchorNode, sel.anchorOffset);
      anchorRange.collapse(true);
      var focusRange = dom2.createRng();
      focusRange.setStart(focusNode, sel.focusOffset);
      focusRange.collapse(true);
      return anchorRange.compareBoundaryPoints(anchorRange.START_TO_START, focusRange) <= 0;
    };
    var normalize$12 = function() {
      var rng = getRng$1();
      var sel = getSel();
      if (!hasMultipleRanges(sel) && hasAnyRanges(editor)) {
        var normRng = normalize(dom2, rng);
        normRng.each(function(normRng2) {
          setRng(normRng2, isForward());
        });
        return normRng.getOr(rng);
      }
      return rng;
    };
    var selectorChanged = function(selector, callback) {
      selectorChangedWithUnbind(selector, callback);
      return exports;
    };
    var getScrollContainer = function() {
      var scrollContainer;
      var node = dom2.getRoot();
      while (node && node.nodeName !== "BODY") {
        if (node.scrollHeight > node.clientHeight) {
          scrollContainer = node;
          break;
        }
        node = node.parentNode;
      }
      return scrollContainer;
    };
    var scrollIntoView = function(elm, alignToTop) {
      return scrollElementIntoView(editor, elm, alignToTop);
    };
    var placeCaretAt = function(clientX, clientY) {
      return setRng(fromPoint$1(clientX, clientY, editor.getDoc()));
    };
    var getBoundingClientRect2 = function() {
      var rng = getRng$1();
      return rng.collapsed ? CaretPosition.fromRangeStart(rng).getClientRects()[0] : rng.getBoundingClientRect();
    };
    var destroy2 = function() {
      win = selectedRange = explicitRange = null;
      controlSelection.destroy();
    };
    var exports = {
      bookmarkManager: null,
      controlSelection: null,
      dom: dom2,
      win,
      serializer,
      editor,
      collapse: collapse2,
      setCursorLocation,
      getContent: getContent2,
      setContent: setContent2,
      getBookmark: getBookmark2,
      moveToBookmark: moveToBookmark2,
      select: select2,
      isCollapsed,
      isForward,
      setNode,
      getNode: getNode2,
      getSel,
      setRng,
      getRng: getRng$1,
      getStart: getStart2,
      getEnd: getEnd$1,
      getSelectedBlocks: getSelectedBlocks$1,
      normalize: normalize$12,
      selectorChanged,
      selectorChangedWithUnbind,
      getScrollContainer,
      scrollIntoView,
      placeCaretAt,
      getBoundingClientRect: getBoundingClientRect2,
      destroy: destroy2
    };
    var bookmarkManager = BookmarkManager(exports);
    var controlSelection = ControlSelection(exports, editor);
    exports.bookmarkManager = bookmarkManager;
    exports.controlSelection = controlSelection;
    return exports;
  };
  var removeAttrs = function(node, names) {
    each(names, function(name2) {
      node.attr(name2, null);
    });
  };
  var addFontToSpansFilter = function(domParser, styles, fontSizes) {
    domParser.addNodeFilter("font", function(nodes) {
      each(nodes, function(node) {
        var props = styles.parse(node.attr("style"));
        var color = node.attr("color");
        var face = node.attr("face");
        var size = node.attr("size");
        if (color) {
          props.color = color;
        }
        if (face) {
          props["font-family"] = face;
        }
        if (size) {
          props["font-size"] = fontSizes[parseInt(node.attr("size"), 10) - 1];
        }
        node.name = "span";
        node.attr("style", styles.serialize(props));
        removeAttrs(node, [
          "color",
          "face",
          "size"
        ]);
      });
    });
  };
  var addStrikeToSpanFilter = function(domParser, styles) {
    domParser.addNodeFilter("strike", function(nodes) {
      each(nodes, function(node) {
        var props = styles.parse(node.attr("style"));
        props["text-decoration"] = "line-through";
        node.name = "span";
        node.attr("style", styles.serialize(props));
      });
    });
  };
  var addFilters = function(domParser, settings) {
    var styles = Styles();
    if (settings.convert_fonts_to_spans) {
      addFontToSpansFilter(domParser, styles, Tools.explode(settings.font_size_legacy_values));
    }
    addStrikeToSpanFilter(domParser, styles);
  };
  var register$1 = function(domParser, settings) {
    if (settings.inline_styles) {
      addFilters(domParser, settings);
    }
  };
  var blobUriToBlob = function(url) {
    return new promiseObj(function(resolve2, reject) {
      var rejectWithError = function() {
        reject("Cannot convert " + url + " to Blob. Resource might not exist or is inaccessible.");
      };
      try {
        var xhr_1 = new XMLHttpRequest();
        xhr_1.open("GET", url, true);
        xhr_1.responseType = "blob";
        xhr_1.onload = function() {
          if (xhr_1.status === 200) {
            resolve2(xhr_1.response);
          } else {
            rejectWithError();
          }
        };
        xhr_1.onerror = rejectWithError;
        xhr_1.send();
      } catch (ex) {
        rejectWithError();
      }
    });
  };
  var parseDataUri$1 = function(uri) {
    var type2;
    var uriParts = decodeURIComponent(uri).split(",");
    var matches2 = /data:([^;]+)/.exec(uriParts[0]);
    if (matches2) {
      type2 = matches2[1];
    }
    return {
      type: type2,
      data: uriParts[1]
    };
  };
  var buildBlob = function(type2, data2) {
    var str;
    try {
      str = atob(data2);
    } catch (e) {
      return Optional.none();
    }
    var arr2 = new Uint8Array(str.length);
    for (var i = 0; i < arr2.length; i++) {
      arr2[i] = str.charCodeAt(i);
    }
    return Optional.some(new Blob([arr2], { type: type2 }));
  };
  var dataUriToBlob = function(uri) {
    return new promiseObj(function(resolve2) {
      var _a = parseDataUri$1(uri), type2 = _a.type, data2 = _a.data;
      buildBlob(type2, data2).fold(function() {
        return resolve2(new Blob([]));
      }, resolve2);
    });
  };
  var uriToBlob = function(url) {
    if (url.indexOf("blob:") === 0) {
      return blobUriToBlob(url);
    }
    if (url.indexOf("data:") === 0) {
      return dataUriToBlob(url);
    }
    return null;
  };
  var blobToDataUri = function(blob) {
    return new promiseObj(function(resolve2) {
      var reader = new FileReader();
      reader.onloadend = function() {
        resolve2(reader.result);
      };
      reader.readAsDataURL(blob);
    });
  };
  var count = 0;
  var uniqueId = function(prefix) {
    return (prefix || "blobid") + count++;
  };
  var imageToBlobInfo = function(blobCache, img, resolve2, reject) {
    var base64, blobInfo;
    if (img.src.indexOf("blob:") === 0) {
      blobInfo = blobCache.getByUri(img.src);
      if (blobInfo) {
        resolve2({
          image: img,
          blobInfo
        });
      } else {
        uriToBlob(img.src).then(function(blob) {
          blobToDataUri(blob).then(function(dataUri) {
            base64 = parseDataUri$1(dataUri).data;
            blobInfo = blobCache.create(uniqueId(), blob, base64);
            blobCache.add(blobInfo);
            resolve2({
              image: img,
              blobInfo
            });
          });
        }, function(err) {
          reject(err);
        });
      }
      return;
    }
    var _a = parseDataUri$1(img.src), data2 = _a.data, type2 = _a.type;
    base64 = data2;
    blobInfo = blobCache.getByData(base64, type2);
    if (blobInfo) {
      resolve2({
        image: img,
        blobInfo
      });
    } else {
      uriToBlob(img.src).then(function(blob) {
        blobInfo = blobCache.create(uniqueId(), blob, base64);
        blobCache.add(blobInfo);
        resolve2({
          image: img,
          blobInfo
        });
      }, function(err) {
        reject(err);
      });
    }
  };
  var getAllImages = function(elm) {
    return elm ? from$1(elm.getElementsByTagName("img")) : [];
  };
  var ImageScanner = function(uploadStatus, blobCache) {
    var cachedPromises = {};
    var findAll2 = function(elm, predicate) {
      if (!predicate) {
        predicate = always;
      }
      var images = filter(getAllImages(elm), function(img) {
        var src = img.src;
        if (!Env.fileApi) {
          return false;
        }
        if (img.hasAttribute("data-mce-bogus")) {
          return false;
        }
        if (img.hasAttribute("data-mce-placeholder")) {
          return false;
        }
        if (!src || src === Env.transparentSrc) {
          return false;
        }
        if (src.indexOf("blob:") === 0) {
          return !uploadStatus.isUploaded(src) && predicate(img);
        }
        if (src.indexOf("data:") === 0) {
          return predicate(img);
        }
        return false;
      });
      var promises = map(images, function(img) {
        if (cachedPromises[img.src] !== void 0) {
          return new promiseObj(function(resolve2) {
            cachedPromises[img.src].then(function(imageInfo) {
              if (typeof imageInfo === "string") {
                return imageInfo;
              }
              resolve2({
                image: img,
                blobInfo: imageInfo.blobInfo
              });
            });
          });
        }
        var newPromise = new promiseObj(function(resolve2, reject) {
          imageToBlobInfo(blobCache, img, resolve2, reject);
        }).then(function(result) {
          delete cachedPromises[result.image.src];
          return result;
        }).catch(function(error2) {
          delete cachedPromises[img.src];
          return error2;
        });
        cachedPromises[img.src] = newPromise;
        return newPromise;
      });
      return promiseObj.all(promises);
    };
    return { findAll: findAll2 };
  };
  var paddEmptyNode = function(settings, args, blockElements, node) {
    var brPreferred = settings.padd_empty_with_br || args.insert;
    if (brPreferred && blockElements[node.name]) {
      node.empty().append(new AstNode("br", 1)).shortEnded = true;
    } else {
      node.empty().append(new AstNode("#text", 3)).value = nbsp;
    }
  };
  var isPaddedWithNbsp = function(node) {
    return hasOnlyChild(node, "#text") && node.firstChild.value === nbsp;
  };
  var hasOnlyChild = function(node, name2) {
    return node && node.firstChild && node.firstChild === node.lastChild && node.firstChild.name === name2;
  };
  var isPadded = function(schema, node) {
    var rule = schema.getElementRule(node.name);
    return rule && rule.paddEmpty;
  };
  var isEmpty$2 = function(schema, nonEmptyElements, whitespaceElements, node) {
    return node.isEmpty(nonEmptyElements, whitespaceElements, function(node2) {
      return isPadded(schema, node2);
    });
  };
  var isLineBreakNode = function(node, blockElements) {
    return node && (blockElements[node.name] || node.name === "br");
  };
  var isBogusImage = function(img) {
    return img.attr("data-mce-bogus");
  };
  var isInternalImageSource = function(img) {
    return img.attr("src") === Env.transparentSrc || img.attr("data-mce-placeholder");
  };
  var isValidDataImg = function(img, settings) {
    if (settings.images_dataimg_filter) {
      var imgElem_1 = new Image();
      imgElem_1.src = img.attr("src");
      each$1(img.attributes.map, function(value2, key) {
        imgElem_1.setAttribute(key, value2);
      });
      return settings.images_dataimg_filter(imgElem_1);
    } else {
      return true;
    }
  };
  var registerBase64ImageFilter = function(parser, settings) {
    var blobCache = settings.blob_cache;
    var processImage = function(img) {
      var inputSrc = img.attr("src");
      if (isInternalImageSource(img) || isBogusImage(img)) {
        return;
      }
      parseDataUri(inputSrc).filter(function() {
        return isValidDataImg(img, settings);
      }).bind(function(_a) {
        var type2 = _a.type, data2 = _a.data;
        return Optional.from(blobCache.getByData(data2, type2)).orThunk(function() {
          return buildBlob(type2, data2).map(function(blob) {
            var blobInfo = blobCache.create(uniqueId(), blob, data2);
            blobCache.add(blobInfo);
            return blobInfo;
          });
        });
      }).each(function(blobInfo) {
        img.attr("src", blobInfo.blobUri());
      });
    };
    if (blobCache) {
      parser.addAttributeFilter("src", function(nodes) {
        return each(nodes, processImage);
      });
    }
  };
  var register$2 = function(parser, settings) {
    var schema = parser.schema;
    if (settings.remove_trailing_brs) {
      parser.addNodeFilter("br", function(nodes, _, args) {
        var i;
        var l2 = nodes.length;
        var node;
        var blockElements = Tools.extend({}, schema.getBlockElements());
        var nonEmptyElements = schema.getNonEmptyElements();
        var parent2, lastParent, prev, prevName;
        var whiteSpaceElements = schema.getWhiteSpaceElements();
        var elementRule, textNode;
        blockElements.body = 1;
        for (i = 0; i < l2; i++) {
          node = nodes[i];
          parent2 = node.parent;
          if (blockElements[node.parent.name] && node === parent2.lastChild) {
            prev = node.prev;
            while (prev) {
              prevName = prev.name;
              if (prevName !== "span" || prev.attr("data-mce-type") !== "bookmark") {
                if (prevName === "br") {
                  node = null;
                }
                break;
              }
              prev = prev.prev;
            }
            if (node) {
              node.remove();
              if (isEmpty$2(schema, nonEmptyElements, whiteSpaceElements, parent2)) {
                elementRule = schema.getElementRule(parent2.name);
                if (elementRule) {
                  if (elementRule.removeEmpty) {
                    parent2.remove();
                  } else if (elementRule.paddEmpty) {
                    paddEmptyNode(settings, args, blockElements, parent2);
                  }
                }
              }
            }
          } else {
            lastParent = node;
            while (parent2 && parent2.firstChild === lastParent && parent2.lastChild === lastParent) {
              lastParent = parent2;
              if (blockElements[parent2.name]) {
                break;
              }
              parent2 = parent2.parent;
            }
            if (lastParent === parent2 && settings.padd_empty_with_br !== true) {
              textNode = new AstNode("#text", 3);
              textNode.value = nbsp;
              node.replace(textNode);
            }
          }
        }
      });
    }
    parser.addAttributeFilter("href", function(nodes) {
      var i = nodes.length;
      var appendRel = function(rel) {
        var parts = rel.split(" ").filter(function(p2) {
          return p2.length > 0;
        });
        return parts.concat(["noopener"]).sort().join(" ");
      };
      var addNoOpener = function(rel) {
        var newRel = rel ? Tools.trim(rel) : "";
        if (!/\b(noopener)\b/g.test(newRel)) {
          return appendRel(newRel);
        } else {
          return newRel;
        }
      };
      if (!settings.allow_unsafe_link_target) {
        while (i--) {
          var node = nodes[i];
          if (node.name === "a" && node.attr("target") === "_blank") {
            node.attr("rel", addNoOpener(node.attr("rel")));
          }
        }
      }
    });
    if (!settings.allow_html_in_named_anchor) {
      parser.addAttributeFilter("id,name", function(nodes) {
        var i = nodes.length, sibling2, prevSibling2, parent2, node;
        while (i--) {
          node = nodes[i];
          if (node.name === "a" && node.firstChild && !node.attr("href")) {
            parent2 = node.parent;
            sibling2 = node.lastChild;
            do {
              prevSibling2 = sibling2.prev;
              parent2.insert(sibling2, node);
              sibling2 = prevSibling2;
            } while (sibling2);
          }
        }
      });
    }
    if (settings.fix_list_elements) {
      parser.addNodeFilter("ul,ol", function(nodes) {
        var i = nodes.length, node, parentNode;
        while (i--) {
          node = nodes[i];
          parentNode = node.parent;
          if (parentNode.name === "ul" || parentNode.name === "ol") {
            if (node.prev && node.prev.name === "li") {
              node.prev.append(node);
            } else {
              var li2 = new AstNode("li", 1);
              li2.attr("style", "list-style-type: none");
              node.wrap(li2);
            }
          }
        }
      });
    }
    if (settings.validate && schema.getValidClasses()) {
      parser.addAttributeFilter("class", function(nodes) {
        var i = nodes.length, node, classList, ci2, className, classValue;
        var validClasses = schema.getValidClasses();
        var validClassesMap, valid;
        while (i--) {
          node = nodes[i];
          classList = node.attr("class").split(" ");
          classValue = "";
          for (ci2 = 0; ci2 < classList.length; ci2++) {
            className = classList[ci2];
            valid = false;
            validClassesMap = validClasses["*"];
            if (validClassesMap && validClassesMap[className]) {
              valid = true;
            }
            validClassesMap = validClasses[node.name];
            if (!valid && validClassesMap && validClassesMap[className]) {
              valid = true;
            }
            if (valid) {
              if (classValue) {
                classValue += " ";
              }
              classValue += className;
            }
          }
          if (!classValue.length) {
            classValue = null;
          }
          node.attr("class", classValue);
        }
      });
    }
    registerBase64ImageFilter(parser, settings);
  };
  var makeMap$4 = Tools.makeMap, each$d = Tools.each, explode$2 = Tools.explode, extend$2 = Tools.extend;
  var DomParser = function(settings, schema) {
    if (schema === void 0) {
      schema = Schema();
    }
    var nodeFilters = {};
    var attributeFilters = [];
    var matchedNodes = {};
    var matchedAttributes = {};
    settings = settings || {};
    settings.validate = "validate" in settings ? settings.validate : true;
    settings.root_name = settings.root_name || "body";
    var fixInvalidChildren = function(nodes) {
      var ni2, node, parent2, parents2, newParent, currentNode, tempNode, childNode, i;
      var sibling2, nextNode;
      var nonSplitableElements = makeMap$4("tr,td,th,tbody,thead,tfoot,table");
      var nonEmptyElements = schema.getNonEmptyElements();
      var whitespaceElements = schema.getWhiteSpaceElements();
      var textBlockElements = schema.getTextBlockElements();
      var specialElements = schema.getSpecialElements();
      for (ni2 = 0; ni2 < nodes.length; ni2++) {
        node = nodes[ni2];
        if (!node.parent || node.fixed) {
          continue;
        }
        if (textBlockElements[node.name] && node.parent.name === "li") {
          sibling2 = node.next;
          while (sibling2) {
            if (textBlockElements[sibling2.name]) {
              sibling2.name = "li";
              sibling2.fixed = true;
              node.parent.insert(sibling2, node.parent);
            } else {
              break;
            }
            sibling2 = sibling2.next;
          }
          node.unwrap(node);
          continue;
        }
        parents2 = [node];
        for (parent2 = node.parent; parent2 && !schema.isValidChild(parent2.name, node.name) && !nonSplitableElements[parent2.name]; parent2 = parent2.parent) {
          parents2.push(parent2);
        }
        if (parent2 && parents2.length > 1) {
          parents2.reverse();
          newParent = currentNode = filterNode(parents2[0].clone());
          for (i = 0; i < parents2.length - 1; i++) {
            if (schema.isValidChild(currentNode.name, parents2[i].name)) {
              tempNode = filterNode(parents2[i].clone());
              currentNode.append(tempNode);
            } else {
              tempNode = currentNode;
            }
            for (childNode = parents2[i].firstChild; childNode && childNode !== parents2[i + 1]; ) {
              nextNode = childNode.next;
              tempNode.append(childNode);
              childNode = nextNode;
            }
            currentNode = tempNode;
          }
          if (!isEmpty$2(schema, nonEmptyElements, whitespaceElements, newParent)) {
            parent2.insert(newParent, parents2[0], true);
            parent2.insert(node, newParent);
          } else {
            parent2.insert(node, parents2[0], true);
          }
          parent2 = parents2[0];
          if (isEmpty$2(schema, nonEmptyElements, whitespaceElements, parent2) || hasOnlyChild(parent2, "br")) {
            parent2.empty().remove();
          }
        } else if (node.parent) {
          if (node.name === "li") {
            sibling2 = node.prev;
            if (sibling2 && (sibling2.name === "ul" || sibling2.name === "ol")) {
              sibling2.append(node);
              continue;
            }
            sibling2 = node.next;
            if (sibling2 && (sibling2.name === "ul" || sibling2.name === "ol")) {
              sibling2.insert(node, sibling2.firstChild, true);
              continue;
            }
            node.wrap(filterNode(new AstNode("ul", 1)));
            continue;
          }
          if (schema.isValidChild(node.parent.name, "div") && schema.isValidChild("div", node.name)) {
            node.wrap(filterNode(new AstNode("div", 1)));
          } else {
            if (specialElements[node.name]) {
              node.empty().remove();
            } else {
              node.unwrap();
            }
          }
        }
      }
    };
    var filterNode = function(node) {
      var i, name2, list;
      name2 = node.name;
      if (name2 in nodeFilters) {
        list = matchedNodes[name2];
        if (list) {
          list.push(node);
        } else {
          matchedNodes[name2] = [node];
        }
      }
      i = attributeFilters.length;
      while (i--) {
        name2 = attributeFilters[i].name;
        if (name2 in node.attributes.map) {
          list = matchedAttributes[name2];
          if (list) {
            list.push(node);
          } else {
            matchedAttributes[name2] = [node];
          }
        }
      }
      return node;
    };
    var addNodeFilter = function(name2, callback) {
      each$d(explode$2(name2), function(name3) {
        var list = nodeFilters[name3];
        if (!list) {
          nodeFilters[name3] = list = [];
        }
        list.push(callback);
      });
    };
    var getNodeFilters = function() {
      var out = [];
      for (var name_1 in nodeFilters) {
        if (nodeFilters.hasOwnProperty(name_1)) {
          out.push({
            name: name_1,
            callbacks: nodeFilters[name_1]
          });
        }
      }
      return out;
    };
    var addAttributeFilter = function(name2, callback) {
      each$d(explode$2(name2), function(name3) {
        var i;
        for (i = 0; i < attributeFilters.length; i++) {
          if (attributeFilters[i].name === name3) {
            attributeFilters[i].callbacks.push(callback);
            return;
          }
        }
        attributeFilters.push({
          name: name3,
          callbacks: [callback]
        });
      });
    };
    var getAttributeFilters = function() {
      return [].concat(attributeFilters);
    };
    var parse = function(html, args) {
      var nodes, i, l2, fi2, fl, list, name2;
      var invalidChildren = [];
      var isInWhiteSpacePreservedElement;
      var node;
      var getRootBlockName = function(name3) {
        if (name3 === false) {
          return "";
        } else if (name3 === true) {
          return "p";
        } else {
          return name3;
        }
      };
      args = args || {};
      matchedNodes = {};
      matchedAttributes = {};
      var blockElements = extend$2(makeMap$4("script,style,head,html,body,title,meta,param"), schema.getBlockElements());
      var nonEmptyElements = schema.getNonEmptyElements();
      var children2 = schema.children;
      var validate2 = settings.validate;
      var forcedRootBlockName = "forced_root_block" in args ? args.forced_root_block : settings.forced_root_block;
      var rootBlockName = getRootBlockName(forcedRootBlockName);
      var whiteSpaceElements = schema.getWhiteSpaceElements();
      var startWhiteSpaceRegExp = /^[ \t\r\n]+/;
      var endWhiteSpaceRegExp = /[ \t\r\n]+$/;
      var allWhiteSpaceRegExp = /[ \t\r\n]+/g;
      var isAllWhiteSpaceRegExp = /^[ \t\r\n]+$/;
      isInWhiteSpacePreservedElement = whiteSpaceElements.hasOwnProperty(args.context) || whiteSpaceElements.hasOwnProperty(settings.root_name);
      var addRootBlocks2 = function() {
        var node2 = rootNode.firstChild, next, rootBlockNode;
        var trim2 = function(rootBlockNode2) {
          if (rootBlockNode2) {
            node2 = rootBlockNode2.firstChild;
            if (node2 && node2.type === 3) {
              node2.value = node2.value.replace(startWhiteSpaceRegExp, "");
            }
            node2 = rootBlockNode2.lastChild;
            if (node2 && node2.type === 3) {
              node2.value = node2.value.replace(endWhiteSpaceRegExp, "");
            }
          }
        };
        if (!schema.isValidChild(rootNode.name, rootBlockName.toLowerCase())) {
          return;
        }
        while (node2) {
          next = node2.next;
          if (node2.type === 3 || node2.type === 1 && node2.name !== "p" && !blockElements[node2.name] && !node2.attr("data-mce-type")) {
            if (!rootBlockNode) {
              rootBlockNode = createNode(rootBlockName, 1);
              rootBlockNode.attr(settings.forced_root_block_attrs);
              rootNode.insert(rootBlockNode, node2);
              rootBlockNode.append(node2);
            } else {
              rootBlockNode.append(node2);
            }
          } else {
            trim2(rootBlockNode);
            rootBlockNode = null;
          }
          node2 = next;
        }
        trim2(rootBlockNode);
      };
      var createNode = function(name3, type2) {
        var node2 = new AstNode(name3, type2);
        var list2;
        if (name3 in nodeFilters) {
          list2 = matchedNodes[name3];
          if (list2) {
            list2.push(node2);
          } else {
            matchedNodes[name3] = [node2];
          }
        }
        return node2;
      };
      var removeWhitespaceBefore = function(node2) {
        var textNode, textNodeNext, textVal, sibling2;
        var blockElements2 = schema.getBlockElements();
        for (textNode = node2.prev; textNode && textNode.type === 3; ) {
          textVal = textNode.value.replace(endWhiteSpaceRegExp, "");
          if (textVal.length > 0) {
            textNode.value = textVal;
            return;
          }
          textNodeNext = textNode.next;
          if (textNodeNext) {
            if (textNodeNext.type === 3 && textNodeNext.value.length) {
              textNode = textNode.prev;
              continue;
            }
            if (!blockElements2[textNodeNext.name] && textNodeNext.name !== "script" && textNodeNext.name !== "style") {
              textNode = textNode.prev;
              continue;
            }
          }
          sibling2 = textNode.prev;
          textNode.remove();
          textNode = sibling2;
        }
      };
      var cloneAndExcludeBlocks = function(input) {
        var name3;
        var output = {};
        for (name3 in input) {
          if (name3 !== "li" && name3 !== "p") {
            output[name3] = input[name3];
          }
        }
        return output;
      };
      var parser = SaxParser({
        validate: validate2,
        allow_html_data_urls: settings.allow_html_data_urls,
        allow_svg_data_urls: settings.allow_svg_data_urls,
        allow_script_urls: settings.allow_script_urls,
        allow_conditional_comments: settings.allow_conditional_comments,
        preserve_cdata: settings.preserve_cdata,
        self_closing_elements: cloneAndExcludeBlocks(schema.getSelfClosingElements()),
        cdata: function(text) {
          node.append(createNode("#cdata", 4)).value = text;
        },
        text: function(text, raw) {
          var textNode;
          if (!isInWhiteSpacePreservedElement) {
            text = text.replace(allWhiteSpaceRegExp, " ");
            if (isLineBreakNode(node.lastChild, blockElements)) {
              text = text.replace(startWhiteSpaceRegExp, "");
            }
          }
          if (text.length !== 0) {
            textNode = createNode("#text", 3);
            textNode.raw = !!raw;
            node.append(textNode).value = text;
          }
        },
        comment: function(text) {
          node.append(createNode("#comment", 8)).value = text;
        },
        pi: function(name3, text) {
          node.append(createNode(name3, 7)).value = text;
          removeWhitespaceBefore(node);
        },
        doctype: function(text) {
          var newNode = node.append(createNode("#doctype", 10));
          newNode.value = text;
          removeWhitespaceBefore(node);
        },
        start: function(name3, attrs, empty2) {
          var newNode, attrFiltersLen, attrName, parent2;
          var elementRule = validate2 ? schema.getElementRule(name3) : {};
          if (elementRule) {
            newNode = createNode(elementRule.outputName || name3, 1);
            newNode.attributes = attrs;
            newNode.shortEnded = empty2;
            node.append(newNode);
            parent2 = children2[node.name];
            if (parent2 && children2[newNode.name] && !parent2[newNode.name]) {
              invalidChildren.push(newNode);
            }
            attrFiltersLen = attributeFilters.length;
            while (attrFiltersLen--) {
              attrName = attributeFilters[attrFiltersLen].name;
              if (attrName in attrs.map) {
                list = matchedAttributes[attrName];
                if (list) {
                  list.push(newNode);
                } else {
                  matchedAttributes[attrName] = [newNode];
                }
              }
            }
            if (blockElements[name3]) {
              removeWhitespaceBefore(newNode);
            }
            if (!empty2) {
              node = newNode;
            }
            if (!isInWhiteSpacePreservedElement && whiteSpaceElements[name3]) {
              isInWhiteSpacePreservedElement = true;
            }
          }
        },
        end: function(name3) {
          var textNode, text, sibling2, tempNode;
          var elementRule = validate2 ? schema.getElementRule(name3) : {};
          if (elementRule) {
            if (blockElements[name3]) {
              if (!isInWhiteSpacePreservedElement) {
                textNode = node.firstChild;
                if (textNode && textNode.type === 3) {
                  text = textNode.value.replace(startWhiteSpaceRegExp, "");
                  if (text.length > 0) {
                    textNode.value = text;
                    textNode = textNode.next;
                  } else {
                    sibling2 = textNode.next;
                    textNode.remove();
                    textNode = sibling2;
                    while (textNode && textNode.type === 3) {
                      text = textNode.value;
                      sibling2 = textNode.next;
                      if (text.length === 0 || isAllWhiteSpaceRegExp.test(text)) {
                        textNode.remove();
                        textNode = sibling2;
                      }
                      textNode = sibling2;
                    }
                  }
                }
                textNode = node.lastChild;
                if (textNode && textNode.type === 3) {
                  text = textNode.value.replace(endWhiteSpaceRegExp, "");
                  if (text.length > 0) {
                    textNode.value = text;
                    textNode = textNode.prev;
                  } else {
                    sibling2 = textNode.prev;
                    textNode.remove();
                    textNode = sibling2;
                    while (textNode && textNode.type === 3) {
                      text = textNode.value;
                      sibling2 = textNode.prev;
                      if (text.length === 0 || isAllWhiteSpaceRegExp.test(text)) {
                        textNode.remove();
                        textNode = sibling2;
                      }
                      textNode = sibling2;
                    }
                  }
                }
              }
            }
            if (isInWhiteSpacePreservedElement && whiteSpaceElements[name3]) {
              isInWhiteSpacePreservedElement = false;
            }
            if (elementRule.removeEmpty && isEmpty$2(schema, nonEmptyElements, whiteSpaceElements, node)) {
              tempNode = node.parent;
              if (blockElements[node.name]) {
                node.empty().remove();
              } else {
                node.unwrap();
              }
              node = tempNode;
              return;
            }
            if (elementRule.paddEmpty && (isPaddedWithNbsp(node) || isEmpty$2(schema, nonEmptyElements, whiteSpaceElements, node))) {
              paddEmptyNode(settings, args, blockElements, node);
            }
            node = node.parent;
          }
        }
      }, schema);
      var rootNode = node = new AstNode(args.context || settings.root_name, 11);
      parser.parse(html, args.format);
      if (validate2 && invalidChildren.length) {
        if (!args.context) {
          fixInvalidChildren(invalidChildren);
        } else {
          args.invalid = true;
        }
      }
      if (rootBlockName && (rootNode.name === "body" || args.isRootContent)) {
        addRootBlocks2();
      }
      if (!args.invalid) {
        for (name2 in matchedNodes) {
          if (!matchedNodes.hasOwnProperty(name2)) {
            continue;
          }
          list = nodeFilters[name2];
          nodes = matchedNodes[name2];
          fi2 = nodes.length;
          while (fi2--) {
            if (!nodes[fi2].parent) {
              nodes.splice(fi2, 1);
            }
          }
          for (i = 0, l2 = list.length; i < l2; i++) {
            list[i](nodes, name2, args);
          }
        }
        for (i = 0, l2 = attributeFilters.length; i < l2; i++) {
          list = attributeFilters[i];
          if (list.name in matchedAttributes) {
            nodes = matchedAttributes[list.name];
            fi2 = nodes.length;
            while (fi2--) {
              if (!nodes[fi2].parent) {
                nodes.splice(fi2, 1);
              }
            }
            for (fi2 = 0, fl = list.callbacks.length; fi2 < fl; fi2++) {
              list.callbacks[fi2](nodes, list.name, args);
            }
          }
        }
      }
      return rootNode;
    };
    var exports = {
      schema,
      addAttributeFilter,
      getAttributeFilters,
      addNodeFilter,
      getNodeFilters,
      filterNode,
      parse
    };
    register$2(exports, settings);
    register$1(exports, settings);
    return exports;
  };
  var register$3 = function(htmlParser, settings, dom2) {
    htmlParser.addAttributeFilter("data-mce-tabindex", function(nodes, name2) {
      var i = nodes.length, node;
      while (i--) {
        node = nodes[i];
        node.attr("tabindex", node.attr("data-mce-tabindex"));
        node.attr(name2, null);
      }
    });
    htmlParser.addAttributeFilter("src,href,style", function(nodes, name2) {
      var i = nodes.length, node, value2;
      var internalName = "data-mce-" + name2;
      var urlConverter = settings.url_converter;
      var urlConverterScope = settings.url_converter_scope;
      while (i--) {
        node = nodes[i];
        value2 = node.attr(internalName);
        if (value2 !== void 0) {
          node.attr(name2, value2.length > 0 ? value2 : null);
          node.attr(internalName, null);
        } else {
          value2 = node.attr(name2);
          if (name2 === "style") {
            value2 = dom2.serializeStyle(dom2.parseStyle(value2), node.name);
          } else if (urlConverter) {
            value2 = urlConverter.call(urlConverterScope, value2, name2, node.name);
          }
          node.attr(name2, value2.length > 0 ? value2 : null);
        }
      }
    });
    htmlParser.addAttributeFilter("class", function(nodes) {
      var i = nodes.length, node, value2;
      while (i--) {
        node = nodes[i];
        value2 = node.attr("class");
        if (value2) {
          value2 = node.attr("class").replace(/(?:^|\s)mce-item-\w+(?!\S)/g, "");
          node.attr("class", value2.length > 0 ? value2 : null);
        }
      }
    });
    htmlParser.addAttributeFilter("data-mce-type", function(nodes, name2, args) {
      var i = nodes.length, node;
      while (i--) {
        node = nodes[i];
        if (node.attr("data-mce-type") === "bookmark" && !args.cleanup) {
          var hasChildren = Optional.from(node.firstChild).exists(function(firstChild2) {
            return !isZwsp$1(firstChild2.value);
          });
          if (hasChildren) {
            node.unwrap();
          } else {
            node.remove();
          }
        }
      }
    });
    htmlParser.addNodeFilter("noscript", function(nodes) {
      var i = nodes.length, node;
      while (i--) {
        node = nodes[i].firstChild;
        if (node) {
          node.value = Entities.decode(node.value);
        }
      }
    });
    htmlParser.addNodeFilter("script,style", function(nodes, name2) {
      var i = nodes.length, node, value2, type2;
      var trim2 = function(value3) {
        return value3.replace(/(<!--\[CDATA\[|\]\]-->)/g, "\n").replace(/^[\r\n]*|[\r\n]*$/g, "").replace(/^\s*((<!--)?(\s*\/\/)?\s*<!\[CDATA\[|(<!--\s*)?\/\*\s*<!\[CDATA\[\s*\*\/|(\/\/)?\s*<!--|\/\*\s*<!--\s*\*\/)\s*[\r\n]*/gi, "").replace(/\s*(\/\*\s*\]\]>\s*\*\/(-->)?|\s*\/\/\s*\]\]>(-->)?|\/\/\s*(-->)?|\]\]>|\/\*\s*-->\s*\*\/|\s*-->\s*)\s*$/g, "");
      };
      while (i--) {
        node = nodes[i];
        value2 = node.firstChild ? node.firstChild.value : "";
        if (name2 === "script") {
          type2 = node.attr("type");
          if (type2) {
            node.attr("type", type2 === "mce-no/type" ? null : type2.replace(/^mce\-/, ""));
          }
          if (settings.element_format === "xhtml" && value2.length > 0) {
            node.firstChild.value = "// <![CDATA[\n" + trim2(value2) + "\n// ]]>";
          }
        } else {
          if (settings.element_format === "xhtml" && value2.length > 0) {
            node.firstChild.value = "<!--\n" + trim2(value2) + "\n-->";
          }
        }
      }
    });
    htmlParser.addNodeFilter("#comment", function(nodes) {
      var i = nodes.length, node;
      while (i--) {
        node = nodes[i];
        if (settings.preserve_cdata && node.value.indexOf("[CDATA[") === 0) {
          node.name = "#cdata";
          node.type = 4;
          node.value = dom2.decode(node.value.replace(/^\[CDATA\[|\]\]$/g, ""));
        } else if (node.value.indexOf("mce:protected ") === 0) {
          node.name = "#text";
          node.type = 3;
          node.raw = true;
          node.value = unescape(node.value).substr(14);
        }
      }
    });
    htmlParser.addNodeFilter("xml:namespace,input", function(nodes, name2) {
      var i = nodes.length, node;
      while (i--) {
        node = nodes[i];
        if (node.type === 7) {
          node.remove();
        } else if (node.type === 1) {
          if (name2 === "input" && !node.attr("type")) {
            node.attr("type", "text");
          }
        }
      }
    });
    htmlParser.addAttributeFilter("data-mce-type", function(nodes) {
      each(nodes, function(node) {
        if (node.attr("data-mce-type") === "format-caret") {
          if (node.isEmpty(htmlParser.schema.getNonEmptyElements())) {
            node.remove();
          } else {
            node.unwrap();
          }
        }
      });
    });
    htmlParser.addAttributeFilter("data-mce-src,data-mce-href,data-mce-style,data-mce-selected,data-mce-expando,data-mce-type,data-mce-resize,data-mce-placeholder", function(nodes, name2) {
      var i = nodes.length;
      while (i--) {
        nodes[i].attr(name2, null);
      }
    });
  };
  var trimTrailingBr = function(rootNode) {
    var isBr2 = function(node) {
      return node && node.name === "br";
    };
    var brNode1 = rootNode.lastChild;
    if (isBr2(brNode1)) {
      var brNode2 = brNode1.prev;
      if (isBr2(brNode2)) {
        brNode1.remove();
        brNode2.remove();
      }
    }
  };
  var preProcess = function(editor, node, args) {
    var doc2, oldDoc;
    var dom2 = editor.dom;
    node = node.cloneNode(true);
    var impl = document.implementation;
    if (impl.createHTMLDocument) {
      doc2 = impl.createHTMLDocument("");
      Tools.each(node.nodeName === "BODY" ? node.childNodes : [node], function(node2) {
        doc2.body.appendChild(doc2.importNode(node2, true));
      });
      if (node.nodeName !== "BODY") {
        node = doc2.body.firstChild;
      } else {
        node = doc2.body;
      }
      oldDoc = dom2.doc;
      dom2.doc = doc2;
    }
    firePreProcess(editor, __assign2(__assign2({}, args), { node }));
    if (oldDoc) {
      dom2.doc = oldDoc;
    }
    return node;
  };
  var shouldFireEvent = function(editor, args) {
    return editor && editor.hasEventListeners("PreProcess") && !args.no_events;
  };
  var process = function(editor, node, args) {
    return shouldFireEvent(editor, args) ? preProcess(editor, node, args) : node;
  };
  var addTempAttr = function(htmlParser, tempAttrs, name2) {
    if (Tools.inArray(tempAttrs, name2) === -1) {
      htmlParser.addAttributeFilter(name2, function(nodes, name3) {
        var i = nodes.length;
        while (i--) {
          nodes[i].attr(name3, null);
        }
      });
      tempAttrs.push(name2);
    }
  };
  var postProcess$1 = function(editor, args, content) {
    if (!args.no_events && editor) {
      var outArgs = firePostProcess(editor, __assign2(__assign2({}, args), { content }));
      return outArgs.content;
    } else {
      return content;
    }
  };
  var getHtmlFromNode = function(dom2, node, args) {
    var html = trim$2(args.getInner ? node.innerHTML : dom2.getOuterHTML(node));
    return args.selection || isWsPreserveElement(SugarElement.fromDom(node)) ? html : Tools.trim(html);
  };
  var parseHtml = function(htmlParser, html, args) {
    var parserArgs = args.selection ? __assign2({ forced_root_block: false }, args) : args;
    var rootNode = htmlParser.parse(html, parserArgs);
    trimTrailingBr(rootNode);
    return rootNode;
  };
  var serializeNode = function(settings, schema, node) {
    var htmlSerializer = HtmlSerializer(settings, schema);
    return htmlSerializer.serialize(node);
  };
  var toHtml = function(editor, settings, schema, rootNode, args) {
    var content = serializeNode(settings, schema, rootNode);
    return postProcess$1(editor, args, content);
  };
  var DomSerializerImpl = function(settings, editor) {
    var tempAttrs = ["data-mce-selected"];
    var dom2 = editor && editor.dom ? editor.dom : DOMUtils.DOM;
    var schema = editor && editor.schema ? editor.schema : Schema(settings);
    settings.entity_encoding = settings.entity_encoding || "named";
    settings.remove_trailing_brs = "remove_trailing_brs" in settings ? settings.remove_trailing_brs : true;
    var htmlParser = DomParser(settings, schema);
    register$3(htmlParser, settings, dom2);
    var serialize2 = function(node, parserArgs) {
      if (parserArgs === void 0) {
        parserArgs = {};
      }
      var args = __assign2({ format: "html" }, parserArgs);
      var targetNode = process(editor, node, args);
      var html = getHtmlFromNode(dom2, targetNode, args);
      var rootNode = parseHtml(htmlParser, html, args);
      return args.format === "tree" ? rootNode : toHtml(editor, settings, schema, rootNode, args);
    };
    return {
      schema,
      addNodeFilter: htmlParser.addNodeFilter,
      addAttributeFilter: htmlParser.addAttributeFilter,
      serialize: serialize2,
      addRules: function(rules) {
        schema.addValidElements(rules);
      },
      setRules: function(rules) {
        schema.setValidElements(rules);
      },
      addTempAttr: curry(addTempAttr, htmlParser, tempAttrs),
      getTempAttrs: constant(tempAttrs),
      getNodeFilters: htmlParser.getNodeFilters,
      getAttributeFilters: htmlParser.getAttributeFilters
    };
  };
  var DomSerializer = function(settings, editor) {
    var domSerializer = DomSerializerImpl(settings, editor);
    return {
      schema: domSerializer.schema,
      addNodeFilter: domSerializer.addNodeFilter,
      addAttributeFilter: domSerializer.addAttributeFilter,
      serialize: domSerializer.serialize,
      addRules: domSerializer.addRules,
      setRules: domSerializer.setRules,
      addTempAttr: domSerializer.addTempAttr,
      getTempAttrs: domSerializer.getTempAttrs,
      getNodeFilters: domSerializer.getNodeFilters,
      getAttributeFilters: domSerializer.getAttributeFilters
    };
  };
  var defaultFormat$1 = "html";
  var getContent$2 = function(editor, args) {
    if (args === void 0) {
      args = {};
    }
    var format = args.format ? args.format : defaultFormat$1;
    return getContent(editor, args, format);
  };
  var setContent$2 = function(editor, content, args) {
    if (args === void 0) {
      args = {};
    }
    return setContent(editor, content, args);
  };
  var DOM$3 = DOMUtils.DOM;
  var restoreOriginalStyles = function(editor) {
    DOM$3.setStyle(editor.id, "display", editor.orgDisplay);
  };
  var safeDestroy = function(x2) {
    return Optional.from(x2).each(function(x3) {
      return x3.destroy();
    });
  };
  var clearDomReferences = function(editor) {
    editor.contentAreaContainer = editor.formElement = editor.container = editor.editorContainer = null;
    editor.bodyElement = editor.contentDocument = editor.contentWindow = null;
    editor.iframeElement = editor.targetElm = null;
    if (editor.selection) {
      editor.selection = editor.selection.win = editor.selection.dom = editor.selection.dom.doc = null;
    }
  };
  var restoreForm = function(editor) {
    var form = editor.formElement;
    if (form) {
      if (form._mceOldSubmit) {
        form.submit = form._mceOldSubmit;
        form._mceOldSubmit = null;
      }
      DOM$3.unbind(form, "submit reset", editor.formEventDelegate);
    }
  };
  var remove$7 = function(editor) {
    if (!editor.removed) {
      var _selectionOverrides = editor._selectionOverrides, editorUpload = editor.editorUpload;
      var body = editor.getBody();
      var element = editor.getElement();
      if (body) {
        editor.save({ is_removing: true });
      }
      editor.removed = true;
      editor.unbindAllNativeEvents();
      if (editor.hasHiddenInput && element) {
        DOM$3.remove(element.nextSibling);
      }
      fireRemove(editor);
      editor.editorManager.remove(editor);
      if (!editor.inline && body) {
        restoreOriginalStyles(editor);
      }
      fireDetach(editor);
      DOM$3.remove(editor.getContainer());
      safeDestroy(_selectionOverrides);
      safeDestroy(editorUpload);
      editor.destroy();
    }
  };
  var destroy = function(editor, automatic) {
    var selection = editor.selection, dom2 = editor.dom;
    if (editor.destroyed) {
      return;
    }
    if (!automatic && !editor.removed) {
      editor.remove();
      return;
    }
    if (!automatic) {
      editor.editorManager.off("beforeunload", editor._beforeUnload);
      if (editor.theme && editor.theme.destroy) {
        editor.theme.destroy();
      }
      safeDestroy(selection);
      safeDestroy(dom2);
    }
    restoreForm(editor);
    clearDomReferences(editor);
    editor.destroyed = true;
  };
  var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
  var deep$1 = function(old, nu2) {
    var bothObjects = isObject(old) && isObject(nu2);
    return bothObjects ? deepMerge(old, nu2) : nu2;
  };
  var baseMerge = function(merger) {
    return function() {
      var objects = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        objects[_i] = arguments[_i];
      }
      if (objects.length === 0) {
        throw new Error("Can't merge zero objects");
      }
      var ret = {};
      for (var j = 0; j < objects.length; j++) {
        var curObject = objects[j];
        for (var key in curObject) {
          if (hasOwnProperty$2.call(curObject, key)) {
            ret[key] = merger(ret[key], curObject[key]);
          }
        }
      }
      return ret;
    };
  };
  var deepMerge = baseMerge(deep$1);
  var sectionResult = function(sections, settings) {
    return {
      sections: constant(sections),
      settings: constant(settings)
    };
  };
  var deviceDetection = detect$3().deviceType;
  var isTouch = deviceDetection.isTouch();
  var isPhone = deviceDetection.isPhone();
  var isTablet = deviceDetection.isTablet();
  var legacyMobilePlugins = [
    "lists",
    "autolink",
    "autosave"
  ];
  var defaultTouchSettings = {
    table_grid: false,
    object_resizing: false,
    resize: false
  };
  var normalizePlugins = function(plugins) {
    var pluginNames = isArray(plugins) ? plugins.join(" ") : plugins;
    var trimmedPlugins = map(isString(pluginNames) ? pluginNames.split(" ") : [], trim);
    return filter(trimmedPlugins, function(item) {
      return item.length > 0;
    });
  };
  var filterLegacyMobilePlugins = function(plugins) {
    return filter(plugins, curry(contains, legacyMobilePlugins));
  };
  var extractSections = function(keys2, settings) {
    var result = bifilter(settings, function(value2, key) {
      return contains(keys2, key);
    });
    return sectionResult(result.t, result.f);
  };
  var getSection = function(sectionResult2, name2, defaults) {
    if (defaults === void 0) {
      defaults = {};
    }
    var sections = sectionResult2.sections();
    var sectionSettings = sections.hasOwnProperty(name2) ? sections[name2] : {};
    return Tools.extend({}, defaults, sectionSettings);
  };
  var hasSection = function(sectionResult2, name2) {
    return sectionResult2.sections().hasOwnProperty(name2);
  };
  var isSectionTheme = function(sectionResult2, name2, theme) {
    var section = sectionResult2.sections();
    return hasSection(sectionResult2, name2) && section[name2].theme === theme;
  };
  var getSectionConfig = function(sectionResult2, name2) {
    return hasSection(sectionResult2, name2) ? sectionResult2.sections()[name2] : {};
  };
  var getToolbarMode = function(settings, defaultVal) {
    return get$1(settings, "toolbar_mode").orThunk(function() {
      return get$1(settings, "toolbar_drawer").map(function(val) {
        return val === false ? "wrap" : val;
      });
    }).getOr(defaultVal);
  };
  var getDefaultSettings = function(settings, id2, documentBaseUrl, isTouch2, editor) {
    var baseDefaults = {
      id: id2,
      theme: "silver",
      toolbar_mode: getToolbarMode(settings, "floating"),
      plugins: "",
      document_base_url: documentBaseUrl,
      add_form_submit_trigger: true,
      submit_patch: true,
      add_unload_trigger: true,
      convert_urls: true,
      relative_urls: true,
      remove_script_host: true,
      object_resizing: true,
      doctype: "<!DOCTYPE html>",
      visual: true,
      font_size_legacy_values: "xx-small,small,medium,large,x-large,xx-large,300%",
      forced_root_block: "p",
      hidden_input: true,
      inline_styles: true,
      convert_fonts_to_spans: true,
      indent: true,
      indent_before: "p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,tfoot,tbody,tr,section,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist",
      indent_after: "p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,tfoot,tbody,tr,section,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist",
      entity_encoding: "named",
      url_converter: editor.convertURL,
      url_converter_scope: editor
    };
    return __assign2(__assign2({}, baseDefaults), isTouch2 ? defaultTouchSettings : {});
  };
  var getDefaultMobileSettings = function(mobileSettings, isPhone2) {
    var defaultMobileSettings = {
      resize: false,
      toolbar_mode: getToolbarMode(mobileSettings, "scrolling"),
      toolbar_sticky: false
    };
    var defaultPhoneSettings = { menubar: false };
    return __assign2(__assign2(__assign2({}, defaultTouchSettings), defaultMobileSettings), isPhone2 ? defaultPhoneSettings : {});
  };
  var getExternalPlugins$1 = function(overrideSettings, settings) {
    var userDefinedExternalPlugins = settings.external_plugins ? settings.external_plugins : {};
    if (overrideSettings && overrideSettings.external_plugins) {
      return Tools.extend({}, overrideSettings.external_plugins, userDefinedExternalPlugins);
    } else {
      return userDefinedExternalPlugins;
    }
  };
  var combinePlugins = function(forcedPlugins, plugins) {
    return [].concat(normalizePlugins(forcedPlugins)).concat(normalizePlugins(plugins));
  };
  var getPlatformPlugins = function(isMobileDevice, sectionResult2, desktopPlugins, mobilePlugins) {
    if (isMobileDevice && isSectionTheme(sectionResult2, "mobile", "mobile")) {
      return filterLegacyMobilePlugins(mobilePlugins);
    } else if (isMobileDevice && hasSection(sectionResult2, "mobile")) {
      return mobilePlugins;
    } else {
      return desktopPlugins;
    }
  };
  var processPlugins = function(isMobileDevice, sectionResult2, defaultOverrideSettings, settings) {
    var forcedPlugins = normalizePlugins(defaultOverrideSettings.forced_plugins);
    var desktopPlugins = normalizePlugins(settings.plugins);
    var mobileConfig = getSectionConfig(sectionResult2, "mobile");
    var mobilePlugins = mobileConfig.plugins ? normalizePlugins(mobileConfig.plugins) : desktopPlugins;
    var platformPlugins = getPlatformPlugins(isMobileDevice, sectionResult2, desktopPlugins, mobilePlugins);
    var combinedPlugins = combinePlugins(forcedPlugins, platformPlugins);
    if (Env.browser.isIE() && contains(combinedPlugins, "rtc")) {
      throw new Error("RTC plugin is not supported on IE 11.");
    }
    return Tools.extend(settings, { plugins: combinedPlugins.join(" ") });
  };
  var isOnMobile = function(isMobileDevice, sectionResult2) {
    return isMobileDevice && hasSection(sectionResult2, "mobile");
  };
  var combineSettings = function(isMobileDevice, isPhone2, defaultSettings, defaultOverrideSettings, settings) {
    var defaultDeviceSettings = isMobileDevice ? { mobile: getDefaultMobileSettings(settings.mobile || {}, isPhone2) } : {};
    var sectionResult2 = extractSections(["mobile"], deepMerge(defaultDeviceSettings, settings));
    var extendedSettings = Tools.extend(defaultSettings, defaultOverrideSettings, sectionResult2.settings(), isOnMobile(isMobileDevice, sectionResult2) ? getSection(sectionResult2, "mobile") : {}, {
      validate: true,
      external_plugins: getExternalPlugins$1(defaultOverrideSettings, sectionResult2.settings())
    });
    return processPlugins(isMobileDevice, sectionResult2, defaultOverrideSettings, extendedSettings);
  };
  var getEditorSettings = function(editor, id2, documentBaseUrl, defaultOverrideSettings, settings) {
    var defaultSettings = getDefaultSettings(settings, id2, documentBaseUrl, isTouch, editor);
    return combineSettings(isPhone || isTablet, isPhone, defaultSettings, defaultOverrideSettings, settings);
  };
  var getFiltered = function(predicate, editor, name2) {
    return Optional.from(editor.settings[name2]).filter(predicate);
  };
  var getParamObject = function(value2) {
    var output = {};
    if (typeof value2 === "string") {
      each(value2.indexOf("=") > 0 ? value2.split(/[;,](?![^=;,]*(?:[;,]|$))/) : value2.split(","), function(val) {
        var arr2 = val.split("=");
        if (arr2.length > 1) {
          output[Tools.trim(arr2[0])] = Tools.trim(arr2[1]);
        } else {
          output[Tools.trim(arr2[0])] = Tools.trim(arr2[0]);
        }
      });
    } else {
      output = value2;
    }
    return output;
  };
  var isArrayOf = function(p2) {
    return function(a) {
      return isArray(a) && forall(a, p2);
    };
  };
  var getParam = function(editor, name2, defaultVal, type2) {
    var value2 = name2 in editor.settings ? editor.settings[name2] : defaultVal;
    if (type2 === "hash") {
      return getParamObject(value2);
    } else if (type2 === "string") {
      return getFiltered(isString, editor, name2).getOr(defaultVal);
    } else if (type2 === "number") {
      return getFiltered(isNumber, editor, name2).getOr(defaultVal);
    } else if (type2 === "boolean") {
      return getFiltered(isBoolean, editor, name2).getOr(defaultVal);
    } else if (type2 === "object") {
      return getFiltered(isObject, editor, name2).getOr(defaultVal);
    } else if (type2 === "array") {
      return getFiltered(isArray, editor, name2).getOr(defaultVal);
    } else if (type2 === "string[]") {
      return getFiltered(isArrayOf(isString), editor, name2).getOr(defaultVal);
    } else if (type2 === "function") {
      return getFiltered(isFunction2, editor, name2).getOr(defaultVal);
    } else {
      return value2;
    }
  };
  var CreateIconManager = function() {
    var lookup = {};
    var add2 = function(id2, iconPack) {
      lookup[id2] = iconPack;
    };
    var get2 = function(id2) {
      if (lookup[id2]) {
        return lookup[id2];
      }
      return { icons: {} };
    };
    var has$12 = function(id2) {
      return has(lookup, id2);
    };
    return {
      add: add2,
      get: get2,
      has: has$12
    };
  };
  var IconManager = CreateIconManager();
  var getProp = function(propName, elm) {
    var rawElm = elm.dom;
    return rawElm[propName];
  };
  var getComputedSizeProp = function(propName, elm) {
    return parseInt(get$5(elm, propName), 10);
  };
  var getClientWidth = curry(getProp, "clientWidth");
  var getClientHeight = curry(getProp, "clientHeight");
  var getMarginTop = curry(getComputedSizeProp, "margin-top");
  var getMarginLeft = curry(getComputedSizeProp, "margin-left");
  var getBoundingClientRect$1 = function(elm) {
    return elm.dom.getBoundingClientRect();
  };
  var isInsideElementContentArea = function(bodyElm, clientX, clientY) {
    var clientWidth = getClientWidth(bodyElm);
    var clientHeight = getClientHeight(bodyElm);
    return clientX >= 0 && clientY >= 0 && clientX <= clientWidth && clientY <= clientHeight;
  };
  var transpose = function(inline, elm, clientX, clientY) {
    var clientRect = getBoundingClientRect$1(elm);
    var deltaX = inline ? clientRect.left + elm.dom.clientLeft + getMarginLeft(elm) : 0;
    var deltaY = inline ? clientRect.top + elm.dom.clientTop + getMarginTop(elm) : 0;
    var x2 = clientX - deltaX;
    var y2 = clientY - deltaY;
    return {
      x: x2,
      y: y2
    };
  };
  var isXYInContentArea = function(editor, clientX, clientY) {
    var bodyElm = SugarElement.fromDom(editor.getBody());
    var targetElm = editor.inline ? bodyElm : documentElement(bodyElm);
    var transposedPoint = transpose(editor.inline, targetElm, clientX, clientY);
    return isInsideElementContentArea(targetElm, transposedPoint.x, transposedPoint.y);
  };
  var fromDomSafe = function(node) {
    return Optional.from(node).map(SugarElement.fromDom);
  };
  var isEditorAttachedToDom = function(editor) {
    var rawContainer = editor.inline ? editor.getBody() : editor.getContentAreaContainer();
    return fromDomSafe(rawContainer).map(inBody).getOr(false);
  };
  var NotificationManagerImpl = function() {
    var unimplemented = function() {
      throw new Error("Theme did not provide a NotificationManager implementation.");
    };
    return {
      open: unimplemented,
      close: unimplemented,
      reposition: unimplemented,
      getArgs: unimplemented
    };
  };
  var NotificationManager = function(editor) {
    var notifications = [];
    var getImplementation = function() {
      var theme = editor.theme;
      return theme && theme.getNotificationManagerImpl ? theme.getNotificationManagerImpl() : NotificationManagerImpl();
    };
    var getTopNotification = function() {
      return Optional.from(notifications[0]);
    };
    var isEqual2 = function(a, b) {
      return a.type === b.type && a.text === b.text && !a.progressBar && !a.timeout && !b.progressBar && !b.timeout;
    };
    var reposition2 = function() {
      if (notifications.length > 0) {
        getImplementation().reposition(notifications);
      }
    };
    var addNotification = function(notification) {
      notifications.push(notification);
    };
    var closeNotification = function(notification) {
      findIndex(notifications, function(otherNotification) {
        return otherNotification === notification;
      }).each(function(index) {
        notifications.splice(index, 1);
      });
    };
    var open = function(spec, fireEvent2) {
      if (fireEvent2 === void 0) {
        fireEvent2 = true;
      }
      if (editor.removed || !isEditorAttachedToDom(editor)) {
        return;
      }
      if (fireEvent2) {
        editor.fire("BeforeOpenNotification", { notification: spec });
      }
      return find(notifications, function(notification) {
        return isEqual2(getImplementation().getArgs(notification), spec);
      }).getOrThunk(function() {
        editor.editorManager.setActive(editor);
        var notification = getImplementation().open(spec, function() {
          closeNotification(notification);
          reposition2();
          getTopNotification().fold(function() {
            return editor.focus();
          }, function(top) {
            return focus(SugarElement.fromDom(top.getEl()));
          });
        });
        addNotification(notification);
        reposition2();
        editor.fire("OpenNotification", { notification: __assign2({}, notification) });
        return notification;
      });
    };
    var close = function() {
      getTopNotification().each(function(notification) {
        getImplementation().close(notification);
        closeNotification(notification);
        reposition2();
      });
    };
    var getNotifications = function() {
      return notifications;
    };
    var registerEvents2 = function(editor2) {
      editor2.on("SkinLoaded", function() {
        var serviceMessage = getServiceMessage(editor2);
        if (serviceMessage) {
          open({
            text: serviceMessage,
            type: "warning",
            timeout: 0
          }, false);
        }
      });
      editor2.on("ResizeEditor ResizeWindow NodeChange", function() {
        Delay.requestAnimationFrame(reposition2);
      });
      editor2.on("remove", function() {
        each(notifications.slice(), function(notification) {
          getImplementation().close(notification);
        });
      });
    };
    registerEvents2(editor);
    return {
      open,
      close,
      getNotifications
    };
  };
  var PluginManager = AddOnManager.PluginManager;
  var ThemeManager = AddOnManager.ThemeManager;
  function WindowManagerImpl() {
    var unimplemented = function() {
      throw new Error("Theme did not provide a WindowManager implementation.");
    };
    return {
      open: unimplemented,
      openUrl: unimplemented,
      alert: unimplemented,
      confirm: unimplemented,
      close: unimplemented,
      getParams: unimplemented,
      setParams: unimplemented
    };
  }
  var WindowManager = function(editor) {
    var dialogs = [];
    var getImplementation = function() {
      var theme = editor.theme;
      return theme && theme.getWindowManagerImpl ? theme.getWindowManagerImpl() : WindowManagerImpl();
    };
    var funcBind = function(scope, f) {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return f ? f.apply(scope, args) : void 0;
      };
    };
    var fireOpenEvent = function(dialog) {
      editor.fire("OpenWindow", { dialog });
    };
    var fireCloseEvent = function(dialog) {
      editor.fire("CloseWindow", { dialog });
    };
    var addDialog = function(dialog) {
      dialogs.push(dialog);
      fireOpenEvent(dialog);
    };
    var closeDialog = function(dialog) {
      fireCloseEvent(dialog);
      dialogs = filter(dialogs, function(otherDialog) {
        return otherDialog !== dialog;
      });
      if (dialogs.length === 0) {
        editor.focus();
      }
    };
    var getTopDialog = function() {
      return Optional.from(dialogs[dialogs.length - 1]);
    };
    var storeSelectionAndOpenDialog = function(openDialog) {
      editor.editorManager.setActive(editor);
      store(editor);
      var dialog = openDialog();
      addDialog(dialog);
      return dialog;
    };
    var open = function(args, params) {
      return storeSelectionAndOpenDialog(function() {
        return getImplementation().open(args, params, closeDialog);
      });
    };
    var openUrl = function(args) {
      return storeSelectionAndOpenDialog(function() {
        return getImplementation().openUrl(args, closeDialog);
      });
    };
    var alert = function(message, callback, scope) {
      var windowManagerImpl = getImplementation();
      windowManagerImpl.alert(message, funcBind(scope ? scope : windowManagerImpl, callback));
    };
    var confirm = function(message, callback, scope) {
      var windowManagerImpl = getImplementation();
      windowManagerImpl.confirm(message, funcBind(scope ? scope : windowManagerImpl, callback));
    };
    var close = function() {
      getTopDialog().each(function(dialog) {
        getImplementation().close(dialog);
        closeDialog(dialog);
      });
    };
    editor.on("remove", function() {
      each(dialogs, function(dialog) {
        getImplementation().close(dialog);
      });
    });
    return {
      open,
      openUrl,
      alert,
      confirm,
      close
    };
  };
  var displayNotification = function(editor, message) {
    editor.notificationManager.open({
      type: "error",
      text: message
    });
  };
  var displayError = function(editor, message) {
    if (editor._skinLoaded) {
      displayNotification(editor, message);
    } else {
      editor.on("SkinLoaded", function() {
        displayNotification(editor, message);
      });
    }
  };
  var uploadError = function(editor, message) {
    displayError(editor, I18n.translate([
      "Failed to upload image: {0}",
      message
    ]));
  };
  var logError = function(editor, errorType, msg) {
    fireError(editor, errorType, { message: msg });
    console.error(msg);
  };
  var createLoadError = function(type2, url, name2) {
    return name2 ? "Failed to load " + type2 + ": " + name2 + " from url " + url : "Failed to load " + type2 + " url: " + url;
  };
  var pluginLoadError = function(editor, url, name2) {
    logError(editor, "PluginLoadError", createLoadError("plugin", url, name2));
  };
  var iconsLoadError = function(editor, url, name2) {
    logError(editor, "IconsLoadError", createLoadError("icons", url, name2));
  };
  var languageLoadError = function(editor, url, name2) {
    logError(editor, "LanguageLoadError", createLoadError("language", url, name2));
  };
  var pluginInitError = function(editor, name2, err) {
    var message = I18n.translate([
      "Failed to initialize plugin: {0}",
      name2
    ]);
    fireError(editor, "PluginLoadError", { message });
    initError(message, err);
    displayError(editor, message);
  };
  var initError = function(message) {
    var x2 = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      x2[_i - 1] = arguments[_i];
    }
    var console2 = window.console;
    if (console2) {
      if (console2.error) {
        console2.error.apply(console2, __spreadArrays([message], x2));
      } else {
        console2.log.apply(console2, __spreadArrays([message], x2));
      }
    }
  };
  var isContentCssSkinName = function(url) {
    return /^[a-z0-9\-]+$/i.test(url);
  };
  var getContentCssUrls = function(editor) {
    return transformToUrls(editor, getContentCss(editor));
  };
  var getFontCssUrls = function(editor) {
    return transformToUrls(editor, getFontCss(editor));
  };
  var transformToUrls = function(editor, cssLinks) {
    var skinUrl = editor.editorManager.baseURL + "/skins/content";
    var suffix = editor.editorManager.suffix;
    var contentCssFile = "content" + suffix + ".css";
    var inline = editor.inline === true;
    return map(cssLinks, function(url) {
      if (isContentCssSkinName(url) && !inline) {
        return skinUrl + "/" + url + "/" + contentCssFile;
      } else {
        return editor.documentBaseURI.toAbsolute(url);
      }
    });
  };
  var appendContentCssFromSettings = function(editor) {
    editor.contentCSS = editor.contentCSS.concat(getContentCssUrls(editor), getFontCssUrls(editor));
  };
  var UploadStatus = function() {
    var PENDING = 1, UPLOADED = 2;
    var blobUriStatuses = {};
    var createStatus = function(status, resultUri) {
      return {
        status,
        resultUri
      };
    };
    var hasBlobUri = function(blobUri) {
      return blobUri in blobUriStatuses;
    };
    var getResultUri = function(blobUri) {
      var result = blobUriStatuses[blobUri];
      return result ? result.resultUri : null;
    };
    var isPending = function(blobUri) {
      return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === PENDING : false;
    };
    var isUploaded = function(blobUri) {
      return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === UPLOADED : false;
    };
    var markPending = function(blobUri) {
      blobUriStatuses[blobUri] = createStatus(PENDING, null);
    };
    var markUploaded = function(blobUri, resultUri) {
      blobUriStatuses[blobUri] = createStatus(UPLOADED, resultUri);
    };
    var removeFailed = function(blobUri) {
      delete blobUriStatuses[blobUri];
    };
    var destroy2 = function() {
      blobUriStatuses = {};
    };
    return {
      hasBlobUri,
      getResultUri,
      isPending,
      isUploaded,
      markPending,
      markUploaded,
      removeFailed,
      destroy: destroy2
    };
  };
  var count$1 = 0;
  var seed = function() {
    var rnd = function() {
      return Math.round(Math.random() * 4294967295).toString(36);
    };
    var now = new Date().getTime();
    return "s" + now.toString(36) + rnd() + rnd() + rnd();
  };
  var uuid2 = function(prefix) {
    return prefix + count$1++ + seed();
  };
  var BlobCache = function() {
    var cache = [];
    var mimeToExt = function(mime) {
      var mimes = {
        "image/jpeg": "jpg",
        "image/jpg": "jpg",
        "image/gif": "gif",
        "image/png": "png",
        "image/apng": "apng",
        "image/avif": "avif",
        "image/svg+xml": "svg",
        "image/webp": "webp",
        "image/bmp": "bmp",
        "image/tiff": "tiff"
      };
      return mimes[mime.toLowerCase()] || "dat";
    };
    var create2 = function(o, blob, base64, name2, filename) {
      if (isString(o)) {
        var id2 = o;
        return toBlobInfo({
          id: id2,
          name: name2,
          filename,
          blob,
          base64
        });
      } else if (isObject(o)) {
        return toBlobInfo(o);
      } else {
        throw new Error("Unknown input type");
      }
    };
    var toBlobInfo = function(o) {
      if (!o.blob || !o.base64) {
        throw new Error("blob and base64 representations of the image are required for BlobInfo to be created");
      }
      var id2 = o.id || uuid2("blobid");
      var name2 = o.name || id2;
      var blob = o.blob;
      return {
        id: constant(id2),
        name: constant(name2),
        filename: constant(o.filename || name2 + "." + mimeToExt(blob.type)),
        blob: constant(blob),
        base64: constant(o.base64),
        blobUri: constant(o.blobUri || URL.createObjectURL(blob)),
        uri: constant(o.uri)
      };
    };
    var add2 = function(blobInfo) {
      if (!get2(blobInfo.id())) {
        cache.push(blobInfo);
      }
    };
    var findFirst = function(predicate) {
      return find(cache, predicate).getOrUndefined();
    };
    var get2 = function(id2) {
      return findFirst(function(cachedBlobInfo) {
        return cachedBlobInfo.id() === id2;
      });
    };
    var getByUri = function(blobUri) {
      return findFirst(function(blobInfo) {
        return blobInfo.blobUri() === blobUri;
      });
    };
    var getByData = function(base64, type2) {
      return findFirst(function(blobInfo) {
        return blobInfo.base64() === base64 && blobInfo.blob().type === type2;
      });
    };
    var removeByUri = function(blobUri) {
      cache = filter(cache, function(blobInfo) {
        if (blobInfo.blobUri() === blobUri) {
          URL.revokeObjectURL(blobInfo.blobUri());
          return false;
        }
        return true;
      });
    };
    var destroy2 = function() {
      each(cache, function(cachedBlobInfo) {
        URL.revokeObjectURL(cachedBlobInfo.blobUri());
      });
      cache = [];
    };
    return {
      create: create2,
      add: add2,
      get: get2,
      getByUri,
      getByData,
      findFirst,
      removeByUri,
      destroy: destroy2
    };
  };
  var Uploader = function(uploadStatus, settings) {
    var pendingPromises = {};
    var pathJoin = function(path1, path2) {
      if (path1) {
        return path1.replace(/\/$/, "") + "/" + path2.replace(/^\//, "");
      }
      return path2;
    };
    var defaultHandler = function(blobInfo, success, failure, progress) {
      var xhr = new XMLHttpRequest();
      xhr.open("POST", settings.url);
      xhr.withCredentials = settings.credentials;
      xhr.upload.onprogress = function(e) {
        progress(e.loaded / e.total * 100);
      };
      xhr.onerror = function() {
        failure("Image upload failed due to a XHR Transport error. Code: " + xhr.status);
      };
      xhr.onload = function() {
        if (xhr.status < 200 || xhr.status >= 300) {
          failure("HTTP Error: " + xhr.status);
          return;
        }
        var json = JSON.parse(xhr.responseText);
        if (!json || typeof json.location !== "string") {
          failure("Invalid JSON: " + xhr.responseText);
          return;
        }
        success(pathJoin(settings.basePath, json.location));
      };
      var formData = new FormData();
      formData.append("file", blobInfo.blob(), blobInfo.filename());
      xhr.send(formData);
    };
    var noUpload = function() {
      return new promiseObj(function(resolve2) {
        resolve2([]);
      });
    };
    var handlerSuccess = function(blobInfo, url) {
      return {
        url,
        blobInfo,
        status: true
      };
    };
    var handlerFailure = function(blobInfo, message, options) {
      return {
        url: "",
        blobInfo,
        status: false,
        error: {
          message,
          options
        }
      };
    };
    var resolvePending = function(blobUri, result) {
      Tools.each(pendingPromises[blobUri], function(resolve2) {
        resolve2(result);
      });
      delete pendingPromises[blobUri];
    };
    var uploadBlobInfo = function(blobInfo, handler, openNotification2) {
      uploadStatus.markPending(blobInfo.blobUri());
      return new promiseObj(function(resolve2) {
        var notification, progress;
        try {
          var closeNotification_1 = function() {
            if (notification) {
              notification.close();
              progress = noop;
            }
          };
          var success = function(url) {
            closeNotification_1();
            uploadStatus.markUploaded(blobInfo.blobUri(), url);
            resolvePending(blobInfo.blobUri(), handlerSuccess(blobInfo, url));
            resolve2(handlerSuccess(blobInfo, url));
          };
          var failure = function(error2, options) {
            var failureOptions = options ? options : {};
            closeNotification_1();
            uploadStatus.removeFailed(blobInfo.blobUri());
            resolvePending(blobInfo.blobUri(), handlerFailure(blobInfo, error2, failureOptions));
            resolve2(handlerFailure(blobInfo, error2, failureOptions));
          };
          progress = function(percent) {
            if (percent < 0 || percent > 100) {
              return;
            }
            Optional.from(notification).orThunk(function() {
              return Optional.from(openNotification2).map(apply);
            }).each(function(n2) {
              notification = n2;
              n2.progressBar.value(percent);
            });
          };
          handler(blobInfo, success, failure, progress);
        } catch (ex) {
          resolve2(handlerFailure(blobInfo, ex.message, {}));
        }
      });
    };
    var isDefaultHandler = function(handler) {
      return handler === defaultHandler;
    };
    var pendingUploadBlobInfo = function(blobInfo) {
      var blobUri = blobInfo.blobUri();
      return new promiseObj(function(resolve2) {
        pendingPromises[blobUri] = pendingPromises[blobUri] || [];
        pendingPromises[blobUri].push(resolve2);
      });
    };
    var uploadBlobs = function(blobInfos, openNotification2) {
      blobInfos = Tools.grep(blobInfos, function(blobInfo) {
        return !uploadStatus.isUploaded(blobInfo.blobUri());
      });
      return promiseObj.all(Tools.map(blobInfos, function(blobInfo) {
        return uploadStatus.isPending(blobInfo.blobUri()) ? pendingUploadBlobInfo(blobInfo) : uploadBlobInfo(blobInfo, settings.handler, openNotification2);
      }));
    };
    var upload = function(blobInfos, openNotification2) {
      return !settings.url && isDefaultHandler(settings.handler) ? noUpload() : uploadBlobs(blobInfos, openNotification2);
    };
    if (isFunction2(settings.handler) === false) {
      settings.handler = defaultHandler;
    }
    return { upload };
  };
  var openNotification = function(editor) {
    return function() {
      return editor.notificationManager.open({
        text: editor.translate("Image uploading..."),
        type: "info",
        timeout: -1,
        progressBar: true
      });
    };
  };
  var createUploader = function(editor, uploadStatus) {
    return Uploader(uploadStatus, {
      url: getImageUploadUrl(editor),
      basePath: getImageUploadBasePath(editor),
      credentials: getImagesUploadCredentials(editor),
      handler: getImagesUploadHandler(editor)
    });
  };
  var ImageUploader = function(editor) {
    var uploadStatus = UploadStatus();
    var uploader = createUploader(editor, uploadStatus);
    return {
      upload: function(blobInfos, showNotification) {
        if (showNotification === void 0) {
          showNotification = true;
        }
        return uploader.upload(blobInfos, showNotification ? openNotification(editor) : void 0);
      }
    };
  };
  var UploadChangeHandler = function(editor) {
    var lastChangedLevel = Cell(null);
    editor.on("change AddUndo", function(e) {
      lastChangedLevel.set(__assign2({}, e.level));
    });
    var fireIfChanged = function() {
      var data2 = editor.undoManager.data;
      last(data2).filter(function(level) {
        return !isEq$4(lastChangedLevel.get(), level);
      }).each(function(level) {
        editor.setDirty(true);
        editor.fire("change", {
          level,
          lastLevel: get(data2, data2.length - 2).getOrNull()
        });
      });
    };
    return { fireIfChanged };
  };
  var EditorUpload = function(editor) {
    var blobCache = BlobCache();
    var uploader, imageScanner;
    var uploadStatus = UploadStatus();
    var urlFilters = [];
    var changeHandler = UploadChangeHandler(editor);
    var aliveGuard = function(callback) {
      return function(result) {
        if (editor.selection) {
          return callback(result);
        }
        return [];
      };
    };
    var cacheInvalidator = function(url) {
      return url + (url.indexOf("?") === -1 ? "?" : "&") + new Date().getTime();
    };
    var replaceString = function(content, search2, replace) {
      var index = 0;
      do {
        index = content.indexOf(search2, index);
        if (index !== -1) {
          content = content.substring(0, index) + replace + content.substr(index + search2.length);
          index += replace.length - search2.length + 1;
        }
      } while (index !== -1);
      return content;
    };
    var replaceImageUrl = function(content, targetUrl, replacementUrl) {
      var replacementString = 'src="' + replacementUrl + '"' + (replacementUrl === Env.transparentSrc ? ' data-mce-placeholder="1"' : "");
      content = replaceString(content, 'src="' + targetUrl + '"', replacementString);
      content = replaceString(content, 'data-mce-src="' + targetUrl + '"', 'data-mce-src="' + replacementUrl + '"');
      return content;
    };
    var replaceUrlInUndoStack = function(targetUrl, replacementUrl) {
      each(editor.undoManager.data, function(level) {
        if (level.type === "fragmented") {
          level.fragments = map(level.fragments, function(fragment) {
            return replaceImageUrl(fragment, targetUrl, replacementUrl);
          });
        } else {
          level.content = replaceImageUrl(level.content, targetUrl, replacementUrl);
        }
      });
    };
    var replaceImageUriInView = function(image, resultUri) {
      var src = editor.convertURL(resultUri, "src");
      replaceUrlInUndoStack(image.src, resultUri);
      editor.$(image).attr({
        "src": shouldReuseFileName(editor) ? cacheInvalidator(resultUri) : resultUri,
        "data-mce-src": src
      });
    };
    var uploadImages = function(callback) {
      if (!uploader) {
        uploader = createUploader(editor, uploadStatus);
      }
      return scanForImages().then(aliveGuard(function(imageInfos) {
        var blobInfos = map(imageInfos, function(imageInfo) {
          return imageInfo.blobInfo;
        });
        return uploader.upload(blobInfos, openNotification(editor)).then(aliveGuard(function(result) {
          var imagesToRemove = [];
          var filteredResult = map(result, function(uploadInfo, index) {
            var blobInfo = imageInfos[index].blobInfo;
            var image = imageInfos[index].image;
            if (uploadInfo.status && shouldReplaceBlobUris(editor)) {
              blobCache.removeByUri(image.src);
              replaceImageUriInView(image, uploadInfo.url);
            } else if (uploadInfo.error) {
              if (uploadInfo.error.options.remove) {
                replaceUrlInUndoStack(image.getAttribute("src"), Env.transparentSrc);
                imagesToRemove.push(image);
              }
              uploadError(editor, uploadInfo.error.message);
            }
            return {
              element: image,
              status: uploadInfo.status,
              uploadUri: uploadInfo.url,
              blobInfo
            };
          });
          if (filteredResult.length > 0) {
            changeHandler.fireIfChanged();
          }
          if (imagesToRemove.length > 0) {
            if (isRtc(editor)) {
              console.error("Removing images on failed uploads is currently unsupported for RTC");
            } else {
              editor.undoManager.transact(function() {
                each(imagesToRemove, function(element) {
                  editor.dom.remove(element);
                  blobCache.removeByUri(element.src);
                });
              });
            }
          }
          if (callback) {
            callback(filteredResult);
          }
          return filteredResult;
        }));
      }));
    };
    var uploadImagesAuto = function(callback) {
      if (isAutomaticUploadsEnabled(editor)) {
        return uploadImages(callback);
      }
    };
    var isValidDataUriImage = function(imgElm) {
      if (forall(urlFilters, function(filter2) {
        return filter2(imgElm);
      }) === false) {
        return false;
      }
      if (imgElm.getAttribute("src").indexOf("data:") === 0) {
        var dataImgFilter = getImagesDataImgFilter(editor);
        return dataImgFilter(imgElm);
      }
      return true;
    };
    var addFilter = function(filter2) {
      urlFilters.push(filter2);
    };
    var scanForImages = function() {
      if (!imageScanner) {
        imageScanner = ImageScanner(uploadStatus, blobCache);
      }
      return imageScanner.findAll(editor.getBody(), isValidDataUriImage).then(aliveGuard(function(result) {
        result = filter(result, function(resultItem) {
          if (typeof resultItem === "string") {
            displayError(editor, resultItem);
            return false;
          }
          return true;
        });
        each(result, function(resultItem) {
          replaceUrlInUndoStack(resultItem.image.src, resultItem.blobInfo.blobUri());
          resultItem.image.src = resultItem.blobInfo.blobUri();
          resultItem.image.removeAttribute("data-mce-src");
        });
        return result;
      }));
    };
    var destroy2 = function() {
      blobCache.destroy();
      uploadStatus.destroy();
      imageScanner = uploader = null;
    };
    var replaceBlobUris = function(content) {
      return content.replace(/src="(blob:[^"]+)"/g, function(match2, blobUri) {
        var resultUri = uploadStatus.getResultUri(blobUri);
        if (resultUri) {
          return 'src="' + resultUri + '"';
        }
        var blobInfo = blobCache.getByUri(blobUri);
        if (!blobInfo) {
          blobInfo = foldl(editor.editorManager.get(), function(result, editor2) {
            return result || editor2.editorUpload && editor2.editorUpload.blobCache.getByUri(blobUri);
          }, null);
        }
        if (blobInfo) {
          var blob = blobInfo.blob();
          return 'src="data:' + blob.type + ";base64," + blobInfo.base64() + '"';
        }
        return match2;
      });
    };
    editor.on("SetContent", function() {
      if (isAutomaticUploadsEnabled(editor)) {
        uploadImagesAuto();
      } else {
        scanForImages();
      }
    });
    editor.on("RawSaveContent", function(e) {
      e.content = replaceBlobUris(e.content);
    });
    editor.on("GetContent", function(e) {
      if (e.source_view || e.format === "raw" || e.format === "tree") {
        return;
      }
      e.content = replaceBlobUris(e.content);
    });
    editor.on("PostRender", function() {
      editor.parser.addNodeFilter("img", function(images) {
        each(images, function(img) {
          var src = img.attr("src");
          if (blobCache.getByUri(src)) {
            return;
          }
          var resultUri = uploadStatus.getResultUri(src);
          if (resultUri) {
            img.attr("src", resultUri);
          }
        });
      });
    });
    return {
      blobCache,
      addFilter,
      uploadImages,
      uploadImagesAuto,
      scanForImages,
      destroy: destroy2
    };
  };
  var get$a = function(dom2) {
    var formats = {
      valigntop: [{
        selector: "td,th",
        styles: { verticalAlign: "top" }
      }],
      valignmiddle: [{
        selector: "td,th",
        styles: { verticalAlign: "middle" }
      }],
      valignbottom: [{
        selector: "td,th",
        styles: { verticalAlign: "bottom" }
      }],
      alignleft: [
        {
          selector: "figure.image",
          collapsed: false,
          classes: "align-left",
          ceFalseOverride: true,
          preview: "font-family font-size"
        },
        {
          selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li",
          styles: { textAlign: "left" },
          inherit: false,
          preview: false,
          defaultBlock: "div"
        },
        {
          selector: "img,table,audio,video",
          collapsed: false,
          styles: { float: "left" },
          preview: "font-family font-size"
        }
      ],
      aligncenter: [
        {
          selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li",
          styles: { textAlign: "center" },
          inherit: false,
          preview: "font-family font-size",
          defaultBlock: "div"
        },
        {
          selector: "figure.image",
          collapsed: false,
          classes: "align-center",
          ceFalseOverride: true,
          preview: "font-family font-size"
        },
        {
          selector: "img,audio,video",
          collapsed: false,
          styles: {
            display: "block",
            marginLeft: "auto",
            marginRight: "auto"
          },
          preview: false
        },
        {
          selector: "table",
          collapsed: false,
          styles: {
            marginLeft: "auto",
            marginRight: "auto"
          },
          preview: "font-family font-size"
        }
      ],
      alignright: [
        {
          selector: "figure.image",
          collapsed: false,
          classes: "align-right",
          ceFalseOverride: true,
          preview: "font-family font-size"
        },
        {
          selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li",
          styles: { textAlign: "right" },
          inherit: false,
          preview: "font-family font-size",
          defaultBlock: "div"
        },
        {
          selector: "img,table,audio,video",
          collapsed: false,
          styles: { float: "right" },
          preview: "font-family font-size"
        }
      ],
      alignjustify: [{
        selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li",
        styles: { textAlign: "justify" },
        inherit: false,
        defaultBlock: "div",
        preview: "font-family font-size"
      }],
      bold: [
        {
          inline: "strong",
          remove: "all",
          preserve_attributes: [
            "class",
            "style"
          ]
        },
        {
          inline: "span",
          styles: { fontWeight: "bold" }
        },
        {
          inline: "b",
          remove: "all",
          preserve_attributes: [
            "class",
            "style"
          ]
        }
      ],
      italic: [
        {
          inline: "em",
          remove: "all",
          preserve_attributes: [
            "class",
            "style"
          ]
        },
        {
          inline: "span",
          styles: { fontStyle: "italic" }
        },
        {
          inline: "i",
          remove: "all",
          preserve_attributes: [
            "class",
            "style"
          ]
        }
      ],
      underline: [
        {
          inline: "span",
          styles: { textDecoration: "underline" },
          exact: true
        },
        {
          inline: "u",
          remove: "all",
          preserve_attributes: [
            "class",
            "style"
          ]
        }
      ],
      strikethrough: [
        {
          inline: "span",
          styles: { textDecoration: "line-through" },
          exact: true
        },
        {
          inline: "strike",
          remove: "all",
          preserve_attributes: [
            "class",
            "style"
          ]
        },
        {
          inline: "s",
          remove: "all",
          preserve_attributes: [
            "class",
            "style"
          ]
        }
      ],
      forecolor: {
        inline: "span",
        styles: { color: "%value" },
        links: true,
        remove_similar: true,
        clear_child_styles: true
      },
      hilitecolor: {
        inline: "span",
        styles: { backgroundColor: "%value" },
        links: true,
        remove_similar: true,
        clear_child_styles: true
      },
      fontname: {
        inline: "span",
        toggle: false,
        styles: { fontFamily: "%value" },
        clear_child_styles: true
      },
      fontsize: {
        inline: "span",
        toggle: false,
        styles: { fontSize: "%value" },
        clear_child_styles: true
      },
      lineheight: {
        selector: "h1,h2,h3,h4,h5,h6,p,li,td,th,div",
        defaultBlock: "p",
        styles: { lineHeight: "%value" }
      },
      fontsize_class: {
        inline: "span",
        attributes: { class: "%value" }
      },
      blockquote: {
        block: "blockquote",
        wrapper: true,
        remove: "all"
      },
      subscript: { inline: "sub" },
      superscript: { inline: "sup" },
      code: { inline: "code" },
      link: {
        inline: "a",
        selector: "a",
        remove: "all",
        split: true,
        deep: true,
        onmatch: function(node, _fmt, _itemName) {
          return isElement$1(node) && node.hasAttribute("href");
        },
        onformat: function(elm, _fmt, vars) {
          Tools.each(vars, function(value2, key) {
            dom2.setAttrib(elm, key, value2);
          });
        }
      },
      removeformat: [
        {
          selector: "b,strong,em,i,font,u,strike,s,sub,sup,dfn,code,samp,kbd,var,cite,mark,q,del,ins,small",
          remove: "all",
          split: true,
          expand: false,
          block_expand: true,
          deep: true
        },
        {
          selector: "span",
          attributes: [
            "style",
            "class"
          ],
          remove: "empty",
          split: true,
          expand: false,
          deep: true
        },
        {
          selector: "*",
          attributes: [
            "style",
            "class"
          ],
          split: false,
          expand: false,
          deep: true
        }
      ]
    };
    Tools.each("p h1 h2 h3 h4 h5 h6 div address pre dt dd samp".split(/\s/), function(name2) {
      formats[name2] = {
        block: name2,
        remove: "all"
      };
    });
    return formats;
  };
  var FormatRegistry = function(editor) {
    var formats = {};
    var get2 = function(name2) {
      return name2 ? formats[name2] : formats;
    };
    var has$12 = function(name2) {
      return has(formats, name2);
    };
    var register2 = function(name2, format) {
      if (name2) {
        if (typeof name2 !== "string") {
          Tools.each(name2, function(format2, name3) {
            register2(name3, format2);
          });
        } else {
          if (!isArray(format)) {
            format = [format];
          }
          Tools.each(format, function(format2) {
            if (typeof format2.deep === "undefined") {
              format2.deep = !format2.selector;
            }
            if (typeof format2.split === "undefined") {
              format2.split = !format2.selector || format2.inline;
            }
            if (typeof format2.remove === "undefined" && format2.selector && !format2.inline) {
              format2.remove = "none";
            }
            if (format2.selector && format2.inline) {
              format2.mixed = true;
              format2.block_expand = true;
            }
            if (typeof format2.classes === "string") {
              format2.classes = format2.classes.split(/\s+/);
            }
          });
          formats[name2] = format;
        }
      }
    };
    var unregister = function(name2) {
      if (name2 && formats[name2]) {
        delete formats[name2];
      }
      return formats;
    };
    register2(get$a(editor.dom));
    register2(getFormats(editor));
    return {
      get: get2,
      has: has$12,
      register: register2,
      unregister
    };
  };
  var each$e = Tools.each;
  var dom = DOMUtils.DOM;
  var parsedSelectorToHtml = function(ancestry, editor) {
    var elm, item, fragment;
    var schema = editor && editor.schema || Schema({});
    var decorate = function(elm2, item2) {
      if (item2.classes.length) {
        dom.addClass(elm2, item2.classes.join(" "));
      }
      dom.setAttribs(elm2, item2.attrs);
    };
    var createElement = function(sItem) {
      item = typeof sItem === "string" ? {
        name: sItem,
        classes: [],
        attrs: {}
      } : sItem;
      var elm2 = dom.create(item.name);
      decorate(elm2, item);
      return elm2;
    };
    var getRequiredParent = function(elm2, candidate) {
      var name2 = typeof elm2 !== "string" ? elm2.nodeName.toLowerCase() : elm2;
      var elmRule = schema.getElementRule(name2);
      var parentsRequired = elmRule && elmRule.parentsRequired;
      if (parentsRequired && parentsRequired.length) {
        return candidate && Tools.inArray(parentsRequired, candidate) !== -1 ? candidate : parentsRequired[0];
      } else {
        return false;
      }
    };
    var wrapInHtml = function(elm2, ancestry2, siblings2) {
      var parent2, parentCandidate;
      var ancestor2 = ancestry2.length > 0 && ancestry2[0];
      var ancestorName = ancestor2 && ancestor2.name;
      var parentRequired = getRequiredParent(elm2, ancestorName);
      if (parentRequired) {
        if (ancestorName === parentRequired) {
          parentCandidate = ancestry2[0];
          ancestry2 = ancestry2.slice(1);
        } else {
          parentCandidate = parentRequired;
        }
      } else if (ancestor2) {
        parentCandidate = ancestry2[0];
        ancestry2 = ancestry2.slice(1);
      } else if (!siblings2) {
        return elm2;
      }
      if (parentCandidate) {
        parent2 = createElement(parentCandidate);
        parent2.appendChild(elm2);
      }
      if (siblings2) {
        if (!parent2) {
          parent2 = dom.create("div");
          parent2.appendChild(elm2);
        }
        Tools.each(siblings2, function(sibling2) {
          var siblingElm = createElement(sibling2);
          parent2.insertBefore(siblingElm, elm2);
        });
      }
      return wrapInHtml(parent2, ancestry2, parentCandidate && parentCandidate.siblings);
    };
    if (ancestry && ancestry.length) {
      item = ancestry[0];
      elm = createElement(item);
      fragment = dom.create("div");
      fragment.appendChild(wrapInHtml(elm, ancestry.slice(1), item.siblings));
      return fragment;
    } else {
      return "";
    }
  };
  var parseSelectorItem = function(item) {
    var tagName;
    var obj = {
      classes: [],
      attrs: {}
    };
    item = obj.selector = Tools.trim(item);
    if (item !== "*") {
      tagName = item.replace(/(?:([#\.]|::?)([\w\-]+)|(\[)([^\]]+)\]?)/g, function($0, $1, $2, $3, $4) {
        switch ($1) {
          case "#":
            obj.attrs.id = $2;
            break;
          case ".":
            obj.classes.push($2);
            break;
          case ":":
            if (Tools.inArray("checked disabled enabled read-only required".split(" "), $2) !== -1) {
              obj.attrs[$2] = $2;
            }
            break;
        }
        if ($3 === "[") {
          var m2 = $4.match(/([\w\-]+)(?:\=\"([^\"]+))?/);
          if (m2) {
            obj.attrs[m2[1]] = m2[2];
          }
        }
        return "";
      });
    }
    obj.name = tagName || "div";
    return obj;
  };
  var parseSelector = function(selector) {
    if (!selector || typeof selector !== "string") {
      return [];
    }
    selector = selector.split(/\s*,\s*/)[0];
    selector = selector.replace(/\s*(~\+|~|\+|>)\s*/g, "$1");
    return Tools.map(selector.split(/(?:>|\s+(?![^\[\]]+\]))/), function(item) {
      var siblings2 = Tools.map(item.split(/(?:~\+|~|\+)/), parseSelectorItem);
      var obj = siblings2.pop();
      if (siblings2.length) {
        obj.siblings = siblings2;
      }
      return obj;
    }).reverse();
  };
  var getCssText = function(editor, format) {
    var name2, previewFrag;
    var previewCss = "", parentFontSize;
    var previewStyles = getPreviewStyles(editor);
    if (previewStyles === "") {
      return "";
    }
    var removeVars = function(val) {
      return val.replace(/%(\w+)/g, "");
    };
    if (typeof format === "string") {
      format = editor.formatter.get(format);
      if (!format) {
        return;
      }
      format = format[0];
    }
    if ("preview" in format) {
      var previewOpt = get$1(format, "preview");
      if (previewOpt.is(false)) {
        return "";
      } else {
        previewStyles = previewOpt.getOr(previewStyles);
      }
    }
    name2 = format.block || format.inline || "span";
    var items = parseSelector(format.selector);
    if (items.length) {
      if (!items[0].name) {
        items[0].name = name2;
      }
      name2 = format.selector;
      previewFrag = parsedSelectorToHtml(items, editor);
    } else {
      previewFrag = parsedSelectorToHtml([name2], editor);
    }
    var previewElm = dom.select(name2, previewFrag)[0] || previewFrag.firstChild;
    each$e(format.styles, function(value2, name3) {
      var newValue = removeVars(value2);
      if (newValue) {
        dom.setStyle(previewElm, name3, newValue);
      }
    });
    each$e(format.attributes, function(value2, name3) {
      var newValue = removeVars(value2);
      if (newValue) {
        dom.setAttrib(previewElm, name3, newValue);
      }
    });
    each$e(format.classes, function(value2) {
      var newValue = removeVars(value2);
      if (!dom.hasClass(previewElm, newValue)) {
        dom.addClass(previewElm, newValue);
      }
    });
    editor.fire("PreviewFormats");
    dom.setStyles(previewFrag, {
      position: "absolute",
      left: -65535
    });
    editor.getBody().appendChild(previewFrag);
    parentFontSize = dom.getStyle(editor.getBody(), "fontSize", true);
    parentFontSize = /px$/.test(parentFontSize) ? parseInt(parentFontSize, 10) : 0;
    each$e(previewStyles.split(" "), function(name3) {
      var value2 = dom.getStyle(previewElm, name3, true);
      if (name3 === "background-color" && /transparent|rgba\s*\([^)]+,\s*0\)/.test(value2)) {
        value2 = dom.getStyle(editor.getBody(), name3, true);
        if (dom.toHex(value2).toLowerCase() === "#ffffff") {
          return;
        }
      }
      if (name3 === "color") {
        if (dom.toHex(value2).toLowerCase() === "#000000") {
          return;
        }
      }
      if (name3 === "font-size") {
        if (/em|%$/.test(value2)) {
          if (parentFontSize === 0) {
            return;
          }
          var numValue = parseFloat(value2) / (/%$/.test(value2) ? 100 : 1);
          value2 = numValue * parentFontSize + "px";
        }
      }
      if (name3 === "border" && value2) {
        previewCss += "padding:0 2px;";
      }
      previewCss += name3 + ":" + value2 + ";";
    });
    editor.fire("AfterPreviewFormats");
    dom.remove(previewFrag);
    return previewCss;
  };
  var setup$6 = function(editor) {
    editor.addShortcut("meta+b", "", "Bold");
    editor.addShortcut("meta+i", "", "Italic");
    editor.addShortcut("meta+u", "", "Underline");
    for (var i = 1; i <= 6; i++) {
      editor.addShortcut("access+" + i, "", [
        "FormatBlock",
        false,
        "h" + i
      ]);
    }
    editor.addShortcut("access+7", "", [
      "FormatBlock",
      false,
      "p"
    ]);
    editor.addShortcut("access+8", "", [
      "FormatBlock",
      false,
      "div"
    ]);
    editor.addShortcut("access+9", "", [
      "FormatBlock",
      false,
      "address"
    ]);
  };
  var Formatter = function(editor) {
    var formats = FormatRegistry(editor);
    var formatChangeState = Cell(null);
    setup$6(editor);
    setup$3(editor);
    return {
      get: formats.get,
      has: formats.has,
      register: formats.register,
      unregister: formats.unregister,
      apply: function(name2, vars, node) {
        applyFormat$1(editor, name2, vars, node);
      },
      remove: function(name2, vars, node, similar) {
        removeFormat$1(editor, name2, vars, node, similar);
      },
      toggle: function(name2, vars, node) {
        toggleFormat(editor, name2, vars, node);
      },
      match: function(name2, vars, node) {
        return matchFormat(editor, name2, vars, node);
      },
      closest: function(names) {
        return closestFormat(editor, names);
      },
      matchAll: function(names, vars) {
        return matchAllFormats(editor, names, vars);
      },
      matchNode: function(node, names, vars, similar) {
        return matchNodeFormat(editor, node, names, vars, similar);
      },
      canApply: function(name2) {
        return canApplyFormat(editor, name2);
      },
      formatChanged: function(formats2, callback, similar) {
        return formatChanged(editor, formatChangeState, formats2, callback, similar);
      },
      getCssText: curry(getCssText, editor)
    };
  };
  var registerEvents$1 = function(editor, undoManager, locks) {
    var isFirstTypedCharacter = Cell(false);
    var addNonTypingUndoLevel = function(e) {
      setTyping(undoManager, false, locks);
      undoManager.add({}, e);
    };
    editor.on("init", function() {
      undoManager.add();
    });
    editor.on("BeforeExecCommand", function(e) {
      var cmd = e.command.toLowerCase();
      if (cmd !== "undo" && cmd !== "redo" && cmd !== "mcerepaint") {
        endTyping(undoManager, locks);
        undoManager.beforeChange();
      }
    });
    editor.on("ExecCommand", function(e) {
      var cmd = e.command.toLowerCase();
      if (cmd !== "undo" && cmd !== "redo" && cmd !== "mcerepaint") {
        addNonTypingUndoLevel(e);
      }
    });
    editor.on("ObjectResizeStart cut", function() {
      undoManager.beforeChange();
    });
    editor.on("SaveContent ObjectResized blur", addNonTypingUndoLevel);
    editor.on("dragend", addNonTypingUndoLevel);
    editor.on("keyup", function(e) {
      var keyCode = e.keyCode;
      if (e.isDefaultPrevented()) {
        return;
      }
      if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || keyCode === 45 || e.ctrlKey) {
        addNonTypingUndoLevel();
        editor.nodeChanged();
      }
      if (keyCode === 46 || keyCode === 8) {
        editor.nodeChanged();
      }
      if (isFirstTypedCharacter.get() && undoManager.typing && isEq$4(createFromEditor(editor), undoManager.data[0]) === false) {
        if (editor.isDirty() === false) {
          editor.setDirty(true);
          editor.fire("change", {
            level: undoManager.data[0],
            lastLevel: null
          });
        }
        editor.fire("TypingUndo");
        isFirstTypedCharacter.set(false);
        editor.nodeChanged();
      }
    });
    editor.on("keydown", function(e) {
      var keyCode = e.keyCode;
      if (e.isDefaultPrevented()) {
        return;
      }
      if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || keyCode === 45) {
        if (undoManager.typing) {
          addNonTypingUndoLevel(e);
        }
        return;
      }
      var modKey = e.ctrlKey && !e.altKey || e.metaKey;
      if ((keyCode < 16 || keyCode > 20) && keyCode !== 224 && keyCode !== 91 && !undoManager.typing && !modKey) {
        undoManager.beforeChange();
        setTyping(undoManager, true, locks);
        undoManager.add({}, e);
        isFirstTypedCharacter.set(true);
      }
    });
    editor.on("mousedown", function(e) {
      if (undoManager.typing) {
        addNonTypingUndoLevel(e);
      }
    });
    var isInsertReplacementText = function(event) {
      return event.inputType === "insertReplacementText";
    };
    var isInsertTextDataNull = function(event) {
      return event.inputType === "insertText" && event.data === null;
    };
    var isInsertFromPasteOrDrop = function(event) {
      return event.inputType === "insertFromPaste" || event.inputType === "insertFromDrop";
    };
    editor.on("input", function(e) {
      if (e.inputType && (isInsertReplacementText(e) || isInsertTextDataNull(e) || isInsertFromPasteOrDrop(e))) {
        addNonTypingUndoLevel(e);
      }
    });
    editor.on("AddUndo Undo Redo ClearUndos", function(e) {
      if (!e.isDefaultPrevented()) {
        editor.nodeChanged();
      }
    });
  };
  var addKeyboardShortcuts = function(editor) {
    editor.addShortcut("meta+z", "", "Undo");
    editor.addShortcut("meta+y,meta+shift+z", "", "Redo");
  };
  var UndoManager = function(editor) {
    var beforeBookmark = Cell(Optional.none());
    var locks = Cell(0);
    var index = Cell(0);
    var undoManager = {
      data: [],
      typing: false,
      beforeChange: function() {
        beforeChange$1(editor, locks, beforeBookmark);
      },
      add: function(level, event) {
        return addUndoLevel$1(editor, undoManager, index, locks, beforeBookmark, level, event);
      },
      undo: function() {
        return undo$1(editor, undoManager, locks, index);
      },
      redo: function() {
        return redo$1(editor, index, undoManager.data);
      },
      clear: function() {
        clear$1(editor, undoManager, index);
      },
      reset: function() {
        reset$1(editor, undoManager);
      },
      hasUndo: function() {
        return hasUndo$1(editor, undoManager, index);
      },
      hasRedo: function() {
        return hasRedo$1(editor, undoManager, index);
      },
      transact: function(callback) {
        return transact$1(editor, undoManager, locks, callback);
      },
      ignore: function(callback) {
        ignore$1(editor, locks, callback);
      },
      extra: function(callback1, callback2) {
        extra$1(editor, undoManager, index, callback1, callback2);
      }
    };
    if (!isRtc(editor)) {
      registerEvents$1(editor, undoManager, locks);
    }
    addKeyboardShortcuts(editor);
    return undoManager;
  };
  var nonTypingKeycodes = [
    9,
    27,
    VK.HOME,
    VK.END,
    19,
    20,
    44,
    144,
    145,
    33,
    34,
    45,
    16,
    17,
    18,
    91,
    92,
    93,
    VK.DOWN,
    VK.UP,
    VK.LEFT,
    VK.RIGHT
  ].concat(Env.browser.isFirefox() ? [224] : []);
  var placeholderAttr = "data-mce-placeholder";
  var isKeyboardEvent = function(e) {
    return e.type === "keydown" || e.type === "keyup";
  };
  var isDeleteEvent = function(e) {
    var keyCode = e.keyCode;
    return keyCode === VK.BACKSPACE || keyCode === VK.DELETE;
  };
  var isNonTypingKeyboardEvent = function(e) {
    if (isKeyboardEvent(e)) {
      var keyCode = e.keyCode;
      return !isDeleteEvent(e) && (VK.metaKeyPressed(e) || e.altKey || keyCode >= 112 && keyCode <= 123 || contains(nonTypingKeycodes, keyCode));
    } else {
      return false;
    }
  };
  var isTypingKeyboardEvent = function(e) {
    return isKeyboardEvent(e) && !(isDeleteEvent(e) || e.type === "keyup" && e.keyCode === 229);
  };
  var isVisuallyEmpty = function(dom2, rootElm, forcedRootBlock) {
    if (isEmpty(SugarElement.fromDom(rootElm), false)) {
      var isForcedRootBlockFalse = forcedRootBlock === "";
      var firstElement2 = rootElm.firstElementChild;
      if (!firstElement2) {
        return true;
      } else if (dom2.getStyle(rootElm.firstElementChild, "padding-left") || dom2.getStyle(rootElm.firstElementChild, "padding-right")) {
        return false;
      } else {
        return isForcedRootBlockFalse ? !dom2.isBlock(firstElement2) : forcedRootBlock === firstElement2.nodeName.toLowerCase();
      }
    } else {
      return false;
    }
  };
  var setup$7 = function(editor) {
    var dom2 = editor.dom;
    var rootBlock = getForcedRootBlock(editor);
    var placeholder = getPlaceholder(editor);
    var updatePlaceholder = function(e, initial) {
      if (isNonTypingKeyboardEvent(e)) {
        return;
      }
      var body = editor.getBody();
      var showPlaceholder = isTypingKeyboardEvent(e) ? false : isVisuallyEmpty(dom2, body, rootBlock);
      var isPlaceholderShown = dom2.getAttrib(body, placeholderAttr) !== "";
      if (isPlaceholderShown !== showPlaceholder || initial) {
        dom2.setAttrib(body, placeholderAttr, showPlaceholder ? placeholder : null);
        dom2.setAttrib(body, "aria-placeholder", showPlaceholder ? placeholder : null);
        firePlaceholderToggle(editor, showPlaceholder);
        editor.on(showPlaceholder ? "keydown" : "keyup", updatePlaceholder);
        editor.off(showPlaceholder ? "keyup" : "keydown", updatePlaceholder);
      }
    };
    if (placeholder) {
      editor.on("init", function(e) {
        updatePlaceholder(e, true);
        editor.on("change SetContent ExecCommand", updatePlaceholder);
        editor.on("paste", function(e2) {
          return Delay.setEditorTimeout(editor, function() {
            return updatePlaceholder(e2);
          });
        });
      });
    }
  };
  var strongRtl = /[\u0591-\u07FF\uFB1D-\uFDFF\uFE70-\uFEFC]/;
  var hasStrongRtl = function(text) {
    return strongRtl.test(text);
  };
  var isInlineTarget = function(editor, elm) {
    return is$1(SugarElement.fromDom(elm), getInlineBoundarySelector(editor));
  };
  var isRtl$1 = function(element) {
    return DOMUtils.DOM.getStyle(element, "direction", true) === "rtl" || hasStrongRtl(element.textContent);
  };
  var findInlineParents = function(isInlineTarget2, rootNode, pos) {
    return filter(DOMUtils.DOM.getParents(pos.container(), "*", rootNode), isInlineTarget2);
  };
  var findRootInline = function(isInlineTarget2, rootNode, pos) {
    var parents2 = findInlineParents(isInlineTarget2, rootNode, pos);
    return Optional.from(parents2[parents2.length - 1]);
  };
  var hasSameParentBlock = function(rootNode, node1, node2) {
    var block1 = getParentBlock(node1, rootNode);
    var block2 = getParentBlock(node2, rootNode);
    return block1 && block1 === block2;
  };
  var isAtZwsp = function(pos) {
    return isBeforeInline(pos) || isAfterInline(pos);
  };
  var normalizePosition = function(forward, pos) {
    if (!pos) {
      return pos;
    }
    var container = pos.container(), offset = pos.offset();
    if (forward) {
      if (isCaretContainerInline(container)) {
        if (isText$1(container.nextSibling)) {
          return CaretPosition(container.nextSibling, 0);
        } else {
          return CaretPosition.after(container);
        }
      } else {
        return isBeforeInline(pos) ? CaretPosition(container, offset + 1) : pos;
      }
    } else {
      if (isCaretContainerInline(container)) {
        if (isText$1(container.previousSibling)) {
          return CaretPosition(container.previousSibling, container.previousSibling.data.length);
        } else {
          return CaretPosition.before(container);
        }
      } else {
        return isAfterInline(pos) ? CaretPosition(container, offset - 1) : pos;
      }
    }
  };
  var normalizeForwards = curry(normalizePosition, true);
  var normalizeBackwards = curry(normalizePosition, false);
  var isBeforeRoot = function(rootNode) {
    return function(elm) {
      return eq$2(rootNode, SugarElement.fromDom(elm.dom.parentNode));
    };
  };
  var getParentBlock$1 = function(rootNode, elm) {
    return contains$2(rootNode, elm) ? closest(elm, function(element) {
      return isTextBlock(element) || isListItem(element);
    }, isBeforeRoot(rootNode)) : Optional.none();
  };
  var placeCaretInEmptyBody = function(editor) {
    var body = editor.getBody();
    var node = body.firstChild && editor.dom.isBlock(body.firstChild) ? body.firstChild : body;
    editor.selection.setCursorLocation(node, 0);
  };
  var paddEmptyBody = function(editor) {
    if (editor.dom.isEmpty(editor.getBody())) {
      editor.setContent("");
      placeCaretInEmptyBody(editor);
    }
  };
  var willDeleteLastPositionInElement = function(forward, fromPos, elm) {
    return lift2(firstPositionIn(elm), lastPositionIn(elm), function(firstPos, lastPos) {
      var normalizedFirstPos = normalizePosition(true, firstPos);
      var normalizedLastPos = normalizePosition(false, lastPos);
      var normalizedFromPos = normalizePosition(false, fromPos);
      if (forward) {
        return nextPosition(elm, normalizedFromPos).exists(function(nextPos) {
          return nextPos.isEqual(normalizedLastPos) && fromPos.isEqual(normalizedFirstPos);
        });
      } else {
        return prevPosition(elm, normalizedFromPos).exists(function(prevPos) {
          return prevPos.isEqual(normalizedFirstPos) && fromPos.isEqual(normalizedLastPos);
        });
      }
    }).getOr(true);
  };
  var blockPosition = function(block, position) {
    return {
      block,
      position
    };
  };
  var blockBoundary = function(from2, to2) {
    return {
      from: from2,
      to: to2
    };
  };
  var getBlockPosition = function(rootNode, pos) {
    var rootElm = SugarElement.fromDom(rootNode);
    var containerElm = SugarElement.fromDom(pos.container());
    return getParentBlock$1(rootElm, containerElm).map(function(block) {
      return blockPosition(block, pos);
    });
  };
  var isDifferentBlocks = function(blockBoundary2) {
    return eq$2(blockBoundary2.from.block, blockBoundary2.to.block) === false;
  };
  var hasSameParent = function(blockBoundary2) {
    return parent(blockBoundary2.from.block).bind(function(parent1) {
      return parent(blockBoundary2.to.block).filter(function(parent2) {
        return eq$2(parent1, parent2);
      });
    }).isSome();
  };
  var isEditable = function(blockBoundary2) {
    return isContentEditableFalse(blockBoundary2.from.block.dom) === false && isContentEditableFalse(blockBoundary2.to.block.dom) === false;
  };
  var skipLastBr = function(rootNode, forward, blockPosition2) {
    if (isBr(blockPosition2.position.getNode()) && isEmpty(blockPosition2.block) === false) {
      return positionIn(false, blockPosition2.block.dom).bind(function(lastPositionInBlock) {
        if (lastPositionInBlock.isEqual(blockPosition2.position)) {
          return fromPosition(forward, rootNode, lastPositionInBlock).bind(function(to2) {
            return getBlockPosition(rootNode, to2);
          });
        } else {
          return Optional.some(blockPosition2);
        }
      }).getOr(blockPosition2);
    } else {
      return blockPosition2;
    }
  };
  var readFromRange = function(rootNode, forward, rng) {
    var fromBlockPos = getBlockPosition(rootNode, CaretPosition.fromRangeStart(rng));
    var toBlockPos = fromBlockPos.bind(function(blockPos) {
      return fromPosition(forward, rootNode, blockPos.position).bind(function(to2) {
        return getBlockPosition(rootNode, to2).map(function(blockPos2) {
          return skipLastBr(rootNode, forward, blockPos2);
        });
      });
    });
    return lift2(fromBlockPos, toBlockPos, blockBoundary).filter(function(blockBoundary2) {
      return isDifferentBlocks(blockBoundary2) && hasSameParent(blockBoundary2) && isEditable(blockBoundary2);
    });
  };
  var read$3 = function(rootNode, forward, rng) {
    return rng.collapsed ? readFromRange(rootNode, forward, rng) : Optional.none();
  };
  var getChildrenUntilBlockBoundary = function(block) {
    var children$1 = children(block);
    return findIndex(children$1, isBlock).fold(function() {
      return children$1;
    }, function(index) {
      return children$1.slice(0, index);
    });
  };
  var extractChildren = function(block) {
    var children2 = getChildrenUntilBlockBoundary(block);
    each(children2, remove);
    return children2;
  };
  var removeEmptyRoot = function(rootNode, block) {
    var parents2 = parentsAndSelf(block, rootNode);
    return find(parents2.reverse(), function(element) {
      return isEmpty(element);
    }).each(remove);
  };
  var isEmptyBefore = function(el) {
    return filter(prevSiblings(el), function(el2) {
      return !isEmpty(el2);
    }).length === 0;
  };
  var nestedBlockMerge = function(rootNode, fromBlock, toBlock, insertionPoint) {
    if (isEmpty(toBlock)) {
      fillWithPaddingBr(toBlock);
      return firstPositionIn(toBlock.dom);
    }
    if (isEmptyBefore(insertionPoint) && isEmpty(fromBlock)) {
      before(insertionPoint, SugarElement.fromTag("br"));
    }
    var position = prevPosition(toBlock.dom, CaretPosition.before(insertionPoint.dom));
    each(extractChildren(fromBlock), function(child2) {
      before(insertionPoint, child2);
    });
    removeEmptyRoot(rootNode, fromBlock);
    return position;
  };
  var sidelongBlockMerge = function(rootNode, fromBlock, toBlock) {
    if (isEmpty(toBlock)) {
      remove(toBlock);
      if (isEmpty(fromBlock)) {
        fillWithPaddingBr(fromBlock);
      }
      return firstPositionIn(fromBlock.dom);
    }
    var position = lastPositionIn(toBlock.dom);
    each(extractChildren(fromBlock), function(child2) {
      append(toBlock, child2);
    });
    removeEmptyRoot(rootNode, fromBlock);
    return position;
  };
  var findInsertionPoint = function(toBlock, block) {
    var parentsAndSelf$1 = parentsAndSelf(block, toBlock);
    return Optional.from(parentsAndSelf$1[parentsAndSelf$1.length - 1]);
  };
  var getInsertionPoint = function(fromBlock, toBlock) {
    return contains$2(toBlock, fromBlock) ? findInsertionPoint(toBlock, fromBlock) : Optional.none();
  };
  var trimBr = function(first2, block) {
    positionIn(first2, block.dom).map(function(position) {
      return position.getNode();
    }).map(SugarElement.fromDom).filter(isBr$1).each(remove);
  };
  var mergeBlockInto = function(rootNode, fromBlock, toBlock) {
    trimBr(true, fromBlock);
    trimBr(false, toBlock);
    return getInsertionPoint(fromBlock, toBlock).fold(curry(sidelongBlockMerge, rootNode, fromBlock, toBlock), curry(nestedBlockMerge, rootNode, fromBlock, toBlock));
  };
  var mergeBlocks = function(rootNode, forward, block1, block2) {
    return forward ? mergeBlockInto(rootNode, block2, block1) : mergeBlockInto(rootNode, block1, block2);
  };
  var backspaceDelete$1 = function(editor, forward) {
    var rootNode = SugarElement.fromDom(editor.getBody());
    var position = read$3(rootNode.dom, forward, editor.selection.getRng()).bind(function(blockBoundary2) {
      return mergeBlocks(rootNode, forward, blockBoundary2.from.block, blockBoundary2.to.block);
    });
    position.each(function(pos) {
      editor.selection.setRng(pos.toRange());
    });
    return position.isSome();
  };
  var deleteRangeMergeBlocks = function(rootNode, selection) {
    var rng = selection.getRng();
    return lift2(getParentBlock$1(rootNode, SugarElement.fromDom(rng.startContainer)), getParentBlock$1(rootNode, SugarElement.fromDom(rng.endContainer)), function(block1, block2) {
      if (eq$2(block1, block2) === false) {
        rng.deleteContents();
        mergeBlocks(rootNode, true, block1, block2).each(function(pos) {
          selection.setRng(pos.toRange());
        });
        return true;
      } else {
        return false;
      }
    }).getOr(false);
  };
  var isRawNodeInTable = function(root, rawNode) {
    var node = SugarElement.fromDom(rawNode);
    var isRoot = curry(eq$2, root);
    return ancestor(node, isTableCell$1, isRoot).isSome();
  };
  var isSelectionInTable = function(root, rng) {
    return isRawNodeInTable(root, rng.startContainer) || isRawNodeInTable(root, rng.endContainer);
  };
  var isEverythingSelected = function(root, rng) {
    var noPrevious = prevPosition(root.dom, CaretPosition.fromRangeStart(rng)).isNone();
    var noNext = nextPosition(root.dom, CaretPosition.fromRangeEnd(rng)).isNone();
    return !isSelectionInTable(root, rng) && noPrevious && noNext;
  };
  var emptyEditor = function(editor) {
    editor.setContent("");
    editor.selection.setCursorLocation();
    return true;
  };
  var deleteRange$1 = function(editor) {
    var rootNode = SugarElement.fromDom(editor.getBody());
    var rng = editor.selection.getRng();
    return isEverythingSelected(rootNode, rng) ? emptyEditor(editor) : deleteRangeMergeBlocks(rootNode, editor.selection);
  };
  var backspaceDelete$2 = function(editor, _forward) {
    return editor.selection.isCollapsed() ? false : deleteRange$1(editor);
  };
  var isContentEditableTrue$2 = isContentEditableTrue;
  var isContentEditableFalse$7 = isContentEditableFalse;
  var showCaret = function(direction, editor, node, before2, scrollIntoView) {
    return Optional.from(editor._selectionOverrides.showCaret(direction, node, before2, scrollIntoView));
  };
  var getNodeRange = function(node) {
    var rng = node.ownerDocument.createRange();
    rng.selectNode(node);
    return rng;
  };
  var selectNode = function(editor, node) {
    var e = editor.fire("BeforeObjectSelected", { target: node });
    if (e.isDefaultPrevented()) {
      return Optional.none();
    }
    return Optional.some(getNodeRange(node));
  };
  var renderCaretAtRange = function(editor, range2, scrollIntoView) {
    var normalizedRange = normalizeRange(1, editor.getBody(), range2);
    var caretPosition = CaretPosition.fromRangeStart(normalizedRange);
    var caretPositionNode = caretPosition.getNode();
    if (isInlineFakeCaretTarget(caretPositionNode)) {
      return showCaret(1, editor, caretPositionNode, !caretPosition.isAtEnd(), false);
    }
    var caretPositionBeforeNode = caretPosition.getNode(true);
    if (isInlineFakeCaretTarget(caretPositionBeforeNode)) {
      return showCaret(1, editor, caretPositionBeforeNode, false, false);
    }
    var ceRoot = editor.dom.getParent(caretPosition.getNode(), function(node) {
      return isContentEditableFalse$7(node) || isContentEditableTrue$2(node);
    });
    if (isInlineFakeCaretTarget(ceRoot)) {
      return showCaret(1, editor, ceRoot, false, scrollIntoView);
    }
    return Optional.none();
  };
  var renderRangeCaret = function(editor, range2, scrollIntoView) {
    return range2.collapsed ? renderCaretAtRange(editor, range2, scrollIntoView).getOr(range2) : range2;
  };
  var isBeforeBoundary = function(pos) {
    return isBeforeContentEditableFalse(pos) || isBeforeMedia(pos);
  };
  var isAfterBoundary = function(pos) {
    return isAfterContentEditableFalse(pos) || isAfterMedia(pos);
  };
  var trimEmptyTextNode$1 = function(dom2, node) {
    if (isText$1(node) && node.data.length === 0) {
      dom2.remove(node);
    }
  };
  var deleteContentAndShowCaret = function(editor, range2, node, direction, forward, peekCaretPosition) {
    showCaret(direction, editor, peekCaretPosition.getNode(!forward), forward, true).each(function(caretRange) {
      if (range2.collapsed) {
        var deleteRange2 = range2.cloneRange();
        if (forward) {
          deleteRange2.setEnd(caretRange.startContainer, caretRange.startOffset);
        } else {
          deleteRange2.setStart(caretRange.endContainer, caretRange.endOffset);
        }
        deleteRange2.deleteContents();
      } else {
        range2.deleteContents();
      }
      editor.selection.setRng(caretRange);
    });
    trimEmptyTextNode$1(editor.dom, node);
    return true;
  };
  var deleteBoundaryText = function(editor, forward) {
    var range2 = editor.selection.getRng();
    if (!isText$1(range2.commonAncestorContainer)) {
      return false;
    }
    var direction = forward ? HDirection.Forwards : HDirection.Backwards;
    var caretWalker = CaretWalker(editor.getBody());
    var getNextPosFn = curry(getVisualCaretPosition, forward ? caretWalker.next : caretWalker.prev);
    var isBeforeFn = forward ? isBeforeBoundary : isAfterBoundary;
    var caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range2);
    var nextCaretPosition = normalizePosition(forward, getNextPosFn(caretPosition));
    if (!nextCaretPosition || !isMoveInsideSameBlock(caretPosition, nextCaretPosition)) {
      return false;
    } else if (isBeforeFn(nextCaretPosition)) {
      return deleteContentAndShowCaret(editor, range2, caretPosition.getNode(), direction, forward, nextCaretPosition);
    }
    var peekCaretPosition = getNextPosFn(nextCaretPosition);
    if (peekCaretPosition && isBeforeFn(peekCaretPosition)) {
      if (isMoveInsideSameBlock(nextCaretPosition, peekCaretPosition)) {
        return deleteContentAndShowCaret(editor, range2, caretPosition.getNode(), direction, forward, peekCaretPosition);
      }
    }
    return false;
  };
  var backspaceDelete$3 = function(editor, forward) {
    return deleteBoundaryText(editor, forward);
  };
  var isCompoundElement = function(node) {
    return isTableCell$1(SugarElement.fromDom(node)) || isListItem(SugarElement.fromDom(node));
  };
  var DeleteAction = Adt.generate([
    { remove: ["element"] },
    { moveToElement: ["element"] },
    { moveToPosition: ["position"] }
  ]);
  var isAtContentEditableBlockCaret = function(forward, from2) {
    var elm = from2.getNode(forward === false);
    var caretLocation = forward ? "after" : "before";
    return isElement$1(elm) && elm.getAttribute("data-mce-caret") === caretLocation;
  };
  var isDeleteFromCefDifferentBlocks = function(root, forward, from2, to2) {
    var inSameBlock = function(elm) {
      return isInline(SugarElement.fromDom(elm)) && !isInSameBlock(from2, to2, root);
    };
    return getRelativeCefElm(!forward, from2).fold(function() {
      return getRelativeCefElm(forward, to2).fold(never, inSameBlock);
    }, inSameBlock);
  };
  var deleteEmptyBlockOrMoveToCef = function(root, forward, from2, to2) {
    var toCefElm = to2.getNode(forward === false);
    return getParentBlock$1(SugarElement.fromDom(root), SugarElement.fromDom(from2.getNode())).map(function(blockElm) {
      return isEmpty(blockElm) ? DeleteAction.remove(blockElm.dom) : DeleteAction.moveToElement(toCefElm);
    }).orThunk(function() {
      return Optional.some(DeleteAction.moveToElement(toCefElm));
    });
  };
  var findCefPosition = function(root, forward, from2) {
    return fromPosition(forward, root, from2).bind(function(to2) {
      if (isCompoundElement(to2.getNode())) {
        return Optional.none();
      } else if (isDeleteFromCefDifferentBlocks(root, forward, from2, to2)) {
        return Optional.none();
      } else if (forward && isContentEditableFalse(to2.getNode())) {
        return deleteEmptyBlockOrMoveToCef(root, forward, from2, to2);
      } else if (forward === false && isContentEditableFalse(to2.getNode(true))) {
        return deleteEmptyBlockOrMoveToCef(root, forward, from2, to2);
      } else if (forward && isAfterContentEditableFalse(from2)) {
        return Optional.some(DeleteAction.moveToPosition(to2));
      } else if (forward === false && isBeforeContentEditableFalse(from2)) {
        return Optional.some(DeleteAction.moveToPosition(to2));
      } else {
        return Optional.none();
      }
    });
  };
  var getContentEditableBlockAction = function(forward, elm) {
    if (forward && isContentEditableFalse(elm.nextSibling)) {
      return Optional.some(DeleteAction.moveToElement(elm.nextSibling));
    } else if (forward === false && isContentEditableFalse(elm.previousSibling)) {
      return Optional.some(DeleteAction.moveToElement(elm.previousSibling));
    } else {
      return Optional.none();
    }
  };
  var skipMoveToActionFromInlineCefToContent = function(root, from2, deleteAction2) {
    return deleteAction2.fold(function(elm) {
      return Optional.some(DeleteAction.remove(elm));
    }, function(elm) {
      return Optional.some(DeleteAction.moveToElement(elm));
    }, function(to2) {
      if (isInSameBlock(from2, to2, root)) {
        return Optional.none();
      } else {
        return Optional.some(DeleteAction.moveToPosition(to2));
      }
    });
  };
  var getContentEditableAction = function(root, forward, from2) {
    if (isAtContentEditableBlockCaret(forward, from2)) {
      return getContentEditableBlockAction(forward, from2.getNode(forward === false)).fold(function() {
        return findCefPosition(root, forward, from2);
      }, Optional.some);
    } else {
      return findCefPosition(root, forward, from2).bind(function(deleteAction2) {
        return skipMoveToActionFromInlineCefToContent(root, from2, deleteAction2);
      });
    }
  };
  var read$4 = function(root, forward, rng) {
    var normalizedRange = normalizeRange(forward ? 1 : -1, root, rng);
    var from2 = CaretPosition.fromRangeStart(normalizedRange);
    var rootElement = SugarElement.fromDom(root);
    if (forward === false && isAfterContentEditableFalse(from2)) {
      return Optional.some(DeleteAction.remove(from2.getNode(true)));
    } else if (forward && isBeforeContentEditableFalse(from2)) {
      return Optional.some(DeleteAction.remove(from2.getNode()));
    } else if (forward === false && isBeforeContentEditableFalse(from2) && isAfterBr(rootElement, from2)) {
      return findPreviousBr(rootElement, from2).map(function(br) {
        return DeleteAction.remove(br.getNode());
      });
    } else if (forward && isAfterContentEditableFalse(from2) && isBeforeBr(rootElement, from2)) {
      return findNextBr(rootElement, from2).map(function(br) {
        return DeleteAction.remove(br.getNode());
      });
    } else {
      return getContentEditableAction(root, forward, from2);
    }
  };
  var deleteElement$1 = function(editor, forward) {
    return function(element) {
      editor._selectionOverrides.hideFakeCaret();
      deleteElement(editor, forward, SugarElement.fromDom(element));
      return true;
    };
  };
  var moveToElement = function(editor, forward) {
    return function(element) {
      var pos = forward ? CaretPosition.before(element) : CaretPosition.after(element);
      editor.selection.setRng(pos.toRange());
      return true;
    };
  };
  var moveToPosition = function(editor) {
    return function(pos) {
      editor.selection.setRng(pos.toRange());
      return true;
    };
  };
  var getAncestorCe = function(editor, node) {
    return Optional.from(getContentEditableRoot(editor.getBody(), node));
  };
  var backspaceDeleteCaret = function(editor, forward) {
    var selectedNode = editor.selection.getNode();
    return getAncestorCe(editor, selectedNode).filter(isContentEditableFalse).fold(function() {
      return read$4(editor.getBody(), forward, editor.selection.getRng()).exists(function(deleteAction2) {
        return deleteAction2.fold(deleteElement$1(editor, forward), moveToElement(editor, forward), moveToPosition(editor));
      });
    }, always);
  };
  var deleteOffscreenSelection = function(rootElement) {
    each(descendants$1(rootElement, ".mce-offscreen-selection"), remove);
  };
  var backspaceDeleteRange = function(editor, forward) {
    var selectedNode = editor.selection.getNode();
    if (isContentEditableFalse(selectedNode)) {
      var hasCefAncestor = getAncestorCe(editor, selectedNode.parentNode).filter(isContentEditableFalse);
      return hasCefAncestor.fold(function() {
        deleteOffscreenSelection(SugarElement.fromDom(editor.getBody()));
        deleteElement(editor, forward, SugarElement.fromDom(editor.selection.getNode()));
        paddEmptyBody(editor);
        return true;
      }, always);
    }
    return false;
  };
  var paddEmptyElement = function(editor) {
    var dom2 = editor.dom, selection = editor.selection;
    var ceRoot = getContentEditableRoot(editor.getBody(), selection.getNode());
    if (isContentEditableTrue(ceRoot) && dom2.isBlock(ceRoot) && dom2.isEmpty(ceRoot)) {
      var br = dom2.create("br", { "data-mce-bogus": "1" });
      dom2.setHTML(ceRoot, "");
      ceRoot.appendChild(br);
      selection.setRng(CaretPosition.before(br).toRange());
    }
    return true;
  };
  var backspaceDelete$4 = function(editor, forward) {
    if (editor.selection.isCollapsed()) {
      return backspaceDeleteCaret(editor, forward);
    } else {
      return backspaceDeleteRange(editor, forward);
    }
  };
  var deleteCaret$1 = function(editor, forward) {
    var fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());
    return fromPosition(forward, editor.getBody(), fromPos).filter(function(pos) {
      return forward ? isBeforeImageBlock(pos) : isAfterImageBlock(pos);
    }).bind(function(pos) {
      return Optional.from(getChildNodeAtRelativeOffset(forward ? 0 : -1, pos));
    }).exists(function(elm) {
      editor.selection.select(elm);
      return true;
    });
  };
  var backspaceDelete$5 = function(editor, forward) {
    return editor.selection.isCollapsed() ? deleteCaret$1(editor, forward) : false;
  };
  var isText$8 = isText$1;
  var startsWithCaretContainer$1 = function(node) {
    return isText$8(node) && node.data[0] === ZWSP;
  };
  var endsWithCaretContainer$1 = function(node) {
    return isText$8(node) && node.data[node.data.length - 1] === ZWSP;
  };
  var createZwsp = function(node) {
    return node.ownerDocument.createTextNode(ZWSP);
  };
  var insertBefore$1 = function(node) {
    if (isText$8(node.previousSibling)) {
      if (endsWithCaretContainer$1(node.previousSibling)) {
        return node.previousSibling;
      } else {
        node.previousSibling.appendData(ZWSP);
        return node.previousSibling;
      }
    } else if (isText$8(node)) {
      if (startsWithCaretContainer$1(node)) {
        return node;
      } else {
        node.insertData(0, ZWSP);
        return node;
      }
    } else {
      var newNode = createZwsp(node);
      node.parentNode.insertBefore(newNode, node);
      return newNode;
    }
  };
  var insertAfter$1 = function(node) {
    if (isText$8(node.nextSibling)) {
      if (startsWithCaretContainer$1(node.nextSibling)) {
        return node.nextSibling;
      } else {
        node.nextSibling.insertData(0, ZWSP);
        return node.nextSibling;
      }
    } else if (isText$8(node)) {
      if (endsWithCaretContainer$1(node)) {
        return node;
      } else {
        node.appendData(ZWSP);
        return node;
      }
    } else {
      var newNode = createZwsp(node);
      if (node.nextSibling) {
        node.parentNode.insertBefore(newNode, node.nextSibling);
      } else {
        node.parentNode.appendChild(newNode);
      }
      return newNode;
    }
  };
  var insertInline$1 = function(before2, node) {
    return before2 ? insertBefore$1(node) : insertAfter$1(node);
  };
  var insertInlineBefore = curry(insertInline$1, true);
  var insertInlineAfter = curry(insertInline$1, false);
  var insertInlinePos = function(pos, before2) {
    if (isText$1(pos.container())) {
      return insertInline$1(before2, pos.container());
    } else {
      return insertInline$1(before2, pos.getNode());
    }
  };
  var isPosCaretContainer = function(pos, caret) {
    var caretNode = caret.get();
    return caretNode && pos.container() === caretNode && isCaretContainerInline(caretNode);
  };
  var renderCaret = function(caret, location) {
    return location.fold(function(element) {
      remove$5(caret.get());
      var text = insertInlineBefore(element);
      caret.set(text);
      return Optional.some(CaretPosition(text, text.length - 1));
    }, function(element) {
      return firstPositionIn(element).map(function(pos) {
        if (!isPosCaretContainer(pos, caret)) {
          remove$5(caret.get());
          var text = insertInlinePos(pos, true);
          caret.set(text);
          return CaretPosition(text, 1);
        } else {
          return CaretPosition(caret.get(), 1);
        }
      });
    }, function(element) {
      return lastPositionIn(element).map(function(pos) {
        if (!isPosCaretContainer(pos, caret)) {
          remove$5(caret.get());
          var text = insertInlinePos(pos, false);
          caret.set(text);
          return CaretPosition(text, text.length - 1);
        } else {
          return CaretPosition(caret.get(), caret.get().length - 1);
        }
      });
    }, function(element) {
      remove$5(caret.get());
      var text = insertInlineAfter(element);
      caret.set(text);
      return Optional.some(CaretPosition(text, 1));
    });
  };
  var evaluateUntil = function(fns, args) {
    for (var i = 0; i < fns.length; i++) {
      var result = fns[i].apply(null, args);
      if (result.isSome()) {
        return result;
      }
    }
    return Optional.none();
  };
  var Location = Adt.generate([
    { before: ["element"] },
    { start: ["element"] },
    { end: ["element"] },
    { after: ["element"] }
  ]);
  var rescope = function(rootNode, node) {
    var parentBlock = getParentBlock(node, rootNode);
    return parentBlock ? parentBlock : rootNode;
  };
  var before$4 = function(isInlineTarget2, rootNode, pos) {
    var nPos = normalizeForwards(pos);
    var scope = rescope(rootNode, nPos.container());
    return findRootInline(isInlineTarget2, scope, nPos).fold(function() {
      return nextPosition(scope, nPos).bind(curry(findRootInline, isInlineTarget2, scope)).map(function(inline) {
        return Location.before(inline);
      });
    }, Optional.none);
  };
  var isNotInsideFormatCaretContainer = function(rootNode, elm) {
    return getParentCaretContainer(rootNode, elm) === null;
  };
  var findInsideRootInline = function(isInlineTarget2, rootNode, pos) {
    return findRootInline(isInlineTarget2, rootNode, pos).filter(curry(isNotInsideFormatCaretContainer, rootNode));
  };
  var start = function(isInlineTarget2, rootNode, pos) {
    var nPos = normalizeBackwards(pos);
    return findInsideRootInline(isInlineTarget2, rootNode, nPos).bind(function(inline) {
      var prevPos = prevPosition(inline, nPos);
      return prevPos.isNone() ? Optional.some(Location.start(inline)) : Optional.none();
    });
  };
  var end = function(isInlineTarget2, rootNode, pos) {
    var nPos = normalizeForwards(pos);
    return findInsideRootInline(isInlineTarget2, rootNode, nPos).bind(function(inline) {
      var nextPos = nextPosition(inline, nPos);
      return nextPos.isNone() ? Optional.some(Location.end(inline)) : Optional.none();
    });
  };
  var after$3 = function(isInlineTarget2, rootNode, pos) {
    var nPos = normalizeBackwards(pos);
    var scope = rescope(rootNode, nPos.container());
    return findRootInline(isInlineTarget2, scope, nPos).fold(function() {
      return prevPosition(scope, nPos).bind(curry(findRootInline, isInlineTarget2, scope)).map(function(inline) {
        return Location.after(inline);
      });
    }, Optional.none);
  };
  var isValidLocation = function(location) {
    return isRtl$1(getElement(location)) === false;
  };
  var readLocation = function(isInlineTarget2, rootNode, pos) {
    var location = evaluateUntil([
      before$4,
      start,
      end,
      after$3
    ], [
      isInlineTarget2,
      rootNode,
      pos
    ]);
    return location.filter(isValidLocation);
  };
  var getElement = function(location) {
    return location.fold(identity, identity, identity, identity);
  };
  var getName = function(location) {
    return location.fold(constant("before"), constant("start"), constant("end"), constant("after"));
  };
  var outside = function(location) {
    return location.fold(Location.before, Location.before, Location.after, Location.after);
  };
  var inside = function(location) {
    return location.fold(Location.start, Location.start, Location.end, Location.end);
  };
  var isEq$5 = function(location1, location2) {
    return getName(location1) === getName(location2) && getElement(location1) === getElement(location2);
  };
  var betweenInlines = function(forward, isInlineTarget2, rootNode, from2, to2, location) {
    return lift2(findRootInline(isInlineTarget2, rootNode, from2), findRootInline(isInlineTarget2, rootNode, to2), function(fromInline, toInline) {
      if (fromInline !== toInline && hasSameParentBlock(rootNode, fromInline, toInline)) {
        return Location.after(forward ? fromInline : toInline);
      } else {
        return location;
      }
    }).getOr(location);
  };
  var skipNoMovement = function(fromLocation, toLocation) {
    return fromLocation.fold(always, function(fromLocation2) {
      return !isEq$5(fromLocation2, toLocation);
    });
  };
  var findLocationTraverse = function(forward, isInlineTarget2, rootNode, fromLocation, pos) {
    var from2 = normalizePosition(forward, pos);
    var to2 = fromPosition(forward, rootNode, from2).map(curry(normalizePosition, forward));
    var location = to2.fold(function() {
      return fromLocation.map(outside);
    }, function(to3) {
      return readLocation(isInlineTarget2, rootNode, to3).map(curry(betweenInlines, forward, isInlineTarget2, rootNode, from2, to3)).filter(curry(skipNoMovement, fromLocation));
    });
    return location.filter(isValidLocation);
  };
  var findLocationSimple = function(forward, location) {
    if (forward) {
      return location.fold(compose(Optional.some, Location.start), Optional.none, compose(Optional.some, Location.after), Optional.none);
    } else {
      return location.fold(Optional.none, compose(Optional.some, Location.before), Optional.none, compose(Optional.some, Location.end));
    }
  };
  var findLocation = function(forward, isInlineTarget2, rootNode, pos) {
    var from2 = normalizePosition(forward, pos);
    var fromLocation = readLocation(isInlineTarget2, rootNode, from2);
    return readLocation(isInlineTarget2, rootNode, from2).bind(curry(findLocationSimple, forward)).orThunk(function() {
      return findLocationTraverse(forward, isInlineTarget2, rootNode, fromLocation, pos);
    });
  };
  curry(findLocation, false);
  curry(findLocation, true);
  var hasSelectionModifyApi = function(editor) {
    return isFunction2(editor.selection.getSel().modify);
  };
  var moveRel = function(forward, selection, pos) {
    var delta = forward ? 1 : -1;
    selection.setRng(CaretPosition(pos.container(), pos.offset() + delta).toRange());
    selection.getSel().modify("move", forward ? "forward" : "backward", "word");
    return true;
  };
  var moveByWord = function(forward, editor) {
    var rng = editor.selection.getRng();
    var pos = forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);
    if (!hasSelectionModifyApi(editor)) {
      return false;
    } else if (forward && isBeforeInline(pos)) {
      return moveRel(true, editor.selection, pos);
    } else if (!forward && isAfterInline(pos)) {
      return moveRel(false, editor.selection, pos);
    } else {
      return false;
    }
  };
  var BreakType;
  (function(BreakType2) {
    BreakType2[BreakType2["Br"] = 0] = "Br";
    BreakType2[BreakType2["Block"] = 1] = "Block";
    BreakType2[BreakType2["Wrap"] = 2] = "Wrap";
    BreakType2[BreakType2["Eol"] = 3] = "Eol";
  })(BreakType || (BreakType = {}));
  var flip = function(direction, positions) {
    return direction === HDirection.Backwards ? reverse(positions) : positions;
  };
  var walk$3 = function(direction, caretWalker, pos) {
    return direction === HDirection.Forwards ? caretWalker.next(pos) : caretWalker.prev(pos);
  };
  var getBreakType = function(scope, direction, currentPos, nextPos) {
    if (isBr(nextPos.getNode(direction === HDirection.Forwards))) {
      return BreakType.Br;
    } else if (isInSameBlock(currentPos, nextPos) === false) {
      return BreakType.Block;
    } else {
      return BreakType.Wrap;
    }
  };
  var getPositionsUntil = function(predicate, direction, scope, start2) {
    var caretWalker = CaretWalker(scope);
    var currentPos = start2, nextPos;
    var positions = [];
    while (currentPos) {
      nextPos = walk$3(direction, caretWalker, currentPos);
      if (!nextPos) {
        break;
      }
      if (isBr(nextPos.getNode(false))) {
        if (direction === HDirection.Forwards) {
          return {
            positions: flip(direction, positions).concat([nextPos]),
            breakType: BreakType.Br,
            breakAt: Optional.some(nextPos)
          };
        } else {
          return {
            positions: flip(direction, positions),
            breakType: BreakType.Br,
            breakAt: Optional.some(nextPos)
          };
        }
      }
      if (!nextPos.isVisible()) {
        currentPos = nextPos;
        continue;
      }
      if (predicate(currentPos, nextPos)) {
        var breakType = getBreakType(scope, direction, currentPos, nextPos);
        return {
          positions: flip(direction, positions),
          breakType,
          breakAt: Optional.some(nextPos)
        };
      }
      positions.push(nextPos);
      currentPos = nextPos;
    }
    return {
      positions: flip(direction, positions),
      breakType: BreakType.Eol,
      breakAt: Optional.none()
    };
  };
  var getAdjacentLinePositions = function(direction, getPositionsUntilBreak, scope, start2) {
    return getPositionsUntilBreak(scope, start2).breakAt.map(function(pos) {
      var positions = getPositionsUntilBreak(scope, pos).positions;
      return direction === HDirection.Backwards ? positions.concat(pos) : [pos].concat(positions);
    }).getOr([]);
  };
  var findClosestHorizontalPositionFromPoint = function(positions, x2) {
    return foldl(positions, function(acc, newPos) {
      return acc.fold(function() {
        return Optional.some(newPos);
      }, function(lastPos) {
        return lift2(head(lastPos.getClientRects()), head(newPos.getClientRects()), function(lastRect, newRect) {
          var lastDist = Math.abs(x2 - lastRect.left);
          var newDist = Math.abs(x2 - newRect.left);
          return newDist <= lastDist ? newPos : lastPos;
        }).or(acc);
      });
    }, Optional.none());
  };
  var findClosestHorizontalPosition = function(positions, pos) {
    return head(pos.getClientRects()).bind(function(targetRect) {
      return findClosestHorizontalPositionFromPoint(positions, targetRect.left);
    });
  };
  var getPositionsUntilPreviousLine = curry(getPositionsUntil, CaretPosition.isAbove, -1);
  var getPositionsUntilNextLine = curry(getPositionsUntil, CaretPosition.isBelow, 1);
  var isAtFirstLine = function(scope, pos) {
    return getPositionsUntilPreviousLine(scope, pos).breakAt.isNone();
  };
  var isAtLastLine = function(scope, pos) {
    return getPositionsUntilNextLine(scope, pos).breakAt.isNone();
  };
  var getPositionsAbove = curry(getAdjacentLinePositions, -1, getPositionsUntilPreviousLine);
  var getPositionsBelow = curry(getAdjacentLinePositions, 1, getPositionsUntilNextLine);
  var getFirstLinePositions = function(scope) {
    return firstPositionIn(scope).map(function(pos) {
      return [pos].concat(getPositionsUntilNextLine(scope, pos).positions);
    }).getOr([]);
  };
  var getLastLinePositions = function(scope) {
    return lastPositionIn(scope).map(function(pos) {
      return getPositionsUntilPreviousLine(scope, pos).positions.concat(pos);
    }).getOr([]);
  };
  var getNodeClientRects = function(node) {
    var toArrayWithNode = function(clientRects) {
      return map(clientRects, function(clientRect) {
        clientRect = clone$2(clientRect);
        clientRect.node = node;
        return clientRect;
      });
    };
    if (isElement$1(node)) {
      return toArrayWithNode(node.getClientRects());
    }
    if (isText$1(node)) {
      var rng = node.ownerDocument.createRange();
      rng.setStart(node, 0);
      rng.setEnd(node, node.data.length);
      return toArrayWithNode(rng.getClientRects());
    }
  };
  var getClientRects = function(nodes) {
    return bind(nodes, getNodeClientRects);
  };
  var VDirection;
  (function(VDirection2) {
    VDirection2[VDirection2["Up"] = -1] = "Up";
    VDirection2[VDirection2["Down"] = 1] = "Down";
  })(VDirection || (VDirection = {}));
  var findUntil$1 = function(direction, root, predicateFn, node) {
    while (node = findNode(node, direction, isEditableCaretCandidate, root)) {
      if (predicateFn(node)) {
        return;
      }
    }
  };
  var walkUntil = function(direction, isAboveFn, isBeflowFn, root, predicateFn, caretPosition) {
    var line = 0;
    var result = [];
    var add2 = function(node2) {
      var i, clientRect, clientRects;
      clientRects = getClientRects([node2]);
      if (direction === -1) {
        clientRects = clientRects.reverse();
      }
      for (i = 0; i < clientRects.length; i++) {
        clientRect = clientRects[i];
        if (isBeflowFn(clientRect, targetClientRect)) {
          continue;
        }
        if (result.length > 0 && isAboveFn(clientRect, last$1(result))) {
          line++;
        }
        clientRect.line = line;
        if (predicateFn(clientRect)) {
          return true;
        }
        result.push(clientRect);
      }
    };
    var targetClientRect = last$1(caretPosition.getClientRects());
    if (!targetClientRect) {
      return result;
    }
    var node = caretPosition.getNode();
    add2(node);
    findUntil$1(direction, root, add2, node);
    return result;
  };
  var aboveLineNumber = function(lineNumber, clientRect) {
    return clientRect.line > lineNumber;
  };
  var isLineNumber = function(lineNumber, clientRect) {
    return clientRect.line === lineNumber;
  };
  var upUntil = curry(walkUntil, VDirection.Up, isAbove, isBelow);
  var downUntil = curry(walkUntil, VDirection.Down, isBelow, isAbove);
  var positionsUntil = function(direction, root, predicateFn, node) {
    var caretWalker = CaretWalker(root);
    var walkFn, isBelowFn, isAboveFn, caretPosition;
    var result = [];
    var line = 0, clientRect;
    var getClientRect = function(caretPosition2) {
      if (direction === 1) {
        return last$1(caretPosition2.getClientRects());
      }
      return last$1(caretPosition2.getClientRects());
    };
    if (direction === 1) {
      walkFn = caretWalker.next;
      isBelowFn = isBelow;
      isAboveFn = isAbove;
      caretPosition = CaretPosition.after(node);
    } else {
      walkFn = caretWalker.prev;
      isBelowFn = isAbove;
      isAboveFn = isBelow;
      caretPosition = CaretPosition.before(node);
    }
    var targetClientRect = getClientRect(caretPosition);
    do {
      if (!caretPosition.isVisible()) {
        continue;
      }
      clientRect = getClientRect(caretPosition);
      if (isAboveFn(clientRect, targetClientRect)) {
        continue;
      }
      if (result.length > 0 && isBelowFn(clientRect, last$1(result))) {
        line++;
      }
      clientRect = clone$2(clientRect);
      clientRect.position = caretPosition;
      clientRect.line = line;
      if (predicateFn(clientRect)) {
        return result;
      }
      result.push(clientRect);
    } while (caretPosition = walkFn(caretPosition));
    return result;
  };
  var isAboveLine = function(lineNumber) {
    return function(clientRect) {
      return aboveLineNumber(lineNumber, clientRect);
    };
  };
  var isLine = function(lineNumber) {
    return function(clientRect) {
      return isLineNumber(lineNumber, clientRect);
    };
  };
  var isContentEditableFalse$8 = isContentEditableFalse;
  var findNode$1 = findNode;
  var distanceToRectLeft = function(clientRect, clientX) {
    return Math.abs(clientRect.left - clientX);
  };
  var distanceToRectRight = function(clientRect, clientX) {
    return Math.abs(clientRect.right - clientX);
  };
  var isInsideX = function(clientX, clientRect) {
    return clientX >= clientRect.left && clientX <= clientRect.right;
  };
  var isInsideY = function(clientY, clientRect) {
    return clientY >= clientRect.top && clientY <= clientRect.bottom;
  };
  var findClosestClientRect = function(clientRects, clientX) {
    return reduce(clientRects, function(oldClientRect, clientRect) {
      var oldDistance = Math.min(distanceToRectLeft(oldClientRect, clientX), distanceToRectRight(oldClientRect, clientX));
      var newDistance = Math.min(distanceToRectLeft(clientRect, clientX), distanceToRectRight(clientRect, clientX));
      if (isInsideX(clientX, clientRect)) {
        return clientRect;
      }
      if (isInsideX(clientX, oldClientRect)) {
        return oldClientRect;
      }
      if (newDistance === oldDistance && isContentEditableFalse$8(clientRect.node)) {
        return clientRect;
      }
      if (newDistance < oldDistance) {
        return clientRect;
      }
      return oldClientRect;
    });
  };
  var walkUntil$1 = function(direction, root, predicateFn, startNode, includeChildren) {
    var node = findNode$1(startNode, direction, isEditableCaretCandidate, root, !includeChildren);
    do {
      if (!node || predicateFn(node)) {
        return;
      }
    } while (node = findNode$1(node, direction, isEditableCaretCandidate, root));
  };
  var findLineNodeRects = function(root, targetNodeRect, includeChildren) {
    if (includeChildren === void 0) {
      includeChildren = true;
    }
    var clientRects = [];
    var collect = function(checkPosFn, node) {
      var lineRects = filter(getClientRects([node]), function(clientRect) {
        return !checkPosFn(clientRect, targetNodeRect);
      });
      clientRects = clientRects.concat(lineRects);
      return lineRects.length === 0;
    };
    clientRects.push(targetNodeRect);
    walkUntil$1(VDirection.Up, root, curry(collect, isAbove), targetNodeRect.node, includeChildren);
    walkUntil$1(VDirection.Down, root, curry(collect, isBelow), targetNodeRect.node, includeChildren);
    return clientRects;
  };
  var getFakeCaretTargets = function(root) {
    return filter(from$1(root.getElementsByTagName("*")), isFakeCaretTarget);
  };
  var caretInfo = function(clientRect, clientX) {
    return {
      node: clientRect.node,
      before: distanceToRectLeft(clientRect, clientX) < distanceToRectRight(clientRect, clientX)
    };
  };
  var closestFakeCaret = function(root, clientX, clientY) {
    var fakeTargetNodeRects = getClientRects(getFakeCaretTargets(root));
    var targetNodeRects = filter(fakeTargetNodeRects, curry(isInsideY, clientY));
    var closestNodeRect = findClosestClientRect(targetNodeRects, clientX);
    if (closestNodeRect) {
      var includeChildren = !isTable(closestNodeRect.node) && !isMedia(closestNodeRect.node);
      closestNodeRect = findClosestClientRect(findLineNodeRects(root, closestNodeRect, includeChildren), clientX);
      if (closestNodeRect && isFakeCaretTarget(closestNodeRect.node)) {
        return caretInfo(closestNodeRect, clientX);
      }
    }
    return null;
  };
  var moveToRange = function(editor, rng) {
    editor.selection.setRng(rng);
    scrollRangeIntoView(editor, editor.selection.getRng());
  };
  var renderRangeCaretOpt = function(editor, range2, scrollIntoView) {
    return Optional.some(renderRangeCaret(editor, range2, scrollIntoView));
  };
  var moveHorizontally = function(editor, direction, range2, isBefore, isAfter, isElement2) {
    var forwards = direction === HDirection.Forwards;
    var caretWalker = CaretWalker(editor.getBody());
    var getNextPosFn = curry(getVisualCaretPosition, forwards ? caretWalker.next : caretWalker.prev);
    var isBeforeFn = forwards ? isBefore : isAfter;
    if (!range2.collapsed) {
      var node = getSelectedNode(range2);
      if (isElement2(node)) {
        return showCaret(direction, editor, node, direction === HDirection.Backwards, false);
      }
    }
    var caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range2);
    if (isBeforeFn(caretPosition)) {
      return selectNode(editor, caretPosition.getNode(!forwards));
    }
    var nextCaretPosition = normalizePosition(forwards, getNextPosFn(caretPosition));
    var rangeIsInContainerBlock = isRangeInCaretContainerBlock(range2);
    if (!nextCaretPosition) {
      return rangeIsInContainerBlock ? Optional.some(range2) : Optional.none();
    }
    if (isBeforeFn(nextCaretPosition)) {
      return showCaret(direction, editor, nextCaretPosition.getNode(!forwards), forwards, false);
    }
    var peekCaretPosition = getNextPosFn(nextCaretPosition);
    if (peekCaretPosition && isBeforeFn(peekCaretPosition)) {
      if (isMoveInsideSameBlock(nextCaretPosition, peekCaretPosition)) {
        return showCaret(direction, editor, peekCaretPosition.getNode(!forwards), forwards, false);
      }
    }
    if (rangeIsInContainerBlock) {
      return renderRangeCaretOpt(editor, nextCaretPosition.toRange(), false);
    }
    return Optional.none();
  };
  var moveVertically = function(editor, direction, range2, isBefore, isAfter, isElement2) {
    var caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range2);
    var caretClientRect = last$1(caretPosition.getClientRects());
    var forwards = direction === VDirection.Down;
    if (!caretClientRect) {
      return Optional.none();
    }
    var walkerFn = forwards ? downUntil : upUntil;
    var linePositions = walkerFn(editor.getBody(), isAboveLine(1), caretPosition);
    var nextLinePositions = filter(linePositions, isLine(1));
    var clientX = caretClientRect.left;
    var nextLineRect = findClosestClientRect(nextLinePositions, clientX);
    if (nextLineRect && isElement2(nextLineRect.node)) {
      var dist1 = Math.abs(clientX - nextLineRect.left);
      var dist2 = Math.abs(clientX - nextLineRect.right);
      return showCaret(direction, editor, nextLineRect.node, dist1 < dist2, false);
    }
    var currentNode;
    if (isBefore(caretPosition)) {
      currentNode = caretPosition.getNode();
    } else if (isAfter(caretPosition)) {
      currentNode = caretPosition.getNode(true);
    } else {
      currentNode = getSelectedNode(range2);
    }
    if (currentNode) {
      var caretPositions = positionsUntil(direction, editor.getBody(), isAboveLine(1), currentNode);
      var closestNextLineRect = findClosestClientRect(filter(caretPositions, isLine(1)), clientX);
      if (closestNextLineRect) {
        return renderRangeCaretOpt(editor, closestNextLineRect.position.toRange(), false);
      }
      closestNextLineRect = last$1(filter(caretPositions, isLine(0)));
      if (closestNextLineRect) {
        return renderRangeCaretOpt(editor, closestNextLineRect.position.toRange(), false);
      }
    }
    if (nextLinePositions.length === 0) {
      return getLineEndPoint(editor, forwards).filter(forwards ? isAfter : isBefore).map(function(pos) {
        return renderRangeCaret(editor, pos.toRange(), false);
      });
    }
    return Optional.none();
  };
  var getLineEndPoint = function(editor, forward) {
    var rng = editor.selection.getRng();
    var body = editor.getBody();
    if (forward) {
      var from2 = CaretPosition.fromRangeEnd(rng);
      var result = getPositionsUntilNextLine(body, from2);
      return last(result.positions);
    } else {
      var from2 = CaretPosition.fromRangeStart(rng);
      var result = getPositionsUntilPreviousLine(body, from2);
      return head(result.positions);
    }
  };
  var moveToLineEndPoint = function(editor, forward, isElementPosition) {
    return getLineEndPoint(editor, forward).filter(isElementPosition).exists(function(pos) {
      editor.selection.setRng(pos.toRange());
      return true;
    });
  };
  var setCaretPosition = function(editor, pos) {
    var rng = editor.dom.createRng();
    rng.setStart(pos.container(), pos.offset());
    rng.setEnd(pos.container(), pos.offset());
    editor.selection.setRng(rng);
  };
  var setSelected = function(state, elm) {
    if (state) {
      elm.setAttribute("data-mce-selected", "inline-boundary");
    } else {
      elm.removeAttribute("data-mce-selected");
    }
  };
  var renderCaretLocation = function(editor, caret, location) {
    return renderCaret(caret, location).map(function(pos) {
      setCaretPosition(editor, pos);
      return location;
    });
  };
  var findLocation$1 = function(editor, caret, forward) {
    var rootNode = editor.getBody();
    var from2 = CaretPosition.fromRangeStart(editor.selection.getRng());
    var isInlineTarget$1 = curry(isInlineTarget, editor);
    var location = findLocation(forward, isInlineTarget$1, rootNode, from2);
    return location.bind(function(location2) {
      return renderCaretLocation(editor, caret, location2);
    });
  };
  var toggleInlines = function(isInlineTarget2, dom2, elms) {
    var inlineBoundaries = map(descendants$1(SugarElement.fromDom(dom2.getRoot()), '*[data-mce-selected="inline-boundary"]'), function(e) {
      return e.dom;
    });
    var selectedInlines = filter(inlineBoundaries, isInlineTarget2);
    var targetInlines = filter(elms, isInlineTarget2);
    each(difference(selectedInlines, targetInlines), curry(setSelected, false));
    each(difference(targetInlines, selectedInlines), curry(setSelected, true));
  };
  var safeRemoveCaretContainer = function(editor, caret) {
    if (editor.selection.isCollapsed() && editor.composing !== true && caret.get()) {
      var pos = CaretPosition.fromRangeStart(editor.selection.getRng());
      if (CaretPosition.isTextPosition(pos) && isAtZwsp(pos) === false) {
        setCaretPosition(editor, removeAndReposition(caret.get(), pos));
        caret.set(null);
      }
    }
  };
  var renderInsideInlineCaret = function(isInlineTarget2, editor, caret, elms) {
    if (editor.selection.isCollapsed()) {
      var inlines = filter(elms, isInlineTarget2);
      each(inlines, function(_inline) {
        var pos = CaretPosition.fromRangeStart(editor.selection.getRng());
        readLocation(isInlineTarget2, editor.getBody(), pos).bind(function(location) {
          return renderCaretLocation(editor, caret, location);
        });
      });
    }
  };
  var move = function(editor, caret, forward) {
    return isInlineBoundariesEnabled(editor) ? findLocation$1(editor, caret, forward).isSome() : false;
  };
  var moveWord = function(forward, editor, _caret) {
    return isInlineBoundariesEnabled(editor) ? moveByWord(forward, editor) : false;
  };
  var setupSelectedState = function(editor) {
    var caret = Cell(null);
    var isInlineTarget$1 = curry(isInlineTarget, editor);
    editor.on("NodeChange", function(e) {
      if (isInlineBoundariesEnabled(editor) && !(Env.browser.isIE() && e.initial)) {
        toggleInlines(isInlineTarget$1, editor.dom, e.parents);
        safeRemoveCaretContainer(editor, caret);
        renderInsideInlineCaret(isInlineTarget$1, editor, caret, e.parents);
      }
    });
    return caret;
  };
  var moveNextWord = curry(moveWord, true);
  var movePrevWord = curry(moveWord, false);
  var moveToLineEndPoint$1 = function(editor, forward, caret) {
    if (isInlineBoundariesEnabled(editor)) {
      var linePoint = getLineEndPoint(editor, forward).getOrThunk(function() {
        var rng = editor.selection.getRng();
        return forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);
      });
      return readLocation(curry(isInlineTarget, editor), editor.getBody(), linePoint).exists(function(loc) {
        var outsideLoc = outside(loc);
        return renderCaret(caret, outsideLoc).exists(function(pos) {
          setCaretPosition(editor, pos);
          return true;
        });
      });
    } else {
      return false;
    }
  };
  var rangeFromPositions = function(from2, to2) {
    var range2 = document.createRange();
    range2.setStart(from2.container(), from2.offset());
    range2.setEnd(to2.container(), to2.offset());
    return range2;
  };
  var hasOnlyTwoOrLessPositionsLeft = function(elm) {
    return lift2(firstPositionIn(elm), lastPositionIn(elm), function(firstPos, lastPos) {
      var normalizedFirstPos = normalizePosition(true, firstPos);
      var normalizedLastPos = normalizePosition(false, lastPos);
      return nextPosition(elm, normalizedFirstPos).forall(function(pos) {
        return pos.isEqual(normalizedLastPos);
      });
    }).getOr(true);
  };
  var setCaretLocation = function(editor, caret) {
    return function(location) {
      return renderCaret(caret, location).exists(function(pos) {
        setCaretPosition(editor, pos);
        return true;
      });
    };
  };
  var deleteFromTo = function(editor, caret, from2, to2) {
    var rootNode = editor.getBody();
    var isInlineTarget$1 = curry(isInlineTarget, editor);
    editor.undoManager.ignore(function() {
      editor.selection.setRng(rangeFromPositions(from2, to2));
      editor.execCommand("Delete");
      readLocation(isInlineTarget$1, rootNode, CaretPosition.fromRangeStart(editor.selection.getRng())).map(inside).map(setCaretLocation(editor, caret));
    });
    editor.nodeChanged();
  };
  var rescope$1 = function(rootNode, node) {
    var parentBlock = getParentBlock(node, rootNode);
    return parentBlock ? parentBlock : rootNode;
  };
  var backspaceDeleteCollapsed = function(editor, caret, forward, from2) {
    var rootNode = rescope$1(editor.getBody(), from2.container());
    var isInlineTarget$1 = curry(isInlineTarget, editor);
    var fromLocation = readLocation(isInlineTarget$1, rootNode, from2);
    return fromLocation.bind(function(location) {
      if (forward) {
        return location.fold(constant(Optional.some(inside(location))), Optional.none, constant(Optional.some(outside(location))), Optional.none);
      } else {
        return location.fold(Optional.none, constant(Optional.some(outside(location))), Optional.none, constant(Optional.some(inside(location))));
      }
    }).map(setCaretLocation(editor, caret)).getOrThunk(function() {
      var toPosition = navigate(forward, rootNode, from2);
      var toLocation = toPosition.bind(function(pos) {
        return readLocation(isInlineTarget$1, rootNode, pos);
      });
      return lift2(fromLocation, toLocation, function() {
        return findRootInline(isInlineTarget$1, rootNode, from2).exists(function(elm) {
          if (hasOnlyTwoOrLessPositionsLeft(elm)) {
            deleteElement(editor, forward, SugarElement.fromDom(elm));
            return true;
          } else {
            return false;
          }
        });
      }).orThunk(function() {
        return toLocation.bind(function(_) {
          return toPosition.map(function(to2) {
            if (forward) {
              deleteFromTo(editor, caret, from2, to2);
            } else {
              deleteFromTo(editor, caret, to2, from2);
            }
            return true;
          });
        });
      }).getOr(false);
    });
  };
  var backspaceDelete$6 = function(editor, caret, forward) {
    if (editor.selection.isCollapsed() && isInlineBoundariesEnabled(editor)) {
      var from2 = CaretPosition.fromRangeStart(editor.selection.getRng());
      return backspaceDeleteCollapsed(editor, caret, forward, from2);
    }
    return false;
  };
  var getParentInlines = function(rootElm, startElm) {
    var parents2 = parentsAndSelf(startElm, rootElm);
    return findIndex(parents2, isBlock).fold(constant(parents2), function(index) {
      return parents2.slice(0, index);
    });
  };
  var hasOnlyOneChild$1 = function(elm) {
    return children(elm).length === 1;
  };
  var deleteLastPosition = function(forward, editor, target, parentInlines) {
    var isFormatElement$1 = curry(isFormatElement, editor);
    var formatNodes = map(filter(parentInlines, isFormatElement$1), function(elm) {
      return elm.dom;
    });
    if (formatNodes.length === 0) {
      deleteElement(editor, forward, target);
    } else {
      var pos = replaceWithCaretFormat(target.dom, formatNodes);
      editor.selection.setRng(pos.toRange());
    }
  };
  var deleteCaret$2 = function(editor, forward) {
    var rootElm = SugarElement.fromDom(editor.getBody());
    var startElm = SugarElement.fromDom(editor.selection.getStart());
    var parentInlines = filter(getParentInlines(rootElm, startElm), hasOnlyOneChild$1);
    return last(parentInlines).exists(function(target) {
      var fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());
      if (willDeleteLastPositionInElement(forward, fromPos, target.dom) && !isEmptyCaretFormatElement(target)) {
        deleteLastPosition(forward, editor, target, parentInlines);
        return true;
      } else {
        return false;
      }
    });
  };
  var backspaceDelete$7 = function(editor, forward) {
    return editor.selection.isCollapsed() ? deleteCaret$2(editor, forward) : false;
  };
  var deleteElement$2 = function(editor, forward, element) {
    editor._selectionOverrides.hideFakeCaret();
    deleteElement(editor, forward, SugarElement.fromDom(element));
    return true;
  };
  var deleteCaret$3 = function(editor, forward) {
    var isNearMedia = forward ? isBeforeMedia : isAfterMedia;
    var direction = forward ? HDirection.Forwards : HDirection.Backwards;
    var fromPos = getNormalizedRangeEndPoint(direction, editor.getBody(), editor.selection.getRng());
    if (isNearMedia(fromPos)) {
      return deleteElement$2(editor, forward, fromPos.getNode(!forward));
    } else {
      return Optional.from(normalizePosition(forward, fromPos)).filter(function(pos) {
        return isNearMedia(pos) && isMoveInsideSameBlock(fromPos, pos);
      }).exists(function(pos) {
        return deleteElement$2(editor, forward, pos.getNode(!forward));
      });
    }
  };
  var deleteRange$2 = function(editor, forward) {
    var selectedNode = editor.selection.getNode();
    return isMedia(selectedNode) ? deleteElement$2(editor, forward, selectedNode) : false;
  };
  var backspaceDelete$8 = function(editor, forward) {
    return editor.selection.isCollapsed() ? deleteCaret$3(editor, forward) : deleteRange$2(editor, forward);
  };
  var isEditable$1 = function(target) {
    return closest(target, function(elm) {
      return isContentEditableTrue(elm.dom) || isContentEditableFalse(elm.dom);
    }).exists(function(elm) {
      return isContentEditableTrue(elm.dom);
    });
  };
  var parseIndentValue = function(value2) {
    var number = parseInt(value2, 10);
    return isNaN(number) ? 0 : number;
  };
  var getIndentStyleName = function(useMargin, element) {
    var indentStyleName = useMargin || isTable$1(element) ? "margin" : "padding";
    var suffix = get$5(element, "direction") === "rtl" ? "-right" : "-left";
    return indentStyleName + suffix;
  };
  var indentElement = function(dom2, command, useMargin, value2, unit, element) {
    var indentStyleName = getIndentStyleName(useMargin, SugarElement.fromDom(element));
    if (command === "outdent") {
      var styleValue = Math.max(0, parseIndentValue(element.style[indentStyleName]) - value2);
      dom2.setStyle(element, indentStyleName, styleValue ? styleValue + unit : "");
    } else {
      var styleValue = parseIndentValue(element.style[indentStyleName]) + value2 + unit;
      dom2.setStyle(element, indentStyleName, styleValue);
    }
  };
  var validateBlocks = function(editor, blocks2) {
    return forall(blocks2, function(block) {
      var indentStyleName = getIndentStyleName(shouldIndentUseMargin(editor), block);
      var intentValue = getRaw(block, indentStyleName).map(parseIndentValue).getOr(0);
      var contentEditable = editor.dom.getContentEditable(block.dom);
      return contentEditable !== "false" && intentValue > 0;
    });
  };
  var canOutdent = function(editor) {
    var blocks2 = getBlocksToIndent(editor);
    return !editor.mode.isReadOnly() && (blocks2.length > 1 || validateBlocks(editor, blocks2));
  };
  var isListComponent = function(el) {
    return isList(el) || isListItem(el);
  };
  var parentIsListComponent = function(el) {
    return parent(el).map(isListComponent).getOr(false);
  };
  var getBlocksToIndent = function(editor) {
    return filter(map(editor.selection.getSelectedBlocks(), SugarElement.fromDom), function(el) {
      return !isListComponent(el) && !parentIsListComponent(el) && isEditable$1(el);
    });
  };
  var handle = function(editor, command) {
    var dom2 = editor.dom, selection = editor.selection, formatter = editor.formatter;
    var indentation = getIndentation(editor);
    var indentUnit = /[a-z%]+$/i.exec(indentation)[0];
    var indentValue = parseInt(indentation, 10);
    var useMargin = shouldIndentUseMargin(editor);
    var forcedRootBlock = getForcedRootBlock(editor);
    if (!editor.queryCommandState("InsertUnorderedList") && !editor.queryCommandState("InsertOrderedList")) {
      if (forcedRootBlock === "" && !dom2.getParent(selection.getNode(), dom2.isBlock)) {
        formatter.apply("div");
      }
    }
    each(getBlocksToIndent(editor), function(block) {
      indentElement(dom2, command, useMargin, indentValue, indentUnit, block.dom);
    });
  };
  var backspaceDelete$9 = function(editor, _forward) {
    if (editor.selection.isCollapsed() && canOutdent(editor)) {
      var dom2 = editor.dom;
      var rng = editor.selection.getRng();
      var pos = CaretPosition.fromRangeStart(rng);
      var block = dom2.getParent(rng.startContainer, dom2.isBlock);
      if (block !== null && isAtStartOfBlock(SugarElement.fromDom(block), pos)) {
        handle(editor, "outdent");
        return true;
      }
    }
    return false;
  };
  var nativeCommand = function(editor, command) {
    editor.getDoc().execCommand(command, false, null);
  };
  var deleteCommand = function(editor, caret) {
    if (backspaceDelete$9(editor)) {
      return;
    } else if (backspaceDelete$4(editor, false)) {
      return;
    } else if (backspaceDelete$3(editor, false)) {
      return;
    } else if (backspaceDelete$6(editor, caret, false)) {
      return;
    } else if (backspaceDelete$1(editor, false)) {
      return;
    } else if (backspaceDelete(editor)) {
      return;
    } else if (backspaceDelete$5(editor, false)) {
      return;
    } else if (backspaceDelete$8(editor, false)) {
      return;
    } else if (backspaceDelete$2(editor)) {
      return;
    } else if (backspaceDelete$7(editor, false)) {
      return;
    } else {
      nativeCommand(editor, "Delete");
      paddEmptyBody(editor);
    }
  };
  var forwardDeleteCommand = function(editor, caret) {
    if (backspaceDelete$4(editor, true)) {
      return;
    } else if (backspaceDelete$3(editor, true)) {
      return;
    } else if (backspaceDelete$6(editor, caret, true)) {
      return;
    } else if (backspaceDelete$1(editor, true)) {
      return;
    } else if (backspaceDelete(editor)) {
      return;
    } else if (backspaceDelete$5(editor, true)) {
      return;
    } else if (backspaceDelete$8(editor, true)) {
      return;
    } else if (backspaceDelete$2(editor)) {
      return;
    } else if (backspaceDelete$7(editor, true)) {
      return;
    } else {
      nativeCommand(editor, "ForwardDelete");
    }
  };
  var setup$8 = function(editor, caret) {
    editor.addCommand("delete", function() {
      deleteCommand(editor, caret);
    });
    editor.addCommand("forwardDelete", function() {
      forwardDeleteCommand(editor, caret);
    });
  };
  var SIGNIFICANT_MOVE = 5;
  var LONGPRESS_DELAY = 400;
  var getTouch = function(event) {
    if (event.touches === void 0 || event.touches.length !== 1) {
      return Optional.none();
    }
    return Optional.some(event.touches[0]);
  };
  var isFarEnough = function(touch, data2) {
    var distX = Math.abs(touch.clientX - data2.x);
    var distY = Math.abs(touch.clientY - data2.y);
    return distX > SIGNIFICANT_MOVE || distY > SIGNIFICANT_MOVE;
  };
  var setup$9 = function(editor) {
    var startData = Cell(Optional.none());
    var longpressFired = Cell(false);
    var debounceLongpress = last$2(function(e) {
      editor.fire("longpress", __assign2(__assign2({}, e), { type: "longpress" }));
      longpressFired.set(true);
    }, LONGPRESS_DELAY);
    editor.on("touchstart", function(e) {
      getTouch(e).each(function(touch) {
        debounceLongpress.cancel();
        var data2 = {
          x: touch.clientX,
          y: touch.clientY,
          target: e.target
        };
        debounceLongpress.throttle(e);
        longpressFired.set(false);
        startData.set(Optional.some(data2));
      });
    }, true);
    editor.on("touchmove", function(e) {
      debounceLongpress.cancel();
      getTouch(e).each(function(touch) {
        startData.get().each(function(data2) {
          if (isFarEnough(touch, data2)) {
            startData.set(Optional.none());
            longpressFired.set(false);
            editor.fire("longpresscancel");
          }
        });
      });
    }, true);
    editor.on("touchend touchcancel", function(e) {
      debounceLongpress.cancel();
      if (e.type === "touchcancel") {
        return;
      }
      startData.get().filter(function(data2) {
        return data2.target.isEqualNode(e.target);
      }).each(function() {
        if (longpressFired.get()) {
          e.preventDefault();
        } else {
          editor.fire("tap", __assign2(__assign2({}, e), { type: "tap" }));
        }
      });
    }, true);
  };
  var isBlockElement = function(blockElements, node) {
    return blockElements.hasOwnProperty(node.nodeName);
  };
  var isValidTarget = function(blockElements, node) {
    if (isText$1(node)) {
      return true;
    } else if (isElement$1(node)) {
      return !isBlockElement(blockElements, node) && !isBookmarkNode$1(node);
    } else {
      return false;
    }
  };
  var hasBlockParent = function(blockElements, root, node) {
    return exists(parents$1(SugarElement.fromDom(node), SugarElement.fromDom(root)), function(elm) {
      return isBlockElement(blockElements, elm.dom);
    });
  };
  var shouldRemoveTextNode = function(blockElements, node) {
    if (isText$1(node)) {
      if (node.nodeValue.length === 0) {
        return true;
      } else if (/^\s+$/.test(node.nodeValue) && (!node.nextSibling || isBlockElement(blockElements, node.nextSibling))) {
        return true;
      }
    }
    return false;
  };
  var addRootBlocks = function(editor) {
    var dom2 = editor.dom, selection = editor.selection;
    var schema = editor.schema, blockElements = schema.getBlockElements();
    var node = selection.getStart();
    var rootNode = editor.getBody();
    var rootBlockNode, tempNode, wrapped;
    var forcedRootBlock = getForcedRootBlock(editor);
    if (!node || !isElement$1(node) || !forcedRootBlock) {
      return;
    }
    var rootNodeName = rootNode.nodeName.toLowerCase();
    if (!schema.isValidChild(rootNodeName, forcedRootBlock.toLowerCase()) || hasBlockParent(blockElements, rootNode, node)) {
      return;
    }
    var rng = selection.getRng();
    var startContainer = rng.startContainer;
    var startOffset = rng.startOffset;
    var endContainer = rng.endContainer;
    var endOffset = rng.endOffset;
    var restoreSelection = hasFocus$1(editor);
    node = rootNode.firstChild;
    while (node) {
      if (isValidTarget(blockElements, node)) {
        if (shouldRemoveTextNode(blockElements, node)) {
          tempNode = node;
          node = node.nextSibling;
          dom2.remove(tempNode);
          continue;
        }
        if (!rootBlockNode) {
          rootBlockNode = dom2.create(forcedRootBlock, getForcedRootBlockAttrs(editor));
          node.parentNode.insertBefore(rootBlockNode, node);
          wrapped = true;
        }
        tempNode = node;
        node = node.nextSibling;
        rootBlockNode.appendChild(tempNode);
      } else {
        rootBlockNode = null;
        node = node.nextSibling;
      }
    }
    if (wrapped && restoreSelection) {
      rng.setStart(startContainer, startOffset);
      rng.setEnd(endContainer, endOffset);
      selection.setRng(rng);
      editor.nodeChanged();
    }
  };
  var setup$a = function(editor) {
    if (getForcedRootBlock(editor)) {
      editor.on("NodeChange", curry(addRootBlocks, editor));
    }
  };
  var findBlockCaretContainer = function(editor) {
    return descendant(SugarElement.fromDom(editor.getBody()), "*[data-mce-caret]").fold(constant(null), function(elm) {
      return elm.dom;
    });
  };
  var removeIeControlRect = function(editor) {
    editor.selection.setRng(editor.selection.getRng());
  };
  var showBlockCaretContainer = function(editor, blockCaretContainer) {
    if (blockCaretContainer.hasAttribute("data-mce-caret")) {
      showCaretContainerBlock(blockCaretContainer);
      removeIeControlRect(editor);
      editor.selection.scrollIntoView(blockCaretContainer);
    }
  };
  var handleBlockContainer = function(editor, e) {
    var blockCaretContainer = findBlockCaretContainer(editor);
    if (!blockCaretContainer) {
      return;
    }
    if (e.type === "compositionstart") {
      e.preventDefault();
      e.stopPropagation();
      showBlockCaretContainer(editor, blockCaretContainer);
      return;
    }
    if (hasContent(blockCaretContainer)) {
      showBlockCaretContainer(editor, blockCaretContainer);
      editor.undoManager.add();
    }
  };
  var setup$b = function(editor) {
    editor.on("keyup compositionstart", curry(handleBlockContainer, editor));
  };
  var isContentEditableFalse$9 = isContentEditableFalse;
  var moveToCeFalseHorizontally = function(direction, editor, range2) {
    return moveHorizontally(editor, direction, range2, isBeforeContentEditableFalse, isAfterContentEditableFalse, isContentEditableFalse$9);
  };
  var moveToCeFalseVertically = function(direction, editor, range2) {
    var isBefore = function(caretPosition) {
      return isBeforeContentEditableFalse(caretPosition) || isBeforeTable(caretPosition);
    };
    var isAfter = function(caretPosition) {
      return isAfterContentEditableFalse(caretPosition) || isAfterTable(caretPosition);
    };
    return moveVertically(editor, direction, range2, isBefore, isAfter, isContentEditableFalse$9);
  };
  var createTextBlock = function(editor) {
    var textBlock = editor.dom.create(getForcedRootBlock(editor));
    if (!Env.ie || Env.ie >= 11) {
      textBlock.innerHTML = '<br data-mce-bogus="1">';
    }
    return textBlock;
  };
  var exitPreBlock = function(editor, direction, range2) {
    var caretWalker = CaretWalker(editor.getBody());
    var getVisualCaretPosition$1 = curry(getVisualCaretPosition, direction === 1 ? caretWalker.next : caretWalker.prev);
    if (range2.collapsed && hasForcedRootBlock(editor)) {
      var pre = editor.dom.getParent(range2.startContainer, "PRE");
      if (!pre) {
        return;
      }
      var caretPos = getVisualCaretPosition$1(CaretPosition.fromRangeStart(range2));
      if (!caretPos) {
        var newBlock = createTextBlock(editor);
        if (direction === 1) {
          editor.$(pre).after(newBlock);
        } else {
          editor.$(pre).before(newBlock);
        }
        editor.selection.select(newBlock, true);
        editor.selection.collapse();
      }
    }
  };
  var getHorizontalRange = function(editor, forward) {
    var direction = forward ? HDirection.Forwards : HDirection.Backwards;
    var range2 = editor.selection.getRng();
    return moveToCeFalseHorizontally(direction, editor, range2).orThunk(function() {
      exitPreBlock(editor, direction, range2);
      return Optional.none();
    });
  };
  var getVerticalRange = function(editor, down) {
    var direction = down ? 1 : -1;
    var range2 = editor.selection.getRng();
    return moveToCeFalseVertically(direction, editor, range2).orThunk(function() {
      exitPreBlock(editor, direction, range2);
      return Optional.none();
    });
  };
  var moveH = function(editor, forward) {
    return getHorizontalRange(editor, forward).exists(function(newRange) {
      moveToRange(editor, newRange);
      return true;
    });
  };
  var moveV = function(editor, down) {
    return getVerticalRange(editor, down).exists(function(newRange) {
      moveToRange(editor, newRange);
      return true;
    });
  };
  var moveToLineEndPoint$2 = function(editor, forward) {
    var isCefPosition = forward ? isAfterContentEditableFalse : isBeforeContentEditableFalse;
    return moveToLineEndPoint(editor, forward, isCefPosition);
  };
  var isTarget = function(node) {
    return contains(["figcaption"], name(node));
  };
  var rangeBefore = function(target) {
    var rng = document.createRange();
    rng.setStartBefore(target.dom);
    rng.setEndBefore(target.dom);
    return rng;
  };
  var insertElement = function(root, elm, forward) {
    if (forward) {
      append(root, elm);
    } else {
      prepend(root, elm);
    }
  };
  var insertBr = function(root, forward) {
    var br = SugarElement.fromTag("br");
    insertElement(root, br, forward);
    return rangeBefore(br);
  };
  var insertBlock$1 = function(root, forward, blockName, attrs) {
    var block = SugarElement.fromTag(blockName);
    var br = SugarElement.fromTag("br");
    setAll(block, attrs);
    append(block, br);
    insertElement(root, block, forward);
    return rangeBefore(br);
  };
  var insertEmptyLine = function(root, rootBlockName, attrs, forward) {
    if (rootBlockName === "") {
      return insertBr(root, forward);
    } else {
      return insertBlock$1(root, forward, rootBlockName, attrs);
    }
  };
  var getClosestTargetBlock = function(pos, root) {
    var isRoot = curry(eq$2, root);
    return closest(SugarElement.fromDom(pos.container()), isBlock, isRoot).filter(isTarget);
  };
  var isAtFirstOrLastLine = function(root, forward, pos) {
    return forward ? isAtLastLine(root.dom, pos) : isAtFirstLine(root.dom, pos);
  };
  var moveCaretToNewEmptyLine = function(editor, forward) {
    var root = SugarElement.fromDom(editor.getBody());
    var pos = CaretPosition.fromRangeStart(editor.selection.getRng());
    var rootBlock = getForcedRootBlock(editor);
    var rootBlockAttrs = getForcedRootBlockAttrs(editor);
    return getClosestTargetBlock(pos, root).exists(function() {
      if (isAtFirstOrLastLine(root, forward, pos)) {
        var rng = insertEmptyLine(root, rootBlock, rootBlockAttrs, forward);
        editor.selection.setRng(rng);
        return true;
      } else {
        return false;
      }
    });
  };
  var moveV$1 = function(editor, forward) {
    if (editor.selection.isCollapsed()) {
      return moveCaretToNewEmptyLine(editor, forward);
    } else {
      return false;
    }
  };
  var defaultPatterns = function(patterns) {
    return map(patterns, function(pattern) {
      return __assign2({
        shiftKey: false,
        altKey: false,
        ctrlKey: false,
        metaKey: false,
        keyCode: 0,
        action: noop
      }, pattern);
    });
  };
  var matchesEvent = function(pattern, evt) {
    return evt.keyCode === pattern.keyCode && evt.shiftKey === pattern.shiftKey && evt.altKey === pattern.altKey && evt.ctrlKey === pattern.ctrlKey && evt.metaKey === pattern.metaKey;
  };
  var match$1 = function(patterns, evt) {
    return bind(defaultPatterns(patterns), function(pattern) {
      return matchesEvent(pattern, evt) ? [pattern] : [];
    });
  };
  var action = function(f) {
    var x2 = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      x2[_i - 1] = arguments[_i];
    }
    return function() {
      return f.apply(null, x2);
    };
  };
  var execute = function(patterns, evt) {
    return find(match$1(patterns, evt), function(pattern) {
      return pattern.action();
    });
  };
  var moveH$1 = function(editor, forward) {
    var direction = forward ? HDirection.Forwards : HDirection.Backwards;
    var range2 = editor.selection.getRng();
    return moveHorizontally(editor, direction, range2, isBeforeMedia, isAfterMedia, isMedia).exists(function(newRange) {
      moveToRange(editor, newRange);
      return true;
    });
  };
  var moveV$2 = function(editor, down) {
    var direction = down ? 1 : -1;
    var range2 = editor.selection.getRng();
    return moveVertically(editor, direction, range2, isBeforeMedia, isAfterMedia, isMedia).exists(function(newRange) {
      moveToRange(editor, newRange);
      return true;
    });
  };
  var moveToLineEndPoint$3 = function(editor, forward) {
    var isNearMedia = forward ? isAfterMedia : isBeforeMedia;
    return moveToLineEndPoint(editor, forward, isNearMedia);
  };
  var deflate = function(rect, delta) {
    return {
      left: rect.left - delta,
      top: rect.top - delta,
      right: rect.right + delta * 2,
      bottom: rect.bottom + delta * 2,
      width: rect.width + delta,
      height: rect.height + delta
    };
  };
  var getCorners = function(getYAxisValue, tds) {
    return bind(tds, function(td2) {
      var rect = deflate(clone$2(td2.getBoundingClientRect()), -1);
      return [
        {
          x: rect.left,
          y: getYAxisValue(rect),
          cell: td2
        },
        {
          x: rect.right,
          y: getYAxisValue(rect),
          cell: td2
        }
      ];
    });
  };
  var findClosestCorner = function(corners, x2, y2) {
    return foldl(corners, function(acc, newCorner) {
      return acc.fold(function() {
        return Optional.some(newCorner);
      }, function(oldCorner) {
        var oldDist = Math.sqrt(Math.abs(oldCorner.x - x2) + Math.abs(oldCorner.y - y2));
        var newDist = Math.sqrt(Math.abs(newCorner.x - x2) + Math.abs(newCorner.y - y2));
        return Optional.some(newDist < oldDist ? newCorner : oldCorner);
      });
    }, Optional.none());
  };
  var getClosestCell$1 = function(getYAxisValue, isTargetCorner, table, x2, y2) {
    var cells = descendants$1(SugarElement.fromDom(table), "td,th,caption").map(function(e) {
      return e.dom;
    });
    var corners = filter(getCorners(getYAxisValue, cells), function(corner) {
      return isTargetCorner(corner, y2);
    });
    return findClosestCorner(corners, x2, y2).map(function(corner) {
      return corner.cell;
    });
  };
  var getBottomValue = function(rect) {
    return rect.bottom;
  };
  var getTopValue = function(rect) {
    return rect.top;
  };
  var isAbove$1 = function(corner, y2) {
    return corner.y < y2;
  };
  var isBelow$1 = function(corner, y2) {
    return corner.y > y2;
  };
  var getClosestCellAbove = curry(getClosestCell$1, getBottomValue, isAbove$1);
  var getClosestCellBelow = curry(getClosestCell$1, getTopValue, isBelow$1);
  var findClosestPositionInAboveCell = function(table, pos) {
    return head(pos.getClientRects()).bind(function(rect) {
      return getClosestCellAbove(table, rect.left, rect.top);
    }).bind(function(cell) {
      return findClosestHorizontalPosition(getLastLinePositions(cell), pos);
    });
  };
  var findClosestPositionInBelowCell = function(table, pos) {
    return last(pos.getClientRects()).bind(function(rect) {
      return getClosestCellBelow(table, rect.left, rect.top);
    }).bind(function(cell) {
      return findClosestHorizontalPosition(getFirstLinePositions(cell), pos);
    });
  };
  var hasNextBreak = function(getPositionsUntil2, scope, lineInfo) {
    return lineInfo.breakAt.exists(function(breakPos) {
      return getPositionsUntil2(scope, breakPos).breakAt.isSome();
    });
  };
  var startsWithWrapBreak = function(lineInfo) {
    return lineInfo.breakType === BreakType.Wrap && lineInfo.positions.length === 0;
  };
  var startsWithBrBreak = function(lineInfo) {
    return lineInfo.breakType === BreakType.Br && lineInfo.positions.length === 1;
  };
  var isAtTableCellLine = function(getPositionsUntil2, scope, pos) {
    var lineInfo = getPositionsUntil2(scope, pos);
    if (startsWithWrapBreak(lineInfo) || !isBr(pos.getNode()) && startsWithBrBreak(lineInfo)) {
      return !hasNextBreak(getPositionsUntil2, scope, lineInfo);
    } else {
      return lineInfo.breakAt.isNone();
    }
  };
  var isAtFirstTableCellLine = curry(isAtTableCellLine, getPositionsUntilPreviousLine);
  var isAtLastTableCellLine = curry(isAtTableCellLine, getPositionsUntilNextLine);
  var isCaretAtStartOrEndOfTable = function(forward, rng, table) {
    var caretPos = CaretPosition.fromRangeStart(rng);
    return positionIn(!forward, table).exists(function(pos) {
      return pos.isEqual(caretPos);
    });
  };
  var navigateHorizontally = function(editor, forward, table, _td) {
    var rng = editor.selection.getRng();
    var direction = forward ? 1 : -1;
    if (isFakeCaretTableBrowser() && isCaretAtStartOrEndOfTable(forward, rng, table)) {
      showCaret(direction, editor, table, !forward, false).each(function(newRng) {
        moveToRange(editor, newRng);
      });
      return true;
    }
    return false;
  };
  var getClosestAbovePosition = function(root, table, start2) {
    return findClosestPositionInAboveCell(table, start2).orThunk(function() {
      return head(start2.getClientRects()).bind(function(rect) {
        return findClosestHorizontalPositionFromPoint(getPositionsAbove(root, CaretPosition.before(table)), rect.left);
      });
    }).getOr(CaretPosition.before(table));
  };
  var getClosestBelowPosition = function(root, table, start2) {
    return findClosestPositionInBelowCell(table, start2).orThunk(function() {
      return head(start2.getClientRects()).bind(function(rect) {
        return findClosestHorizontalPositionFromPoint(getPositionsBelow(root, CaretPosition.after(table)), rect.left);
      });
    }).getOr(CaretPosition.after(table));
  };
  var getTable = function(previous, pos) {
    var node = pos.getNode(previous);
    return isElement$1(node) && node.nodeName === "TABLE" ? Optional.some(node) : Optional.none();
  };
  var renderBlock = function(down, editor, table, pos) {
    var forcedRootBlock = getForcedRootBlock(editor);
    if (forcedRootBlock) {
      editor.undoManager.transact(function() {
        var element = SugarElement.fromTag(forcedRootBlock);
        setAll(element, getForcedRootBlockAttrs(editor));
        append(element, SugarElement.fromTag("br"));
        if (down) {
          after(SugarElement.fromDom(table), element);
        } else {
          before(SugarElement.fromDom(table), element);
        }
        var rng = editor.dom.createRng();
        rng.setStart(element.dom, 0);
        rng.setEnd(element.dom, 0);
        moveToRange(editor, rng);
      });
    } else {
      moveToRange(editor, pos.toRange());
    }
  };
  var moveCaret = function(editor, down, pos) {
    var table = down ? getTable(true, pos) : getTable(false, pos);
    var last2 = down === false;
    table.fold(function() {
      return moveToRange(editor, pos.toRange());
    }, function(table2) {
      return positionIn(last2, editor.getBody()).filter(function(lastPos) {
        return lastPos.isEqual(pos);
      }).fold(function() {
        return moveToRange(editor, pos.toRange());
      }, function(_) {
        return renderBlock(down, editor, table2, pos);
      });
    });
  };
  var navigateVertically = function(editor, down, table, td2) {
    var rng = editor.selection.getRng();
    var pos = CaretPosition.fromRangeStart(rng);
    var root = editor.getBody();
    if (!down && isAtFirstTableCellLine(td2, pos)) {
      var newPos = getClosestAbovePosition(root, table, pos);
      moveCaret(editor, down, newPos);
      return true;
    } else if (down && isAtLastTableCellLine(td2, pos)) {
      var newPos = getClosestBelowPosition(root, table, pos);
      moveCaret(editor, down, newPos);
      return true;
    } else {
      return false;
    }
  };
  var move$1 = function(editor, forward, mover) {
    return Optional.from(editor.dom.getParent(editor.selection.getNode(), "td,th")).bind(function(td2) {
      return Optional.from(editor.dom.getParent(td2, "table")).map(function(table) {
        return mover(editor, forward, table, td2);
      });
    }).getOr(false);
  };
  var moveH$2 = function(editor, forward) {
    return move$1(editor, forward, navigateHorizontally);
  };
  var moveV$3 = function(editor, forward) {
    return move$1(editor, forward, navigateVertically);
  };
  var executeKeydownOverride = function(editor, caret, evt) {
    var os2 = detect$3().os;
    execute([
      {
        keyCode: VK.RIGHT,
        action: action(moveH, editor, true)
      },
      {
        keyCode: VK.LEFT,
        action: action(moveH, editor, false)
      },
      {
        keyCode: VK.UP,
        action: action(moveV, editor, false)
      },
      {
        keyCode: VK.DOWN,
        action: action(moveV, editor, true)
      },
      {
        keyCode: VK.RIGHT,
        action: action(moveH$2, editor, true)
      },
      {
        keyCode: VK.LEFT,
        action: action(moveH$2, editor, false)
      },
      {
        keyCode: VK.UP,
        action: action(moveV$3, editor, false)
      },
      {
        keyCode: VK.DOWN,
        action: action(moveV$3, editor, true)
      },
      {
        keyCode: VK.RIGHT,
        action: action(moveH$1, editor, true)
      },
      {
        keyCode: VK.LEFT,
        action: action(moveH$1, editor, false)
      },
      {
        keyCode: VK.UP,
        action: action(moveV$2, editor, false)
      },
      {
        keyCode: VK.DOWN,
        action: action(moveV$2, editor, true)
      },
      {
        keyCode: VK.RIGHT,
        action: action(move, editor, caret, true)
      },
      {
        keyCode: VK.LEFT,
        action: action(move, editor, caret, false)
      },
      {
        keyCode: VK.RIGHT,
        ctrlKey: !os2.isOSX(),
        altKey: os2.isOSX(),
        action: action(moveNextWord, editor, caret)
      },
      {
        keyCode: VK.LEFT,
        ctrlKey: !os2.isOSX(),
        altKey: os2.isOSX(),
        action: action(movePrevWord, editor, caret)
      },
      {
        keyCode: VK.UP,
        action: action(moveV$1, editor, false)
      },
      {
        keyCode: VK.DOWN,
        action: action(moveV$1, editor, true)
      }
    ], evt).each(function(_) {
      evt.preventDefault();
    });
  };
  var setup$c = function(editor, caret) {
    editor.on("keydown", function(evt) {
      if (evt.isDefaultPrevented() === false) {
        executeKeydownOverride(editor, caret, evt);
      }
    });
  };
  var executeKeydownOverride$1 = function(editor, caret, evt) {
    execute([
      {
        keyCode: VK.BACKSPACE,
        action: action(backspaceDelete$9, editor, false)
      },
      {
        keyCode: VK.BACKSPACE,
        action: action(backspaceDelete$4, editor, false)
      },
      {
        keyCode: VK.DELETE,
        action: action(backspaceDelete$4, editor, true)
      },
      {
        keyCode: VK.BACKSPACE,
        action: action(backspaceDelete$3, editor, false)
      },
      {
        keyCode: VK.DELETE,
        action: action(backspaceDelete$3, editor, true)
      },
      {
        keyCode: VK.BACKSPACE,
        action: action(backspaceDelete$6, editor, caret, false)
      },
      {
        keyCode: VK.DELETE,
        action: action(backspaceDelete$6, editor, caret, true)
      },
      {
        keyCode: VK.BACKSPACE,
        action: action(backspaceDelete, editor, false)
      },
      {
        keyCode: VK.DELETE,
        action: action(backspaceDelete, editor, true)
      },
      {
        keyCode: VK.BACKSPACE,
        action: action(backspaceDelete$5, editor, false)
      },
      {
        keyCode: VK.DELETE,
        action: action(backspaceDelete$5, editor, true)
      },
      {
        keyCode: VK.BACKSPACE,
        action: action(backspaceDelete$8, editor, false)
      },
      {
        keyCode: VK.DELETE,
        action: action(backspaceDelete$8, editor, true)
      },
      {
        keyCode: VK.BACKSPACE,
        action: action(backspaceDelete$2, editor, false)
      },
      {
        keyCode: VK.DELETE,
        action: action(backspaceDelete$2, editor, true)
      },
      {
        keyCode: VK.BACKSPACE,
        action: action(backspaceDelete$1, editor, false)
      },
      {
        keyCode: VK.DELETE,
        action: action(backspaceDelete$1, editor, true)
      },
      {
        keyCode: VK.BACKSPACE,
        action: action(backspaceDelete$7, editor, false)
      },
      {
        keyCode: VK.DELETE,
        action: action(backspaceDelete$7, editor, true)
      }
    ], evt).each(function(_) {
      evt.preventDefault();
    });
  };
  var executeKeyupOverride = function(editor, evt) {
    execute([
      {
        keyCode: VK.BACKSPACE,
        action: action(paddEmptyElement, editor)
      },
      {
        keyCode: VK.DELETE,
        action: action(paddEmptyElement, editor)
      }
    ], evt);
  };
  var setup$d = function(editor, caret) {
    editor.on("keydown", function(evt) {
      if (evt.isDefaultPrevented() === false) {
        executeKeydownOverride$1(editor, caret, evt);
      }
    });
    editor.on("keyup", function(evt) {
      if (evt.isDefaultPrevented() === false) {
        executeKeyupOverride(editor, evt);
      }
    });
  };
  var firstNonWhiteSpaceNodeSibling = function(node) {
    while (node) {
      if (node.nodeType === 1 || node.nodeType === 3 && node.data && /[\r\n\s]/.test(node.data)) {
        return node;
      }
      node = node.nextSibling;
    }
  };
  var moveToCaretPosition = function(editor, root) {
    var node, lastNode = root;
    var dom2 = editor.dom;
    var moveCaretBeforeOnEnterElementsMap = editor.schema.getMoveCaretBeforeOnEnterElements();
    if (!root) {
      return;
    }
    if (/^(LI|DT|DD)$/.test(root.nodeName)) {
      var firstChild2 = firstNonWhiteSpaceNodeSibling(root.firstChild);
      if (firstChild2 && /^(UL|OL|DL)$/.test(firstChild2.nodeName)) {
        root.insertBefore(dom2.doc.createTextNode(nbsp), root.firstChild);
      }
    }
    var rng = dom2.createRng();
    root.normalize();
    if (root.hasChildNodes()) {
      var walker = new DomTreeWalker(root, root);
      while (node = walker.current()) {
        if (isText$1(node)) {
          rng.setStart(node, 0);
          rng.setEnd(node, 0);
          break;
        }
        if (moveCaretBeforeOnEnterElementsMap[node.nodeName.toLowerCase()]) {
          rng.setStartBefore(node);
          rng.setEndBefore(node);
          break;
        }
        lastNode = node;
        node = walker.next();
      }
      if (!node) {
        rng.setStart(lastNode, 0);
        rng.setEnd(lastNode, 0);
      }
    } else {
      if (isBr(root)) {
        if (root.nextSibling && dom2.isBlock(root.nextSibling)) {
          rng.setStartBefore(root);
          rng.setEndBefore(root);
        } else {
          rng.setStartAfter(root);
          rng.setEndAfter(root);
        }
      } else {
        rng.setStart(root, 0);
        rng.setEnd(root, 0);
      }
    }
    editor.selection.setRng(rng);
    scrollRangeIntoView(editor, rng);
  };
  var getEditableRoot = function(dom2, node) {
    var root = dom2.getRoot();
    var parent2, editableRoot;
    parent2 = node;
    while (parent2 !== root && dom2.getContentEditable(parent2) !== "false") {
      if (dom2.getContentEditable(parent2) === "true") {
        editableRoot = parent2;
      }
      parent2 = parent2.parentNode;
    }
    return parent2 !== root ? editableRoot : root;
  };
  var getParentBlock$2 = function(editor) {
    return Optional.from(editor.dom.getParent(editor.selection.getStart(true), editor.dom.isBlock));
  };
  var getParentBlockName = function(editor) {
    return getParentBlock$2(editor).fold(constant(""), function(parentBlock) {
      return parentBlock.nodeName.toUpperCase();
    });
  };
  var isListItemParentBlock = function(editor) {
    return getParentBlock$2(editor).filter(function(elm) {
      return isListItem(SugarElement.fromDom(elm));
    }).isSome();
  };
  var hasFirstChild = function(elm, name2) {
    return elm.firstChild && elm.firstChild.nodeName === name2;
  };
  var isFirstChild = function(elm) {
    var _a;
    return ((_a = elm.parentNode) === null || _a === void 0 ? void 0 : _a.firstChild) === elm;
  };
  var hasParent$1 = function(elm, parentName) {
    return elm && elm.parentNode && elm.parentNode.nodeName === parentName;
  };
  var isListBlock = function(elm) {
    return elm && /^(OL|UL|LI)$/.test(elm.nodeName);
  };
  var isNestedList = function(elm) {
    return isListBlock(elm) && isListBlock(elm.parentNode);
  };
  var getContainerBlock = function(containerBlock) {
    var containerBlockParent = containerBlock.parentNode;
    if (/^(LI|DT|DD)$/.test(containerBlockParent.nodeName)) {
      return containerBlockParent;
    }
    return containerBlock;
  };
  var isFirstOrLastLi = function(containerBlock, parentBlock, first2) {
    var node = containerBlock[first2 ? "firstChild" : "lastChild"];
    while (node) {
      if (isElement$1(node)) {
        break;
      }
      node = node[first2 ? "nextSibling" : "previousSibling"];
    }
    return node === parentBlock;
  };
  var insert = function(editor, createNewBlock, containerBlock, parentBlock, newBlockName) {
    var dom2 = editor.dom;
    var rng = editor.selection.getRng();
    if (containerBlock === editor.getBody()) {
      return;
    }
    if (isNestedList(containerBlock)) {
      newBlockName = "LI";
    }
    var newBlock = newBlockName ? createNewBlock(newBlockName) : dom2.create("BR");
    if (isFirstOrLastLi(containerBlock, parentBlock, true) && isFirstOrLastLi(containerBlock, parentBlock, false)) {
      if (hasParent$1(containerBlock, "LI")) {
        var containerBlockParent = getContainerBlock(containerBlock);
        dom2.insertAfter(newBlock, containerBlockParent);
        if (isFirstChild(containerBlock)) {
          dom2.remove(containerBlockParent);
        } else {
          dom2.remove(containerBlock);
        }
      } else {
        dom2.replace(newBlock, containerBlock);
      }
    } else if (isFirstOrLastLi(containerBlock, parentBlock, true)) {
      if (hasParent$1(containerBlock, "LI")) {
        dom2.insertAfter(newBlock, getContainerBlock(containerBlock));
        newBlock.appendChild(dom2.doc.createTextNode(" "));
        newBlock.appendChild(containerBlock);
      } else {
        containerBlock.parentNode.insertBefore(newBlock, containerBlock);
      }
      dom2.remove(parentBlock);
    } else if (isFirstOrLastLi(containerBlock, parentBlock, false)) {
      dom2.insertAfter(newBlock, getContainerBlock(containerBlock));
      dom2.remove(parentBlock);
    } else {
      containerBlock = getContainerBlock(containerBlock);
      var tmpRng = rng.cloneRange();
      tmpRng.setStartAfter(parentBlock);
      tmpRng.setEndAfter(containerBlock);
      var fragment = tmpRng.extractContents();
      if (newBlockName === "LI" && hasFirstChild(fragment, "LI")) {
        newBlock = fragment.firstChild;
        dom2.insertAfter(fragment, containerBlock);
      } else {
        dom2.insertAfter(fragment, containerBlock);
        dom2.insertAfter(newBlock, containerBlock);
      }
      dom2.remove(parentBlock);
    }
    moveToCaretPosition(editor, newBlock);
  };
  var trimZwsp = function(fragment) {
    each(descendants(SugarElement.fromDom(fragment), isText), function(text) {
      var rawNode = text.dom;
      rawNode.nodeValue = trim$2(rawNode.nodeValue);
    });
  };
  var isEmptyAnchor = function(dom2, elm) {
    return elm && elm.nodeName === "A" && dom2.isEmpty(elm);
  };
  var isTableCell$5 = function(node) {
    return node && /^(TD|TH|CAPTION)$/.test(node.nodeName);
  };
  var emptyBlock = function(elm) {
    elm.innerHTML = '<br data-mce-bogus="1">';
  };
  var containerAndSiblingName = function(container, nodeName) {
    return container.nodeName === nodeName || container.previousSibling && container.previousSibling.nodeName === nodeName;
  };
  var canSplitBlock = function(dom2, node) {
    return node && dom2.isBlock(node) && !/^(TD|TH|CAPTION|FORM)$/.test(node.nodeName) && !/^(fixed|absolute)/i.test(node.style.position) && dom2.getContentEditable(node) !== "true";
  };
  var trimInlineElementsOnLeftSideOfBlock = function(dom2, nonEmptyElementsMap, block) {
    var node = block;
    var firstChilds = [];
    var i;
    if (!node) {
      return;
    }
    while (node = node.firstChild) {
      if (dom2.isBlock(node)) {
        return;
      }
      if (isElement$1(node) && !nonEmptyElementsMap[node.nodeName.toLowerCase()]) {
        firstChilds.push(node);
      }
    }
    i = firstChilds.length;
    while (i--) {
      node = firstChilds[i];
      if (!node.hasChildNodes() || node.firstChild === node.lastChild && node.firstChild.nodeValue === "") {
        dom2.remove(node);
      } else {
        if (isEmptyAnchor(dom2, node)) {
          dom2.remove(node);
        }
      }
    }
  };
  var normalizeZwspOffset = function(start2, container, offset) {
    if (isText$1(container) === false) {
      return offset;
    } else if (start2) {
      return offset === 1 && container.data.charAt(offset - 1) === ZWSP ? 0 : offset;
    } else {
      return offset === container.data.length - 1 && container.data.charAt(offset) === ZWSP ? container.data.length : offset;
    }
  };
  var includeZwspInRange = function(rng) {
    var newRng = rng.cloneRange();
    newRng.setStart(rng.startContainer, normalizeZwspOffset(true, rng.startContainer, rng.startOffset));
    newRng.setEnd(rng.endContainer, normalizeZwspOffset(false, rng.endContainer, rng.endOffset));
    return newRng;
  };
  var trimLeadingLineBreaks = function(node) {
    do {
      if (isText$1(node)) {
        node.nodeValue = node.nodeValue.replace(/^[\r\n]+/, "");
      }
      node = node.firstChild;
    } while (node);
  };
  var getEditableRoot$1 = function(dom2, node) {
    var root = dom2.getRoot();
    var parent2, editableRoot;
    parent2 = node;
    while (parent2 !== root && dom2.getContentEditable(parent2) !== "false") {
      if (dom2.getContentEditable(parent2) === "true") {
        editableRoot = parent2;
      }
      parent2 = parent2.parentNode;
    }
    return parent2 !== root ? editableRoot : root;
  };
  var applyAttributes = function(editor, node, forcedRootBlockAttrs) {
    var dom2 = editor.dom;
    Optional.from(forcedRootBlockAttrs.style).map(dom2.parseStyle).each(function(attrStyles) {
      var currentStyles = getAllRaw(SugarElement.fromDom(node));
      var newStyles = __assign2(__assign2({}, currentStyles), attrStyles);
      dom2.setStyles(node, newStyles);
    });
    var attrClassesOpt = Optional.from(forcedRootBlockAttrs.class).map(function(attrClasses) {
      return attrClasses.split(/\s+/);
    });
    var currentClassesOpt = Optional.from(node.className).map(function(currentClasses) {
      return filter(currentClasses.split(/\s+/), function(clazz) {
        return clazz !== "";
      });
    });
    lift2(attrClassesOpt, currentClassesOpt, function(attrClasses, currentClasses) {
      var filteredClasses = filter(currentClasses, function(clazz) {
        return !contains(attrClasses, clazz);
      });
      var newClasses = __spreadArrays(attrClasses, filteredClasses);
      dom2.setAttrib(node, "class", newClasses.join(" "));
    });
    var appliedAttrs = [
      "style",
      "class"
    ];
    var remainingAttrs = filter$1(forcedRootBlockAttrs, function(_, attrs) {
      return !contains(appliedAttrs, attrs);
    });
    dom2.setAttribs(node, remainingAttrs);
  };
  var setForcedBlockAttrs = function(editor, node) {
    var forcedRootBlockName = getForcedRootBlock(editor);
    if (forcedRootBlockName && forcedRootBlockName.toLowerCase() === node.tagName.toLowerCase()) {
      var forcedRootBlockAttrs = getForcedRootBlockAttrs(editor);
      applyAttributes(editor, node, forcedRootBlockAttrs);
    }
  };
  var wrapSelfAndSiblingsInDefaultBlock = function(editor, newBlockName, rng, container, offset) {
    var newBlock, parentBlock, startNode, node, next, rootBlockName;
    var blockName = newBlockName || "P";
    var dom2 = editor.dom, editableRoot = getEditableRoot$1(dom2, container);
    parentBlock = dom2.getParent(container, dom2.isBlock);
    if (!parentBlock || !canSplitBlock(dom2, parentBlock)) {
      parentBlock = parentBlock || editableRoot;
      if (parentBlock === editor.getBody() || isTableCell$5(parentBlock)) {
        rootBlockName = parentBlock.nodeName.toLowerCase();
      } else {
        rootBlockName = parentBlock.parentNode.nodeName.toLowerCase();
      }
      if (!parentBlock.hasChildNodes()) {
        newBlock = dom2.create(blockName);
        setForcedBlockAttrs(editor, newBlock);
        parentBlock.appendChild(newBlock);
        rng.setStart(newBlock, 0);
        rng.setEnd(newBlock, 0);
        return newBlock;
      }
      node = container;
      while (node.parentNode !== parentBlock) {
        node = node.parentNode;
      }
      while (node && !dom2.isBlock(node)) {
        startNode = node;
        node = node.previousSibling;
      }
      if (startNode && editor.schema.isValidChild(rootBlockName, blockName.toLowerCase())) {
        newBlock = dom2.create(blockName);
        setForcedBlockAttrs(editor, newBlock);
        startNode.parentNode.insertBefore(newBlock, startNode);
        node = startNode;
        while (node && !dom2.isBlock(node)) {
          next = node.nextSibling;
          newBlock.appendChild(node);
          node = next;
        }
        rng.setStart(container, offset);
        rng.setEnd(container, offset);
      }
    }
    return container;
  };
  var addBrToBlockIfNeeded = function(dom2, block) {
    block.normalize();
    var lastChild2 = block.lastChild;
    if (!lastChild2 || /^(left|right)$/gi.test(dom2.getStyle(lastChild2, "float", true))) {
      dom2.add(block, "br");
    }
  };
  var insert$1 = function(editor, evt) {
    var tmpRng, container, offset, parentBlock;
    var newBlock, fragment, containerBlock, parentBlockName, newBlockName, isAfterLastNodeInContainer;
    var dom2 = editor.dom;
    var schema = editor.schema, nonEmptyElementsMap = schema.getNonEmptyElements();
    var rng = editor.selection.getRng();
    var createNewBlock = function(name2) {
      var node = container, block, clonedNode, caretNode;
      var textInlineElements = schema.getTextInlineElements();
      if (name2 || parentBlockName === "TABLE" || parentBlockName === "HR") {
        block = dom2.create(name2 || newBlockName);
      } else {
        block = parentBlock.cloneNode(false);
      }
      caretNode = block;
      if (shouldKeepStyles(editor) === false) {
        dom2.setAttrib(block, "style", null);
        dom2.setAttrib(block, "class", null);
      } else {
        do {
          if (textInlineElements[node.nodeName]) {
            if (isCaretNode(node) || isBookmarkNode$1(node)) {
              continue;
            }
            clonedNode = node.cloneNode(false);
            dom2.setAttrib(clonedNode, "id", "");
            if (block.hasChildNodes()) {
              clonedNode.appendChild(block.firstChild);
              block.appendChild(clonedNode);
            } else {
              caretNode = clonedNode;
              block.appendChild(clonedNode);
            }
          }
        } while ((node = node.parentNode) && node !== editableRoot);
      }
      setForcedBlockAttrs(editor, block);
      emptyBlock(caretNode);
      return block;
    };
    var isCaretAtStartOrEndOfBlock = function(start2) {
      var node, name2;
      var normalizedOffset = normalizeZwspOffset(start2, container, offset);
      if (isText$1(container) && (start2 ? normalizedOffset > 0 : normalizedOffset < container.nodeValue.length)) {
        return false;
      }
      if (container.parentNode === parentBlock && isAfterLastNodeInContainer && !start2) {
        return true;
      }
      if (start2 && isElement$1(container) && container === parentBlock.firstChild) {
        return true;
      }
      if (containerAndSiblingName(container, "TABLE") || containerAndSiblingName(container, "HR")) {
        return isAfterLastNodeInContainer && !start2 || !isAfterLastNodeInContainer && start2;
      }
      var walker = new DomTreeWalker(container, parentBlock);
      if (isText$1(container)) {
        if (start2 && normalizedOffset === 0) {
          walker.prev();
        } else if (!start2 && normalizedOffset === container.nodeValue.length) {
          walker.next();
        }
      }
      while (node = walker.current()) {
        if (isElement$1(node)) {
          if (!node.getAttribute("data-mce-bogus")) {
            name2 = node.nodeName.toLowerCase();
            if (nonEmptyElementsMap[name2] && name2 !== "br") {
              return false;
            }
          }
        } else if (isText$1(node) && !isWhitespaceText(node.nodeValue)) {
          return false;
        }
        if (start2) {
          walker.prev();
        } else {
          walker.next();
        }
      }
      return true;
    };
    var insertNewBlockAfter = function() {
      if (/^(H[1-6]|PRE|FIGURE)$/.test(parentBlockName) && containerBlockName !== "HGROUP") {
        newBlock = createNewBlock(newBlockName);
      } else {
        newBlock = createNewBlock();
      }
      if (shouldEndContainerOnEmptyBlock(editor) && canSplitBlock(dom2, containerBlock) && dom2.isEmpty(parentBlock)) {
        newBlock = dom2.split(containerBlock, parentBlock);
      } else {
        dom2.insertAfter(newBlock, parentBlock);
      }
      moveToCaretPosition(editor, newBlock);
    };
    normalize(dom2, rng).each(function(normRng) {
      rng.setStart(normRng.startContainer, normRng.startOffset);
      rng.setEnd(normRng.endContainer, normRng.endOffset);
    });
    container = rng.startContainer;
    offset = rng.startOffset;
    newBlockName = getForcedRootBlock(editor);
    var shiftKey = !!(evt && evt.shiftKey);
    var ctrlKey = !!(evt && evt.ctrlKey);
    if (isElement$1(container) && container.hasChildNodes()) {
      isAfterLastNodeInContainer = offset > container.childNodes.length - 1;
      container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;
      if (isAfterLastNodeInContainer && isText$1(container)) {
        offset = container.nodeValue.length;
      } else {
        offset = 0;
      }
    }
    var editableRoot = getEditableRoot$1(dom2, container);
    if (!editableRoot) {
      return;
    }
    if (newBlockName && !shiftKey || !newBlockName && shiftKey) {
      container = wrapSelfAndSiblingsInDefaultBlock(editor, newBlockName, rng, container, offset);
    }
    parentBlock = dom2.getParent(container, dom2.isBlock);
    containerBlock = parentBlock ? dom2.getParent(parentBlock.parentNode, dom2.isBlock) : null;
    parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : "";
    var containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : "";
    if (containerBlockName === "LI" && !ctrlKey) {
      parentBlock = containerBlock;
      containerBlock = containerBlock.parentNode;
      parentBlockName = containerBlockName;
    }
    if (/^(LI|DT|DD)$/.test(parentBlockName)) {
      if (dom2.isEmpty(parentBlock)) {
        insert(editor, createNewBlock, containerBlock, parentBlock, newBlockName);
        return;
      }
    }
    if (newBlockName && parentBlock === editor.getBody()) {
      return;
    }
    newBlockName = newBlockName || "P";
    if (isCaretContainerBlock(parentBlock)) {
      newBlock = showCaretContainerBlock(parentBlock);
      if (dom2.isEmpty(parentBlock)) {
        emptyBlock(parentBlock);
      }
      setForcedBlockAttrs(editor, newBlock);
      moveToCaretPosition(editor, newBlock);
    } else if (isCaretAtStartOrEndOfBlock()) {
      insertNewBlockAfter();
    } else if (isCaretAtStartOrEndOfBlock(true)) {
      newBlock = parentBlock.parentNode.insertBefore(createNewBlock(), parentBlock);
      moveToCaretPosition(editor, containerAndSiblingName(parentBlock, "HR") ? newBlock : parentBlock);
    } else {
      tmpRng = includeZwspInRange(rng).cloneRange();
      tmpRng.setEndAfter(parentBlock);
      fragment = tmpRng.extractContents();
      trimZwsp(fragment);
      trimLeadingLineBreaks(fragment);
      newBlock = fragment.firstChild;
      dom2.insertAfter(fragment, parentBlock);
      trimInlineElementsOnLeftSideOfBlock(dom2, nonEmptyElementsMap, newBlock);
      addBrToBlockIfNeeded(dom2, parentBlock);
      if (dom2.isEmpty(parentBlock)) {
        emptyBlock(parentBlock);
      }
      newBlock.normalize();
      if (dom2.isEmpty(newBlock)) {
        dom2.remove(newBlock);
        insertNewBlockAfter();
      } else {
        setForcedBlockAttrs(editor, newBlock);
        moveToCaretPosition(editor, newBlock);
      }
    }
    dom2.setAttrib(newBlock, "id", "");
    editor.fire("NewBlock", { newBlock });
  };
  var hasRightSideContent = function(schema, container, parentBlock) {
    var walker = new DomTreeWalker(container, parentBlock);
    var node;
    var nonEmptyElementsMap = schema.getNonEmptyElements();
    while (node = walker.next()) {
      if (nonEmptyElementsMap[node.nodeName.toLowerCase()] || node.length > 0) {
        return true;
      }
    }
  };
  var moveSelectionToBr = function(editor, brElm, extraBr) {
    var rng = editor.dom.createRng();
    if (!extraBr) {
      rng.setStartAfter(brElm);
      rng.setEndAfter(brElm);
    } else {
      rng.setStartBefore(brElm);
      rng.setEndBefore(brElm);
    }
    editor.selection.setRng(rng);
    scrollRangeIntoView(editor, rng);
  };
  var insertBrAtCaret = function(editor, evt) {
    var selection = editor.selection;
    var dom2 = editor.dom;
    var rng = selection.getRng();
    var brElm;
    var extraBr;
    normalize(dom2, rng).each(function(normRng) {
      rng.setStart(normRng.startContainer, normRng.startOffset);
      rng.setEnd(normRng.endContainer, normRng.endOffset);
    });
    var offset = rng.startOffset;
    var container = rng.startContainer;
    if (container.nodeType === 1 && container.hasChildNodes()) {
      var isAfterLastNodeInContainer = offset > container.childNodes.length - 1;
      container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;
      if (isAfterLastNodeInContainer && container.nodeType === 3) {
        offset = container.nodeValue.length;
      } else {
        offset = 0;
      }
    }
    var parentBlock = dom2.getParent(container, dom2.isBlock);
    var containerBlock = parentBlock ? dom2.getParent(parentBlock.parentNode, dom2.isBlock) : null;
    var containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : "";
    var isControlKey = !!(evt && evt.ctrlKey);
    if (containerBlockName === "LI" && !isControlKey) {
      parentBlock = containerBlock;
    }
    if (container && container.nodeType === 3 && offset >= container.nodeValue.length) {
      if (!hasRightSideContent(editor.schema, container, parentBlock)) {
        brElm = dom2.create("br");
        rng.insertNode(brElm);
        rng.setStartAfter(brElm);
        rng.setEndAfter(brElm);
        extraBr = true;
      }
    }
    brElm = dom2.create("br");
    rangeInsertNode(dom2, rng, brElm);
    moveSelectionToBr(editor, brElm, extraBr);
    editor.undoManager.add();
  };
  var insertBrBefore = function(editor, inline) {
    var br = SugarElement.fromTag("br");
    before(SugarElement.fromDom(inline), br);
    editor.undoManager.add();
  };
  var insertBrAfter = function(editor, inline) {
    if (!hasBrAfter(editor.getBody(), inline)) {
      after(SugarElement.fromDom(inline), SugarElement.fromTag("br"));
    }
    var br = SugarElement.fromTag("br");
    after(SugarElement.fromDom(inline), br);
    moveSelectionToBr(editor, br.dom, false);
    editor.undoManager.add();
  };
  var isBeforeBr$1 = function(pos) {
    return isBr(pos.getNode());
  };
  var hasBrAfter = function(rootNode, startNode) {
    if (isBeforeBr$1(CaretPosition.after(startNode))) {
      return true;
    } else {
      return nextPosition(rootNode, CaretPosition.after(startNode)).map(function(pos) {
        return isBr(pos.getNode());
      }).getOr(false);
    }
  };
  var isAnchorLink = function(elm) {
    return elm && elm.nodeName === "A" && "href" in elm;
  };
  var isInsideAnchor = function(location) {
    return location.fold(never, isAnchorLink, isAnchorLink, never);
  };
  var readInlineAnchorLocation = function(editor) {
    var isInlineTarget$1 = curry(isInlineTarget, editor);
    var position = CaretPosition.fromRangeStart(editor.selection.getRng());
    return readLocation(isInlineTarget$1, editor.getBody(), position).filter(isInsideAnchor);
  };
  var insertBrOutsideAnchor = function(editor, location) {
    location.fold(noop, curry(insertBrBefore, editor), curry(insertBrAfter, editor), noop);
  };
  var insert$2 = function(editor, evt) {
    var anchorLocation = readInlineAnchorLocation(editor);
    if (anchorLocation.isSome()) {
      anchorLocation.each(curry(insertBrOutsideAnchor, editor));
    } else {
      insertBrAtCaret(editor, evt);
    }
  };
  var matchesSelector = function(editor, selector) {
    return getParentBlock$2(editor).filter(function(parentBlock) {
      return selector.length > 0 && is$1(SugarElement.fromDom(parentBlock), selector);
    }).isSome();
  };
  var shouldInsertBr = function(editor) {
    return matchesSelector(editor, getBrNewLineSelector(editor));
  };
  var shouldBlockNewLine = function(editor) {
    return matchesSelector(editor, getNoNewLineSelector(editor));
  };
  var newLineAction = Adt.generate([
    { br: [] },
    { block: [] },
    { none: [] }
  ]);
  var shouldBlockNewLine$1 = function(editor, _shiftKey) {
    return shouldBlockNewLine(editor);
  };
  var isBrMode = function(requiredState) {
    return function(editor, _shiftKey) {
      var brMode = getForcedRootBlock(editor) === "";
      return brMode === requiredState;
    };
  };
  var inListBlock = function(requiredState) {
    return function(editor, _shiftKey) {
      return isListItemParentBlock(editor) === requiredState;
    };
  };
  var inBlock = function(blockName, requiredState) {
    return function(editor, _shiftKey) {
      var state = getParentBlockName(editor) === blockName.toUpperCase();
      return state === requiredState;
    };
  };
  var inPreBlock = function(requiredState) {
    return inBlock("pre", requiredState);
  };
  var inSummaryBlock = function() {
    return inBlock("summary", true);
  };
  var shouldPutBrInPre$1 = function(requiredState) {
    return function(editor, _shiftKey) {
      return shouldPutBrInPre(editor) === requiredState;
    };
  };
  var inBrContext = function(editor, _shiftKey) {
    return shouldInsertBr(editor);
  };
  var hasShiftKey = function(_editor, shiftKey) {
    return shiftKey;
  };
  var canInsertIntoEditableRoot = function(editor) {
    var forcedRootBlock = getForcedRootBlock(editor);
    var rootEditable = getEditableRoot(editor.dom, editor.selection.getStart());
    return rootEditable && editor.schema.isValidChild(rootEditable.nodeName, forcedRootBlock ? forcedRootBlock : "P");
  };
  var match$2 = function(predicates, action2) {
    return function(editor, shiftKey) {
      var isMatch = foldl(predicates, function(res, p2) {
        return res && p2(editor, shiftKey);
      }, true);
      return isMatch ? Optional.some(action2) : Optional.none();
    };
  };
  var getAction$1 = function(editor, evt) {
    return evaluateUntil([
      match$2([shouldBlockNewLine$1], newLineAction.none()),
      match$2([inSummaryBlock()], newLineAction.br()),
      match$2([
        inPreBlock(true),
        shouldPutBrInPre$1(false),
        hasShiftKey
      ], newLineAction.br()),
      match$2([
        inPreBlock(true),
        shouldPutBrInPre$1(false)
      ], newLineAction.block()),
      match$2([
        inPreBlock(true),
        shouldPutBrInPre$1(true),
        hasShiftKey
      ], newLineAction.block()),
      match$2([
        inPreBlock(true),
        shouldPutBrInPre$1(true)
      ], newLineAction.br()),
      match$2([
        inListBlock(true),
        hasShiftKey
      ], newLineAction.br()),
      match$2([inListBlock(true)], newLineAction.block()),
      match$2([
        isBrMode(true),
        hasShiftKey,
        canInsertIntoEditableRoot
      ], newLineAction.block()),
      match$2([isBrMode(true)], newLineAction.br()),
      match$2([inBrContext], newLineAction.br()),
      match$2([
        isBrMode(false),
        hasShiftKey
      ], newLineAction.br()),
      match$2([canInsertIntoEditableRoot], newLineAction.block())
    ], [
      editor,
      !!(evt && evt.shiftKey)
    ]).getOr(newLineAction.none());
  };
  var insert$3 = function(editor, evt) {
    getAction$1(editor, evt).fold(function() {
      insert$2(editor, evt);
    }, function() {
      insert$1(editor, evt);
    }, noop);
  };
  var handleEnterKeyEvent = function(editor, event) {
    if (event.isDefaultPrevented()) {
      return;
    }
    event.preventDefault();
    endTypingLevelIgnoreLocks(editor.undoManager);
    editor.undoManager.transact(function() {
      if (editor.selection.isCollapsed() === false) {
        editor.execCommand("Delete");
      }
      insert$3(editor, event);
    });
  };
  var setup$e = function(editor) {
    editor.on("keydown", function(event) {
      if (event.keyCode === VK.ENTER) {
        handleEnterKeyEvent(editor, event);
      }
    });
  };
  var executeKeydownOverride$2 = function(editor, caret, evt) {
    execute([
      {
        keyCode: VK.END,
        action: action(moveToLineEndPoint$2, editor, true)
      },
      {
        keyCode: VK.HOME,
        action: action(moveToLineEndPoint$2, editor, false)
      },
      {
        keyCode: VK.END,
        action: action(moveToLineEndPoint$3, editor, true)
      },
      {
        keyCode: VK.HOME,
        action: action(moveToLineEndPoint$3, editor, false)
      },
      {
        keyCode: VK.END,
        action: action(moveToLineEndPoint$1, editor, true, caret)
      },
      {
        keyCode: VK.HOME,
        action: action(moveToLineEndPoint$1, editor, false, caret)
      }
    ], evt).each(function(_) {
      evt.preventDefault();
    });
  };
  var setup$f = function(editor, caret) {
    editor.on("keydown", function(evt) {
      if (evt.isDefaultPrevented() === false) {
        executeKeydownOverride$2(editor, caret, evt);
      }
    });
  };
  var browser$4 = detect$3().browser;
  var setupIeInput = function(editor) {
    var keypressThrotter = first(function() {
      if (!editor.composing) {
        normalizeNbspsInEditor(editor);
      }
    }, 0);
    if (browser$4.isIE()) {
      editor.on("keypress", function(_e) {
        keypressThrotter.throttle();
      });
      editor.on("remove", function(_e) {
        keypressThrotter.cancel();
      });
    }
  };
  var setup$g = function(editor) {
    setupIeInput(editor);
    editor.on("input", function(e) {
      if (e.isComposing === false) {
        normalizeNbspsInEditor(editor);
      }
    });
  };
  var platform$2 = detect$3();
  var executeKeyupAction = function(editor, caret, evt) {
    execute([
      {
        keyCode: VK.PAGE_UP,
        action: action(moveToLineEndPoint$1, editor, false, caret)
      },
      {
        keyCode: VK.PAGE_DOWN,
        action: action(moveToLineEndPoint$1, editor, true, caret)
      }
    ], evt);
  };
  var stopImmediatePropagation = function(e) {
    return e.stopImmediatePropagation();
  };
  var isPageUpDown = function(evt) {
    return evt.keyCode === VK.PAGE_UP || evt.keyCode === VK.PAGE_DOWN;
  };
  var setNodeChangeBlocker = function(blocked, editor, block) {
    if (block && !blocked.get()) {
      editor.on("NodeChange", stopImmediatePropagation, true);
    } else if (!block && blocked.get()) {
      editor.off("NodeChange", stopImmediatePropagation);
    }
    blocked.set(block);
  };
  var setup$h = function(editor, caret) {
    if (platform$2.os.isOSX()) {
      return;
    }
    var blocked = Cell(false);
    editor.on("keydown", function(evt) {
      if (isPageUpDown(evt)) {
        setNodeChangeBlocker(blocked, editor, true);
      }
    });
    editor.on("keyup", function(evt) {
      if (evt.isDefaultPrevented() === false) {
        executeKeyupAction(editor, caret, evt);
      }
      if (isPageUpDown(evt) && blocked.get()) {
        setNodeChangeBlocker(blocked, editor, false);
        editor.nodeChanged();
      }
    });
  };
  var insertTextAtPosition = function(text, pos) {
    var container = pos.container();
    var offset = pos.offset();
    if (isText$1(container)) {
      container.insertData(offset, text);
      return Optional.some(CaretPosition(container, offset + text.length));
    } else {
      return getElementFromPosition(pos).map(function(elm) {
        var textNode = SugarElement.fromText(text);
        if (pos.isAtEnd()) {
          after(elm, textNode);
        } else {
          before(elm, textNode);
        }
        return CaretPosition(textNode.dom, text.length);
      });
    }
  };
  var insertNbspAtPosition = curry(insertTextAtPosition, nbsp);
  var insertSpaceAtPosition = curry(insertTextAtPosition, " ");
  var locationToCaretPosition = function(root) {
    return function(location) {
      return location.fold(function(element) {
        return prevPosition(root.dom, CaretPosition.before(element));
      }, function(element) {
        return firstPositionIn(element);
      }, function(element) {
        return lastPositionIn(element);
      }, function(element) {
        return nextPosition(root.dom, CaretPosition.after(element));
      });
    };
  };
  var insertInlineBoundarySpaceOrNbsp = function(root, pos) {
    return function(checkPos) {
      return needsToHaveNbsp(root, checkPos) ? insertNbspAtPosition(pos) : insertSpaceAtPosition(pos);
    };
  };
  var setSelection$1 = function(editor) {
    return function(pos) {
      editor.selection.setRng(pos.toRange());
      editor.nodeChanged();
      return true;
    };
  };
  var insertSpaceOrNbspAtSelection = function(editor) {
    var pos = CaretPosition.fromRangeStart(editor.selection.getRng());
    var root = SugarElement.fromDom(editor.getBody());
    if (editor.selection.isCollapsed()) {
      var isInlineTarget$1 = curry(isInlineTarget, editor);
      var caretPosition = CaretPosition.fromRangeStart(editor.selection.getRng());
      return readLocation(isInlineTarget$1, editor.getBody(), caretPosition).bind(locationToCaretPosition(root)).bind(insertInlineBoundarySpaceOrNbsp(root, pos)).exists(setSelection$1(editor));
    } else {
      return false;
    }
  };
  var executeKeydownOverride$3 = function(editor, evt) {
    execute([{
      keyCode: VK.SPACEBAR,
      action: action(insertSpaceOrNbspAtSelection, editor)
    }], evt).each(function(_) {
      evt.preventDefault();
    });
  };
  var setup$i = function(editor) {
    editor.on("keydown", function(evt) {
      if (evt.isDefaultPrevented() === false) {
        executeKeydownOverride$3(editor, evt);
      }
    });
  };
  var registerKeyboardOverrides = function(editor) {
    var caret = setupSelectedState(editor);
    setup$b(editor);
    setup$c(editor, caret);
    setup$d(editor, caret);
    setup$e(editor);
    setup$i(editor);
    setup$g(editor);
    setup$f(editor, caret);
    setup$h(editor, caret);
    return caret;
  };
  var setup$j = function(editor) {
    if (!isRtc(editor)) {
      return registerKeyboardOverrides(editor);
    } else {
      return Cell(null);
    }
  };
  var NodeChange = function() {
    function NodeChange2(editor) {
      this.lastPath = [];
      this.editor = editor;
      var lastRng;
      var self2 = this;
      if (!("onselectionchange" in editor.getDoc())) {
        editor.on("NodeChange click mouseup keyup focus", function(e) {
          var nativeRng = editor.selection.getRng();
          var fakeRng = {
            startContainer: nativeRng.startContainer,
            startOffset: nativeRng.startOffset,
            endContainer: nativeRng.endContainer,
            endOffset: nativeRng.endOffset
          };
          if (e.type === "nodechange" || !isEq$1(fakeRng, lastRng)) {
            editor.fire("SelectionChange");
          }
          lastRng = fakeRng;
        });
      }
      editor.on("contextmenu", function() {
        editor.fire("SelectionChange");
      });
      editor.on("SelectionChange", function() {
        var startElm = editor.selection.getStart(true);
        if (!startElm || !Env.range && editor.selection.isCollapsed()) {
          return;
        }
        if (hasAnyRanges(editor) && !self2.isSameElementPath(startElm) && editor.dom.isChildOf(startElm, editor.getBody())) {
          editor.nodeChanged({ selectionChange: true });
        }
      });
      editor.on("mouseup", function(e) {
        if (!e.isDefaultPrevented() && hasAnyRanges(editor)) {
          if (editor.selection.getNode().nodeName === "IMG") {
            Delay.setEditorTimeout(editor, function() {
              editor.nodeChanged();
            });
          } else {
            editor.nodeChanged();
          }
        }
      });
    }
    NodeChange2.prototype.nodeChanged = function(args) {
      var selection = this.editor.selection;
      var node, parents2, root;
      if (this.editor.initialized && selection && !shouldDisableNodeChange(this.editor) && !this.editor.mode.isReadOnly()) {
        root = this.editor.getBody();
        node = selection.getStart(true) || root;
        if (node.ownerDocument !== this.editor.getDoc() || !this.editor.dom.isChildOf(node, root)) {
          node = root;
        }
        parents2 = [];
        this.editor.dom.getParent(node, function(node2) {
          if (node2 === root) {
            return true;
          }
          parents2.push(node2);
        });
        args = args || {};
        args.element = node;
        args.parents = parents2;
        this.editor.fire("NodeChange", args);
      }
    };
    NodeChange2.prototype.isSameElementPath = function(startElm) {
      var i;
      var currentPath = this.editor.$(startElm).parentsUntil(this.editor.getBody()).add(startElm);
      if (currentPath.length === this.lastPath.length) {
        for (i = currentPath.length; i >= 0; i--) {
          if (currentPath[i] !== this.lastPath[i]) {
            break;
          }
        }
        if (i === -1) {
          this.lastPath = currentPath;
          return true;
        }
      }
      this.lastPath = currentPath;
      return false;
    };
    return NodeChange2;
  }();
  var preventSummaryToggle = function(editor) {
    editor.on("click", function(e) {
      if (editor.dom.getParent(e.target, "details")) {
        e.preventDefault();
      }
    });
  };
  var filterDetails = function(editor) {
    editor.parser.addNodeFilter("details", function(elms) {
      each(elms, function(details) {
        details.attr("data-mce-open", details.attr("open"));
        details.attr("open", "open");
      });
    });
    editor.serializer.addNodeFilter("details", function(elms) {
      each(elms, function(details) {
        var open = details.attr("data-mce-open");
        details.attr("open", isString(open) ? open : null);
        details.attr("data-mce-open", null);
      });
    });
  };
  var setup$k = function(editor) {
    preventSummaryToggle(editor);
    filterDetails(editor);
  };
  var isTextBlockNode = function(node) {
    return isElement$1(node) && isTextBlock(SugarElement.fromDom(node));
  };
  var normalizeSelection$1 = function(editor) {
    var rng = editor.selection.getRng();
    var startPos = CaretPosition.fromRangeStart(rng);
    var endPos = CaretPosition.fromRangeEnd(rng);
    if (CaretPosition.isElementPosition(startPos)) {
      var container = startPos.container();
      if (isTextBlockNode(container)) {
        firstPositionIn(container).each(function(pos) {
          return rng.setStart(pos.container(), pos.offset());
        });
      }
    }
    if (CaretPosition.isElementPosition(endPos)) {
      var container = startPos.container();
      if (isTextBlockNode(container)) {
        lastPositionIn(container).each(function(pos) {
          return rng.setEnd(pos.container(), pos.offset());
        });
      }
    }
    editor.selection.setRng(normalize$2(rng));
  };
  var setup$l = function(editor) {
    editor.on("click", function(e) {
      if (e.detail >= 3) {
        normalizeSelection$1(editor);
      }
    });
  };
  var value$1 = function() {
    var subject = Cell(Optional.none());
    var clear2 = function() {
      return subject.set(Optional.none());
    };
    var set2 = function(s) {
      return subject.set(Optional.some(s));
    };
    var isSet = function() {
      return subject.get().isSome();
    };
    var on2 = function(f) {
      return subject.get().each(f);
    };
    return {
      clear: clear2,
      set: set2,
      isSet,
      on: on2
    };
  };
  var getAbsolutePosition = function(elm) {
    var clientRect = elm.getBoundingClientRect();
    var doc2 = elm.ownerDocument;
    var docElem2 = doc2.documentElement;
    var win = doc2.defaultView;
    return {
      top: clientRect.top + win.pageYOffset - docElem2.clientTop,
      left: clientRect.left + win.pageXOffset - docElem2.clientLeft
    };
  };
  var getBodyPosition = function(editor) {
    return editor.inline ? getAbsolutePosition(editor.getBody()) : {
      left: 0,
      top: 0
    };
  };
  var getScrollPosition = function(editor) {
    var body = editor.getBody();
    return editor.inline ? {
      left: body.scrollLeft,
      top: body.scrollTop
    } : {
      left: 0,
      top: 0
    };
  };
  var getBodyScroll = function(editor) {
    var body = editor.getBody(), docElm = editor.getDoc().documentElement;
    var inlineScroll = {
      left: body.scrollLeft,
      top: body.scrollTop
    };
    var iframeScroll = {
      left: body.scrollLeft || docElm.scrollLeft,
      top: body.scrollTop || docElm.scrollTop
    };
    return editor.inline ? inlineScroll : iframeScroll;
  };
  var getMousePosition = function(editor, event) {
    if (event.target.ownerDocument !== editor.getDoc()) {
      var iframePosition = getAbsolutePosition(editor.getContentAreaContainer());
      var scrollPosition = getBodyScroll(editor);
      return {
        left: event.pageX - iframePosition.left + scrollPosition.left,
        top: event.pageY - iframePosition.top + scrollPosition.top
      };
    }
    return {
      left: event.pageX,
      top: event.pageY
    };
  };
  var calculatePosition = function(bodyPosition, scrollPosition, mousePosition) {
    return {
      pageX: mousePosition.left - bodyPosition.left + scrollPosition.left,
      pageY: mousePosition.top - bodyPosition.top + scrollPosition.top
    };
  };
  var calc = function(editor, event) {
    return calculatePosition(getBodyPosition(editor), getScrollPosition(editor), getMousePosition(editor, event));
  };
  var isContentEditableFalse$a = isContentEditableFalse, isContentEditableTrue$3 = isContentEditableTrue;
  var isDraggable = function(rootElm, elm) {
    return isContentEditableFalse$a(elm) && elm !== rootElm;
  };
  var isValidDropTarget = function(editor, targetElement, dragElement) {
    if (targetElement === dragElement || editor.dom.isChildOf(targetElement, dragElement)) {
      return false;
    }
    return !isContentEditableFalse$a(targetElement);
  };
  var cloneElement = function(elm) {
    var cloneElm = elm.cloneNode(true);
    cloneElm.removeAttribute("data-mce-selected");
    return cloneElm;
  };
  var createGhost = function(editor, elm, width, height) {
    var dom2 = editor.dom;
    var clonedElm = elm.cloneNode(true);
    dom2.setStyles(clonedElm, {
      width,
      height
    });
    dom2.setAttrib(clonedElm, "data-mce-selected", null);
    var ghostElm = dom2.create("div", {
      "class": "mce-drag-container",
      "data-mce-bogus": "all",
      "unselectable": "on",
      "contenteditable": "false"
    });
    dom2.setStyles(ghostElm, {
      position: "absolute",
      opacity: 0.5,
      overflow: "hidden",
      border: 0,
      padding: 0,
      margin: 0,
      width,
      height
    });
    dom2.setStyles(clonedElm, {
      margin: 0,
      boxSizing: "border-box"
    });
    ghostElm.appendChild(clonedElm);
    return ghostElm;
  };
  var appendGhostToBody = function(ghostElm, bodyElm) {
    if (ghostElm.parentNode !== bodyElm) {
      bodyElm.appendChild(ghostElm);
    }
  };
  var moveGhost = function(ghostElm, position, width, height, maxX, maxY) {
    var overflowX = 0, overflowY = 0;
    ghostElm.style.left = position.pageX + "px";
    ghostElm.style.top = position.pageY + "px";
    if (position.pageX + width > maxX) {
      overflowX = position.pageX + width - maxX;
    }
    if (position.pageY + height > maxY) {
      overflowY = position.pageY + height - maxY;
    }
    ghostElm.style.width = width - overflowX + "px";
    ghostElm.style.height = height - overflowY + "px";
  };
  var removeElement = function(elm) {
    if (elm && elm.parentNode) {
      elm.parentNode.removeChild(elm);
    }
  };
  var isLeftMouseButtonPressed = function(e) {
    return e.button === 0;
  };
  var applyRelPos = function(state, position) {
    return {
      pageX: position.pageX - state.relX,
      pageY: position.pageY + 5
    };
  };
  var start$1 = function(state, editor) {
    return function(e) {
      if (isLeftMouseButtonPressed(e)) {
        var ceElm = find(editor.dom.getParents(e.target), or(isContentEditableFalse$a, isContentEditableTrue$3)).getOr(null);
        if (isDraggable(editor.getBody(), ceElm)) {
          var elmPos = editor.dom.getPos(ceElm);
          var bodyElm = editor.getBody();
          var docElm = editor.getDoc().documentElement;
          state.set({
            element: ceElm,
            dragging: false,
            screenX: e.screenX,
            screenY: e.screenY,
            maxX: (editor.inline ? bodyElm.scrollWidth : docElm.offsetWidth) - 2,
            maxY: (editor.inline ? bodyElm.scrollHeight : docElm.offsetHeight) - 2,
            relX: e.pageX - elmPos.x,
            relY: e.pageY - elmPos.y,
            width: ceElm.offsetWidth,
            height: ceElm.offsetHeight,
            ghost: createGhost(editor, ceElm, ceElm.offsetWidth, ceElm.offsetHeight)
          });
        }
      }
    };
  };
  var move$2 = function(state, editor) {
    var throttledPlaceCaretAt = Delay.throttle(function(clientX, clientY) {
      editor._selectionOverrides.hideFakeCaret();
      editor.selection.placeCaretAt(clientX, clientY);
    }, 0);
    editor.on("remove", throttledPlaceCaretAt.stop);
    return function(e) {
      return state.on(function(state2) {
        var movement = Math.max(Math.abs(e.screenX - state2.screenX), Math.abs(e.screenY - state2.screenY));
        if (!state2.dragging && movement > 10) {
          var args = editor.fire("dragstart", { target: state2.element });
          if (args.isDefaultPrevented()) {
            return;
          }
          state2.dragging = true;
          editor.focus();
        }
        if (state2.dragging) {
          var targetPos = applyRelPos(state2, calc(editor, e));
          appendGhostToBody(state2.ghost, editor.getBody());
          moveGhost(state2.ghost, targetPos, state2.width, state2.height, state2.maxX, state2.maxY);
          throttledPlaceCaretAt(e.clientX, e.clientY);
        }
      });
    };
  };
  var getRawTarget = function(selection) {
    var rng = selection.getSel().getRangeAt(0);
    var startContainer = rng.startContainer;
    return startContainer.nodeType === 3 ? startContainer.parentNode : startContainer;
  };
  var drop = function(state, editor) {
    return function(e) {
      state.on(function(state2) {
        if (state2.dragging) {
          if (isValidDropTarget(editor, getRawTarget(editor.selection), state2.element)) {
            var targetClone_1 = cloneElement(state2.element);
            var args = editor.fire("drop", {
              clientX: e.clientX,
              clientY: e.clientY
            });
            if (!args.isDefaultPrevented()) {
              editor.undoManager.transact(function() {
                removeElement(state2.element);
                editor.insertContent(editor.dom.getOuterHTML(targetClone_1));
                editor._selectionOverrides.hideFakeCaret();
              });
            }
          }
        }
      });
      removeDragState(state);
    };
  };
  var stop = function(state, editor) {
    return function() {
      state.on(function(state2) {
        if (state2.dragging) {
          editor.fire("dragend");
        }
      });
      removeDragState(state);
    };
  };
  var removeDragState = function(state) {
    state.on(function(state2) {
      removeElement(state2.ghost);
    });
    state.clear();
  };
  var bindFakeDragEvents = function(editor) {
    var state = value$1();
    var pageDom = DOMUtils.DOM;
    var rootDocument = document;
    var dragStartHandler = start$1(state, editor);
    var dragHandler = move$2(state, editor);
    var dropHandler = drop(state, editor);
    var dragEndHandler = stop(state, editor);
    editor.on("mousedown", dragStartHandler);
    editor.on("mousemove", dragHandler);
    editor.on("mouseup", dropHandler);
    pageDom.bind(rootDocument, "mousemove", dragHandler);
    pageDom.bind(rootDocument, "mouseup", dragEndHandler);
    editor.on("remove", function() {
      pageDom.unbind(rootDocument, "mousemove", dragHandler);
      pageDom.unbind(rootDocument, "mouseup", dragEndHandler);
    });
  };
  var blockIeDrop = function(editor) {
    editor.on("drop", function(e) {
      console.log(e);
      var realTarget = typeof e.clientX !== "undefined" ? editor.getDoc().elementFromPoint(e.clientX, e.clientY) : null;
      if (isContentEditableFalse$a(realTarget) || editor.dom.getContentEditableParent(realTarget) === "false") {
        e.preventDefault();
      }
    });
  };
  var blockUnsupportedFileDrop = function(editor) {
    var preventFileDrop = function(e) {
      if (!e.isDefaultPrevented()) {
        var dataTransfer = e.dataTransfer;
        if (dataTransfer && (contains(dataTransfer.types, "Files") || dataTransfer.files.length > 0)) {
          e.preventDefault();
          if (e.type === "drop") {
            displayError(editor, "Dropped file type is not supported");
          }
        }
      }
    };
    var preventFileDropIfUIElement = function(e) {
      if (isUIElement(editor, e.target)) {
        preventFileDrop(e);
      }
    };
    var setup2 = function() {
      var pageDom = DOMUtils.DOM;
      var dom2 = editor.dom;
      var doc2 = document;
      var editorRoot = editor.inline ? editor.getBody() : editor.getDoc();
      var eventNames = [
        "drop",
        "dragover"
      ];
      each(eventNames, function(name2) {
        pageDom.bind(doc2, name2, preventFileDropIfUIElement);
        dom2.bind(editorRoot, name2, preventFileDrop);
      });
      editor.on("remove", function() {
        each(eventNames, function(name2) {
          pageDom.unbind(doc2, name2, preventFileDropIfUIElement);
          dom2.unbind(editorRoot, name2, preventFileDrop);
        });
      });
    };
    editor.on("init", function() {
      Delay.setEditorTimeout(editor, setup2, 0);
    });
  };
  var init = function(editor) {
    bindFakeDragEvents(editor);
    blockIeDrop(editor);
    if (shouldBlockUnsupportedDrop(editor)) {
      blockUnsupportedFileDrop(editor);
    }
  };
  var setup$m = function(editor) {
    var renderFocusCaret = first(function() {
      if (!editor.removed && editor.getBody().contains(document.activeElement)) {
        var rng = editor.selection.getRng();
        if (rng.collapsed) {
          var caretRange = renderRangeCaret(editor, rng, false);
          editor.selection.setRng(caretRange);
        }
      }
    }, 0);
    editor.on("focus", function() {
      renderFocusCaret.throttle();
    });
    editor.on("blur", function() {
      renderFocusCaret.cancel();
    });
  };
  var setup$n = function(editor) {
    editor.on("init", function() {
      editor.on("focusin", function(e) {
        var target = e.target;
        if (isMedia(target)) {
          var ceRoot = getContentEditableRoot(editor.getBody(), target);
          var node = isContentEditableFalse(ceRoot) ? ceRoot : target;
          if (editor.selection.getNode() !== node) {
            selectNode(editor, node).each(function(rng) {
              return editor.selection.setRng(rng);
            });
          }
        }
      });
    });
  };
  var isContentEditableTrue$4 = isContentEditableTrue;
  var isContentEditableFalse$b = isContentEditableFalse;
  var getContentEditableRoot$1 = function(editor, node) {
    return getContentEditableRoot(editor.getBody(), node);
  };
  var SelectionOverrides = function(editor) {
    var selection = editor.selection, dom2 = editor.dom;
    var isBlock2 = dom2.isBlock;
    var rootNode = editor.getBody();
    var fakeCaret = FakeCaret(editor, rootNode, isBlock2, function() {
      return hasFocus$1(editor);
    });
    var realSelectionId = "sel-" + dom2.uniqueId();
    var elementSelectionAttr = "data-mce-selected";
    var selectedElement;
    var isFakeSelectionElement = function(node) {
      return dom2.hasClass(node, "mce-offscreen-selection");
    };
    var isFakeSelectionTargetElement = function(node) {
      return node !== rootNode && (isContentEditableFalse$b(node) || isMedia(node)) && dom2.isChildOf(node, rootNode);
    };
    var isNearFakeSelectionElement = function(pos) {
      return isBeforeContentEditableFalse(pos) || isAfterContentEditableFalse(pos) || isBeforeMedia(pos) || isAfterMedia(pos);
    };
    var getRealSelectionElement = function() {
      var container = dom2.get(realSelectionId);
      return container ? container.getElementsByTagName("*")[0] : container;
    };
    var setRange = function(range2) {
      if (range2) {
        selection.setRng(range2);
      }
    };
    var getRange = selection.getRng;
    var showCaret2 = function(direction, node, before2, scrollIntoView) {
      if (scrollIntoView === void 0) {
        scrollIntoView = true;
      }
      var e = editor.fire("ShowCaret", {
        target: node,
        direction,
        before: before2
      });
      if (e.isDefaultPrevented()) {
        return null;
      }
      if (scrollIntoView) {
        selection.scrollIntoView(node, direction === -1);
      }
      return fakeCaret.show(before2, node);
    };
    var showBlockCaretContainer2 = function(blockCaretContainer) {
      if (blockCaretContainer.hasAttribute("data-mce-caret")) {
        showCaretContainerBlock(blockCaretContainer);
        setRange(getRange());
        selection.scrollIntoView(blockCaretContainer);
      }
    };
    var registerEvents2 = function() {
      editor.on("mouseup", function(e) {
        var range2 = getRange();
        if (range2.collapsed && isXYInContentArea(editor, e.clientX, e.clientY)) {
          renderCaretAtRange(editor, range2, false).each(setRange);
        }
      });
      editor.on("click", function(e) {
        var contentEditableRoot = getContentEditableRoot$1(editor, e.target);
        if (contentEditableRoot) {
          if (isContentEditableFalse$b(contentEditableRoot)) {
            e.preventDefault();
            editor.focus();
          }
          if (isContentEditableTrue$4(contentEditableRoot)) {
            if (dom2.isChildOf(contentEditableRoot, selection.getNode())) {
              removeElementSelection();
            }
          }
        }
      });
      editor.on("blur NewBlock", removeElementSelection);
      editor.on("ResizeWindow FullscreenStateChanged", fakeCaret.reposition);
      var hasNormalCaretPosition = function(elm) {
        var caretWalker = CaretWalker(elm);
        if (!elm.firstChild) {
          return false;
        }
        var startPos = CaretPosition.before(elm.firstChild);
        var newPos = caretWalker.next(startPos);
        return newPos && !isNearFakeSelectionElement(newPos);
      };
      var isInSameBlock2 = function(node1, node2) {
        var block1 = dom2.getParent(node1, isBlock2);
        var block2 = dom2.getParent(node2, isBlock2);
        return block1 === block2;
      };
      var hasBetterMouseTarget = function(targetNode, caretNode) {
        var targetBlock = dom2.getParent(targetNode, isBlock2);
        var caretBlock = dom2.getParent(caretNode, isBlock2);
        if (targetBlock && targetNode !== caretBlock && dom2.isChildOf(targetBlock, caretBlock) && isContentEditableFalse$b(getContentEditableRoot$1(editor, targetBlock)) === false) {
          return true;
        }
        return targetBlock && !isInSameBlock2(targetBlock, caretBlock) && hasNormalCaretPosition(targetBlock);
      };
      editor.on("tap", function(e) {
        var targetElm = e.target;
        var contentEditableRoot = getContentEditableRoot$1(editor, targetElm);
        if (isContentEditableFalse$b(contentEditableRoot)) {
          e.preventDefault();
          selectNode(editor, contentEditableRoot).each(setElementSelection);
        } else if (isFakeSelectionTargetElement(targetElm)) {
          selectNode(editor, targetElm).each(setElementSelection);
        }
      }, true);
      editor.on("mousedown", function(e) {
        var targetElm = e.target;
        if (targetElm !== rootNode && targetElm.nodeName !== "HTML" && !dom2.isChildOf(targetElm, rootNode)) {
          return;
        }
        if (isXYInContentArea(editor, e.clientX, e.clientY) === false) {
          return;
        }
        var contentEditableRoot = getContentEditableRoot$1(editor, targetElm);
        if (contentEditableRoot) {
          if (isContentEditableFalse$b(contentEditableRoot)) {
            e.preventDefault();
            selectNode(editor, contentEditableRoot).each(setElementSelection);
          } else {
            removeElementSelection();
            if (!(isContentEditableTrue$4(contentEditableRoot) && e.shiftKey) && !isXYWithinRange(e.clientX, e.clientY, selection.getRng())) {
              hideFakeCaret();
              selection.placeCaretAt(e.clientX, e.clientY);
            }
          }
        } else if (isFakeSelectionTargetElement(targetElm)) {
          selectNode(editor, targetElm).each(setElementSelection);
        } else if (isFakeCaretTarget(targetElm) === false) {
          removeElementSelection();
          hideFakeCaret();
          var fakeCaretInfo = closestFakeCaret(rootNode, e.clientX, e.clientY);
          if (fakeCaretInfo) {
            if (!hasBetterMouseTarget(targetElm, fakeCaretInfo.node)) {
              e.preventDefault();
              var range2 = showCaret2(1, fakeCaretInfo.node, fakeCaretInfo.before, false);
              editor.getBody().focus();
              setRange(range2);
            }
          }
        }
      });
      editor.on("keypress", function(e) {
        if (VK.modifierPressed(e)) {
          return;
        }
        if (isContentEditableFalse$b(selection.getNode())) {
          e.preventDefault();
        }
      });
      editor.on("GetSelectionRange", function(e) {
        var rng = e.range;
        if (selectedElement) {
          if (!selectedElement.parentNode) {
            selectedElement = null;
            return;
          }
          rng = rng.cloneRange();
          rng.selectNode(selectedElement);
          e.range = rng;
        }
      });
      editor.on("SetSelectionRange", function(e) {
        e.range = normalizeShortEndedElementSelection(e.range);
        var rng = setElementSelection(e.range, e.forward);
        if (rng) {
          e.range = rng;
        }
      });
      var isPasteBin = function(node) {
        return node.id === "mcepastebin";
      };
      editor.on("AfterSetSelectionRange", function(e) {
        var rng = e.range;
        var parentNode = rng.startContainer.parentNode;
        if (!isRangeInCaretContainer(rng) && !isPasteBin(parentNode)) {
          hideFakeCaret();
        }
        if (!isFakeSelectionElement(parentNode)) {
          removeElementSelection();
        }
      });
      editor.on("copy", function(e) {
        var clipboardData = e.clipboardData;
        if (!e.isDefaultPrevented() && e.clipboardData && !Env.ie) {
          var realSelectionElement = getRealSelectionElement();
          if (realSelectionElement) {
            e.preventDefault();
            clipboardData.clearData();
            clipboardData.setData("text/html", realSelectionElement.outerHTML);
            clipboardData.setData("text/plain", realSelectionElement.outerText || realSelectionElement.innerText);
          }
        }
      });
      init(editor);
      setup$m(editor);
      setup$n(editor);
    };
    var isWithinCaretContainer = function(node) {
      return isCaretContainer(node) || startsWithCaretContainer(node) || endsWithCaretContainer(node);
    };
    var isRangeInCaretContainer = function(rng) {
      return isWithinCaretContainer(rng.startContainer) || isWithinCaretContainer(rng.endContainer);
    };
    var normalizeShortEndedElementSelection = function(rng) {
      var shortEndedElements = editor.schema.getShortEndedElements();
      var newRng = dom2.createRng();
      var startContainer = rng.startContainer;
      var startOffset = rng.startOffset;
      var endContainer = rng.endContainer;
      var endOffset = rng.endOffset;
      if (has(shortEndedElements, startContainer.nodeName.toLowerCase())) {
        if (startOffset === 0) {
          newRng.setStartBefore(startContainer);
        } else {
          newRng.setStartAfter(startContainer);
        }
      } else {
        newRng.setStart(startContainer, startOffset);
      }
      if (has(shortEndedElements, endContainer.nodeName.toLowerCase())) {
        if (endOffset === 0) {
          newRng.setEndBefore(endContainer);
        } else {
          newRng.setEndAfter(endContainer);
        }
      } else {
        newRng.setEnd(endContainer, endOffset);
      }
      return newRng;
    };
    var setupOffscreenSelection = function(node, targetClone, origTargetClone) {
      var $ = editor.$;
      var $realSelectionContainer = descendant(SugarElement.fromDom(editor.getBody()), "#" + realSelectionId).fold(function() {
        return $([]);
      }, function(elm) {
        return $([elm.dom]);
      });
      if ($realSelectionContainer.length === 0) {
        $realSelectionContainer = $('<div data-mce-bogus="all" class="mce-offscreen-selection"></div>').attr("id", realSelectionId);
        $realSelectionContainer.appendTo(editor.getBody());
      }
      var newRange = dom2.createRng();
      if (targetClone === origTargetClone && Env.ie) {
        $realSelectionContainer.empty().append('<p style="font-size: 0" data-mce-bogus="all">\xA0</p>').append(targetClone);
        newRange.setStartAfter($realSelectionContainer[0].firstChild.firstChild);
        newRange.setEndAfter(targetClone);
      } else {
        $realSelectionContainer.empty().append(nbsp).append(targetClone).append(nbsp);
        newRange.setStart($realSelectionContainer[0].firstChild, 1);
        newRange.setEnd($realSelectionContainer[0].lastChild, 0);
      }
      $realSelectionContainer.css({ top: dom2.getPos(node, editor.getBody()).y });
      $realSelectionContainer[0].focus();
      var sel = selection.getSel();
      sel.removeAllRanges();
      sel.addRange(newRange);
      return newRange;
    };
    var selectElement = function(elm) {
      var targetClone = elm.cloneNode(true);
      var e = editor.fire("ObjectSelected", {
        target: elm,
        targetClone
      });
      if (e.isDefaultPrevented()) {
        return null;
      }
      var range2 = setupOffscreenSelection(elm, e.targetClone, targetClone);
      var nodeElm = SugarElement.fromDom(elm);
      each(descendants$1(SugarElement.fromDom(editor.getBody()), "*[data-mce-selected]"), function(elm2) {
        if (!eq$2(nodeElm, elm2)) {
          remove$1(elm2, elementSelectionAttr);
        }
      });
      if (!dom2.getAttrib(elm, elementSelectionAttr)) {
        elm.setAttribute(elementSelectionAttr, "1");
      }
      selectedElement = elm;
      hideFakeCaret();
      return range2;
    };
    var setElementSelection = function(range2, forward) {
      if (!range2) {
        return null;
      }
      if (range2.collapsed) {
        if (!isRangeInCaretContainer(range2)) {
          var dir2 = forward ? 1 : -1;
          var caretPosition = getNormalizedRangeEndPoint(dir2, rootNode, range2);
          var beforeNode = caretPosition.getNode(!forward);
          if (isFakeCaretTarget(beforeNode)) {
            return showCaret2(dir2, beforeNode, forward ? !caretPosition.isAtEnd() : false, false);
          }
          var afterNode = caretPosition.getNode(forward);
          if (isFakeCaretTarget(afterNode)) {
            return showCaret2(dir2, afterNode, forward ? false : !caretPosition.isAtEnd(), false);
          }
        }
        return null;
      }
      var startContainer = range2.startContainer;
      var startOffset = range2.startOffset;
      var endOffset = range2.endOffset;
      if (startContainer.nodeType === 3 && startOffset === 0 && isContentEditableFalse$b(startContainer.parentNode)) {
        startContainer = startContainer.parentNode;
        startOffset = dom2.nodeIndex(startContainer);
        startContainer = startContainer.parentNode;
      }
      if (startContainer.nodeType !== 1) {
        return null;
      }
      if (endOffset === startOffset + 1 && startContainer === range2.endContainer) {
        var node = startContainer.childNodes[startOffset];
        if (isFakeSelectionTargetElement(node)) {
          return selectElement(node);
        }
      }
      return null;
    };
    var removeElementSelection = function() {
      if (selectedElement) {
        selectedElement.removeAttribute(elementSelectionAttr);
      }
      descendant(SugarElement.fromDom(editor.getBody()), "#" + realSelectionId).each(remove);
      selectedElement = null;
    };
    var destroy2 = function() {
      fakeCaret.destroy();
      selectedElement = null;
    };
    var hideFakeCaret = function() {
      fakeCaret.hide();
    };
    if (Env.ceFalse && !isRtc(editor)) {
      registerEvents2();
    }
    return {
      showCaret: showCaret2,
      showBlockCaretContainer: showBlockCaretContainer2,
      hideFakeCaret,
      destroy: destroy2
    };
  };
  var Quirks = function(editor) {
    var each2 = Tools.each;
    var BACKSPACE = VK.BACKSPACE, DELETE2 = VK.DELETE, dom2 = editor.dom, selection = editor.selection, parser = editor.parser;
    var isGecko = Env.gecko, isIE2 = Env.ie, isWebKit = Env.webkit;
    var mceInternalUrlPrefix = "data:text/mce-internal,";
    var mceInternalDataType = isIE2 ? "Text" : "URL";
    var setEditorCommandState2 = function(cmd, state) {
      try {
        editor.getDoc().execCommand(cmd, false, state);
      } catch (ex) {
      }
    };
    var isDefaultPrevented = function(e) {
      return e.isDefaultPrevented();
    };
    var setMceInternalContent = function(e) {
      var selectionHtml, internalContent;
      if (e.dataTransfer) {
        if (editor.selection.isCollapsed() && e.target.tagName === "IMG") {
          selection.select(e.target);
        }
        selectionHtml = editor.selection.getContent();
        if (selectionHtml.length > 0) {
          internalContent = mceInternalUrlPrefix + escape(editor.id) + "," + escape(selectionHtml);
          e.dataTransfer.setData(mceInternalDataType, internalContent);
        }
      }
    };
    var getMceInternalContent = function(e) {
      var internalContent;
      if (e.dataTransfer) {
        internalContent = e.dataTransfer.getData(mceInternalDataType);
        if (internalContent && internalContent.indexOf(mceInternalUrlPrefix) >= 0) {
          internalContent = internalContent.substr(mceInternalUrlPrefix.length).split(",");
          return {
            id: unescape(internalContent[0]),
            html: unescape(internalContent[1])
          };
        }
      }
      return null;
    };
    var insertClipboardContents = function(content, internal) {
      if (editor.queryCommandSupported("mceInsertClipboardContent")) {
        editor.execCommand("mceInsertClipboardContent", false, {
          content,
          internal
        });
      } else {
        editor.execCommand("mceInsertContent", false, content);
      }
    };
    var emptyEditorWhenDeleting = function() {
      var serializeRng = function(rng) {
        var body = dom2.create("body");
        var contents = rng.cloneContents();
        body.appendChild(contents);
        return selection.serializer.serialize(body, { format: "html" });
      };
      var allContentsSelected = function(rng) {
        var selection2 = serializeRng(rng);
        var allRng = dom2.createRng();
        allRng.selectNode(editor.getBody());
        var allSelection = serializeRng(allRng);
        return selection2 === allSelection;
      };
      editor.on("keydown", function(e) {
        var keyCode = e.keyCode;
        var isCollapsed, body;
        if (!isDefaultPrevented(e) && (keyCode === DELETE2 || keyCode === BACKSPACE)) {
          isCollapsed = editor.selection.isCollapsed();
          body = editor.getBody();
          if (isCollapsed && !dom2.isEmpty(body)) {
            return;
          }
          if (!isCollapsed && !allContentsSelected(editor.selection.getRng())) {
            return;
          }
          e.preventDefault();
          editor.setContent("");
          if (body.firstChild && dom2.isBlock(body.firstChild)) {
            editor.selection.setCursorLocation(body.firstChild, 0);
          } else {
            editor.selection.setCursorLocation(body, 0);
          }
          editor.nodeChanged();
        }
      });
    };
    var selectAll = function() {
      editor.shortcuts.add("meta+a", null, "SelectAll");
    };
    var inputMethodFocus = function() {
      if (!editor.inline) {
        dom2.bind(editor.getDoc(), "mousedown mouseup", function(e) {
          var rng;
          if (e.target === editor.getDoc().documentElement) {
            rng = selection.getRng();
            editor.getBody().focus();
            if (e.type === "mousedown") {
              if (isCaretContainer(rng.startContainer)) {
                return;
              }
              selection.placeCaretAt(e.clientX, e.clientY);
            } else {
              selection.setRng(rng);
            }
          }
        });
      }
    };
    var removeHrOnBackspace = function() {
      editor.on("keydown", function(e) {
        if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {
          if (!editor.getBody().getElementsByTagName("hr").length) {
            return;
          }
          if (selection.isCollapsed() && selection.getRng().startOffset === 0) {
            var node = selection.getNode();
            var previousSibling = node.previousSibling;
            if (node.nodeName === "HR") {
              dom2.remove(node);
              e.preventDefault();
              return;
            }
            if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === "hr") {
              dom2.remove(previousSibling);
              e.preventDefault();
            }
          }
        }
      });
    };
    var focusBody2 = function() {
      if (!Range.prototype.getClientRects) {
        editor.on("mousedown", function(e) {
          if (!isDefaultPrevented(e) && e.target.nodeName === "HTML") {
            var body_1 = editor.getBody();
            body_1.blur();
            Delay.setEditorTimeout(editor, function() {
              body_1.focus();
            });
          }
        });
      }
    };
    var selectControlElements = function() {
      editor.on("click", function(e) {
        var target = e.target;
        if (/^(IMG|HR)$/.test(target.nodeName) && dom2.getContentEditableParent(target) !== "false") {
          e.preventDefault();
          editor.selection.select(target);
          editor.nodeChanged();
        }
        if (target.nodeName === "A" && dom2.hasClass(target, "mce-item-anchor")) {
          e.preventDefault();
          selection.select(target);
        }
      });
    };
    var removeStylesWhenDeletingAcrossBlockElements = function() {
      var getAttributeApplyFunction = function() {
        var template = dom2.getAttribs(selection.getStart().cloneNode(false));
        return function() {
          var target = selection.getStart();
          if (target !== editor.getBody()) {
            dom2.setAttrib(target, "style", null);
            each2(template, function(attr) {
              target.setAttributeNode(attr.cloneNode(true));
            });
          }
        };
      };
      var isSelectionAcrossElements = function() {
        return !selection.isCollapsed() && dom2.getParent(selection.getStart(), dom2.isBlock) !== dom2.getParent(selection.getEnd(), dom2.isBlock);
      };
      editor.on("keypress", function(e) {
        var applyAttributes2;
        if (!isDefaultPrevented(e) && (e.keyCode === 8 || e.keyCode === 46) && isSelectionAcrossElements()) {
          applyAttributes2 = getAttributeApplyFunction();
          editor.getDoc().execCommand("delete", false, null);
          applyAttributes2();
          e.preventDefault();
          return false;
        }
      });
      dom2.bind(editor.getDoc(), "cut", function(e) {
        var applyAttributes2;
        if (!isDefaultPrevented(e) && isSelectionAcrossElements()) {
          applyAttributes2 = getAttributeApplyFunction();
          Delay.setEditorTimeout(editor, function() {
            applyAttributes2();
          });
        }
      });
    };
    var disableBackspaceIntoATable = function() {
      editor.on("keydown", function(e) {
        if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {
          if (selection.isCollapsed() && selection.getRng().startOffset === 0) {
            var previousSibling = selection.getNode().previousSibling;
            if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === "table") {
              e.preventDefault();
              return false;
            }
          }
        }
      });
    };
    var removeBlockQuoteOnBackSpace = function() {
      editor.on("keydown", function(e) {
        var rng, parent2;
        if (isDefaultPrevented(e) || e.keyCode !== VK.BACKSPACE) {
          return;
        }
        rng = selection.getRng();
        var container = rng.startContainer;
        var offset = rng.startOffset;
        var root = dom2.getRoot();
        parent2 = container;
        if (!rng.collapsed || offset !== 0) {
          return;
        }
        while (parent2 && parent2.parentNode && parent2.parentNode.firstChild === parent2 && parent2.parentNode !== root) {
          parent2 = parent2.parentNode;
        }
        if (parent2.tagName === "BLOCKQUOTE") {
          editor.formatter.toggle("blockquote", null, parent2);
          rng = dom2.createRng();
          rng.setStart(container, 0);
          rng.setEnd(container, 0);
          selection.setRng(rng);
        }
      });
    };
    var setGeckoEditingOptions = function() {
      var setOpts = function() {
        setEditorCommandState2("StyleWithCSS", false);
        setEditorCommandState2("enableInlineTableEditing", false);
        if (!getObjectResizing(editor)) {
          setEditorCommandState2("enableObjectResizing", false);
        }
      };
      if (!isReadOnly(editor)) {
        editor.on("BeforeExecCommand mousedown", setOpts);
      }
    };
    var addBrAfterLastLinks = function() {
      var fixLinks = function() {
        each2(dom2.select("a"), function(node) {
          var parentNode = node.parentNode;
          var root = dom2.getRoot();
          if (parentNode.lastChild === node) {
            while (parentNode && !dom2.isBlock(parentNode)) {
              if (parentNode.parentNode.lastChild !== parentNode || parentNode === root) {
                return;
              }
              parentNode = parentNode.parentNode;
            }
            dom2.add(parentNode, "br", { "data-mce-bogus": 1 });
          }
        });
      };
      editor.on("SetContent ExecCommand", function(e) {
        if (e.type === "setcontent" || e.command === "mceInsertLink") {
          fixLinks();
        }
      });
    };
    var setDefaultBlockType = function() {
      if (getForcedRootBlock(editor)) {
        editor.on("init", function() {
          setEditorCommandState2("DefaultParagraphSeparator", getForcedRootBlock(editor));
        });
      }
    };
    var normalizeSelection2 = function() {
      editor.on("keyup focusin mouseup", function(e) {
        if (!VK.modifierPressed(e)) {
          selection.normalize();
        }
      }, true);
    };
    var showBrokenImageIcon = function() {
      editor.contentStyles.push("img:-moz-broken {-moz-force-broken-image-icon:1;min-width:24px;min-height:24px}");
    };
    var restoreFocusOnKeyDown = function() {
      if (!editor.inline) {
        editor.on("keydown", function() {
          if (document.activeElement === document.body) {
            editor.getWin().focus();
          }
        });
      }
    };
    var bodyHeight = function() {
      if (!editor.inline) {
        editor.contentStyles.push("body {min-height: 150px}");
        editor.on("click", function(e) {
          var rng;
          if (e.target.nodeName === "HTML") {
            if (Env.ie > 11) {
              editor.getBody().focus();
              return;
            }
            rng = editor.selection.getRng();
            editor.getBody().focus();
            editor.selection.setRng(rng);
            editor.selection.normalize();
            editor.nodeChanged();
          }
        });
      }
    };
    var blockCmdArrowNavigation = function() {
      if (Env.mac) {
        editor.on("keydown", function(e) {
          if (VK.metaKeyPressed(e) && !e.shiftKey && (e.keyCode === 37 || e.keyCode === 39)) {
            e.preventDefault();
            var selection_1 = editor.selection.getSel();
            selection_1.modify("move", e.keyCode === 37 ? "backward" : "forward", "lineboundary");
          }
        });
      }
    };
    var disableAutoUrlDetect = function() {
      setEditorCommandState2("AutoUrlDetect", false);
    };
    var tapLinksAndImages = function() {
      editor.on("click", function(e) {
        var elm = e.target;
        do {
          if (elm.tagName === "A") {
            e.preventDefault();
            return;
          }
        } while (elm = elm.parentNode);
      });
      editor.contentStyles.push(".mce-content-body {-webkit-touch-callout: none}");
    };
    var blockFormSubmitInsideEditor = function() {
      editor.on("init", function() {
        editor.dom.bind(editor.getBody(), "submit", function(e) {
          e.preventDefault();
        });
      });
    };
    var removeAppleInterchangeBrs = function() {
      parser.addNodeFilter("br", function(nodes) {
        var i = nodes.length;
        while (i--) {
          if (nodes[i].attr("class") === "Apple-interchange-newline") {
            nodes[i].remove();
          }
        }
      });
    };
    var ieInternalDragAndDrop = function() {
      editor.on("dragstart", function(e) {
        setMceInternalContent(e);
      });
      editor.on("drop", function(e) {
        if (!isDefaultPrevented(e)) {
          var internalContent = getMceInternalContent(e);
          if (internalContent && internalContent.id !== editor.id) {
            e.preventDefault();
            var rng = fromPoint$1(e.x, e.y, editor.getDoc());
            selection.setRng(rng);
            insertClipboardContents(internalContent.html, true);
          }
        }
      });
    };
    var refreshContentEditable = noop;
    var isHidden = function() {
      if (!isGecko || editor.removed) {
        return false;
      }
      var sel = editor.selection.getSel();
      return !sel || !sel.rangeCount || sel.rangeCount === 0;
    };
    var setupRtc = function() {
      if (isWebKit) {
        selectControlElements();
        blockFormSubmitInsideEditor();
        selectAll();
        if (Env.iOS) {
          restoreFocusOnKeyDown();
          bodyHeight();
          tapLinksAndImages();
        }
      }
      if (isGecko) {
        focusBody2();
        setGeckoEditingOptions();
        showBrokenImageIcon();
        blockCmdArrowNavigation();
      }
    };
    var setup2 = function() {
      removeBlockQuoteOnBackSpace();
      emptyEditorWhenDeleting();
      if (!Env.windowsPhone) {
        normalizeSelection2();
      }
      if (isWebKit) {
        inputMethodFocus();
        selectControlElements();
        setDefaultBlockType();
        blockFormSubmitInsideEditor();
        disableBackspaceIntoATable();
        removeAppleInterchangeBrs();
        if (Env.iOS) {
          restoreFocusOnKeyDown();
          bodyHeight();
          tapLinksAndImages();
        } else {
          selectAll();
        }
      }
      if (Env.ie >= 11) {
        bodyHeight();
        disableBackspaceIntoATable();
      }
      if (Env.ie) {
        selectAll();
        disableAutoUrlDetect();
        ieInternalDragAndDrop();
      }
      if (isGecko) {
        removeHrOnBackspace();
        focusBody2();
        removeStylesWhenDeletingAcrossBlockElements();
        setGeckoEditingOptions();
        addBrAfterLastLinks();
        showBrokenImageIcon();
        blockCmdArrowNavigation();
        disableBackspaceIntoATable();
      }
    };
    if (isRtc(editor)) {
      setupRtc();
    } else {
      setup2();
    }
    return {
      refreshContentEditable,
      isHidden
    };
  };
  var DOM$4 = DOMUtils.DOM;
  var appendStyle = function(editor, text) {
    var body = SugarElement.fromDom(editor.getBody());
    var container = getStyleContainer(getRootNode(body));
    var style = SugarElement.fromTag("style");
    set(style, "type", "text/css");
    append(style, SugarElement.fromText(text));
    append(container, style);
    editor.on("remove", function() {
      remove(style);
    });
  };
  var getRootName = function(editor) {
    return editor.inline ? editor.getElement().nodeName.toLowerCase() : void 0;
  };
  var removeUndefined = function(obj) {
    return filter$1(obj, function(v2) {
      return isUndefined(v2) === false;
    });
  };
  var mkParserSettings = function(editor) {
    var settings = editor.settings;
    var blobCache = editor.editorUpload.blobCache;
    return removeUndefined({
      allow_conditional_comments: settings.allow_conditional_comments,
      allow_html_data_urls: settings.allow_html_data_urls,
      allow_svg_data_urls: settings.allow_svg_data_urls,
      allow_html_in_named_anchor: settings.allow_html_in_named_anchor,
      allow_script_urls: settings.allow_script_urls,
      allow_unsafe_link_target: settings.allow_unsafe_link_target,
      convert_fonts_to_spans: settings.convert_fonts_to_spans,
      fix_list_elements: settings.fix_list_elements,
      font_size_legacy_values: settings.font_size_legacy_values,
      forced_root_block: settings.forced_root_block,
      forced_root_block_attrs: settings.forced_root_block_attrs,
      padd_empty_with_br: settings.padd_empty_with_br,
      preserve_cdata: settings.preserve_cdata,
      remove_trailing_brs: settings.remove_trailing_brs,
      inline_styles: settings.inline_styles,
      root_name: getRootName(editor),
      validate: true,
      blob_cache: blobCache,
      images_dataimg_filter: settings.images_dataimg_filter
    });
  };
  var mkSerializerSettings = function(editor) {
    var settings = editor.settings;
    return __assign2(__assign2({}, mkParserSettings(editor)), removeUndefined({
      url_converter: settings.url_converter,
      url_converter_scope: settings.url_converter_scope,
      element_format: settings.element_format,
      entities: settings.entities,
      entity_encoding: settings.entity_encoding,
      indent: settings.indent,
      indent_after: settings.indent_after,
      indent_before: settings.indent_before,
      block_elements: settings.block_elements,
      boolean_attributes: settings.boolean_attributes,
      custom_elements: settings.custom_elements,
      extended_valid_elements: settings.extended_valid_elements,
      invalid_elements: settings.invalid_elements,
      invalid_styles: settings.invalid_styles,
      move_caret_before_on_enter_elements: settings.move_caret_before_on_enter_elements,
      non_empty_elements: settings.non_empty_elements,
      schema: settings.schema,
      self_closing_elements: settings.self_closing_elements,
      short_ended_elements: settings.short_ended_elements,
      special: settings.special,
      text_block_elements: settings.text_block_elements,
      text_inline_elements: settings.text_inline_elements,
      valid_children: settings.valid_children,
      valid_classes: settings.valid_classes,
      valid_elements: settings.valid_elements,
      valid_styles: settings.valid_styles,
      verify_html: settings.verify_html,
      whitespace_elements: settings.whitespace_elements
    }));
  };
  var createParser = function(editor) {
    var parser = DomParser(mkParserSettings(editor), editor.schema);
    parser.addAttributeFilter("src,href,style,tabindex", function(nodes, name2) {
      var i = nodes.length, node, value2;
      var dom2 = editor.dom;
      var internalName = "data-mce-" + name2;
      while (i--) {
        node = nodes[i];
        value2 = node.attr(name2);
        if (value2 && !node.attr(internalName)) {
          if (value2.indexOf("data:") === 0 || value2.indexOf("blob:") === 0) {
            continue;
          }
          if (name2 === "style") {
            value2 = dom2.serializeStyle(dom2.parseStyle(value2), node.name);
            if (!value2.length) {
              value2 = null;
            }
            node.attr(internalName, value2);
            node.attr(name2, value2);
          } else if (name2 === "tabindex") {
            node.attr(internalName, value2);
            node.attr(name2, null);
          } else {
            node.attr(internalName, editor.convertURL(value2, name2, node.name));
          }
        }
      }
    });
    parser.addNodeFilter("script", function(nodes) {
      var i = nodes.length;
      while (i--) {
        var node = nodes[i];
        var type2 = node.attr("type") || "no/type";
        if (type2.indexOf("mce-") !== 0) {
          node.attr("type", "mce-" + type2);
        }
      }
    });
    if (editor.settings.preserve_cdata) {
      parser.addNodeFilter("#cdata", function(nodes) {
        var i = nodes.length;
        while (i--) {
          var node = nodes[i];
          node.type = 8;
          node.name = "#comment";
          node.value = "[CDATA[" + editor.dom.encode(node.value) + "]]";
        }
      });
    }
    parser.addNodeFilter("p,h1,h2,h3,h4,h5,h6,div", function(nodes) {
      var i = nodes.length;
      var nonEmptyElements = editor.schema.getNonEmptyElements();
      while (i--) {
        var node = nodes[i];
        if (node.isEmpty(nonEmptyElements) && node.getAll("br").length === 0) {
          node.append(new AstNode("br", 1)).shortEnded = true;
        }
      }
    });
    return parser;
  };
  var autoFocus = function(editor) {
    if (editor.settings.auto_focus) {
      Delay.setEditorTimeout(editor, function() {
        var focusEditor2;
        if (editor.settings.auto_focus === true) {
          focusEditor2 = editor;
        } else {
          focusEditor2 = editor.editorManager.get(editor.settings.auto_focus);
        }
        if (!focusEditor2.destroyed) {
          focusEditor2.focus();
        }
      }, 100);
    }
  };
  var moveSelectionToFirstCaretPosition = function(editor) {
    var root = editor.dom.getRoot();
    if (!editor.inline && (!hasAnyRanges(editor) || editor.selection.getStart(true) === root)) {
      firstPositionIn(root).each(function(pos) {
        var node = pos.getNode();
        var caretPos = isTable(node) ? firstPositionIn(node).getOr(pos) : pos;
        if (Env.browser.isIE()) {
          storeNative(editor, caretPos.toRange());
        } else {
          editor.selection.setRng(caretPos.toRange());
        }
      });
    }
  };
  var initEditor = function(editor) {
    editor.bindPendingEventDelegates();
    editor.initialized = true;
    fireInit(editor);
    editor.focus(true);
    moveSelectionToFirstCaretPosition(editor);
    editor.nodeChanged({ initial: true });
    editor.execCallback("init_instance_callback", editor);
    autoFocus(editor);
  };
  var getStyleSheetLoader = function(editor) {
    return editor.inline ? editor.ui.styleSheetLoader : editor.dom.styleSheetLoader;
  };
  var makeStylesheetLoadingPromises = function(editor, css, framedFonts) {
    var promises = [new promiseObj(function(resolve2, reject) {
      return getStyleSheetLoader(editor).loadAll(css, resolve2, reject);
    })];
    if (editor.inline) {
      return promises;
    } else {
      return promises.concat([new promiseObj(function(resolve2, reject) {
        return editor.ui.styleSheetLoader.loadAll(framedFonts, resolve2, reject);
      })]);
    }
  };
  var loadContentCss = function(editor, css) {
    var styleSheetLoader = getStyleSheetLoader(editor);
    var fontCss = getFontCss(editor);
    var removeCss = function() {
      styleSheetLoader.unloadAll(css);
      if (!editor.inline) {
        editor.ui.styleSheetLoader.unloadAll(fontCss);
      }
    };
    var loaded = function() {
      if (editor.removed) {
        removeCss();
      } else {
        editor.on("remove", removeCss);
        initEditor(editor);
      }
    };
    promiseObj.all(makeStylesheetLoadingPromises(editor, css, fontCss)).then(loaded).catch(loaded);
  };
  var preInit = function(editor) {
    var settings = editor.settings, doc2 = editor.getDoc(), body = editor.getBody();
    if (!settings.browser_spellcheck && !settings.gecko_spellcheck) {
      doc2.body.spellcheck = false;
      DOM$4.setAttrib(body, "spellcheck", "false");
    }
    editor.quirks = Quirks(editor);
    firePostRender(editor);
    var directionality = getDirectionality(editor);
    if (directionality !== void 0) {
      body.dir = directionality;
    }
    if (settings.protect) {
      editor.on("BeforeSetContent", function(e) {
        Tools.each(settings.protect, function(pattern) {
          e.content = e.content.replace(pattern, function(str) {
            return "<!--mce:protected " + escape(str) + "-->";
          });
        });
      });
    }
    editor.on("SetContent", function() {
      editor.addVisual(editor.getBody());
    });
    if (!isRtc(editor)) {
      editor.load({
        initial: true,
        format: "html"
      });
    }
    editor.startContent = editor.getContent({ format: "raw" });
    editor.on("compositionstart compositionend", function(e) {
      editor.composing = e.type === "compositionstart";
    });
    if (editor.contentStyles.length > 0) {
      var contentCssText_1 = "";
      Tools.each(editor.contentStyles, function(style) {
        contentCssText_1 += style + "\r\n";
      });
      editor.dom.addStyle(contentCssText_1);
    }
    loadContentCss(editor, editor.contentCSS);
    if (settings.content_style) {
      appendStyle(editor, settings.content_style);
    }
  };
  var initContentBody = function(editor, skipWrite) {
    var settings = editor.settings;
    var targetElm = editor.getElement();
    var doc2 = editor.getDoc();
    if (!settings.inline) {
      editor.getElement().style.visibility = editor.orgVisibility;
    }
    if (!skipWrite && !editor.inline) {
      doc2.open();
      doc2.write(editor.iframeHTML);
      doc2.close();
    }
    if (editor.inline) {
      DOM$4.addClass(targetElm, "mce-content-body");
      editor.contentDocument = doc2 = document;
      editor.contentWindow = window;
      editor.bodyElement = targetElm;
      editor.contentAreaContainer = targetElm;
    }
    var body = editor.getBody();
    body.disabled = true;
    editor.readonly = !!settings.readonly;
    if (!editor.readonly) {
      if (editor.inline && DOM$4.getStyle(body, "position", true) === "static") {
        body.style.position = "relative";
      }
      body.contentEditable = editor.getParam("content_editable_state", true);
    }
    body.disabled = false;
    editor.editorUpload = EditorUpload(editor);
    editor.schema = Schema(settings);
    editor.dom = DOMUtils(doc2, {
      keep_values: true,
      url_converter: editor.convertURL,
      url_converter_scope: editor,
      hex_colors: settings.force_hex_style_colors,
      update_styles: true,
      root_element: editor.inline ? editor.getBody() : null,
      collect: function() {
        return editor.inline;
      },
      schema: editor.schema,
      contentCssCors: shouldUseContentCssCors(editor),
      referrerPolicy: getReferrerPolicy(editor),
      onSetAttrib: function(e) {
        editor.fire("SetAttrib", e);
      }
    });
    editor.parser = createParser(editor);
    editor.serializer = DomSerializer(mkSerializerSettings(editor), editor);
    editor.selection = EditorSelection(editor.dom, editor.getWin(), editor.serializer, editor);
    editor.annotator = Annotator(editor);
    editor.formatter = Formatter(editor);
    editor.undoManager = UndoManager(editor);
    editor._nodeChangeDispatcher = new NodeChange(editor);
    editor._selectionOverrides = SelectionOverrides(editor);
    setup$9(editor);
    setup$k(editor);
    if (!isRtc(editor)) {
      setup$l(editor);
    }
    var caret = setup$j(editor);
    setup$8(editor, caret);
    setup$a(editor);
    setup$7(editor);
    firePreInit(editor);
    setup$5(editor).fold(function() {
      preInit(editor);
    }, function(loadingRtc) {
      editor.setProgressState(true);
      loadingRtc.then(function(_rtcMode) {
        editor.setProgressState(false);
        preInit(editor);
      }, function(err) {
        editor.notificationManager.open({
          type: "error",
          text: String(err)
        });
        preInit(editor);
      });
    });
  };
  var DOM$5 = DOMUtils.DOM;
  var relaxDomain = function(editor, ifr) {
    if (document.domain !== window.location.hostname && Env.browser.isIE()) {
      var bodyUuid = uuid2("mce");
      editor[bodyUuid] = function() {
        initContentBody(editor);
      };
      var domainRelaxUrl = 'javascript:(function(){document.open();document.domain="' + document.domain + '";var ed = window.parent.tinymce.get("' + editor.id + '");document.write(ed.iframeHTML);document.close();ed.' + bodyUuid + "(true);})()";
      DOM$5.setAttrib(ifr, "src", domainRelaxUrl);
      return true;
    }
    return false;
  };
  var createIframeElement = function(id2, title, height, customAttrs) {
    var iframe = SugarElement.fromTag("iframe");
    setAll(iframe, customAttrs);
    setAll(iframe, {
      id: id2 + "_ifr",
      frameBorder: "0",
      allowTransparency: "true",
      title
    });
    add$3(iframe, "tox-edit-area__iframe");
    return iframe;
  };
  var getIframeHtml = function(editor) {
    var iframeHTML = getDocType(editor) + "<html><head>";
    if (getDocumentBaseUrl(editor) !== editor.documentBaseUrl) {
      iframeHTML += '<base href="' + editor.documentBaseURI.getURI() + '" />';
    }
    iframeHTML += '<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />';
    var bodyId = getBodyId(editor);
    var bodyClass = getBodyClass(editor);
    if (getContentSecurityPolicy(editor)) {
      iframeHTML += '<meta http-equiv="Content-Security-Policy" content="' + getContentSecurityPolicy(editor) + '" />';
    }
    iframeHTML += '</head><body id="' + bodyId + '" class="mce-content-body ' + bodyClass + '" data-id="' + editor.id + '"><br></body></html>';
    return iframeHTML;
  };
  var createIframe = function(editor, o) {
    var title = editor.editorManager.translate("Rich Text Area. Press ALT-0 for help.");
    var ifr = createIframeElement(editor.id, title, o.height, getIframeAttrs(editor)).dom;
    ifr.onload = function() {
      ifr.onload = null;
      editor.fire("load");
    };
    var isDomainRelaxed = relaxDomain(editor, ifr);
    editor.contentAreaContainer = o.iframeContainer;
    editor.iframeElement = ifr;
    editor.iframeHTML = getIframeHtml(editor);
    DOM$5.add(o.iframeContainer, ifr);
    return isDomainRelaxed;
  };
  var init$1 = function(editor, boxInfo) {
    var isDomainRelaxed = createIframe(editor, boxInfo);
    if (boxInfo.editorContainer) {
      DOM$5.get(boxInfo.editorContainer).style.display = editor.orgDisplay;
      editor.hidden = DOM$5.isHidden(boxInfo.editorContainer);
    }
    editor.getElement().style.display = "none";
    DOM$5.setAttrib(editor.id, "aria-hidden", "true");
    if (!isDomainRelaxed) {
      initContentBody(editor);
    }
  };
  var DOM$6 = DOMUtils.DOM;
  var initPlugin = function(editor, initializedPlugins, plugin) {
    var Plugin = PluginManager.get(plugin);
    var pluginUrl = PluginManager.urls[plugin] || editor.documentBaseUrl.replace(/\/$/, "");
    plugin = Tools.trim(plugin);
    if (Plugin && Tools.inArray(initializedPlugins, plugin) === -1) {
      Tools.each(PluginManager.dependencies(plugin), function(dep) {
        initPlugin(editor, initializedPlugins, dep);
      });
      if (editor.plugins[plugin]) {
        return;
      }
      try {
        var pluginInstance = new Plugin(editor, pluginUrl, editor.$);
        editor.plugins[plugin] = pluginInstance;
        if (pluginInstance.init) {
          pluginInstance.init(editor, pluginUrl);
          initializedPlugins.push(plugin);
        }
      } catch (e) {
        pluginInitError(editor, plugin, e);
      }
    }
  };
  var trimLegacyPrefix = function(name2) {
    return name2.replace(/^\-/, "");
  };
  var initPlugins = function(editor) {
    var initializedPlugins = [];
    Tools.each(getPlugins(editor).split(/[ ,]/), function(name2) {
      initPlugin(editor, initializedPlugins, trimLegacyPrefix(name2));
    });
  };
  var initIcons = function(editor) {
    var iconPackName = Tools.trim(getIconPackName(editor));
    var currentIcons = editor.ui.registry.getAll().icons;
    var loadIcons2 = __assign2(__assign2({}, IconManager.get("default").icons), IconManager.get(iconPackName).icons);
    each$1(loadIcons2, function(svgData, icon) {
      if (!has(currentIcons, icon)) {
        editor.ui.registry.addIcon(icon, svgData);
      }
    });
  };
  var initTheme = function(editor) {
    var theme = getTheme(editor);
    if (isString(theme)) {
      editor.settings.theme = trimLegacyPrefix(theme);
      var Theme = ThemeManager.get(theme);
      editor.theme = new Theme(editor, ThemeManager.urls[theme]);
      if (editor.theme.init) {
        editor.theme.init(editor, ThemeManager.urls[theme] || editor.documentBaseUrl.replace(/\/$/, ""), editor.$);
      }
    } else {
      editor.theme = {};
    }
  };
  var renderFromLoadedTheme = function(editor) {
    return editor.theme.renderUI();
  };
  var renderFromThemeFunc = function(editor) {
    var elm = editor.getElement();
    var theme = getTheme(editor);
    var info = theme(editor, elm);
    if (info.editorContainer.nodeType) {
      info.editorContainer.id = info.editorContainer.id || editor.id + "_parent";
    }
    if (info.iframeContainer && info.iframeContainer.nodeType) {
      info.iframeContainer.id = info.iframeContainer.id || editor.id + "_iframecontainer";
    }
    info.height = info.iframeHeight ? info.iframeHeight : elm.offsetHeight;
    return info;
  };
  var createThemeFalseResult = function(element) {
    return {
      editorContainer: element,
      iframeContainer: element,
      api: {}
    };
  };
  var renderThemeFalseIframe = function(targetElement) {
    var iframeContainer = DOM$6.create("div");
    DOM$6.insertAfter(iframeContainer, targetElement);
    return createThemeFalseResult(iframeContainer);
  };
  var renderThemeFalse = function(editor) {
    var targetElement = editor.getElement();
    return editor.inline ? createThemeFalseResult(null) : renderThemeFalseIframe(targetElement);
  };
  var renderThemeUi = function(editor) {
    var elm = editor.getElement();
    editor.orgDisplay = elm.style.display;
    if (isString(getTheme(editor))) {
      return renderFromLoadedTheme(editor);
    } else if (isFunction2(getTheme(editor))) {
      return renderFromThemeFunc(editor);
    } else {
      return renderThemeFalse(editor);
    }
  };
  var augmentEditorUiApi = function(editor, api2) {
    var uiApiFacade = {
      show: Optional.from(api2.show).getOr(noop),
      hide: Optional.from(api2.hide).getOr(noop),
      disable: Optional.from(api2.disable).getOr(noop),
      isDisabled: Optional.from(api2.isDisabled).getOr(never),
      enable: function() {
        if (!editor.mode.isReadOnly()) {
          Optional.from(api2.enable).map(call);
        }
      }
    };
    editor.ui = __assign2(__assign2({}, editor.ui), uiApiFacade);
  };
  var init$2 = function(editor) {
    editor.fire("ScriptsLoaded");
    initIcons(editor);
    initTheme(editor);
    initPlugins(editor);
    var renderInfo = renderThemeUi(editor);
    augmentEditorUiApi(editor, Optional.from(renderInfo.api).getOr({}));
    var boxInfo = {
      editorContainer: renderInfo.editorContainer,
      iframeContainer: renderInfo.iframeContainer
    };
    editor.editorContainer = boxInfo.editorContainer ? boxInfo.editorContainer : null;
    appendContentCssFromSettings(editor);
    if (editor.inline) {
      return initContentBody(editor);
    } else {
      return init$1(editor, boxInfo);
    }
  };
  var DOM$7 = DOMUtils.DOM;
  var hasSkipLoadPrefix = function(name2) {
    return name2.charAt(0) === "-";
  };
  var loadLanguage = function(scriptLoader, editor) {
    var languageCode = getLanguageCode(editor);
    var languageUrl = getLanguageUrl(editor);
    if (I18n.hasCode(languageCode) === false && languageCode !== "en") {
      var url_1 = languageUrl !== "" ? languageUrl : editor.editorManager.baseURL + "/langs/" + languageCode + ".js";
      scriptLoader.add(url_1, noop, void 0, function() {
        languageLoadError(editor, url_1, languageCode);
      });
    }
  };
  var loadTheme = function(scriptLoader, editor, suffix, callback) {
    var theme = getTheme(editor);
    if (isString(theme)) {
      if (!hasSkipLoadPrefix(theme) && !ThemeManager.urls.hasOwnProperty(theme)) {
        var themeUrl = getThemeUrl(editor);
        if (themeUrl) {
          ThemeManager.load(theme, editor.documentBaseURI.toAbsolute(themeUrl));
        } else {
          ThemeManager.load(theme, "themes/" + theme + "/theme" + suffix + ".js");
        }
      }
      scriptLoader.loadQueue(function() {
        ThemeManager.waitFor(theme, callback);
      });
    } else {
      callback();
    }
  };
  var getIconsUrlMetaFromUrl = function(editor) {
    return Optional.from(getIconsUrl(editor)).filter(function(url) {
      return url.length > 0;
    }).map(function(url) {
      return {
        url,
        name: Optional.none()
      };
    });
  };
  var getIconsUrlMetaFromName = function(editor, name2, suffix) {
    return Optional.from(name2).filter(function(name3) {
      return name3.length > 0 && !IconManager.has(name3);
    }).map(function(name3) {
      return {
        url: editor.editorManager.baseURL + "/icons/" + name3 + "/icons" + suffix + ".js",
        name: Optional.some(name3)
      };
    });
  };
  var loadIcons = function(scriptLoader, editor, suffix) {
    var defaultIconsUrl = getIconsUrlMetaFromName(editor, "default", suffix);
    var customIconsUrl = getIconsUrlMetaFromUrl(editor).orThunk(function() {
      return getIconsUrlMetaFromName(editor, getIconPackName(editor), "");
    });
    each(cat([
      defaultIconsUrl,
      customIconsUrl
    ]), function(urlMeta) {
      scriptLoader.add(urlMeta.url, noop, void 0, function() {
        iconsLoadError(editor, urlMeta.url, urlMeta.name.getOrUndefined());
      });
    });
  };
  var loadPlugins = function(editor, suffix) {
    Tools.each(getExternalPlugins(editor), function(url, name2) {
      PluginManager.load(name2, url, noop, void 0, function() {
        pluginLoadError(editor, url, name2);
      });
      editor.settings.plugins += " " + name2;
    });
    Tools.each(getPlugins(editor).split(/[ ,]/), function(plugin) {
      plugin = Tools.trim(plugin);
      if (plugin && !PluginManager.urls[plugin]) {
        if (hasSkipLoadPrefix(plugin)) {
          plugin = plugin.substr(1, plugin.length);
          var dependencies = PluginManager.dependencies(plugin);
          Tools.each(dependencies, function(depPlugin) {
            var defaultSettings = {
              prefix: "plugins/",
              resource: depPlugin,
              suffix: "/plugin" + suffix + ".js"
            };
            var dep = PluginManager.createUrl(defaultSettings, depPlugin);
            PluginManager.load(dep.resource, dep, noop, void 0, function() {
              pluginLoadError(editor, dep.prefix + dep.resource + dep.suffix, dep.resource);
            });
          });
        } else {
          var url_2 = {
            prefix: "plugins/",
            resource: plugin,
            suffix: "/plugin" + suffix + ".js"
          };
          PluginManager.load(plugin, url_2, noop, void 0, function() {
            pluginLoadError(editor, url_2.prefix + url_2.resource + url_2.suffix, plugin);
          });
        }
      }
    });
  };
  var loadScripts = function(editor, suffix) {
    var scriptLoader = ScriptLoader2.ScriptLoader;
    loadTheme(scriptLoader, editor, suffix, function() {
      loadLanguage(scriptLoader, editor);
      loadIcons(scriptLoader, editor, suffix);
      loadPlugins(editor, suffix);
      scriptLoader.loadQueue(function() {
        if (!editor.removed) {
          init$2(editor);
        }
      }, editor, function() {
        if (!editor.removed) {
          init$2(editor);
        }
      });
    });
  };
  var getStyleSheetLoader$1 = function(element, editor) {
    return instance.forElement(element, {
      contentCssCors: hasContentCssCors(editor),
      referrerPolicy: getReferrerPolicy(editor)
    });
  };
  var render = function(editor) {
    var id2 = editor.id;
    I18n.setCode(getLanguageCode(editor));
    var readyHandler = function() {
      DOM$7.unbind(window, "ready", readyHandler);
      editor.render();
    };
    if (!EventUtils.Event.domLoaded) {
      DOM$7.bind(window, "ready", readyHandler);
      return;
    }
    if (!editor.getElement()) {
      return;
    }
    if (!Env.contentEditable) {
      return;
    }
    var element = SugarElement.fromDom(editor.getElement());
    var snapshot = clone(element);
    editor.on("remove", function() {
      eachr(element.dom.attributes, function(attr) {
        return remove$1(element, attr.name);
      });
      setAll(element, snapshot);
    });
    editor.ui.styleSheetLoader = getStyleSheetLoader$1(element, editor);
    if (!isInline$1(editor)) {
      editor.orgVisibility = editor.getElement().style.visibility;
      editor.getElement().style.visibility = "hidden";
    } else {
      editor.inline = true;
    }
    var form = editor.getElement().form || DOM$7.getParent(id2, "form");
    if (form) {
      editor.formElement = form;
      if (hasHiddenInput(editor) && !isTextareaOrInput2(editor.getElement())) {
        DOM$7.insertAfter(DOM$7.create("input", {
          type: "hidden",
          name: id2
        }), id2);
        editor.hasHiddenInput = true;
      }
      editor.formEventDelegate = function(e) {
        editor.fire(e.type, e);
      };
      DOM$7.bind(form, "submit reset", editor.formEventDelegate);
      editor.on("reset", function() {
        editor.resetContent();
      });
      if (shouldPatchSubmit(editor) && !form.submit.nodeType && !form.submit.length && !form._mceOldSubmit) {
        form._mceOldSubmit = form.submit;
        form.submit = function() {
          editor.editorManager.triggerSave();
          editor.setDirty(false);
          return form._mceOldSubmit(form);
        };
      }
    }
    editor.windowManager = WindowManager(editor);
    editor.notificationManager = NotificationManager(editor);
    if (isEncodingXml(editor)) {
      editor.on("GetContent", function(e) {
        if (e.save) {
          e.content = DOM$7.encode(e.content);
        }
      });
    }
    if (shouldAddFormSubmitTrigger(editor)) {
      editor.on("submit", function() {
        if (editor.initialized) {
          editor.save();
        }
      });
    }
    if (shouldAddUnloadTrigger(editor)) {
      editor._beforeUnload = function() {
        if (editor.initialized && !editor.destroyed && !editor.isHidden()) {
          editor.save({
            format: "raw",
            no_events: true,
            set_dirty: false
          });
        }
      };
      editor.editorManager.on("BeforeUnload", editor._beforeUnload);
    }
    editor.editorManager.add(editor);
    loadScripts(editor, editor.suffix);
  };
  var addVisual$1 = function(editor, elm) {
    return addVisual(editor, elm);
  };
  var legacyPropNames = {
    "font-size": "size",
    "font-family": "face"
  };
  var getSpecifiedFontProp = function(propName, rootElm, elm) {
    var getProperty = function(elm2) {
      return getRaw(elm2, propName).orThunk(function() {
        if (name(elm2) === "font") {
          return get$1(legacyPropNames, propName).bind(function(legacyPropName) {
            return getOpt(elm2, legacyPropName);
          });
        } else {
          return Optional.none();
        }
      });
    };
    var isRoot = function(elm2) {
      return eq$2(SugarElement.fromDom(rootElm), elm2);
    };
    return closest$2(SugarElement.fromDom(elm), function(elm2) {
      return getProperty(elm2);
    }, isRoot);
  };
  var normalizeFontFamily = function(fontFamily) {
    return fontFamily.replace(/[\'\"\\]/g, "").replace(/,\s+/g, ",");
  };
  var getComputedFontProp = function(propName, elm) {
    return Optional.from(DOMUtils.DOM.getStyle(elm, propName, true));
  };
  var getFontProp = function(propName) {
    return function(rootElm, elm) {
      return Optional.from(elm).map(SugarElement.fromDom).filter(isElement).bind(function(element) {
        return getSpecifiedFontProp(propName, rootElm, element.dom).or(getComputedFontProp(propName, element.dom));
      }).getOr("");
    };
  };
  var getFontSize = getFontProp("font-size");
  var getFontFamily = compose(normalizeFontFamily, getFontProp("font-family"));
  var findFirstCaretElement = function(editor) {
    return firstPositionIn(editor.getBody()).map(function(caret) {
      var container = caret.container();
      return isText$1(container) ? container.parentNode : container;
    });
  };
  var getCaretElement = function(editor) {
    return Optional.from(editor.selection.getRng()).bind(function(rng) {
      var root = editor.getBody();
      var atStartOfNode = rng.startContainer === root && rng.startOffset === 0;
      return atStartOfNode ? Optional.none() : Optional.from(editor.selection.getStart(true));
    });
  };
  var mapRange = function(editor, mapper) {
    return getCaretElement(editor).orThunk(curry(findFirstCaretElement, editor)).map(SugarElement.fromDom).filter(isElement).map(mapper);
  };
  var fromFontSizeNumber = function(editor, value2) {
    if (/^[0-9.]+$/.test(value2)) {
      var fontSizeNumber = parseInt(value2, 10);
      if (fontSizeNumber >= 1 && fontSizeNumber <= 7) {
        var fontSizes = getFontStyleValues(editor);
        var fontClasses = getFontSizeClasses(editor);
        if (fontClasses) {
          return fontClasses[fontSizeNumber - 1] || value2;
        } else {
          return fontSizes[fontSizeNumber - 1] || value2;
        }
      } else {
        return value2;
      }
    } else {
      return value2;
    }
  };
  var normalizeFontNames = function(font) {
    var fonts = font.split(/\s*,\s*/);
    return map(fonts, function(font2) {
      if (font2.indexOf(" ") !== -1 && !(startsWith(font2, '"') || startsWith(font2, "'"))) {
        return "'" + font2 + "'";
      } else {
        return font2;
      }
    }).join(",");
  };
  var fontNameAction = function(editor, value2) {
    var font = fromFontSizeNumber(editor, value2);
    editor.formatter.toggle("fontname", { value: normalizeFontNames(font) });
    editor.nodeChanged();
  };
  var fontNameQuery = function(editor) {
    return mapRange(editor, function(elm) {
      return getFontFamily(editor.getBody(), elm.dom);
    }).getOr("");
  };
  var fontSizeAction = function(editor, value2) {
    editor.formatter.toggle("fontsize", { value: fromFontSizeNumber(editor, value2) });
    editor.nodeChanged();
  };
  var fontSizeQuery = function(editor) {
    return mapRange(editor, function(elm) {
      return getFontSize(editor.getBody(), elm.dom);
    }).getOr("");
  };
  var lineHeightQuery = function(editor) {
    return mapRange(editor, function(elm) {
      var root = SugarElement.fromDom(editor.getBody());
      var specifiedStyle = closest$2(elm, function(elm2) {
        return getRaw(elm2, "line-height");
      }, curry(eq$2, root));
      var computedStyle = function() {
        var lineHeight = parseFloat(get$5(elm, "line-height"));
        var fontSize = parseFloat(get$5(elm, "font-size"));
        return String(lineHeight / fontSize);
      };
      return specifiedStyle.getOrThunk(computedStyle);
    }).getOr("");
  };
  var lineHeightAction = function(editor, lineHeight) {
    editor.formatter.toggle("lineheight", { value: String(lineHeight) });
    editor.nodeChanged();
  };
  var processValue = function(value2) {
    var details;
    if (typeof value2 !== "string") {
      details = Tools.extend({
        paste: value2.paste,
        data: { paste: value2.paste }
      }, value2);
      return {
        content: value2.content,
        details
      };
    }
    return {
      content: value2,
      details: {}
    };
  };
  var insertAtCaret$1 = function(editor, value2) {
    var result = processValue(value2);
    insertContent(editor, result.content, result.details);
  };
  var each$f = Tools.each;
  var map$3 = Tools.map, inArray$2 = Tools.inArray;
  var EditorCommands = function() {
    function EditorCommands2(editor) {
      this.commands = {
        state: {},
        exec: {},
        value: {}
      };
      this.editor = editor;
      this.setupCommands(editor);
    }
    EditorCommands2.prototype.execCommand = function(command, ui2, value2, args) {
      var func, state = false;
      var self2 = this;
      if (self2.editor.removed) {
        return;
      }
      if (!/^(mceAddUndoLevel|mceEndUndoLevel|mceBeginUndoLevel|mceRepaint)$/.test(command) && (!args || !args.skip_focus)) {
        self2.editor.focus();
      } else {
        restore(self2.editor);
      }
      args = self2.editor.fire("BeforeExecCommand", {
        command,
        ui: ui2,
        value: value2
      });
      if (args.isDefaultPrevented()) {
        return false;
      }
      var customCommand = command.toLowerCase();
      if (func = self2.commands.exec[customCommand]) {
        func(customCommand, ui2, value2);
        self2.editor.fire("ExecCommand", {
          command,
          ui: ui2,
          value: value2
        });
        return true;
      }
      each$f(this.editor.plugins, function(p2) {
        if (p2.execCommand && p2.execCommand(command, ui2, value2)) {
          self2.editor.fire("ExecCommand", {
            command,
            ui: ui2,
            value: value2
          });
          state = true;
          return false;
        }
      });
      if (state) {
        return state;
      }
      if (self2.editor.theme && self2.editor.theme.execCommand && self2.editor.theme.execCommand(command, ui2, value2)) {
        self2.editor.fire("ExecCommand", {
          command,
          ui: ui2,
          value: value2
        });
        return true;
      }
      try {
        state = self2.editor.getDoc().execCommand(command, ui2, value2);
      } catch (ex) {
      }
      if (state) {
        self2.editor.fire("ExecCommand", {
          command,
          ui: ui2,
          value: value2
        });
        return true;
      }
      return false;
    };
    EditorCommands2.prototype.queryCommandState = function(command) {
      var func;
      if (this.editor.quirks.isHidden() || this.editor.removed) {
        return;
      }
      command = command.toLowerCase();
      if (func = this.commands.state[command]) {
        return func(command);
      }
      try {
        return this.editor.getDoc().queryCommandState(command);
      } catch (ex) {
      }
      return false;
    };
    EditorCommands2.prototype.queryCommandValue = function(command) {
      var func;
      if (this.editor.quirks.isHidden() || this.editor.removed) {
        return;
      }
      command = command.toLowerCase();
      if (func = this.commands.value[command]) {
        return func(command);
      }
      try {
        return this.editor.getDoc().queryCommandValue(command);
      } catch (ex) {
      }
    };
    EditorCommands2.prototype.addCommands = function(commandList, type2) {
      if (type2 === void 0) {
        type2 = "exec";
      }
      var self2 = this;
      each$f(commandList, function(callback, command) {
        each$f(command.toLowerCase().split(","), function(command2) {
          self2.commands[type2][command2] = callback;
        });
      });
    };
    EditorCommands2.prototype.addCommand = function(command, callback, scope) {
      var _this = this;
      command = command.toLowerCase();
      this.commands.exec[command] = function(command2, ui2, value2, args) {
        return callback.call(scope || _this.editor, ui2, value2, args);
      };
    };
    EditorCommands2.prototype.queryCommandSupported = function(command) {
      command = command.toLowerCase();
      if (this.commands.exec[command]) {
        return true;
      }
      try {
        return this.editor.getDoc().queryCommandSupported(command);
      } catch (ex) {
      }
      return false;
    };
    EditorCommands2.prototype.addQueryStateHandler = function(command, callback, scope) {
      var _this = this;
      command = command.toLowerCase();
      this.commands.state[command] = function() {
        return callback.call(scope || _this.editor);
      };
    };
    EditorCommands2.prototype.addQueryValueHandler = function(command, callback, scope) {
      var _this = this;
      command = command.toLowerCase();
      this.commands.value[command] = function() {
        return callback.call(scope || _this.editor);
      };
    };
    EditorCommands2.prototype.hasCustomCommand = function(command) {
      command = command.toLowerCase();
      return !!this.commands.exec[command];
    };
    EditorCommands2.prototype.execNativeCommand = function(command, ui2, value2) {
      if (ui2 === void 0) {
        ui2 = false;
      }
      if (value2 === void 0) {
        value2 = null;
      }
      return this.editor.getDoc().execCommand(command, ui2, value2);
    };
    EditorCommands2.prototype.isFormatMatch = function(name2) {
      return this.editor.formatter.match(name2);
    };
    EditorCommands2.prototype.toggleFormat = function(name2, value2) {
      this.editor.formatter.toggle(name2, value2 ? { value: value2 } : void 0);
      this.editor.nodeChanged();
    };
    EditorCommands2.prototype.storeSelection = function(type2) {
      this.selectionBookmark = this.editor.selection.getBookmark(type2);
    };
    EditorCommands2.prototype.restoreSelection = function() {
      this.editor.selection.moveToBookmark(this.selectionBookmark);
    };
    EditorCommands2.prototype.setupCommands = function(editor) {
      var self2 = this;
      this.addCommands({
        "mceResetDesignMode,mceBeginUndoLevel": noop,
        "mceEndUndoLevel,mceAddUndoLevel": function() {
          editor.undoManager.add();
        },
        "Cut,Copy,Paste": function(command) {
          var doc2 = editor.getDoc();
          var failed;
          try {
            self2.execNativeCommand(command);
          } catch (ex) {
            failed = true;
          }
          if (command === "paste" && !doc2.queryCommandEnabled(command)) {
            failed = true;
          }
          if (failed || !doc2.queryCommandSupported(command)) {
            var msg = editor.translate("Your browser doesn't support direct access to the clipboard. Please use the Ctrl+X/C/V keyboard shortcuts instead.");
            if (Env.mac) {
              msg = msg.replace(/Ctrl\+/g, "\u2318+");
            }
            editor.notificationManager.open({
              text: msg,
              type: "error"
            });
          }
        },
        "unlink": function() {
          if (editor.selection.isCollapsed()) {
            var elm = editor.dom.getParent(editor.selection.getStart(), "a");
            if (elm) {
              editor.dom.remove(elm, true);
            }
            return;
          }
          editor.formatter.remove("link");
        },
        "JustifyLeft,JustifyCenter,JustifyRight,JustifyFull,JustifyNone": function(command) {
          var align = command.substring(7);
          if (align === "full") {
            align = "justify";
          }
          each$f("left,center,right,justify".split(","), function(name2) {
            if (align !== name2) {
              editor.formatter.remove("align" + name2);
            }
          });
          if (align !== "none") {
            self2.toggleFormat("align" + align);
          }
        },
        "InsertUnorderedList,InsertOrderedList": function(command) {
          var listParent;
          self2.execNativeCommand(command);
          var listElm = editor.dom.getParent(editor.selection.getNode(), "ol,ul");
          if (listElm) {
            listParent = listElm.parentNode;
            if (/^(H[1-6]|P|ADDRESS|PRE)$/.test(listParent.nodeName)) {
              self2.storeSelection();
              editor.dom.split(listParent, listElm);
              self2.restoreSelection();
            }
          }
        },
        "Bold,Italic,Underline,Strikethrough,Superscript,Subscript": function(command) {
          self2.toggleFormat(command);
        },
        "ForeColor,HiliteColor": function(command, ui2, value2) {
          self2.toggleFormat(command, value2);
        },
        "FontName": function(command, ui2, value2) {
          fontNameAction(editor, value2);
        },
        "FontSize": function(command, ui2, value2) {
          fontSizeAction(editor, value2);
        },
        "LineHeight": function(command, ui2, value2) {
          lineHeightAction(editor, value2);
        },
        "RemoveFormat": function(command) {
          editor.formatter.remove(command);
        },
        "mceBlockQuote": function() {
          self2.toggleFormat("blockquote");
        },
        "FormatBlock": function(command, ui2, value2) {
          return self2.toggleFormat(value2 || "p");
        },
        "mceCleanup": function() {
          var bookmark = editor.selection.getBookmark();
          editor.setContent(editor.getContent());
          editor.selection.moveToBookmark(bookmark);
        },
        "mceRemoveNode": function(command, ui2, value2) {
          var node = value2 || editor.selection.getNode();
          if (node !== editor.getBody()) {
            self2.storeSelection();
            editor.dom.remove(node, true);
            self2.restoreSelection();
          }
        },
        "mceSelectNodeDepth": function(command, ui2, value2) {
          var counter = 0;
          editor.dom.getParent(editor.selection.getNode(), function(node) {
            if (node.nodeType === 1 && counter++ === value2) {
              editor.selection.select(node);
              return false;
            }
          }, editor.getBody());
        },
        "mceSelectNode": function(command, ui2, value2) {
          editor.selection.select(value2);
        },
        "mceInsertContent": function(command, ui2, value2) {
          insertAtCaret$1(editor, value2);
        },
        "mceInsertRawHTML": function(command, ui2, value2) {
          editor.selection.setContent("tiny_mce_marker");
          var content = editor.getContent();
          editor.setContent(content.replace(/tiny_mce_marker/g, function() {
            return value2;
          }));
        },
        "mceInsertNewLine": function(command, ui2, value2) {
          insert$3(editor, value2);
        },
        "mceToggleFormat": function(command, ui2, value2) {
          self2.toggleFormat(value2);
        },
        "mceSetContent": function(command, ui2, value2) {
          editor.setContent(value2);
        },
        "Indent,Outdent": function(command) {
          handle(editor, command);
        },
        "mceRepaint": noop,
        "InsertHorizontalRule": function() {
          editor.execCommand("mceInsertContent", false, "<hr />");
        },
        "mceToggleVisualAid": function() {
          editor.hasVisual = !editor.hasVisual;
          editor.addVisual();
        },
        "mceReplaceContent": function(command, ui2, value2) {
          editor.execCommand("mceInsertContent", false, value2.replace(/\{\$selection\}/g, editor.selection.getContent({ format: "text" })));
        },
        "mceInsertLink": function(command, ui2, value2) {
          if (typeof value2 === "string") {
            value2 = { href: value2 };
          }
          var anchor = editor.dom.getParent(editor.selection.getNode(), "a");
          value2.href = value2.href.replace(/ /g, "%20");
          if (!anchor || !value2.href) {
            editor.formatter.remove("link");
          }
          if (value2.href) {
            editor.formatter.apply("link", value2, anchor);
          }
        },
        "selectAll": function() {
          var editingHost = editor.dom.getParent(editor.selection.getStart(), isContentEditableTrue);
          if (editingHost) {
            var rng = editor.dom.createRng();
            rng.selectNodeContents(editingHost);
            editor.selection.setRng(rng);
          }
        },
        "mceNewDocument": function() {
          editor.setContent("");
        },
        "InsertLineBreak": function(command, ui2, value2) {
          insert$2(editor, value2);
          return true;
        }
      });
      var alignStates = function(name2) {
        return function() {
          var selection = editor.selection;
          var nodes = selection.isCollapsed() ? [editor.dom.getParent(selection.getNode(), editor.dom.isBlock)] : selection.getSelectedBlocks();
          var matches2 = map$3(nodes, function(node) {
            return !!editor.formatter.matchNode(node, name2);
          });
          return inArray$2(matches2, true) !== -1;
        };
      };
      self2.addCommands({
        "JustifyLeft": alignStates("alignleft"),
        "JustifyCenter": alignStates("aligncenter"),
        "JustifyRight": alignStates("alignright"),
        "JustifyFull": alignStates("alignjustify"),
        "Bold,Italic,Underline,Strikethrough,Superscript,Subscript": function(command) {
          return self2.isFormatMatch(command);
        },
        "mceBlockQuote": function() {
          return self2.isFormatMatch("blockquote");
        },
        "Outdent": function() {
          return canOutdent(editor);
        },
        "InsertUnorderedList,InsertOrderedList": function(command) {
          var list = editor.dom.getParent(editor.selection.getNode(), "ul,ol");
          return list && (command === "insertunorderedlist" && list.tagName === "UL" || command === "insertorderedlist" && list.tagName === "OL");
        }
      }, "state");
      self2.addCommands({
        Undo: function() {
          editor.undoManager.undo();
        },
        Redo: function() {
          editor.undoManager.redo();
        }
      });
      self2.addQueryValueHandler("FontName", function() {
        return fontNameQuery(editor);
      }, this);
      self2.addQueryValueHandler("FontSize", function() {
        return fontSizeQuery(editor);
      }, this);
      self2.addQueryValueHandler("LineHeight", function() {
        return lineHeightQuery(editor);
      }, this);
    };
    return EditorCommands2;
  }();
  var internalContentEditableAttr = "data-mce-contenteditable";
  var toggleClass = function(elm, cls, state) {
    if (has$2(elm, cls) && state === false) {
      remove$4(elm, cls);
    } else if (state) {
      add$3(elm, cls);
    }
  };
  var setEditorCommandState = function(editor, cmd, state) {
    try {
      editor.getDoc().execCommand(cmd, false, String(state));
    } catch (ex) {
    }
  };
  var setContentEditable = function(elm, state) {
    elm.dom.contentEditable = state ? "true" : "false";
  };
  var switchOffContentEditableTrue = function(elm) {
    each(descendants$1(elm, '*[contenteditable="true"]'), function(elm2) {
      set(elm2, internalContentEditableAttr, "true");
      setContentEditable(elm2, false);
    });
  };
  var switchOnContentEditableTrue = function(elm) {
    each(descendants$1(elm, "*[" + internalContentEditableAttr + '="true"]'), function(elm2) {
      remove$1(elm2, internalContentEditableAttr);
      setContentEditable(elm2, true);
    });
  };
  var removeFakeSelection = function(editor) {
    Optional.from(editor.selection.getNode()).each(function(elm) {
      elm.removeAttribute("data-mce-selected");
    });
  };
  var restoreFakeSelection = function(editor) {
    editor.selection.setRng(editor.selection.getRng());
  };
  var toggleReadOnly = function(editor, state) {
    var body = SugarElement.fromDom(editor.getBody());
    toggleClass(body, "mce-content-readonly", state);
    if (state) {
      editor.selection.controlSelection.hideResizeRect();
      editor._selectionOverrides.hideFakeCaret();
      removeFakeSelection(editor);
      editor.readonly = true;
      setContentEditable(body, false);
      switchOffContentEditableTrue(body);
    } else {
      editor.readonly = false;
      setContentEditable(body, true);
      switchOnContentEditableTrue(body);
      setEditorCommandState(editor, "StyleWithCSS", false);
      setEditorCommandState(editor, "enableInlineTableEditing", false);
      setEditorCommandState(editor, "enableObjectResizing", false);
      if (hasEditorOrUiFocus(editor)) {
        editor.focus();
      }
      restoreFakeSelection(editor);
      editor.nodeChanged();
    }
  };
  var isReadOnly$1 = function(editor) {
    return editor.readonly;
  };
  var registerFilters = function(editor) {
    editor.parser.addAttributeFilter("contenteditable", function(nodes) {
      if (isReadOnly$1(editor)) {
        each(nodes, function(node) {
          node.attr(internalContentEditableAttr, node.attr("contenteditable"));
          node.attr("contenteditable", "false");
        });
      }
    });
    editor.serializer.addAttributeFilter(internalContentEditableAttr, function(nodes) {
      if (isReadOnly$1(editor)) {
        each(nodes, function(node) {
          node.attr("contenteditable", node.attr(internalContentEditableAttr));
        });
      }
    });
    editor.serializer.addTempAttr(internalContentEditableAttr);
  };
  var registerReadOnlyContentFilters = function(editor) {
    if (editor.serializer) {
      registerFilters(editor);
    } else {
      editor.on("PreInit", function() {
        registerFilters(editor);
      });
    }
  };
  var isClickEvent = function(e) {
    return e.type === "click";
  };
  var getAnchorHrefOpt = function(editor, elm) {
    var isRoot = function(elm2) {
      return eq$2(elm2, SugarElement.fromDom(editor.getBody()));
    };
    return closest$1(elm, "a", isRoot).bind(function(a) {
      return getOpt(a, "href");
    });
  };
  var processReadonlyEvents = function(editor, e) {
    if (isClickEvent(e) && !VK.metaKeyPressed(e)) {
      var elm = SugarElement.fromDom(e.target);
      getAnchorHrefOpt(editor, elm).each(function(href) {
        e.preventDefault();
        if (/^#/.test(href)) {
          var targetEl = editor.dom.select(href + ',[name="' + removeLeading(href, "#") + '"]');
          if (targetEl.length) {
            editor.selection.scrollIntoView(targetEl[0], true);
          }
        } else {
          window.open(href, "_blank", "rel=noopener noreferrer,menubar=yes,toolbar=yes,location=yes,status=yes,resizable=yes,scrollbars=yes");
        }
      });
    }
  };
  var registerReadOnlySelectionBlockers = function(editor) {
    editor.on("ShowCaret", function(e) {
      if (isReadOnly$1(editor)) {
        e.preventDefault();
      }
    });
    editor.on("ObjectSelected", function(e) {
      if (isReadOnly$1(editor)) {
        e.preventDefault();
      }
    });
  };
  var nativeEvents = Tools.makeMap("focus blur focusin focusout click dblclick mousedown mouseup mousemove mouseover beforepaste paste cut copy selectionchange mouseout mouseenter mouseleave wheel keydown keypress keyup input beforeinput contextmenu dragstart dragend dragover draggesture dragdrop drop drag submit compositionstart compositionend compositionupdate touchstart touchmove touchend touchcancel", " ");
  var EventDispatcher = function() {
    function EventDispatcher2(settings) {
      this.bindings = {};
      this.settings = settings || {};
      this.scope = this.settings.scope || this;
      this.toggleEvent = this.settings.toggleEvent || never;
    }
    EventDispatcher2.isNative = function(name2) {
      return !!nativeEvents[name2.toLowerCase()];
    };
    EventDispatcher2.prototype.fire = function(nameIn, argsIn) {
      var name2 = nameIn.toLowerCase();
      var args = argsIn || {};
      args.type = name2;
      if (!args.target) {
        args.target = this.scope;
      }
      if (!args.preventDefault) {
        args.preventDefault = function() {
          args.isDefaultPrevented = always;
        };
        args.stopPropagation = function() {
          args.isPropagationStopped = always;
        };
        args.stopImmediatePropagation = function() {
          args.isImmediatePropagationStopped = always;
        };
        args.isDefaultPrevented = never;
        args.isPropagationStopped = never;
        args.isImmediatePropagationStopped = never;
      }
      if (this.settings.beforeFire) {
        this.settings.beforeFire(args);
      }
      var handlers = this.bindings[name2];
      if (handlers) {
        for (var i = 0, l2 = handlers.length; i < l2; i++) {
          var callback = handlers[i];
          if (callback.once) {
            this.off(name2, callback.func);
          }
          if (args.isImmediatePropagationStopped()) {
            args.stopPropagation();
            return args;
          }
          if (callback.func.call(this.scope, args) === false) {
            args.preventDefault();
            return args;
          }
        }
      }
      return args;
    };
    EventDispatcher2.prototype.on = function(name2, callback, prepend2, extra2) {
      if (callback === false) {
        callback = never;
      }
      if (callback) {
        var wrappedCallback = { func: callback };
        if (extra2) {
          Tools.extend(wrappedCallback, extra2);
        }
        var names = name2.toLowerCase().split(" ");
        var i = names.length;
        while (i--) {
          var currentName = names[i];
          var handlers = this.bindings[currentName];
          if (!handlers) {
            handlers = this.bindings[currentName] = [];
            this.toggleEvent(currentName, true);
          }
          if (prepend2) {
            handlers.unshift(wrappedCallback);
          } else {
            handlers.push(wrappedCallback);
          }
        }
      }
      return this;
    };
    EventDispatcher2.prototype.off = function(name2, callback) {
      var _this = this;
      if (name2) {
        var names = name2.toLowerCase().split(" ");
        var i = names.length;
        while (i--) {
          var currentName = names[i];
          var handlers = this.bindings[currentName];
          if (!currentName) {
            each$1(this.bindings, function(_value, bindingName) {
              _this.toggleEvent(bindingName, false);
              delete _this.bindings[bindingName];
            });
            return this;
          }
          if (handlers) {
            if (!callback) {
              handlers.length = 0;
            } else {
              var hi2 = handlers.length;
              while (hi2--) {
                if (handlers[hi2].func === callback) {
                  handlers = handlers.slice(0, hi2).concat(handlers.slice(hi2 + 1));
                  this.bindings[currentName] = handlers;
                }
              }
            }
            if (!handlers.length) {
              this.toggleEvent(name2, false);
              delete this.bindings[currentName];
            }
          }
        }
      } else {
        each$1(this.bindings, function(_value, name3) {
          _this.toggleEvent(name3, false);
        });
        this.bindings = {};
      }
      return this;
    };
    EventDispatcher2.prototype.once = function(name2, callback, prepend2) {
      return this.on(name2, callback, prepend2, { once: true });
    };
    EventDispatcher2.prototype.has = function(name2) {
      name2 = name2.toLowerCase();
      return !(!this.bindings[name2] || this.bindings[name2].length === 0);
    };
    return EventDispatcher2;
  }();
  var getEventDispatcher = function(obj) {
    if (!obj._eventDispatcher) {
      obj._eventDispatcher = new EventDispatcher({
        scope: obj,
        toggleEvent: function(name2, state) {
          if (EventDispatcher.isNative(name2) && obj.toggleNativeEvent) {
            obj.toggleNativeEvent(name2, state);
          }
        }
      });
    }
    return obj._eventDispatcher;
  };
  var Observable = {
    fire: function(name2, args, bubble) {
      var self2 = this;
      if (self2.removed && name2 !== "remove" && name2 !== "detach") {
        return args;
      }
      var dispatcherArgs = getEventDispatcher(self2).fire(name2, args);
      if (bubble !== false && self2.parent) {
        var parent_1 = self2.parent();
        while (parent_1 && !dispatcherArgs.isPropagationStopped()) {
          parent_1.fire(name2, dispatcherArgs, false);
          parent_1 = parent_1.parent();
        }
      }
      return dispatcherArgs;
    },
    on: function(name2, callback, prepend2) {
      return getEventDispatcher(this).on(name2, callback, prepend2);
    },
    off: function(name2, callback) {
      return getEventDispatcher(this).off(name2, callback);
    },
    once: function(name2, callback) {
      return getEventDispatcher(this).once(name2, callback);
    },
    hasEventListeners: function(name2) {
      return getEventDispatcher(this).has(name2);
    }
  };
  var DOM$8 = DOMUtils.DOM;
  var customEventRootDelegates;
  var getEventTarget = function(editor, eventName) {
    if (eventName === "selectionchange") {
      return editor.getDoc();
    }
    if (!editor.inline && /^mouse|touch|click|contextmenu|drop|dragover|dragend/.test(eventName)) {
      return editor.getDoc().documentElement;
    }
    var eventRoot = getEventRoot(editor);
    if (eventRoot) {
      if (!editor.eventRoot) {
        editor.eventRoot = DOM$8.select(eventRoot)[0];
      }
      return editor.eventRoot;
    }
    return editor.getBody();
  };
  var isListening = function(editor) {
    return !editor.hidden && !isReadOnly$1(editor);
  };
  var fireEvent = function(editor, eventName, e) {
    if (isListening(editor)) {
      editor.fire(eventName, e);
    } else if (isReadOnly$1(editor)) {
      processReadonlyEvents(editor, e);
    }
  };
  var bindEventDelegate = function(editor, eventName) {
    var delegate;
    if (!editor.delegates) {
      editor.delegates = {};
    }
    if (editor.delegates[eventName] || editor.removed) {
      return;
    }
    var eventRootElm = getEventTarget(editor, eventName);
    if (getEventRoot(editor)) {
      if (!customEventRootDelegates) {
        customEventRootDelegates = {};
        editor.editorManager.on("removeEditor", function() {
          if (!editor.editorManager.activeEditor) {
            if (customEventRootDelegates) {
              each$1(customEventRootDelegates, function(_value, name2) {
                editor.dom.unbind(getEventTarget(editor, name2));
              });
              customEventRootDelegates = null;
            }
          }
        });
      }
      if (customEventRootDelegates[eventName]) {
        return;
      }
      delegate = function(e) {
        var target = e.target;
        var editors2 = editor.editorManager.get();
        var i = editors2.length;
        while (i--) {
          var body = editors2[i].getBody();
          if (body === target || DOM$8.isChildOf(target, body)) {
            fireEvent(editors2[i], eventName, e);
          }
        }
      };
      customEventRootDelegates[eventName] = delegate;
      DOM$8.bind(eventRootElm, eventName, delegate);
    } else {
      delegate = function(e) {
        fireEvent(editor, eventName, e);
      };
      DOM$8.bind(eventRootElm, eventName, delegate);
      editor.delegates[eventName] = delegate;
    }
  };
  var EditorObservable = __assign2(__assign2({}, Observable), {
    bindPendingEventDelegates: function() {
      var self2 = this;
      Tools.each(self2._pendingNativeEvents, function(name2) {
        bindEventDelegate(self2, name2);
      });
    },
    toggleNativeEvent: function(name2, state) {
      var self2 = this;
      if (name2 === "focus" || name2 === "blur") {
        return;
      }
      if (state) {
        if (self2.initialized) {
          bindEventDelegate(self2, name2);
        } else {
          if (!self2._pendingNativeEvents) {
            self2._pendingNativeEvents = [name2];
          } else {
            self2._pendingNativeEvents.push(name2);
          }
        }
      } else if (self2.initialized) {
        self2.dom.unbind(getEventTarget(self2, name2), name2, self2.delegates[name2]);
        delete self2.delegates[name2];
      }
    },
    unbindAllNativeEvents: function() {
      var self2 = this;
      var body = self2.getBody();
      var dom2 = self2.dom;
      if (self2.delegates) {
        each$1(self2.delegates, function(value2, name2) {
          self2.dom.unbind(getEventTarget(self2, name2), name2, value2);
        });
        delete self2.delegates;
      }
      if (!self2.inline && body && dom2) {
        body.onload = null;
        dom2.unbind(self2.getWin());
        dom2.unbind(self2.getDoc());
      }
      if (dom2) {
        dom2.unbind(body);
        dom2.unbind(self2.getContainer());
      }
    }
  });
  var defaultModes = [
    "design",
    "readonly"
  ];
  var switchToMode = function(editor, activeMode, availableModes, mode) {
    var oldMode = availableModes[activeMode.get()];
    var newMode = availableModes[mode];
    try {
      newMode.activate();
    } catch (e) {
      console.error("problem while activating editor mode " + mode + ":", e);
      return;
    }
    oldMode.deactivate();
    if (oldMode.editorReadOnly !== newMode.editorReadOnly) {
      toggleReadOnly(editor, newMode.editorReadOnly);
    }
    activeMode.set(mode);
    fireSwitchMode(editor, mode);
  };
  var setMode2 = function(editor, availableModes, activeMode, mode) {
    if (mode === activeMode.get()) {
      return;
    } else if (!has(availableModes, mode)) {
      throw new Error("Editor mode '" + mode + "' is invalid");
    }
    if (editor.initialized) {
      switchToMode(editor, activeMode, availableModes, mode);
    } else {
      editor.on("init", function() {
        return switchToMode(editor, activeMode, availableModes, mode);
      });
    }
  };
  var registerMode = function(availableModes, mode, api2) {
    var _a;
    if (contains(defaultModes, mode)) {
      throw new Error("Cannot override default mode " + mode);
    }
    return __assign2(__assign2({}, availableModes), (_a = {}, _a[mode] = __assign2(__assign2({}, api2), {
      deactivate: function() {
        try {
          api2.deactivate();
        } catch (e) {
          console.error("problem while deactivating editor mode " + mode + ":", e);
        }
      }
    }), _a));
  };
  var create$5 = function(editor) {
    var activeMode = Cell("design");
    var availableModes = Cell({
      design: {
        activate: noop,
        deactivate: noop,
        editorReadOnly: false
      },
      readonly: {
        activate: noop,
        deactivate: noop,
        editorReadOnly: true
      }
    });
    registerReadOnlyContentFilters(editor);
    registerReadOnlySelectionBlockers(editor);
    return {
      isReadOnly: function() {
        return isReadOnly$1(editor);
      },
      set: function(mode) {
        return setMode2(editor, availableModes.get(), activeMode, mode);
      },
      get: function() {
        return activeMode.get();
      },
      register: function(mode, api2) {
        availableModes.set(registerMode(availableModes.get(), mode, api2));
      }
    };
  };
  var each$g = Tools.each, explode$3 = Tools.explode;
  var keyCodeLookup = {
    f1: 112,
    f2: 113,
    f3: 114,
    f4: 115,
    f5: 116,
    f6: 117,
    f7: 118,
    f8: 119,
    f9: 120,
    f10: 121,
    f11: 122,
    f12: 123
  };
  var modifierNames = Tools.makeMap("alt,ctrl,shift,meta,access");
  var parseShortcut = function(pattern) {
    var key;
    var shortcut = {};
    each$g(explode$3(pattern.toLowerCase(), "+"), function(value2) {
      if (value2 in modifierNames) {
        shortcut[value2] = true;
      } else {
        if (/^[0-9]{2,}$/.test(value2)) {
          shortcut.keyCode = parseInt(value2, 10);
        } else {
          shortcut.charCode = value2.charCodeAt(0);
          shortcut.keyCode = keyCodeLookup[value2] || value2.toUpperCase().charCodeAt(0);
        }
      }
    });
    var id2 = [shortcut.keyCode];
    for (key in modifierNames) {
      if (shortcut[key]) {
        id2.push(key);
      } else {
        shortcut[key] = false;
      }
    }
    shortcut.id = id2.join(",");
    if (shortcut.access) {
      shortcut.alt = true;
      if (Env.mac) {
        shortcut.ctrl = true;
      } else {
        shortcut.shift = true;
      }
    }
    if (shortcut.meta) {
      if (Env.mac) {
        shortcut.meta = true;
      } else {
        shortcut.ctrl = true;
        shortcut.meta = false;
      }
    }
    return shortcut;
  };
  var Shortcuts = function() {
    function Shortcuts2(editor) {
      this.shortcuts = {};
      this.pendingPatterns = [];
      this.editor = editor;
      var self2 = this;
      editor.on("keyup keypress keydown", function(e) {
        if ((self2.hasModifier(e) || self2.isFunctionKey(e)) && !e.isDefaultPrevented()) {
          each$g(self2.shortcuts, function(shortcut) {
            if (self2.matchShortcut(e, shortcut)) {
              self2.pendingPatterns = shortcut.subpatterns.slice(0);
              if (e.type === "keydown") {
                self2.executeShortcutAction(shortcut);
              }
              return true;
            }
          });
          if (self2.matchShortcut(e, self2.pendingPatterns[0])) {
            if (self2.pendingPatterns.length === 1) {
              if (e.type === "keydown") {
                self2.executeShortcutAction(self2.pendingPatterns[0]);
              }
            }
            self2.pendingPatterns.shift();
          }
        }
      });
    }
    Shortcuts2.prototype.add = function(pattern, desc, cmdFunc, scope) {
      var self2 = this;
      var func = self2.normalizeCommandFunc(cmdFunc);
      each$g(explode$3(Tools.trim(pattern)), function(pattern2) {
        var shortcut = self2.createShortcut(pattern2, desc, func, scope);
        self2.shortcuts[shortcut.id] = shortcut;
      });
      return true;
    };
    Shortcuts2.prototype.remove = function(pattern) {
      var shortcut = this.createShortcut(pattern);
      if (this.shortcuts[shortcut.id]) {
        delete this.shortcuts[shortcut.id];
        return true;
      }
      return false;
    };
    Shortcuts2.prototype.normalizeCommandFunc = function(cmdFunc) {
      var self2 = this;
      var cmd = cmdFunc;
      if (typeof cmd === "string") {
        return function() {
          self2.editor.execCommand(cmd, false, null);
        };
      } else if (Tools.isArray(cmd)) {
        return function() {
          self2.editor.execCommand(cmd[0], cmd[1], cmd[2]);
        };
      } else {
        return cmd;
      }
    };
    Shortcuts2.prototype.createShortcut = function(pattern, desc, cmdFunc, scope) {
      var shortcuts = Tools.map(explode$3(pattern, ">"), parseShortcut);
      shortcuts[shortcuts.length - 1] = Tools.extend(shortcuts[shortcuts.length - 1], {
        func: cmdFunc,
        scope: scope || this.editor
      });
      return Tools.extend(shortcuts[0], {
        desc: this.editor.translate(desc),
        subpatterns: shortcuts.slice(1)
      });
    };
    Shortcuts2.prototype.hasModifier = function(e) {
      return e.altKey || e.ctrlKey || e.metaKey;
    };
    Shortcuts2.prototype.isFunctionKey = function(e) {
      return e.type === "keydown" && e.keyCode >= 112 && e.keyCode <= 123;
    };
    Shortcuts2.prototype.matchShortcut = function(e, shortcut) {
      if (!shortcut) {
        return false;
      }
      if (shortcut.ctrl !== e.ctrlKey || shortcut.meta !== e.metaKey) {
        return false;
      }
      if (shortcut.alt !== e.altKey || shortcut.shift !== e.shiftKey) {
        return false;
      }
      if (e.keyCode === shortcut.keyCode || e.charCode && e.charCode === shortcut.charCode) {
        e.preventDefault();
        return true;
      }
      return false;
    };
    Shortcuts2.prototype.executeShortcutAction = function(shortcut) {
      return shortcut.func ? shortcut.func.call(shortcut.scope) : null;
    };
    return Shortcuts2;
  }();
  var create$6 = function() {
    var buttons = {};
    var menuItems = {};
    var popups = {};
    var icons = {};
    var contextMenus = {};
    var contextToolbars = {};
    var sidebars = {};
    var add2 = function(collection, type2) {
      return function(name2, spec) {
        return collection[name2.toLowerCase()] = __assign2(__assign2({}, spec), { type: type2 });
      };
    };
    var addIcon = function(name2, svgData) {
      return icons[name2.toLowerCase()] = svgData;
    };
    return {
      addButton: add2(buttons, "button"),
      addGroupToolbarButton: add2(buttons, "grouptoolbarbutton"),
      addToggleButton: add2(buttons, "togglebutton"),
      addMenuButton: add2(buttons, "menubutton"),
      addSplitButton: add2(buttons, "splitbutton"),
      addMenuItem: add2(menuItems, "menuitem"),
      addNestedMenuItem: add2(menuItems, "nestedmenuitem"),
      addToggleMenuItem: add2(menuItems, "togglemenuitem"),
      addAutocompleter: add2(popups, "autocompleter"),
      addContextMenu: add2(contextMenus, "contextmenu"),
      addContextToolbar: add2(contextToolbars, "contexttoolbar"),
      addContextForm: add2(contextToolbars, "contextform"),
      addSidebar: add2(sidebars, "sidebar"),
      addIcon,
      getAll: function() {
        return {
          buttons,
          menuItems,
          icons,
          popups,
          contextMenus,
          contextToolbars,
          sidebars
        };
      }
    };
  };
  var registry = function() {
    var bridge = create$6();
    return {
      addAutocompleter: bridge.addAutocompleter,
      addButton: bridge.addButton,
      addContextForm: bridge.addContextForm,
      addContextMenu: bridge.addContextMenu,
      addContextToolbar: bridge.addContextToolbar,
      addIcon: bridge.addIcon,
      addMenuButton: bridge.addMenuButton,
      addMenuItem: bridge.addMenuItem,
      addNestedMenuItem: bridge.addNestedMenuItem,
      addSidebar: bridge.addSidebar,
      addSplitButton: bridge.addSplitButton,
      addToggleButton: bridge.addToggleButton,
      addGroupToolbarButton: bridge.addGroupToolbarButton,
      addToggleMenuItem: bridge.addToggleMenuItem,
      getAll: bridge.getAll
    };
  };
  var each$h = Tools.each, trim$4 = Tools.trim;
  var queryParts = "source protocol authority userInfo user password host port relative path directory file query anchor".split(" ");
  var DEFAULT_PORTS = {
    ftp: 21,
    http: 80,
    https: 443,
    mailto: 25
  };
  var URI = function() {
    function URI2(url, settings) {
      url = trim$4(url);
      this.settings = settings || {};
      var baseUri = this.settings.base_uri;
      var self2 = this;
      if (/^([\w\-]+):([^\/]{2})/i.test(url) || /^\s*#/.test(url)) {
        self2.source = url;
        return;
      }
      var isProtocolRelative = url.indexOf("//") === 0;
      if (url.indexOf("/") === 0 && !isProtocolRelative) {
        url = (baseUri ? baseUri.protocol || "http" : "http") + "://mce_host" + url;
      }
      if (!/^[\w\-]*:?\/\//.test(url)) {
        var baseUrl = this.settings.base_uri ? this.settings.base_uri.path : new URI2(document.location.href).directory;
        if (this.settings.base_uri && this.settings.base_uri.protocol == "") {
          url = "//mce_host" + self2.toAbsPath(baseUrl, url);
        } else {
          var match2 = /([^#?]*)([#?]?.*)/.exec(url);
          url = (baseUri && baseUri.protocol || "http") + "://mce_host" + self2.toAbsPath(baseUrl, match2[1]) + match2[2];
        }
      }
      url = url.replace(/@@/g, "(mce_at)");
      var urlMatch = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@\/]*):?([^:@\/]*))?@)?(\[[a-zA-Z0-9:.%]+\]|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/.exec(url);
      each$h(queryParts, function(v2, i) {
        var part = urlMatch[i];
        if (part) {
          part = part.replace(/\(mce_at\)/g, "@@");
        }
        self2[v2] = part;
      });
      if (baseUri) {
        if (!self2.protocol) {
          self2.protocol = baseUri.protocol;
        }
        if (!self2.userInfo) {
          self2.userInfo = baseUri.userInfo;
        }
        if (!self2.port && self2.host === "mce_host") {
          self2.port = baseUri.port;
        }
        if (!self2.host || self2.host === "mce_host") {
          self2.host = baseUri.host;
        }
        self2.source = "";
      }
      if (isProtocolRelative) {
        self2.protocol = "";
      }
    }
    URI2.parseDataUri = function(uri) {
      var type2;
      var uriComponents = decodeURIComponent(uri).split(",");
      var matches2 = /data:([^;]+)/.exec(uriComponents[0]);
      if (matches2) {
        type2 = matches2[1];
      }
      return {
        type: type2,
        data: uriComponents[1]
      };
    };
    URI2.getDocumentBaseUrl = function(loc) {
      var baseUrl;
      if (loc.protocol.indexOf("http") !== 0 && loc.protocol !== "file:") {
        baseUrl = loc.href;
      } else {
        baseUrl = loc.protocol + "//" + loc.host + loc.pathname;
      }
      if (/^[^:]+:\/\/\/?[^\/]+\//.test(baseUrl)) {
        baseUrl = baseUrl.replace(/[\?#].*$/, "").replace(/[\/\\][^\/]+$/, "");
        if (!/[\/\\]$/.test(baseUrl)) {
          baseUrl += "/";
        }
      }
      return baseUrl;
    };
    URI2.prototype.setPath = function(path) {
      var pathMatch = /^(.*?)\/?(\w+)?$/.exec(path);
      this.path = pathMatch[0];
      this.directory = pathMatch[1];
      this.file = pathMatch[2];
      this.source = "";
      this.getURI();
    };
    URI2.prototype.toRelative = function(uri) {
      var output;
      if (uri === "./") {
        return uri;
      }
      var relativeUri = new URI2(uri, { base_uri: this });
      if (relativeUri.host !== "mce_host" && this.host !== relativeUri.host && relativeUri.host || this.port !== relativeUri.port || this.protocol !== relativeUri.protocol && relativeUri.protocol !== "") {
        return relativeUri.getURI();
      }
      var tu = this.getURI(), uu = relativeUri.getURI();
      if (tu === uu || tu.charAt(tu.length - 1) === "/" && tu.substr(0, tu.length - 1) === uu) {
        return tu;
      }
      output = this.toRelPath(this.path, relativeUri.path);
      if (relativeUri.query) {
        output += "?" + relativeUri.query;
      }
      if (relativeUri.anchor) {
        output += "#" + relativeUri.anchor;
      }
      return output;
    };
    URI2.prototype.toAbsolute = function(uri, noHost) {
      var absoluteUri = new URI2(uri, { base_uri: this });
      return absoluteUri.getURI(noHost && this.isSameOrigin(absoluteUri));
    };
    URI2.prototype.isSameOrigin = function(uri) {
      if (this.host == uri.host && this.protocol == uri.protocol) {
        if (this.port == uri.port) {
          return true;
        }
        var defaultPort = DEFAULT_PORTS[this.protocol];
        if (defaultPort && (this.port || defaultPort) == (uri.port || defaultPort)) {
          return true;
        }
      }
      return false;
    };
    URI2.prototype.toRelPath = function(base, path) {
      var breakPoint = 0, out = "", i, l2;
      var normalizedBase = base.substring(0, base.lastIndexOf("/")).split("/");
      var items = path.split("/");
      if (normalizedBase.length >= items.length) {
        for (i = 0, l2 = normalizedBase.length; i < l2; i++) {
          if (i >= items.length || normalizedBase[i] !== items[i]) {
            breakPoint = i + 1;
            break;
          }
        }
      }
      if (normalizedBase.length < items.length) {
        for (i = 0, l2 = items.length; i < l2; i++) {
          if (i >= normalizedBase.length || normalizedBase[i] !== items[i]) {
            breakPoint = i + 1;
            break;
          }
        }
      }
      if (breakPoint === 1) {
        return path;
      }
      for (i = 0, l2 = normalizedBase.length - (breakPoint - 1); i < l2; i++) {
        out += "../";
      }
      for (i = breakPoint - 1, l2 = items.length; i < l2; i++) {
        if (i !== breakPoint - 1) {
          out += "/" + items[i];
        } else {
          out += items[i];
        }
      }
      return out;
    };
    URI2.prototype.toAbsPath = function(base, path) {
      var i, nb2 = 0, o = [], outPath;
      var tr = /\/$/.test(path) ? "/" : "";
      var normalizedBase = base.split("/");
      var normalizedPath = path.split("/");
      each$h(normalizedBase, function(k) {
        if (k) {
          o.push(k);
        }
      });
      normalizedBase = o;
      for (i = normalizedPath.length - 1, o = []; i >= 0; i--) {
        if (normalizedPath[i].length === 0 || normalizedPath[i] === ".") {
          continue;
        }
        if (normalizedPath[i] === "..") {
          nb2++;
          continue;
        }
        if (nb2 > 0) {
          nb2--;
          continue;
        }
        o.push(normalizedPath[i]);
      }
      i = normalizedBase.length - nb2;
      if (i <= 0) {
        outPath = reverse(o).join("/");
      } else {
        outPath = normalizedBase.slice(0, i).join("/") + "/" + reverse(o).join("/");
      }
      if (outPath.indexOf("/") !== 0) {
        outPath = "/" + outPath;
      }
      if (tr && outPath.lastIndexOf("/") !== outPath.length - 1) {
        outPath += tr;
      }
      return outPath;
    };
    URI2.prototype.getURI = function(noProtoHost) {
      if (noProtoHost === void 0) {
        noProtoHost = false;
      }
      var s;
      if (!this.source || noProtoHost) {
        s = "";
        if (!noProtoHost) {
          if (this.protocol) {
            s += this.protocol + "://";
          } else {
            s += "//";
          }
          if (this.userInfo) {
            s += this.userInfo + "@";
          }
          if (this.host) {
            s += this.host;
          }
          if (this.port) {
            s += ":" + this.port;
          }
        }
        if (this.path) {
          s += this.path;
        }
        if (this.query) {
          s += "?" + this.query;
        }
        if (this.anchor) {
          s += "#" + this.anchor;
        }
        this.source = s;
      }
      return this.source;
    };
    return URI2;
  }();
  var DOM$9 = DOMUtils.DOM;
  var extend$3 = Tools.extend, each$i = Tools.each;
  var resolve$3 = Tools.resolve;
  var ie$1 = Env.ie;
  var Editor2 = function() {
    function Editor3(id2, settings, editorManager) {
      var _this = this;
      this.plugins = {};
      this.contentCSS = [];
      this.contentStyles = [];
      this.loadedCSS = {};
      this.isNotDirty = false;
      this.editorManager = editorManager;
      this.documentBaseUrl = editorManager.documentBaseURL;
      extend$3(this, EditorObservable);
      this.settings = getEditorSettings(this, id2, this.documentBaseUrl, editorManager.defaultSettings, settings);
      if (this.settings.suffix) {
        editorManager.suffix = this.settings.suffix;
      }
      this.suffix = editorManager.suffix;
      if (this.settings.base_url) {
        editorManager._setBaseUrl(this.settings.base_url);
      }
      this.baseUri = editorManager.baseURI;
      if (this.settings.referrer_policy) {
        ScriptLoader2.ScriptLoader._setReferrerPolicy(this.settings.referrer_policy);
        DOMUtils.DOM.styleSheetLoader._setReferrerPolicy(this.settings.referrer_policy);
      }
      AddOnManager.languageLoad = this.settings.language_load;
      AddOnManager.baseURL = editorManager.baseURL;
      this.id = id2;
      this.setDirty(false);
      this.documentBaseURI = new URI(this.settings.document_base_url, { base_uri: this.baseUri });
      this.baseURI = this.baseUri;
      this.inline = !!this.settings.inline;
      this.shortcuts = new Shortcuts(this);
      this.editorCommands = new EditorCommands(this);
      if (this.settings.cache_suffix) {
        Env.cacheSuffix = this.settings.cache_suffix.replace(/^[\?\&]+/, "");
      }
      this.ui = {
        registry: registry(),
        styleSheetLoader: void 0,
        show: noop,
        hide: noop,
        enable: noop,
        disable: noop,
        isDisabled: never
      };
      var self2 = this;
      var modeInstance = create$5(self2);
      this.mode = modeInstance;
      this.setMode = modeInstance.set;
      editorManager.fire("SetupEditor", { editor: this });
      this.execCallback("setup", this);
      this.$ = DomQuery.overrideDefaults(function() {
        return {
          context: _this.inline ? _this.getBody() : _this.getDoc(),
          element: _this.getBody()
        };
      });
    }
    Editor3.prototype.render = function() {
      render(this);
    };
    Editor3.prototype.focus = function(skipFocus) {
      focus$1(this, skipFocus);
    };
    Editor3.prototype.hasFocus = function() {
      return hasFocus$1(this);
    };
    Editor3.prototype.execCallback = function(name2) {
      var x2 = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        x2[_i - 1] = arguments[_i];
      }
      var self2 = this;
      var callback = self2.settings[name2], scope;
      if (!callback) {
        return;
      }
      if (self2.callbackLookup && (scope = self2.callbackLookup[name2])) {
        callback = scope.func;
        scope = scope.scope;
      }
      if (typeof callback === "string") {
        scope = callback.replace(/\.\w+$/, "");
        scope = scope ? resolve$3(scope) : 0;
        callback = resolve$3(callback);
        self2.callbackLookup = self2.callbackLookup || {};
        self2.callbackLookup[name2] = {
          func: callback,
          scope
        };
      }
      return callback.apply(scope || self2, x2);
    };
    Editor3.prototype.translate = function(text) {
      return I18n.translate(text);
    };
    Editor3.prototype.getParam = function(name2, defaultVal, type2) {
      return getParam(this, name2, defaultVal, type2);
    };
    Editor3.prototype.hasPlugin = function(name2, loaded) {
      var hasPlugin = contains(getPlugins(this).split(/[ ,]/), name2);
      if (hasPlugin) {
        return loaded ? PluginManager.get(name2) !== void 0 : true;
      } else {
        return false;
      }
    };
    Editor3.prototype.nodeChanged = function(args) {
      this._nodeChangeDispatcher.nodeChanged(args);
    };
    Editor3.prototype.addCommand = function(name2, callback, scope) {
      this.editorCommands.addCommand(name2, callback, scope);
    };
    Editor3.prototype.addQueryStateHandler = function(name2, callback, scope) {
      this.editorCommands.addQueryStateHandler(name2, callback, scope);
    };
    Editor3.prototype.addQueryValueHandler = function(name2, callback, scope) {
      this.editorCommands.addQueryValueHandler(name2, callback, scope);
    };
    Editor3.prototype.addShortcut = function(pattern, desc, cmdFunc, scope) {
      this.shortcuts.add(pattern, desc, cmdFunc, scope);
    };
    Editor3.prototype.execCommand = function(cmd, ui2, value2, args) {
      return this.editorCommands.execCommand(cmd, ui2, value2, args);
    };
    Editor3.prototype.queryCommandState = function(cmd) {
      return this.editorCommands.queryCommandState(cmd);
    };
    Editor3.prototype.queryCommandValue = function(cmd) {
      return this.editorCommands.queryCommandValue(cmd);
    };
    Editor3.prototype.queryCommandSupported = function(cmd) {
      return this.editorCommands.queryCommandSupported(cmd);
    };
    Editor3.prototype.show = function() {
      var self2 = this;
      if (self2.hidden) {
        self2.hidden = false;
        if (self2.inline) {
          self2.getBody().contentEditable = "true";
        } else {
          DOM$9.show(self2.getContainer());
          DOM$9.hide(self2.id);
        }
        self2.load();
        self2.fire("show");
      }
    };
    Editor3.prototype.hide = function() {
      var self2 = this, doc2 = self2.getDoc();
      if (!self2.hidden) {
        if (ie$1 && doc2 && !self2.inline) {
          doc2.execCommand("SelectAll");
        }
        self2.save();
        if (self2.inline) {
          self2.getBody().contentEditable = "false";
          if (self2 === self2.editorManager.focusedEditor) {
            self2.editorManager.focusedEditor = null;
          }
        } else {
          DOM$9.hide(self2.getContainer());
          DOM$9.setStyle(self2.id, "display", self2.orgDisplay);
        }
        self2.hidden = true;
        self2.fire("hide");
      }
    };
    Editor3.prototype.isHidden = function() {
      return !!this.hidden;
    };
    Editor3.prototype.setProgressState = function(state, time) {
      this.fire("ProgressState", {
        state,
        time
      });
    };
    Editor3.prototype.load = function(args) {
      var self2 = this;
      var elm = self2.getElement(), html;
      if (self2.removed) {
        return "";
      }
      if (elm) {
        args = args || {};
        args.load = true;
        var value2 = isTextareaOrInput2(elm) ? elm.value : elm.innerHTML;
        html = self2.setContent(value2, args);
        args.element = elm;
        if (!args.no_events) {
          self2.fire("LoadContent", args);
        }
        args.element = elm = null;
        return html;
      }
    };
    Editor3.prototype.save = function(args) {
      var self2 = this;
      var elm = self2.getElement(), html, form;
      if (!elm || !self2.initialized || self2.removed) {
        return;
      }
      args = args || {};
      args.save = true;
      args.element = elm;
      html = args.content = self2.getContent(args);
      if (!args.no_events) {
        self2.fire("SaveContent", args);
      }
      if (args.format === "raw") {
        self2.fire("RawSaveContent", args);
      }
      html = args.content;
      if (!isTextareaOrInput2(elm)) {
        if (args.is_removing || !self2.inline) {
          elm.innerHTML = html;
        }
        if (form = DOM$9.getParent(self2.id, "form")) {
          each$i(form.elements, function(elm2) {
            if (elm2.name === self2.id) {
              elm2.value = html;
              return false;
            }
          });
        }
      } else {
        elm.value = html;
      }
      args.element = elm = null;
      if (args.set_dirty !== false) {
        self2.setDirty(false);
      }
      return html;
    };
    Editor3.prototype.setContent = function(content, args) {
      return setContent$2(this, content, args);
    };
    Editor3.prototype.getContent = function(args) {
      return getContent$2(this, args);
    };
    Editor3.prototype.insertContent = function(content, args) {
      if (args) {
        console.log(args);
        content = extend$3({ content }, args);
      }
      this.execCommand("mceInsertContent", false, content);
    };
    Editor3.prototype.resetContent = function(initialContent) {
      if (initialContent === void 0) {
        setContent$2(this, this.startContent, { format: "raw" });
      } else {
        setContent$2(this, initialContent);
      }
      this.undoManager.reset();
      this.setDirty(false);
      this.nodeChanged();
    };
    Editor3.prototype.isDirty = function() {
      return !this.isNotDirty;
    };
    Editor3.prototype.setDirty = function(state) {
      var oldState = !this.isNotDirty;
      this.isNotDirty = !state;
      if (state && state !== oldState) {
        this.fire("dirty");
      }
    };
    Editor3.prototype.getContainer = function() {
      var self2 = this;
      if (!self2.container) {
        self2.container = DOM$9.get(self2.editorContainer || self2.id + "_parent");
      }
      return self2.container;
    };
    Editor3.prototype.getContentAreaContainer = function() {
      return this.contentAreaContainer;
    };
    Editor3.prototype.getElement = function() {
      if (!this.targetElm) {
        this.targetElm = DOM$9.get(this.id);
      }
      return this.targetElm;
    };
    Editor3.prototype.getWin = function() {
      var self2 = this;
      var elm;
      if (!self2.contentWindow) {
        elm = self2.iframeElement;
        if (elm) {
          self2.contentWindow = elm.contentWindow;
        }
      }
      return self2.contentWindow;
    };
    Editor3.prototype.getDoc = function() {
      var self2 = this;
      var win;
      if (!self2.contentDocument) {
        win = self2.getWin();
        if (win) {
          self2.contentDocument = win.document;
        }
      }
      return self2.contentDocument;
    };
    Editor3.prototype.getBody = function() {
      var doc2 = this.getDoc();
      return this.bodyElement || (doc2 ? doc2.body : null);
    };
    Editor3.prototype.convertURL = function(url, name2, elm) {
      var self2 = this, settings = self2.settings;
      if (settings.urlconverter_callback) {
        return self2.execCallback("urlconverter_callback", url, elm, true, name2);
      }
      if (!settings.convert_urls || elm && elm.nodeName === "LINK" || url.indexOf("file:") === 0 || url.length === 0) {
        return url;
      }
      if (settings.relative_urls) {
        return self2.documentBaseURI.toRelative(url);
      }
      url = self2.documentBaseURI.toAbsolute(url, settings.remove_script_host);
      return url;
    };
    Editor3.prototype.addVisual = function(elm) {
      addVisual$1(this, elm);
    };
    Editor3.prototype.remove = function() {
      remove$7(this);
    };
    Editor3.prototype.destroy = function(automatic) {
      destroy(this, automatic);
    };
    Editor3.prototype.uploadImages = function(callback) {
      return this.editorUpload.uploadImages(callback);
    };
    Editor3.prototype._scanForImages = function() {
      return this.editorUpload.scanForImages();
    };
    Editor3.prototype.addButton = function() {
      throw new Error("editor.addButton has been removed in tinymce 5x, use editor.ui.registry.addButton or editor.ui.registry.addToggleButton or editor.ui.registry.addSplitButton instead");
    };
    Editor3.prototype.addSidebar = function() {
      throw new Error("editor.addSidebar has been removed in tinymce 5x, use editor.ui.registry.addSidebar instead");
    };
    Editor3.prototype.addMenuItem = function() {
      throw new Error("editor.addMenuItem has been removed in tinymce 5x, use editor.ui.registry.addMenuItem instead");
    };
    Editor3.prototype.addContextToolbar = function() {
      throw new Error("editor.addContextToolbar has been removed in tinymce 5x, use editor.ui.registry.addContextToolbar instead");
    };
    return Editor3;
  }();
  var DOM$a = DOMUtils.DOM;
  var explode$4 = Tools.explode, each$j = Tools.each, extend$4 = Tools.extend;
  var instanceCounter = 0, boundGlobalEvents = false;
  var beforeUnloadDelegate;
  var legacyEditors = [];
  var editors = [];
  var isValidLegacyKey = function(id2) {
    return id2 !== "length";
  };
  var globalEventDelegate = function(e) {
    var type2 = e.type;
    each$j(EditorManager.get(), function(editor) {
      switch (type2) {
        case "scroll":
          editor.fire("ScrollWindow", e);
          break;
        case "resize":
          editor.fire("ResizeWindow", e);
          break;
      }
    });
  };
  var toggleGlobalEvents = function(state) {
    if (state !== boundGlobalEvents) {
      if (state) {
        DomQuery(window).on("resize scroll", globalEventDelegate);
      } else {
        DomQuery(window).off("resize scroll", globalEventDelegate);
      }
      boundGlobalEvents = state;
    }
  };
  var removeEditorFromList = function(targetEditor) {
    var oldEditors = editors;
    delete legacyEditors[targetEditor.id];
    for (var i = 0; i < legacyEditors.length; i++) {
      if (legacyEditors[i] === targetEditor) {
        legacyEditors.splice(i, 1);
        break;
      }
    }
    editors = filter(editors, function(editor) {
      return targetEditor !== editor;
    });
    if (EditorManager.activeEditor === targetEditor) {
      EditorManager.activeEditor = editors.length > 0 ? editors[0] : null;
    }
    if (EditorManager.focusedEditor === targetEditor) {
      EditorManager.focusedEditor = null;
    }
    return oldEditors.length !== editors.length;
  };
  var purgeDestroyedEditor = function(editor) {
    if (editor && editor.initialized && !(editor.getContainer() || editor.getBody()).parentNode) {
      removeEditorFromList(editor);
      editor.unbindAllNativeEvents();
      editor.destroy(true);
      editor.removed = true;
      editor = null;
    }
    return editor;
  };
  var isQuirksMode = document.compatMode !== "CSS1Compat";
  var EditorManager = __assign2(__assign2({}, Observable), {
    baseURI: null,
    baseURL: null,
    defaultSettings: {},
    documentBaseURL: null,
    suffix: null,
    $: DomQuery,
    majorVersion: "5",
    minorVersion: "8.1",
    releaseDate: "2021-05-20",
    editors: legacyEditors,
    i18n: I18n,
    activeEditor: null,
    focusedEditor: null,
    settings: {},
    setup: function() {
      var self2 = this;
      var baseURL, documentBaseURL, suffix = "";
      documentBaseURL = URI.getDocumentBaseUrl(document.location);
      if (/^[^:]+:\/\/\/?[^\/]+\//.test(documentBaseURL)) {
        documentBaseURL = documentBaseURL.replace(/[\?#].*$/, "").replace(/[\/\\][^\/]+$/, "");
        if (!/[\/\\]$/.test(documentBaseURL)) {
          documentBaseURL += "/";
        }
      }
      var preInit2 = window.tinymce || window.tinyMCEPreInit;
      if (preInit2) {
        baseURL = preInit2.base || preInit2.baseURL;
        suffix = preInit2.suffix;
      } else {
        var scripts = document.getElementsByTagName("script");
        for (var i = 0; i < scripts.length; i++) {
          var src = scripts[i].src || "";
          if (src === "") {
            continue;
          }
          var srcScript = src.substring(src.lastIndexOf("/"));
          if (/tinymce(\.full|\.jquery|)(\.min|\.dev|)\.js/.test(src)) {
            if (srcScript.indexOf(".min") !== -1) {
              suffix = ".min";
            }
            baseURL = src.substring(0, src.lastIndexOf("/"));
            break;
          }
        }
        if (!baseURL && document.currentScript) {
          var src = document.currentScript.src;
          if (src.indexOf(".min") !== -1) {
            suffix = ".min";
          }
          baseURL = src.substring(0, src.lastIndexOf("/"));
        }
      }
      self2.baseURL = new URI(documentBaseURL).toAbsolute(baseURL);
      self2.documentBaseURL = documentBaseURL;
      self2.baseURI = new URI(self2.baseURL);
      self2.suffix = suffix;
      setup$2(self2);
    },
    overrideDefaults: function(defaultSettings) {
      var baseUrl = defaultSettings.base_url;
      if (baseUrl) {
        this._setBaseUrl(baseUrl);
      }
      var suffix = defaultSettings.suffix;
      if (defaultSettings.suffix) {
        this.suffix = suffix;
      }
      this.defaultSettings = defaultSettings;
      var pluginBaseUrls = defaultSettings.plugin_base_urls;
      if (pluginBaseUrls !== void 0) {
        each$1(pluginBaseUrls, function(pluginBaseUrl, pluginName) {
          AddOnManager.PluginManager.urls[pluginName] = pluginBaseUrl;
        });
      }
    },
    init: function(settings) {
      var self2 = this;
      var result;
      var invalidInlineTargets = Tools.makeMap("area base basefont br col frame hr img input isindex link meta param embed source wbr track colgroup option table tbody tfoot thead tr th td script noscript style textarea video audio iframe object menu", " ");
      var isInvalidInlineTarget = function(settings2, elm) {
        return settings2.inline && elm.tagName.toLowerCase() in invalidInlineTargets;
      };
      var createId = function(elm) {
        var id2 = elm.id;
        if (!id2) {
          id2 = get$1(elm, "name").filter(function(name2) {
            return !DOM$a.get(name2);
          }).getOrThunk(DOM$a.uniqueId);
          elm.setAttribute("id", id2);
        }
        return id2;
      };
      var execCallback = function(name2) {
        var callback = settings[name2];
        if (!callback) {
          return;
        }
        return callback.apply(self2, []);
      };
      var hasClass2 = function(elm, className) {
        return className.constructor === RegExp ? className.test(elm.className) : DOM$a.hasClass(elm, className);
      };
      var findTargets = function(settings2) {
        var targets = [];
        if (Env.browser.isIE() && Env.browser.version.major < 11) {
          initError("TinyMCE does not support the browser you are using. For a list of supported browsers please see: https://www.tinymce.com/docs/get-started/system-requirements/");
          return [];
        } else if (isQuirksMode) {
          initError("Failed to initialize the editor as the document is not in standards mode. TinyMCE requires standards mode.");
          return [];
        }
        if (settings2.types) {
          each$j(settings2.types, function(type2) {
            targets = targets.concat(DOM$a.select(type2.selector));
          });
          return targets;
        } else if (settings2.selector) {
          return DOM$a.select(settings2.selector);
        } else if (settings2.target) {
          return [settings2.target];
        }
        switch (settings2.mode) {
          case "exact":
            var l2 = settings2.elements || "";
            if (l2.length > 0) {
              each$j(explode$4(l2), function(id2) {
                var elm = DOM$a.get(id2);
                if (elm) {
                  targets.push(elm);
                } else {
                  each$j(document.forms, function(f) {
                    each$j(f.elements, function(e) {
                      if (e.name === id2) {
                        id2 = "mce_editor_" + instanceCounter++;
                        DOM$a.setAttrib(e, "id", id2);
                        targets.push(e);
                      }
                    });
                  });
                }
              });
            }
            break;
          case "textareas":
          case "specific_textareas":
            each$j(DOM$a.select("textarea"), function(elm) {
              if (settings2.editor_deselector && hasClass2(elm, settings2.editor_deselector)) {
                return;
              }
              if (!settings2.editor_selector || hasClass2(elm, settings2.editor_selector)) {
                targets.push(elm);
              }
            });
            break;
        }
        return targets;
      };
      var provideResults = function(editors2) {
        result = editors2;
      };
      var initEditors = function() {
        var initCount = 0;
        var editors2 = [];
        var targets;
        var createEditor = function(id2, settings2, targetElm) {
          var editor = new Editor2(id2, settings2, self2);
          editors2.push(editor);
          editor.on("init", function() {
            if (++initCount === targets.length) {
              provideResults(editors2);
            }
          });
          editor.targetElm = editor.targetElm || targetElm;
          editor.render();
        };
        DOM$a.unbind(window, "ready", initEditors);
        execCallback("onpageload");
        targets = DomQuery.unique(findTargets(settings));
        if (settings.types) {
          each$j(settings.types, function(type2) {
            Tools.each(targets, function(elm) {
              if (DOM$a.is(elm, type2.selector)) {
                createEditor(createId(elm), extend$4({}, settings, type2), elm);
                return false;
              }
              return true;
            });
          });
          return;
        }
        Tools.each(targets, function(elm) {
          purgeDestroyedEditor(self2.get(elm.id));
        });
        targets = Tools.grep(targets, function(elm) {
          return !self2.get(elm.id);
        });
        if (targets.length === 0) {
          provideResults([]);
        } else {
          each$j(targets, function(elm) {
            if (isInvalidInlineTarget(settings, elm)) {
              initError("Could not initialize inline editor on invalid inline target element", elm);
            } else {
              createEditor(createId(elm), settings, elm);
            }
          });
        }
      };
      self2.settings = settings;
      DOM$a.bind(window, "ready", initEditors);
      return new promiseObj(function(resolve2) {
        if (result) {
          resolve2(result);
        } else {
          provideResults = function(editors2) {
            resolve2(editors2);
          };
        }
      });
    },
    get: function(id2) {
      if (arguments.length === 0) {
        return editors.slice(0);
      } else if (isString(id2)) {
        return find(editors, function(editor) {
          return editor.id === id2;
        }).getOr(null);
      } else if (isNumber(id2)) {
        return editors[id2] ? editors[id2] : null;
      } else {
        return null;
      }
    },
    add: function(editor) {
      var self2 = this;
      var existingEditor = legacyEditors[editor.id];
      if (existingEditor === editor) {
        return editor;
      }
      if (self2.get(editor.id) === null) {
        if (isValidLegacyKey(editor.id)) {
          legacyEditors[editor.id] = editor;
        }
        legacyEditors.push(editor);
        editors.push(editor);
      }
      toggleGlobalEvents(true);
      self2.activeEditor = editor;
      self2.fire("AddEditor", { editor });
      if (!beforeUnloadDelegate) {
        beforeUnloadDelegate = function(e) {
          var event = self2.fire("BeforeUnload");
          if (event.returnValue) {
            e.preventDefault();
            e.returnValue = event.returnValue;
            return event.returnValue;
          }
        };
        window.addEventListener("beforeunload", beforeUnloadDelegate);
      }
      return editor;
    },
    createEditor: function(id2, settings) {
      return this.add(new Editor2(id2, settings, this));
    },
    remove: function(selector) {
      var self2 = this;
      var i, editor;
      if (!selector) {
        for (i = editors.length - 1; i >= 0; i--) {
          self2.remove(editors[i]);
        }
        return;
      }
      if (isString(selector)) {
        each$j(DOM$a.select(selector), function(elm) {
          editor = self2.get(elm.id);
          if (editor) {
            self2.remove(editor);
          }
        });
        return;
      }
      editor = selector;
      if (isNull(self2.get(editor.id))) {
        return null;
      }
      if (removeEditorFromList(editor)) {
        self2.fire("RemoveEditor", { editor });
      }
      if (editors.length === 0) {
        window.removeEventListener("beforeunload", beforeUnloadDelegate);
      }
      editor.remove();
      toggleGlobalEvents(editors.length > 0);
      return editor;
    },
    execCommand: function(cmd, ui2, value2) {
      var self2 = this, editor = self2.get(value2);
      switch (cmd) {
        case "mceAddEditor":
          if (!self2.get(value2)) {
            new Editor2(value2, self2.settings, self2).render();
          }
          return true;
        case "mceRemoveEditor":
          if (editor) {
            editor.remove();
          }
          return true;
        case "mceToggleEditor":
          if (!editor) {
            self2.execCommand("mceAddEditor", false, value2);
            return true;
          }
          if (editor.isHidden()) {
            editor.show();
          } else {
            editor.hide();
          }
          return true;
      }
      if (self2.activeEditor) {
        return self2.activeEditor.execCommand(cmd, ui2, value2);
      }
      return false;
    },
    triggerSave: function() {
      each$j(editors, function(editor) {
        editor.save();
      });
    },
    addI18n: function(code, items) {
      I18n.add(code, items);
    },
    translate: function(text) {
      return I18n.translate(text);
    },
    setActive: function(editor) {
      var activeEditor = this.activeEditor;
      if (this.activeEditor !== editor) {
        if (activeEditor) {
          activeEditor.fire("deactivate", { relatedTarget: editor });
        }
        editor.fire("activate", { relatedTarget: activeEditor });
      }
      this.activeEditor = editor;
    },
    _setBaseUrl: function(baseUrl) {
      this.baseURL = new URI(this.documentBaseURL).toAbsolute(baseUrl.replace(/\/+$/, ""));
      this.baseURI = new URI(this.baseURL);
    }
  });
  EditorManager.setup();
  var min = Math.min, max = Math.max, round$1 = Math.round;
  var relativePosition = function(rect, targetRect, rel) {
    var x2 = targetRect.x;
    var y2 = targetRect.y;
    var w = rect.w;
    var h = rect.h;
    var targetW = targetRect.w;
    var targetH = targetRect.h;
    var relChars = (rel || "").split("");
    if (relChars[0] === "b") {
      y2 += targetH;
    }
    if (relChars[1] === "r") {
      x2 += targetW;
    }
    if (relChars[0] === "c") {
      y2 += round$1(targetH / 2);
    }
    if (relChars[1] === "c") {
      x2 += round$1(targetW / 2);
    }
    if (relChars[3] === "b") {
      y2 -= h;
    }
    if (relChars[4] === "r") {
      x2 -= w;
    }
    if (relChars[3] === "c") {
      y2 -= round$1(h / 2);
    }
    if (relChars[4] === "c") {
      x2 -= round$1(w / 2);
    }
    return create$7(x2, y2, w, h);
  };
  var findBestRelativePosition = function(rect, targetRect, constrainRect, rels) {
    var pos, i;
    for (i = 0; i < rels.length; i++) {
      pos = relativePosition(rect, targetRect, rels[i]);
      if (pos.x >= constrainRect.x && pos.x + pos.w <= constrainRect.w + constrainRect.x && pos.y >= constrainRect.y && pos.y + pos.h <= constrainRect.h + constrainRect.y) {
        return rels[i];
      }
    }
    return null;
  };
  var inflate = function(rect, w, h) {
    return create$7(rect.x - w, rect.y - h, rect.w + w * 2, rect.h + h * 2);
  };
  var intersect = function(rect, cropRect) {
    var x1 = max(rect.x, cropRect.x);
    var y1 = max(rect.y, cropRect.y);
    var x2 = min(rect.x + rect.w, cropRect.x + cropRect.w);
    var y2 = min(rect.y + rect.h, cropRect.y + cropRect.h);
    if (x2 - x1 < 0 || y2 - y1 < 0) {
      return null;
    }
    return create$7(x1, y1, x2 - x1, y2 - y1);
  };
  var clamp$1 = function(rect, clampRect, fixedSize) {
    var x1 = rect.x;
    var y1 = rect.y;
    var x2 = rect.x + rect.w;
    var y2 = rect.y + rect.h;
    var cx2 = clampRect.x + clampRect.w;
    var cy2 = clampRect.y + clampRect.h;
    var underflowX1 = max(0, clampRect.x - x1);
    var underflowY1 = max(0, clampRect.y - y1);
    var overflowX2 = max(0, x2 - cx2);
    var overflowY2 = max(0, y2 - cy2);
    x1 += underflowX1;
    y1 += underflowY1;
    if (fixedSize) {
      x2 += underflowX1;
      y2 += underflowY1;
      x1 -= overflowX2;
      y1 -= overflowY2;
    }
    x2 -= overflowX2;
    y2 -= overflowY2;
    return create$7(x1, y1, x2 - x1, y2 - y1);
  };
  var create$7 = function(x2, y2, w, h) {
    return {
      x: x2,
      y: y2,
      w,
      h
    };
  };
  var fromClientRect = function(clientRect) {
    return create$7(clientRect.left, clientRect.top, clientRect.width, clientRect.height);
  };
  var Rect = {
    inflate,
    relativePosition,
    findBestRelativePosition,
    intersect,
    clamp: clamp$1,
    create: create$7,
    fromClientRect
  };
  var awaiter = function(resolveCb, rejectCb, timeout) {
    if (timeout === void 0) {
      timeout = 1e3;
    }
    var done2 = false;
    var timer = null;
    var complete = function(completer) {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (!done2) {
          done2 = true;
          if (timer !== null) {
            clearTimeout(timer);
            timer = null;
          }
          completer.apply(null, args);
        }
      };
    };
    var resolve2 = complete(resolveCb);
    var reject = complete(rejectCb);
    var start2 = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (!done2 && timer === null) {
        timer = setTimeout(function() {
          return reject.apply(null, args);
        }, timeout);
      }
    };
    return {
      start: start2,
      resolve: resolve2,
      reject
    };
  };
  var create$8 = function() {
    var tasks = {};
    var resultFns = {};
    var load = function(id2, url) {
      var loadErrMsg = 'Script at URL "' + url + '" failed to load';
      var runErrMsg = 'Script at URL "' + url + "\" did not call `tinymce.Resource.add('" + id2 + "', data)` within 1 second";
      if (tasks[id2] !== void 0) {
        return tasks[id2];
      } else {
        var task = new promiseObj(function(resolve2, reject) {
          var waiter = awaiter(resolve2, reject);
          resultFns[id2] = waiter.resolve;
          ScriptLoader2.ScriptLoader.loadScript(url, function() {
            return waiter.start(runErrMsg);
          }, function() {
            return waiter.reject(loadErrMsg);
          });
        });
        tasks[id2] = task;
        return task;
      }
    };
    var add2 = function(id2, data2) {
      if (resultFns[id2] !== void 0) {
        resultFns[id2](data2);
        delete resultFns[id2];
      }
      tasks[id2] = promiseObj.resolve(data2);
    };
    return {
      load,
      add: add2
    };
  };
  var Resource = create$8();
  var each$k = Tools.each, extend$5 = Tools.extend;
  var extendClass, initializing;
  var Class = function() {
  };
  Class.extend = extendClass = function(props) {
    var self2 = this;
    var _super = self2.prototype;
    var Class2 = function() {
      var i, mixins, mixin;
      var self3 = this;
      if (!initializing) {
        if (self3.init) {
          self3.init.apply(self3, arguments);
        }
        mixins = self3.Mixins;
        if (mixins) {
          i = mixins.length;
          while (i--) {
            mixin = mixins[i];
            if (mixin.init) {
              mixin.init.apply(self3, arguments);
            }
          }
        }
      }
    };
    var dummy = function() {
      return this;
    };
    var createMethod = function(name2, fn) {
      return function() {
        var self3 = this;
        var tmp = self3._super;
        self3._super = _super[name2];
        var ret = fn.apply(self3, arguments);
        self3._super = tmp;
        return ret;
      };
    };
    initializing = true;
    var prototype = new self2();
    initializing = false;
    if (props.Mixins) {
      each$k(props.Mixins, function(mixin) {
        for (var name_1 in mixin) {
          if (name_1 !== "init") {
            props[name_1] = mixin[name_1];
          }
        }
      });
      if (_super.Mixins) {
        props.Mixins = _super.Mixins.concat(props.Mixins);
      }
    }
    if (props.Methods) {
      each$k(props.Methods.split(","), function(name2) {
        props[name2] = dummy;
      });
    }
    if (props.Properties) {
      each$k(props.Properties.split(","), function(name2) {
        var fieldName = "_" + name2;
        props[name2] = function(value2) {
          var self3 = this;
          if (value2 !== void 0) {
            self3[fieldName] = value2;
            return self3;
          }
          return self3[fieldName];
        };
      });
    }
    if (props.Statics) {
      each$k(props.Statics, function(func, name2) {
        Class2[name2] = func;
      });
    }
    if (props.Defaults && _super.Defaults) {
      props.Defaults = extend$5({}, _super.Defaults, props.Defaults);
    }
    each$1(props, function(member, name2) {
      if (typeof member === "function" && _super[name2]) {
        prototype[name2] = createMethod(name2, member);
      } else {
        prototype[name2] = member;
      }
    });
    Class2.prototype = prototype;
    Class2.constructor = Class2;
    Class2.extend = extendClass;
    return Class2;
  };
  var min$1 = Math.min, max$1 = Math.max, round$2 = Math.round;
  var Color = function(value2) {
    var self2 = {};
    var r3 = 0, g = 0, b = 0;
    var rgb2hsv = function(r4, g2, b2) {
      var h, s, v2;
      h = 0;
      s = 0;
      v2 = 0;
      r4 = r4 / 255;
      g2 = g2 / 255;
      b2 = b2 / 255;
      var minRGB = min$1(r4, min$1(g2, b2));
      var maxRGB = max$1(r4, max$1(g2, b2));
      if (minRGB === maxRGB) {
        v2 = minRGB;
        return {
          h: 0,
          s: 0,
          v: v2 * 100
        };
      }
      var d = r4 === minRGB ? g2 - b2 : b2 === minRGB ? r4 - g2 : b2 - r4;
      h = r4 === minRGB ? 3 : b2 === minRGB ? 1 : 5;
      h = 60 * (h - d / (maxRGB - minRGB));
      s = (maxRGB - minRGB) / maxRGB;
      v2 = maxRGB;
      return {
        h: round$2(h),
        s: round$2(s * 100),
        v: round$2(v2 * 100)
      };
    };
    var hsvToRgb = function(hue, saturation, brightness) {
      hue = (parseInt(hue, 10) || 0) % 360;
      saturation = parseInt(saturation, 10) / 100;
      brightness = parseInt(brightness, 10) / 100;
      saturation = max$1(0, min$1(saturation, 1));
      brightness = max$1(0, min$1(brightness, 1));
      if (saturation === 0) {
        r3 = g = b = round$2(255 * brightness);
        return;
      }
      var side = hue / 60;
      var chroma = brightness * saturation;
      var x2 = chroma * (1 - Math.abs(side % 2 - 1));
      var match2 = brightness - chroma;
      switch (Math.floor(side)) {
        case 0:
          r3 = chroma;
          g = x2;
          b = 0;
          break;
        case 1:
          r3 = x2;
          g = chroma;
          b = 0;
          break;
        case 2:
          r3 = 0;
          g = chroma;
          b = x2;
          break;
        case 3:
          r3 = 0;
          g = x2;
          b = chroma;
          break;
        case 4:
          r3 = x2;
          g = 0;
          b = chroma;
          break;
        case 5:
          r3 = chroma;
          g = 0;
          b = x2;
          break;
        default:
          r3 = g = b = 0;
      }
      r3 = round$2(255 * (r3 + match2));
      g = round$2(255 * (g + match2));
      b = round$2(255 * (b + match2));
    };
    var toHex2 = function() {
      var hex = function(val) {
        val = parseInt(val, 10).toString(16);
        return val.length > 1 ? val : "0" + val;
      };
      return "#" + hex(r3) + hex(g) + hex(b);
    };
    var toRgb = function() {
      return {
        r: r3,
        g,
        b
      };
    };
    var toHsv = function() {
      return rgb2hsv(r3, g, b);
    };
    var parse = function(value3) {
      var matches2;
      if (typeof value3 === "object") {
        if ("r" in value3) {
          r3 = value3.r;
          g = value3.g;
          b = value3.b;
        } else if ("v" in value3) {
          hsvToRgb(value3.h, value3.s, value3.v);
        }
      } else {
        if (matches2 = /rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)[^\)]*\)/gi.exec(value3)) {
          r3 = parseInt(matches2[1], 10);
          g = parseInt(matches2[2], 10);
          b = parseInt(matches2[3], 10);
        } else if (matches2 = /#([0-F]{2})([0-F]{2})([0-F]{2})/gi.exec(value3)) {
          r3 = parseInt(matches2[1], 16);
          g = parseInt(matches2[2], 16);
          b = parseInt(matches2[3], 16);
        } else if (matches2 = /#([0-F])([0-F])([0-F])/gi.exec(value3)) {
          r3 = parseInt(matches2[1] + matches2[1], 16);
          g = parseInt(matches2[2] + matches2[2], 16);
          b = parseInt(matches2[3] + matches2[3], 16);
        }
      }
      r3 = r3 < 0 ? 0 : r3 > 255 ? 255 : r3;
      g = g < 0 ? 0 : g > 255 ? 255 : g;
      b = b < 0 ? 0 : b > 255 ? 255 : b;
      return self2;
    };
    if (value2) {
      parse(value2);
    }
    self2.toRgb = toRgb;
    self2.toHsv = toHsv;
    self2.toHex = toHex2;
    self2.parse = parse;
    return self2;
  };
  var serialize = function(obj) {
    var data2 = JSON.stringify(obj);
    if (!isString(data2)) {
      return data2;
    }
    return data2.replace(/[\u0080-\uFFFF]/g, function(match2) {
      var hexCode = match2.charCodeAt(0).toString(16);
      return "\\u" + "0000".substring(hexCode.length) + hexCode;
    });
  };
  var JSONUtils = {
    serialize,
    parse: function(text) {
      try {
        return JSON.parse(text);
      } catch (ex) {
      }
    }
  };
  var JSONP = {
    callbacks: {},
    count: 0,
    send: function(settings) {
      var self2 = this, dom2 = DOMUtils.DOM, count2 = settings.count !== void 0 ? settings.count : self2.count;
      var id2 = "tinymce_jsonp_" + count2;
      self2.callbacks[count2] = function(json) {
        dom2.remove(id2);
        delete self2.callbacks[count2];
        settings.callback(json);
      };
      dom2.add(dom2.doc.body, "script", {
        id: id2,
        src: settings.url,
        type: "text/javascript"
      });
      self2.count++;
    }
  };
  var XHR = __assign2(__assign2({}, Observable), {
    send: function(settings) {
      var xhr, count2 = 0;
      var ready = function() {
        if (!settings.async || xhr.readyState === 4 || count2++ > 1e4) {
          if (settings.success && count2 < 1e4 && xhr.status === 200) {
            settings.success.call(settings.success_scope, "" + xhr.responseText, xhr, settings);
          } else if (settings.error) {
            settings.error.call(settings.error_scope, count2 > 1e4 ? "TIMED_OUT" : "GENERAL", xhr, settings);
          }
          xhr = null;
        } else {
          Delay.setTimeout(ready, 10);
        }
      };
      settings.scope = settings.scope || this;
      settings.success_scope = settings.success_scope || settings.scope;
      settings.error_scope = settings.error_scope || settings.scope;
      settings.async = settings.async !== false;
      settings.data = settings.data || "";
      XHR.fire("beforeInitialize", { settings });
      xhr = new XMLHttpRequest();
      if (xhr.overrideMimeType) {
        xhr.overrideMimeType(settings.content_type);
      }
      xhr.open(settings.type || (settings.data ? "POST" : "GET"), settings.url, settings.async);
      if (settings.crossDomain) {
        xhr.withCredentials = true;
      }
      if (settings.content_type) {
        xhr.setRequestHeader("Content-Type", settings.content_type);
      }
      if (settings.requestheaders) {
        Tools.each(settings.requestheaders, function(header) {
          xhr.setRequestHeader(header.key, header.value);
        });
      }
      xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
      xhr = XHR.fire("beforeSend", {
        xhr,
        settings
      }).xhr;
      xhr.send(settings.data);
      if (!settings.async) {
        return ready();
      }
      Delay.setTimeout(ready, 10);
    }
  });
  var extend$6 = Tools.extend;
  var JSONRequest = function() {
    function JSONRequest2(settings) {
      this.settings = extend$6({}, settings);
      this.count = 0;
    }
    JSONRequest2.sendRPC = function(o) {
      return new JSONRequest2().send(o);
    };
    JSONRequest2.prototype.send = function(args) {
      var ecb = args.error, scb = args.success;
      var xhrArgs = extend$6(this.settings, args);
      xhrArgs.success = function(c, x2) {
        c = JSONUtils.parse(c);
        if (typeof c === "undefined") {
          c = { error: "JSON Parse error." };
        }
        if (c.error) {
          ecb.call(xhrArgs.error_scope || xhrArgs.scope, c.error, x2);
        } else {
          scb.call(xhrArgs.success_scope || xhrArgs.scope, c.result);
        }
      };
      xhrArgs.error = function(ty, x2) {
        if (ecb) {
          ecb.call(xhrArgs.error_scope || xhrArgs.scope, ty, x2);
        }
      };
      xhrArgs.data = JSONUtils.serialize({
        id: args.id || "c" + this.count++,
        method: args.method,
        params: args.params
      });
      xhrArgs.content_type = "application/json";
      XHR.send(xhrArgs);
    };
    return JSONRequest2;
  }();
  var create$9 = function() {
    return function() {
      var data2 = {};
      var keys2 = [];
      var storage = {
        getItem: function(key) {
          var item = data2[key];
          return item ? item : null;
        },
        setItem: function(key, value2) {
          keys2.push(key);
          data2[key] = String(value2);
        },
        key: function(index) {
          return keys2[index];
        },
        removeItem: function(key) {
          keys2 = keys2.filter(function(k) {
            return k === key;
          });
          delete data2[key];
        },
        clear: function() {
          keys2 = [];
          data2 = {};
        },
        length: 0
      };
      Object.defineProperty(storage, "length", {
        get: function() {
          return keys2.length;
        },
        configurable: false,
        enumerable: false
      });
      return storage;
    }();
  };
  var localStorage;
  try {
    var test = "__storage_test__";
    localStorage = window.localStorage;
    localStorage.setItem(test, test);
    localStorage.removeItem(test);
  } catch (e) {
    localStorage = create$9();
  }
  var LocalStorage = localStorage;
  var publicApi = {
    geom: { Rect },
    util: {
      Promise: promiseObj,
      Delay,
      Tools,
      VK,
      URI,
      Class,
      EventDispatcher,
      Observable,
      I18n,
      XHR,
      JSON: JSONUtils,
      JSONRequest,
      JSONP,
      LocalStorage,
      Color,
      ImageUploader
    },
    dom: {
      EventUtils,
      Sizzle,
      DomQuery,
      TreeWalker: DomTreeWalker,
      TextSeeker,
      DOMUtils,
      ScriptLoader: ScriptLoader2,
      RangeUtils,
      Serializer: DomSerializer,
      StyleSheetLoader,
      ControlSelection,
      BookmarkManager,
      Selection: EditorSelection,
      Event: EventUtils.Event
    },
    html: {
      Styles,
      Entities,
      Node: AstNode,
      Schema,
      SaxParser,
      DomParser,
      Writer,
      Serializer: HtmlSerializer
    },
    Env,
    AddOnManager,
    Annotator,
    Formatter,
    UndoManager,
    EditorCommands,
    WindowManager,
    NotificationManager,
    EditorObservable,
    Shortcuts,
    Editor: Editor2,
    FocusManager,
    EditorManager,
    DOM: DOMUtils.DOM,
    ScriptLoader: ScriptLoader2.ScriptLoader,
    PluginManager,
    ThemeManager,
    IconManager,
    Resource,
    trim: Tools.trim,
    isArray: Tools.isArray,
    is: Tools.is,
    toArray: Tools.toArray,
    makeMap: Tools.makeMap,
    each: Tools.each,
    map: Tools.map,
    grep: Tools.grep,
    inArray: Tools.inArray,
    extend: Tools.extend,
    create: Tools.create,
    walk: Tools.walk,
    createNS: Tools.createNS,
    resolve: Tools.resolve,
    explode: Tools.explode,
    _addCacheSuffix: Tools._addCacheSuffix,
    isOpera: Env.opera,
    isWebKit: Env.webkit,
    isIE: Env.ie,
    isGecko: Env.gecko,
    isMac: Env.mac
  };
  var tinymce2 = Tools.extend(EditorManager, publicApi);
  var exportToModuleLoaders = function(tinymce3) {
    if (typeof module === "object") {
      try {
        module.exports = tinymce3;
      } catch (_) {
      }
    }
  };
  var exportToWindowGlobal = function(tinymce3) {
    window.tinymce = tinymce3;
    window.tinyMCE = tinymce3;
  };
  exportToWindowGlobal(tinymce2);
  exportToModuleLoaders(tinymce2);
})();
tinymce;
var react = { exports: {} };
var react_production_min = {};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject(val) {
  if (val === null || val === void 0) {
    throw new TypeError("Object.assign cannot be called with null or undefined");
  }
  return Object(val);
}
function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    }
    var test1 = new String("abc");
    test1[5] = "de";
    if (Object.getOwnPropertyNames(test1)[0] === "5") {
      return false;
    }
    var test2 = {};
    for (var i = 0; i < 10; i++) {
      test2["_" + String.fromCharCode(i)] = i;
    }
    var order2 = Object.getOwnPropertyNames(test2).map(function(n2) {
      return test2[n2];
    });
    if (order2.join("") !== "0123456789") {
      return false;
    }
    var test3 = {};
    "abcdefghijklmnopqrst".split("").forEach(function(letter) {
      test3[letter] = letter;
    });
    if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
      return false;
    }
    return true;
  } catch (err) {
    return false;
  }
}
var objectAssign = shouldUseNative() ? Object.assign : function(target, source) {
  var from;
  var to = toObject(target);
  var symbols;
  for (var s = 1; s < arguments.length; s++) {
    from = Object(arguments[s]);
    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }
    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);
      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from, symbols[i])) {
          to[symbols[i]] = from[symbols[i]];
        }
      }
    }
  }
  return to;
};
/** @license React v17.0.2
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l = objectAssign, n = 60103, p = 60106;
react_production_min.Fragment = 60107;
react_production_min.StrictMode = 60108;
react_production_min.Profiler = 60114;
var q = 60109, r$1 = 60110, t = 60112;
react_production_min.Suspense = 60113;
var u = 60115, v = 60116;
if (typeof Symbol === "function" && Symbol.for) {
  var w = Symbol.for;
  n = w("react.element");
  p = w("react.portal");
  react_production_min.Fragment = w("react.fragment");
  react_production_min.StrictMode = w("react.strict_mode");
  react_production_min.Profiler = w("react.profiler");
  q = w("react.provider");
  r$1 = w("react.context");
  t = w("react.forward_ref");
  react_production_min.Suspense = w("react.suspense");
  u = w("react.memo");
  v = w("react.lazy");
}
var x = typeof Symbol === "function" && Symbol.iterator;
function y$1(a) {
  if (a === null || typeof a !== "object")
    return null;
  a = x && a[x] || a["@@iterator"];
  return typeof a === "function" ? a : null;
}
function z(a) {
  for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++)
    b += "&args[]=" + encodeURIComponent(arguments[c]);
  return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var A = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, B$1 = {};
function C(a, b, c) {
  this.props = a;
  this.context = b;
  this.refs = B$1;
  this.updater = c || A;
}
C.prototype.isReactComponent = {};
C.prototype.setState = function(a, b) {
  if (typeof a !== "object" && typeof a !== "function" && a != null)
    throw Error(z(85));
  this.updater.enqueueSetState(this, a, b, "setState");
};
C.prototype.forceUpdate = function(a) {
  this.updater.enqueueForceUpdate(this, a, "forceUpdate");
};
function D$1() {
}
D$1.prototype = C.prototype;
function E$1(a, b, c) {
  this.props = a;
  this.context = b;
  this.refs = B$1;
  this.updater = c || A;
}
var F$1 = E$1.prototype = new D$1();
F$1.constructor = E$1;
l(F$1, C.prototype);
F$1.isPureReactComponent = true;
var G$1 = { current: null }, H$1 = Object.prototype.hasOwnProperty, I$1 = { key: true, ref: true, __self: true, __source: true };
function J(a, b, c) {
  var e, d = {}, k = null, h = null;
  if (b != null)
    for (e in b.ref !== void 0 && (h = b.ref), b.key !== void 0 && (k = "" + b.key), b)
      H$1.call(b, e) && !I$1.hasOwnProperty(e) && (d[e] = b[e]);
  var g = arguments.length - 2;
  if (g === 1)
    d.children = c;
  else if (1 < g) {
    for (var f = Array(g), m2 = 0; m2 < g; m2++)
      f[m2] = arguments[m2 + 2];
    d.children = f;
  }
  if (a && a.defaultProps)
    for (e in g = a.defaultProps, g)
      d[e] === void 0 && (d[e] = g[e]);
  return { $$typeof: n, type: a, key: k, ref: h, props: d, _owner: G$1.current };
}
function K(a, b) {
  return { $$typeof: n, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
}
function L(a) {
  return typeof a === "object" && a !== null && a.$$typeof === n;
}
function escape$1(a) {
  var b = { "=": "=0", ":": "=2" };
  return "$" + a.replace(/[=:]/g, function(a2) {
    return b[a2];
  });
}
var M$1 = /\/+/g;
function N$1(a, b) {
  return typeof a === "object" && a !== null && a.key != null ? escape$1("" + a.key) : b.toString(36);
}
function O$1(a, b, c, e, d) {
  var k = typeof a;
  if (k === "undefined" || k === "boolean")
    a = null;
  var h = false;
  if (a === null)
    h = true;
  else
    switch (k) {
      case "string":
      case "number":
        h = true;
        break;
      case "object":
        switch (a.$$typeof) {
          case n:
          case p:
            h = true;
        }
    }
  if (h)
    return h = a, d = d(h), a = e === "" ? "." + N$1(h, 0) : e, Array.isArray(d) ? (c = "", a != null && (c = a.replace(M$1, "$&/") + "/"), O$1(d, b, c, "", function(a2) {
      return a2;
    })) : d != null && (L(d) && (d = K(d, c + (!d.key || h && h.key === d.key ? "" : ("" + d.key).replace(M$1, "$&/") + "/") + a)), b.push(d)), 1;
  h = 0;
  e = e === "" ? "." : e + ":";
  if (Array.isArray(a))
    for (var g = 0; g < a.length; g++) {
      k = a[g];
      var f = e + N$1(k, g);
      h += O$1(k, b, c, f, d);
    }
  else if (f = y$1(a), typeof f === "function")
    for (a = f.call(a), g = 0; !(k = a.next()).done; )
      k = k.value, f = e + N$1(k, g++), h += O$1(k, b, c, f, d);
  else if (k === "object")
    throw b = "" + a, Error(z(31, b === "[object Object]" ? "object with keys {" + Object.keys(a).join(", ") + "}" : b));
  return h;
}
function P$1(a, b, c) {
  if (a == null)
    return a;
  var e = [], d = 0;
  O$1(a, e, "", "", function(a2) {
    return b.call(c, a2, d++);
  });
  return e;
}
function Q(a) {
  if (a._status === -1) {
    var b = a._result;
    b = b();
    a._status = 0;
    a._result = b;
    b.then(function(b2) {
      a._status === 0 && (b2 = b2.default, a._status = 1, a._result = b2);
    }, function(b2) {
      a._status === 0 && (a._status = 2, a._result = b2);
    });
  }
  if (a._status === 1)
    return a._result;
  throw a._result;
}
var R$1 = { current: null };
function S$1() {
  var a = R$1.current;
  if (a === null)
    throw Error(z(321));
  return a;
}
var T$1 = { ReactCurrentDispatcher: R$1, ReactCurrentBatchConfig: { transition: 0 }, ReactCurrentOwner: G$1, IsSomeRendererActing: { current: false }, assign: l };
react_production_min.Children = { map: P$1, forEach: function(a, b, c) {
  P$1(a, function() {
    b.apply(this, arguments);
  }, c);
}, count: function(a) {
  var b = 0;
  P$1(a, function() {
    b++;
  });
  return b;
}, toArray: function(a) {
  return P$1(a, function(a2) {
    return a2;
  }) || [];
}, only: function(a) {
  if (!L(a))
    throw Error(z(143));
  return a;
} };
react_production_min.Component = C;
react_production_min.PureComponent = E$1;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = T$1;
react_production_min.cloneElement = function(a, b, c) {
  if (a === null || a === void 0)
    throw Error(z(267, a));
  var e = l({}, a.props), d = a.key, k = a.ref, h = a._owner;
  if (b != null) {
    b.ref !== void 0 && (k = b.ref, h = G$1.current);
    b.key !== void 0 && (d = "" + b.key);
    if (a.type && a.type.defaultProps)
      var g = a.type.defaultProps;
    for (f in b)
      H$1.call(b, f) && !I$1.hasOwnProperty(f) && (e[f] = b[f] === void 0 && g !== void 0 ? g[f] : b[f]);
  }
  var f = arguments.length - 2;
  if (f === 1)
    e.children = c;
  else if (1 < f) {
    g = Array(f);
    for (var m2 = 0; m2 < f; m2++)
      g[m2] = arguments[m2 + 2];
    e.children = g;
  }
  return {
    $$typeof: n,
    type: a.type,
    key: d,
    ref: k,
    props: e,
    _owner: h
  };
};
react_production_min.createContext = function(a, b) {
  b === void 0 && (b = null);
  a = { $$typeof: r$1, _calculateChangedBits: b, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null };
  a.Provider = { $$typeof: q, _context: a };
  return a.Consumer = a;
};
react_production_min.createElement = J;
react_production_min.createFactory = function(a) {
  var b = J.bind(null, a);
  b.type = a;
  return b;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a) {
  return { $$typeof: t, render: a };
};
react_production_min.isValidElement = L;
react_production_min.lazy = function(a) {
  return { $$typeof: v, _payload: { _status: -1, _result: a }, _init: Q };
};
react_production_min.memo = function(a, b) {
  return { $$typeof: u, type: a, compare: b === void 0 ? null : b };
};
react_production_min.useCallback = function(a, b) {
  return S$1().useCallback(a, b);
};
react_production_min.useContext = function(a, b) {
  return S$1().useContext(a, b);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useEffect = function(a, b) {
  return S$1().useEffect(a, b);
};
react_production_min.useImperativeHandle = function(a, b, c) {
  return S$1().useImperativeHandle(a, b, c);
};
react_production_min.useLayoutEffect = function(a, b) {
  return S$1().useLayoutEffect(a, b);
};
react_production_min.useMemo = function(a, b) {
  return S$1().useMemo(a, b);
};
react_production_min.useReducer = function(a, b, c) {
  return S$1().useReducer(a, b, c);
};
react_production_min.useRef = function(a) {
  return S$1().useRef(a);
};
react_production_min.useState = function(a) {
  return S$1().useState(a);
};
react_production_min.version = "17.0.2";
{
  react.exports = react_production_min;
}
var React = react.exports;
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/** @license React v0.20.2
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  var f, g, h, k;
  if (typeof performance === "object" && typeof performance.now === "function") {
    var l2 = performance;
    exports.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  if (typeof window === "undefined" || typeof MessageChannel !== "function") {
    var t2 = null, u2 = null, w = function() {
      if (t2 !== null)
        try {
          var a = exports.unstable_now();
          t2(true, a);
          t2 = null;
        } catch (b) {
          throw setTimeout(w, 0), b;
        }
    };
    f = function(a) {
      t2 !== null ? setTimeout(f, 0, a) : (t2 = a, setTimeout(w, 0));
    };
    g = function(a, b) {
      u2 = setTimeout(a, b);
    };
    h = function() {
      clearTimeout(u2);
    };
    exports.unstable_shouldYield = function() {
      return false;
    };
    k = exports.unstable_forceFrameRate = function() {
    };
  } else {
    var x2 = window.setTimeout, y2 = window.clearTimeout;
    if (typeof console !== "undefined") {
      var z2 = window.cancelAnimationFrame;
      typeof window.requestAnimationFrame !== "function" && console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
      typeof z2 !== "function" && console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
    }
    var A2 = false, B2 = null, C2 = -1, D2 = 5, E = 0;
    exports.unstable_shouldYield = function() {
      return exports.unstable_now() >= E;
    };
    k = function() {
    };
    exports.unstable_forceFrameRate = function(a) {
      0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : D2 = 0 < a ? Math.floor(1e3 / a) : 5;
    };
    var F2 = new MessageChannel(), G2 = F2.port2;
    F2.port1.onmessage = function() {
      if (B2 !== null) {
        var a = exports.unstable_now();
        E = a + D2;
        try {
          B2(true, a) ? G2.postMessage(null) : (A2 = false, B2 = null);
        } catch (b) {
          throw G2.postMessage(null), b;
        }
      } else
        A2 = false;
    };
    f = function(a) {
      B2 = a;
      A2 || (A2 = true, G2.postMessage(null));
    };
    g = function(a, b) {
      C2 = x2(function() {
        a(exports.unstable_now());
      }, b);
    };
    h = function() {
      y2(C2);
      C2 = -1;
    };
  }
  function H2(a, b) {
    var c = a.length;
    a.push(b);
    a:
      for (; ; ) {
        var d = c - 1 >>> 1, e = a[d];
        if (e !== void 0 && 0 < I2(e, b))
          a[d] = b, a[c] = e, c = d;
        else
          break a;
      }
  }
  function J2(a) {
    a = a[0];
    return a === void 0 ? null : a;
  }
  function K2(a) {
    var b = a[0];
    if (b !== void 0) {
      var c = a.pop();
      if (c !== b) {
        a[0] = c;
        a:
          for (var d = 0, e = a.length; d < e; ) {
            var m2 = 2 * (d + 1) - 1, n2 = a[m2], v2 = m2 + 1, r2 = a[v2];
            if (n2 !== void 0 && 0 > I2(n2, c))
              r2 !== void 0 && 0 > I2(r2, n2) ? (a[d] = r2, a[v2] = c, d = v2) : (a[d] = n2, a[m2] = c, d = m2);
            else if (r2 !== void 0 && 0 > I2(r2, c))
              a[d] = r2, a[v2] = c, d = v2;
            else
              break a;
          }
      }
      return b;
    }
    return null;
  }
  function I2(a, b) {
    var c = a.sortIndex - b.sortIndex;
    return c !== 0 ? c : a.id - b.id;
  }
  var L2 = [], M2 = [], N2 = 1, O2 = null, P2 = 3, Q2 = false, R2 = false, S2 = false;
  function T2(a) {
    for (var b = J2(M2); b !== null; ) {
      if (b.callback === null)
        K2(M2);
      else if (b.startTime <= a)
        K2(M2), b.sortIndex = b.expirationTime, H2(L2, b);
      else
        break;
      b = J2(M2);
    }
  }
  function U2(a) {
    S2 = false;
    T2(a);
    if (!R2)
      if (J2(L2) !== null)
        R2 = true, f(V2);
      else {
        var b = J2(M2);
        b !== null && g(U2, b.startTime - a);
      }
  }
  function V2(a, b) {
    R2 = false;
    S2 && (S2 = false, h());
    Q2 = true;
    var c = P2;
    try {
      T2(b);
      for (O2 = J2(L2); O2 !== null && (!(O2.expirationTime > b) || a && !exports.unstable_shouldYield()); ) {
        var d = O2.callback;
        if (typeof d === "function") {
          O2.callback = null;
          P2 = O2.priorityLevel;
          var e = d(O2.expirationTime <= b);
          b = exports.unstable_now();
          typeof e === "function" ? O2.callback = e : O2 === J2(L2) && K2(L2);
          T2(b);
        } else
          K2(L2);
        O2 = J2(L2);
      }
      if (O2 !== null)
        var m2 = true;
      else {
        var n2 = J2(M2);
        n2 !== null && g(U2, n2.startTime - b);
        m2 = false;
      }
      return m2;
    } finally {
      O2 = null, P2 = c, Q2 = false;
    }
  }
  var W2 = k;
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(a) {
    a.callback = null;
  };
  exports.unstable_continueExecution = function() {
    R2 || Q2 || (R2 = true, f(V2));
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return P2;
  };
  exports.unstable_getFirstCallbackNode = function() {
    return J2(L2);
  };
  exports.unstable_next = function(a) {
    switch (P2) {
      case 1:
      case 2:
      case 3:
        var b = 3;
        break;
      default:
        b = P2;
    }
    var c = P2;
    P2 = b;
    try {
      return a();
    } finally {
      P2 = c;
    }
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_requestPaint = W2;
  exports.unstable_runWithPriority = function(a, b) {
    switch (a) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a = 3;
    }
    var c = P2;
    P2 = a;
    try {
      return b();
    } finally {
      P2 = c;
    }
  };
  exports.unstable_scheduleCallback = function(a, b, c) {
    var d = exports.unstable_now();
    typeof c === "object" && c !== null ? (c = c.delay, c = typeof c === "number" && 0 < c ? d + c : d) : c = d;
    switch (a) {
      case 1:
        var e = -1;
        break;
      case 2:
        e = 250;
        break;
      case 5:
        e = 1073741823;
        break;
      case 4:
        e = 1e4;
        break;
      default:
        e = 5e3;
    }
    e = c + e;
    a = { id: N2++, callback: b, priorityLevel: a, startTime: c, expirationTime: e, sortIndex: -1 };
    c > d ? (a.sortIndex = c, H2(M2, a), J2(L2) === null && a === J2(M2) && (S2 ? h() : S2 = true, g(U2, c - d))) : (a.sortIndex = e, H2(L2, a), R2 || Q2 || (R2 = true, f(V2)));
    return a;
  };
  exports.unstable_wrapCallback = function(a) {
    var b = P2;
    return function() {
      var c = P2;
      P2 = b;
      try {
        return a.apply(this, arguments);
      } finally {
        P2 = c;
      }
    };
  };
})(scheduler_production_min);
{
  scheduler.exports = scheduler_production_min;
}
/** @license React v17.0.2
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = react.exports, m = objectAssign, r = scheduler.exports;
function y(a) {
  for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++)
    b += "&args[]=" + encodeURIComponent(arguments[c]);
  return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
if (!aa)
  throw Error(y(227));
var ba = /* @__PURE__ */ new Set(), ca = {};
function da(a, b) {
  ea(a, b);
  ea(a + "Capture", b);
}
function ea(a, b) {
  ca[a] = b;
  for (a = 0; a < b.length; a++)
    ba.add(b[a]);
}
var fa = !(typeof window === "undefined" || typeof window.document === "undefined" || typeof window.document.createElement === "undefined"), ha = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, ia = Object.prototype.hasOwnProperty, ja = {}, ka = {};
function la(a) {
  if (ia.call(ka, a))
    return true;
  if (ia.call(ja, a))
    return false;
  if (ha.test(a))
    return ka[a] = true;
  ja[a] = true;
  return false;
}
function ma(a, b, c, d) {
  if (c !== null && c.type === 0)
    return false;
  switch (typeof b) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d)
        return false;
      if (c !== null)
        return !c.acceptsBooleans;
      a = a.toLowerCase().slice(0, 5);
      return a !== "data-" && a !== "aria-";
    default:
      return false;
  }
}
function na(a, b, c, d) {
  if (b === null || typeof b === "undefined" || ma(a, b, c, d))
    return true;
  if (d)
    return false;
  if (c !== null)
    switch (c.type) {
      case 3:
        return !b;
      case 4:
        return b === false;
      case 5:
        return isNaN(b);
      case 6:
        return isNaN(b) || 1 > b;
    }
  return false;
}
function B(a, b, c, d, e, f, g) {
  this.acceptsBooleans = b === 2 || b === 3 || b === 4;
  this.attributeName = d;
  this.attributeNamespace = e;
  this.mustUseProperty = c;
  this.propertyName = a;
  this.type = b;
  this.sanitizeURL = f;
  this.removeEmptyString = g;
}
var D = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
  D[a] = new B(a, 0, false, a, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
  var b = a[0];
  D[b] = new B(b, 1, false, a[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
  D[a] = new B(a, 2, false, a.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
  D[a] = new B(a, 2, false, a, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
  D[a] = new B(a, 3, false, a.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a) {
  D[a] = new B(a, 3, true, a, null, false, false);
});
["capture", "download"].forEach(function(a) {
  D[a] = new B(a, 4, false, a, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a) {
  D[a] = new B(a, 6, false, a, null, false, false);
});
["rowSpan", "start"].forEach(function(a) {
  D[a] = new B(a, 5, false, a.toLowerCase(), null, false, false);
});
var oa = /[\-:]([a-z])/g;
function pa(a) {
  return a[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
  var b = a.replace(oa, pa);
  D[b] = new B(b, 1, false, a, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
  var b = a.replace(oa, pa);
  D[b] = new B(b, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
  var b = a.replace(oa, pa);
  D[b] = new B(b, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a) {
  D[a] = new B(a, 1, false, a.toLowerCase(), null, false, false);
});
D.xlinkHref = new B("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a) {
  D[a] = new B(a, 1, false, a.toLowerCase(), null, true, true);
});
function qa(a, b, c, d) {
  var e = D.hasOwnProperty(b) ? D[b] : null;
  var f = e !== null ? e.type === 0 : d ? false : !(2 < b.length) || b[0] !== "o" && b[0] !== "O" || b[1] !== "n" && b[1] !== "N" ? false : true;
  f || (na(b, c, e, d) && (c = null), d || e === null ? la(b) && (c === null ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = c === null ? e.type === 3 ? false : "" : c : (b = e.attributeName, d = e.attributeNamespace, c === null ? a.removeAttribute(b) : (e = e.type, c = e === 3 || e === 4 && c === true ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c))));
}
var ra = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, sa = 60103, ta = 60106, ua = 60107, wa = 60108, xa = 60114, ya = 60109, za = 60110, Aa = 60112, Ba = 60113, Ca = 60120, Da = 60115, Ea = 60116, Fa = 60121, Ga = 60128, Ha = 60129, Ia = 60130, Ja = 60131;
if (typeof Symbol === "function" && Symbol.for) {
  var E = Symbol.for;
  sa = E("react.element");
  ta = E("react.portal");
  ua = E("react.fragment");
  wa = E("react.strict_mode");
  xa = E("react.profiler");
  ya = E("react.provider");
  za = E("react.context");
  Aa = E("react.forward_ref");
  Ba = E("react.suspense");
  Ca = E("react.suspense_list");
  Da = E("react.memo");
  Ea = E("react.lazy");
  Fa = E("react.block");
  E("react.scope");
  Ga = E("react.opaque.id");
  Ha = E("react.debug_trace_mode");
  Ia = E("react.offscreen");
  Ja = E("react.legacy_hidden");
}
var Ka = typeof Symbol === "function" && Symbol.iterator;
function La(a) {
  if (a === null || typeof a !== "object")
    return null;
  a = Ka && a[Ka] || a["@@iterator"];
  return typeof a === "function" ? a : null;
}
var Ma;
function Na(a) {
  if (Ma === void 0)
    try {
      throw Error();
    } catch (c) {
      var b = c.stack.trim().match(/\n( *(at )?)/);
      Ma = b && b[1] || "";
    }
  return "\n" + Ma + a;
}
var Oa = false;
function Pa(a, b) {
  if (!a || Oa)
    return "";
  Oa = true;
  var c = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b)
      if (b = function() {
        throw Error();
      }, Object.defineProperty(b.prototype, "props", { set: function() {
        throw Error();
      } }), typeof Reflect === "object" && Reflect.construct) {
        try {
          Reflect.construct(b, []);
        } catch (k) {
          var d = k;
        }
        Reflect.construct(a, [], b);
      } else {
        try {
          b.call();
        } catch (k) {
          d = k;
        }
        a.call(b.prototype);
      }
    else {
      try {
        throw Error();
      } catch (k) {
        d = k;
      }
      a();
    }
  } catch (k) {
    if (k && d && typeof k.stack === "string") {
      for (var e = k.stack.split("\n"), f = d.stack.split("\n"), g = e.length - 1, h = f.length - 1; 1 <= g && 0 <= h && e[g] !== f[h]; )
        h--;
      for (; 1 <= g && 0 <= h; g--, h--)
        if (e[g] !== f[h]) {
          if (g !== 1 || h !== 1) {
            do
              if (g--, h--, 0 > h || e[g] !== f[h])
                return "\n" + e[g].replace(" at new ", " at ");
            while (1 <= g && 0 <= h);
          }
          break;
        }
    }
  } finally {
    Oa = false, Error.prepareStackTrace = c;
  }
  return (a = a ? a.displayName || a.name : "") ? Na(a) : "";
}
function Qa(a) {
  switch (a.tag) {
    case 5:
      return Na(a.type);
    case 16:
      return Na("Lazy");
    case 13:
      return Na("Suspense");
    case 19:
      return Na("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a = Pa(a.type, false), a;
    case 11:
      return a = Pa(a.type.render, false), a;
    case 22:
      return a = Pa(a.type._render, false), a;
    case 1:
      return a = Pa(a.type, true), a;
    default:
      return "";
  }
}
function Ra(a) {
  if (a == null)
    return null;
  if (typeof a === "function")
    return a.displayName || a.name || null;
  if (typeof a === "string")
    return a;
  switch (a) {
    case ua:
      return "Fragment";
    case ta:
      return "Portal";
    case xa:
      return "Profiler";
    case wa:
      return "StrictMode";
    case Ba:
      return "Suspense";
    case Ca:
      return "SuspenseList";
  }
  if (typeof a === "object")
    switch (a.$$typeof) {
      case za:
        return (a.displayName || "Context") + ".Consumer";
      case ya:
        return (a._context.displayName || "Context") + ".Provider";
      case Aa:
        var b = a.render;
        b = b.displayName || b.name || "";
        return a.displayName || (b !== "" ? "ForwardRef(" + b + ")" : "ForwardRef");
      case Da:
        return Ra(a.type);
      case Fa:
        return Ra(a._render);
      case Ea:
        b = a._payload;
        a = a._init;
        try {
          return Ra(a(b));
        } catch (c) {
        }
    }
  return null;
}
function Sa(a) {
  switch (typeof a) {
    case "boolean":
    case "number":
    case "object":
    case "string":
    case "undefined":
      return a;
    default:
      return "";
  }
}
function Ta(a) {
  var b = a.type;
  return (a = a.nodeName) && a.toLowerCase() === "input" && (b === "checkbox" || b === "radio");
}
function Ua(a) {
  var b = Ta(a) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b), d = "" + a[b];
  if (!a.hasOwnProperty(b) && typeof c !== "undefined" && typeof c.get === "function" && typeof c.set === "function") {
    var e = c.get, f = c.set;
    Object.defineProperty(a, b, { configurable: true, get: function() {
      return e.call(this);
    }, set: function(a2) {
      d = "" + a2;
      f.call(this, a2);
    } });
    Object.defineProperty(a, b, { enumerable: c.enumerable });
    return { getValue: function() {
      return d;
    }, setValue: function(a2) {
      d = "" + a2;
    }, stopTracking: function() {
      a._valueTracker = null;
      delete a[b];
    } };
  }
}
function Va(a) {
  a._valueTracker || (a._valueTracker = Ua(a));
}
function Wa(a) {
  if (!a)
    return false;
  var b = a._valueTracker;
  if (!b)
    return true;
  var c = b.getValue();
  var d = "";
  a && (d = Ta(a) ? a.checked ? "true" : "false" : a.value);
  a = d;
  return a !== c ? (b.setValue(a), true) : false;
}
function Xa(a) {
  a = a || (typeof document !== "undefined" ? document : void 0);
  if (typeof a === "undefined")
    return null;
  try {
    return a.activeElement || a.body;
  } catch (b) {
    return a.body;
  }
}
function Ya(a, b) {
  var c = b.checked;
  return m({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: c != null ? c : a._wrapperState.initialChecked });
}
function Za(a, b) {
  var c = b.defaultValue == null ? "" : b.defaultValue, d = b.checked != null ? b.checked : b.defaultChecked;
  c = Sa(b.value != null ? b.value : c);
  a._wrapperState = { initialChecked: d, initialValue: c, controlled: b.type === "checkbox" || b.type === "radio" ? b.checked != null : b.value != null };
}
function $a(a, b) {
  b = b.checked;
  b != null && qa(a, "checked", b, false);
}
function ab(a, b) {
  $a(a, b);
  var c = Sa(b.value), d = b.type;
  if (c != null)
    if (d === "number") {
      if (c === 0 && a.value === "" || a.value != c)
        a.value = "" + c;
    } else
      a.value !== "" + c && (a.value = "" + c);
  else if (d === "submit" || d === "reset") {
    a.removeAttribute("value");
    return;
  }
  b.hasOwnProperty("value") ? bb(a, b.type, c) : b.hasOwnProperty("defaultValue") && bb(a, b.type, Sa(b.defaultValue));
  b.checked == null && b.defaultChecked != null && (a.defaultChecked = !!b.defaultChecked);
}
function cb(a, b, c) {
  if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
    var d = b.type;
    if (!(d !== "submit" && d !== "reset" || b.value !== void 0 && b.value !== null))
      return;
    b = "" + a._wrapperState.initialValue;
    c || b === a.value || (a.value = b);
    a.defaultValue = b;
  }
  c = a.name;
  c !== "" && (a.name = "");
  a.defaultChecked = !!a._wrapperState.initialChecked;
  c !== "" && (a.name = c);
}
function bb(a, b, c) {
  if (b !== "number" || Xa(a.ownerDocument) !== a)
    c == null ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
}
function db(a) {
  var b = "";
  aa.Children.forEach(a, function(a2) {
    a2 != null && (b += a2);
  });
  return b;
}
function eb(a, b) {
  a = m({ children: void 0 }, b);
  if (b = db(b.children))
    a.children = b;
  return a;
}
function fb(a, b, c, d) {
  a = a.options;
  if (b) {
    b = {};
    for (var e = 0; e < c.length; e++)
      b["$" + c[e]] = true;
    for (c = 0; c < a.length; c++)
      e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = true);
  } else {
    c = "" + Sa(c);
    b = null;
    for (e = 0; e < a.length; e++) {
      if (a[e].value === c) {
        a[e].selected = true;
        d && (a[e].defaultSelected = true);
        return;
      }
      b !== null || a[e].disabled || (b = a[e]);
    }
    b !== null && (b.selected = true);
  }
}
function gb(a, b) {
  if (b.dangerouslySetInnerHTML != null)
    throw Error(y(91));
  return m({}, b, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
}
function hb(a, b) {
  var c = b.value;
  if (c == null) {
    c = b.children;
    b = b.defaultValue;
    if (c != null) {
      if (b != null)
        throw Error(y(92));
      if (Array.isArray(c)) {
        if (!(1 >= c.length))
          throw Error(y(93));
        c = c[0];
      }
      b = c;
    }
    b == null && (b = "");
    c = b;
  }
  a._wrapperState = { initialValue: Sa(c) };
}
function ib(a, b) {
  var c = Sa(b.value), d = Sa(b.defaultValue);
  c != null && (c = "" + c, c !== a.value && (a.value = c), b.defaultValue == null && a.defaultValue !== c && (a.defaultValue = c));
  d != null && (a.defaultValue = "" + d);
}
function jb(a) {
  var b = a.textContent;
  b === a._wrapperState.initialValue && b !== "" && b !== null && (a.value = b);
}
var kb = { html: "http://www.w3.org/1999/xhtml", mathml: "http://www.w3.org/1998/Math/MathML", svg: "http://www.w3.org/2000/svg" };
function lb(a) {
  switch (a) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function mb(a, b) {
  return a == null || a === "http://www.w3.org/1999/xhtml" ? lb(b) : a === "http://www.w3.org/2000/svg" && b === "foreignObject" ? "http://www.w3.org/1999/xhtml" : a;
}
var nb, ob = function(a) {
  return typeof MSApp !== "undefined" && MSApp.execUnsafeLocalFunction ? function(b, c, d, e) {
    MSApp.execUnsafeLocalFunction(function() {
      return a(b, c, d, e);
    });
  } : a;
}(function(a, b) {
  if (a.namespaceURI !== kb.svg || "innerHTML" in a)
    a.innerHTML = b;
  else {
    nb = nb || document.createElement("div");
    nb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
    for (b = nb.firstChild; a.firstChild; )
      a.removeChild(a.firstChild);
    for (; b.firstChild; )
      a.appendChild(b.firstChild);
  }
});
function pb(a, b) {
  if (b) {
    var c = a.firstChild;
    if (c && c === a.lastChild && c.nodeType === 3) {
      c.nodeValue = b;
      return;
    }
  }
  a.textContent = b;
}
var qb = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, rb = ["Webkit", "ms", "Moz", "O"];
Object.keys(qb).forEach(function(a) {
  rb.forEach(function(b) {
    b = b + a.charAt(0).toUpperCase() + a.substring(1);
    qb[b] = qb[a];
  });
});
function sb(a, b, c) {
  return b == null || typeof b === "boolean" || b === "" ? "" : c || typeof b !== "number" || b === 0 || qb.hasOwnProperty(a) && qb[a] ? ("" + b).trim() : b + "px";
}
function tb(a, b) {
  a = a.style;
  for (var c in b)
    if (b.hasOwnProperty(c)) {
      var d = c.indexOf("--") === 0, e = sb(c, b[c], d);
      c === "float" && (c = "cssFloat");
      d ? a.setProperty(c, e) : a[c] = e;
    }
}
var ub = m({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function vb(a, b) {
  if (b) {
    if (ub[a] && (b.children != null || b.dangerouslySetInnerHTML != null))
      throw Error(y(137, a));
    if (b.dangerouslySetInnerHTML != null) {
      if (b.children != null)
        throw Error(y(60));
      if (!(typeof b.dangerouslySetInnerHTML === "object" && "__html" in b.dangerouslySetInnerHTML))
        throw Error(y(61));
    }
    if (b.style != null && typeof b.style !== "object")
      throw Error(y(62));
  }
}
function wb(a, b) {
  if (a.indexOf("-") === -1)
    return typeof b.is === "string";
  switch (a) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
function xb(a) {
  a = a.target || a.srcElement || window;
  a.correspondingUseElement && (a = a.correspondingUseElement);
  return a.nodeType === 3 ? a.parentNode : a;
}
var yb = null, zb = null, Ab = null;
function Bb(a) {
  if (a = Cb(a)) {
    if (typeof yb !== "function")
      throw Error(y(280));
    var b = a.stateNode;
    b && (b = Db(b), yb(a.stateNode, a.type, b));
  }
}
function Eb(a) {
  zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
}
function Fb() {
  if (zb) {
    var a = zb, b = Ab;
    Ab = zb = null;
    Bb(a);
    if (b)
      for (a = 0; a < b.length; a++)
        Bb(b[a]);
  }
}
function Gb(a, b) {
  return a(b);
}
function Hb(a, b, c, d, e) {
  return a(b, c, d, e);
}
function Ib() {
}
var Jb = Gb, Kb = false, Lb = false;
function Mb() {
  if (zb !== null || Ab !== null)
    Ib(), Fb();
}
function Nb(a, b, c) {
  if (Lb)
    return a(b, c);
  Lb = true;
  try {
    return Jb(a, b, c);
  } finally {
    Lb = false, Mb();
  }
}
function Ob(a, b) {
  var c = a.stateNode;
  if (c === null)
    return null;
  var d = Db(c);
  if (d === null)
    return null;
  c = d[b];
  a:
    switch (b) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d = !d.disabled) || (a = a.type, d = !(a === "button" || a === "input" || a === "select" || a === "textarea"));
        a = !d;
        break a;
      default:
        a = false;
    }
  if (a)
    return null;
  if (c && typeof c !== "function")
    throw Error(y(231, b, typeof c));
  return c;
}
var Pb = false;
if (fa)
  try {
    var Qb = {};
    Object.defineProperty(Qb, "passive", { get: function() {
      Pb = true;
    } });
    window.addEventListener("test", Qb, Qb);
    window.removeEventListener("test", Qb, Qb);
  } catch (a) {
    Pb = false;
  }
function Rb(a, b, c, d, e, f, g, h, k) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b.apply(c, l2);
  } catch (n2) {
    this.onError(n2);
  }
}
var Sb = false, Tb = null, Ub = false, Vb = null, Wb = { onError: function(a) {
  Sb = true;
  Tb = a;
} };
function Xb(a, b, c, d, e, f, g, h, k) {
  Sb = false;
  Tb = null;
  Rb.apply(Wb, arguments);
}
function Yb(a, b, c, d, e, f, g, h, k) {
  Xb.apply(this, arguments);
  if (Sb) {
    if (Sb) {
      var l2 = Tb;
      Sb = false;
      Tb = null;
    } else
      throw Error(y(198));
    Ub || (Ub = true, Vb = l2);
  }
}
function Zb(a) {
  var b = a, c = a;
  if (a.alternate)
    for (; b.return; )
      b = b.return;
  else {
    a = b;
    do
      b = a, (b.flags & 1026) !== 0 && (c = b.return), a = b.return;
    while (a);
  }
  return b.tag === 3 ? c : null;
}
function $b(a) {
  if (a.tag === 13) {
    var b = a.memoizedState;
    b === null && (a = a.alternate, a !== null && (b = a.memoizedState));
    if (b !== null)
      return b.dehydrated;
  }
  return null;
}
function ac(a) {
  if (Zb(a) !== a)
    throw Error(y(188));
}
function bc(a) {
  var b = a.alternate;
  if (!b) {
    b = Zb(a);
    if (b === null)
      throw Error(y(188));
    return b !== a ? null : a;
  }
  for (var c = a, d = b; ; ) {
    var e = c.return;
    if (e === null)
      break;
    var f = e.alternate;
    if (f === null) {
      d = e.return;
      if (d !== null) {
        c = d;
        continue;
      }
      break;
    }
    if (e.child === f.child) {
      for (f = e.child; f; ) {
        if (f === c)
          return ac(e), a;
        if (f === d)
          return ac(e), b;
        f = f.sibling;
      }
      throw Error(y(188));
    }
    if (c.return !== d.return)
      c = e, d = f;
    else {
      for (var g = false, h = e.child; h; ) {
        if (h === c) {
          g = true;
          c = e;
          d = f;
          break;
        }
        if (h === d) {
          g = true;
          d = e;
          c = f;
          break;
        }
        h = h.sibling;
      }
      if (!g) {
        for (h = f.child; h; ) {
          if (h === c) {
            g = true;
            c = f;
            d = e;
            break;
          }
          if (h === d) {
            g = true;
            d = f;
            c = e;
            break;
          }
          h = h.sibling;
        }
        if (!g)
          throw Error(y(189));
      }
    }
    if (c.alternate !== d)
      throw Error(y(190));
  }
  if (c.tag !== 3)
    throw Error(y(188));
  return c.stateNode.current === c ? a : b;
}
function cc(a) {
  a = bc(a);
  if (!a)
    return null;
  for (var b = a; ; ) {
    if (b.tag === 5 || b.tag === 6)
      return b;
    if (b.child)
      b.child.return = b, b = b.child;
    else {
      if (b === a)
        break;
      for (; !b.sibling; ) {
        if (!b.return || b.return === a)
          return null;
        b = b.return;
      }
      b.sibling.return = b.return;
      b = b.sibling;
    }
  }
  return null;
}
function dc(a, b) {
  for (var c = a.alternate; b !== null; ) {
    if (b === a || b === c)
      return true;
    b = b.return;
  }
  return false;
}
var ec, fc, gc, hc, ic = false, jc = [], kc = null, lc = null, mc = null, nc = /* @__PURE__ */ new Map(), oc = /* @__PURE__ */ new Map(), pc = [], qc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function rc(a, b, c, d, e) {
  return { blockedOn: a, domEventName: b, eventSystemFlags: c | 16, nativeEvent: e, targetContainers: [d] };
}
function sc(a, b) {
  switch (a) {
    case "focusin":
    case "focusout":
      kc = null;
      break;
    case "dragenter":
    case "dragleave":
      lc = null;
      break;
    case "mouseover":
    case "mouseout":
      mc = null;
      break;
    case "pointerover":
    case "pointerout":
      nc.delete(b.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      oc.delete(b.pointerId);
  }
}
function tc(a, b, c, d, e, f) {
  if (a === null || a.nativeEvent !== f)
    return a = rc(b, c, d, e, f), b !== null && (b = Cb(b), b !== null && fc(b)), a;
  a.eventSystemFlags |= d;
  b = a.targetContainers;
  e !== null && b.indexOf(e) === -1 && b.push(e);
  return a;
}
function uc(a, b, c, d, e) {
  switch (b) {
    case "focusin":
      return kc = tc(kc, a, b, c, d, e), true;
    case "dragenter":
      return lc = tc(lc, a, b, c, d, e), true;
    case "mouseover":
      return mc = tc(mc, a, b, c, d, e), true;
    case "pointerover":
      var f = e.pointerId;
      nc.set(f, tc(nc.get(f) || null, a, b, c, d, e));
      return true;
    case "gotpointercapture":
      return f = e.pointerId, oc.set(f, tc(oc.get(f) || null, a, b, c, d, e)), true;
  }
  return false;
}
function vc(a) {
  var b = wc(a.target);
  if (b !== null) {
    var c = Zb(b);
    if (c !== null) {
      if (b = c.tag, b === 13) {
        if (b = $b(c), b !== null) {
          a.blockedOn = b;
          hc(a.lanePriority, function() {
            r.unstable_runWithPriority(a.priority, function() {
              gc(c);
            });
          });
          return;
        }
      } else if (b === 3 && c.stateNode.hydrate) {
        a.blockedOn = c.tag === 3 ? c.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a.blockedOn = null;
}
function xc(a) {
  if (a.blockedOn !== null)
    return false;
  for (var b = a.targetContainers; 0 < b.length; ) {
    var c = yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
    if (c !== null)
      return b = Cb(c), b !== null && fc(b), a.blockedOn = c, false;
    b.shift();
  }
  return true;
}
function zc(a, b, c) {
  xc(a) && c.delete(b);
}
function Ac() {
  for (ic = false; 0 < jc.length; ) {
    var a = jc[0];
    if (a.blockedOn !== null) {
      a = Cb(a.blockedOn);
      a !== null && ec(a);
      break;
    }
    for (var b = a.targetContainers; 0 < b.length; ) {
      var c = yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
      if (c !== null) {
        a.blockedOn = c;
        break;
      }
      b.shift();
    }
    a.blockedOn === null && jc.shift();
  }
  kc !== null && xc(kc) && (kc = null);
  lc !== null && xc(lc) && (lc = null);
  mc !== null && xc(mc) && (mc = null);
  nc.forEach(zc);
  oc.forEach(zc);
}
function Bc(a, b) {
  a.blockedOn === b && (a.blockedOn = null, ic || (ic = true, r.unstable_scheduleCallback(r.unstable_NormalPriority, Ac)));
}
function Cc(a) {
  function b(b2) {
    return Bc(b2, a);
  }
  if (0 < jc.length) {
    Bc(jc[0], a);
    for (var c = 1; c < jc.length; c++) {
      var d = jc[c];
      d.blockedOn === a && (d.blockedOn = null);
    }
  }
  kc !== null && Bc(kc, a);
  lc !== null && Bc(lc, a);
  mc !== null && Bc(mc, a);
  nc.forEach(b);
  oc.forEach(b);
  for (c = 0; c < pc.length; c++)
    d = pc[c], d.blockedOn === a && (d.blockedOn = null);
  for (; 0 < pc.length && (c = pc[0], c.blockedOn === null); )
    vc(c), c.blockedOn === null && pc.shift();
}
function Dc(a, b) {
  var c = {};
  c[a.toLowerCase()] = b.toLowerCase();
  c["Webkit" + a] = "webkit" + b;
  c["Moz" + a] = "moz" + b;
  return c;
}
var Ec = { animationend: Dc("Animation", "AnimationEnd"), animationiteration: Dc("Animation", "AnimationIteration"), animationstart: Dc("Animation", "AnimationStart"), transitionend: Dc("Transition", "TransitionEnd") }, Fc = {}, Gc = {};
fa && (Gc = document.createElement("div").style, "AnimationEvent" in window || (delete Ec.animationend.animation, delete Ec.animationiteration.animation, delete Ec.animationstart.animation), "TransitionEvent" in window || delete Ec.transitionend.transition);
function Hc(a) {
  if (Fc[a])
    return Fc[a];
  if (!Ec[a])
    return a;
  var b = Ec[a], c;
  for (c in b)
    if (b.hasOwnProperty(c) && c in Gc)
      return Fc[a] = b[c];
  return a;
}
var Ic = Hc("animationend"), Jc = Hc("animationiteration"), Kc = Hc("animationstart"), Lc = Hc("transitionend"), Mc = /* @__PURE__ */ new Map(), Nc = /* @__PURE__ */ new Map(), Oc = [
  "abort",
  "abort",
  Ic,
  "animationEnd",
  Jc,
  "animationIteration",
  Kc,
  "animationStart",
  "canplay",
  "canPlay",
  "canplaythrough",
  "canPlayThrough",
  "durationchange",
  "durationChange",
  "emptied",
  "emptied",
  "encrypted",
  "encrypted",
  "ended",
  "ended",
  "error",
  "error",
  "gotpointercapture",
  "gotPointerCapture",
  "load",
  "load",
  "loadeddata",
  "loadedData",
  "loadedmetadata",
  "loadedMetadata",
  "loadstart",
  "loadStart",
  "lostpointercapture",
  "lostPointerCapture",
  "playing",
  "playing",
  "progress",
  "progress",
  "seeking",
  "seeking",
  "stalled",
  "stalled",
  "suspend",
  "suspend",
  "timeupdate",
  "timeUpdate",
  Lc,
  "transitionEnd",
  "waiting",
  "waiting"
];
function Pc(a, b) {
  for (var c = 0; c < a.length; c += 2) {
    var d = a[c], e = a[c + 1];
    e = "on" + (e[0].toUpperCase() + e.slice(1));
    Nc.set(d, b);
    Mc.set(d, e);
    da(e, [d]);
  }
}
var Qc = r.unstable_now;
Qc();
var F = 8;
function Rc(a) {
  if ((1 & a) !== 0)
    return F = 15, 1;
  if ((2 & a) !== 0)
    return F = 14, 2;
  if ((4 & a) !== 0)
    return F = 13, 4;
  var b = 24 & a;
  if (b !== 0)
    return F = 12, b;
  if ((a & 32) !== 0)
    return F = 11, 32;
  b = 192 & a;
  if (b !== 0)
    return F = 10, b;
  if ((a & 256) !== 0)
    return F = 9, 256;
  b = 3584 & a;
  if (b !== 0)
    return F = 8, b;
  if ((a & 4096) !== 0)
    return F = 7, 4096;
  b = 4186112 & a;
  if (b !== 0)
    return F = 6, b;
  b = 62914560 & a;
  if (b !== 0)
    return F = 5, b;
  if (a & 67108864)
    return F = 4, 67108864;
  if ((a & 134217728) !== 0)
    return F = 3, 134217728;
  b = 805306368 & a;
  if (b !== 0)
    return F = 2, b;
  if ((1073741824 & a) !== 0)
    return F = 1, 1073741824;
  F = 8;
  return a;
}
function Sc(a) {
  switch (a) {
    case 99:
      return 15;
    case 98:
      return 10;
    case 97:
    case 96:
      return 8;
    case 95:
      return 2;
    default:
      return 0;
  }
}
function Tc(a) {
  switch (a) {
    case 15:
    case 14:
      return 99;
    case 13:
    case 12:
    case 11:
    case 10:
      return 98;
    case 9:
    case 8:
    case 7:
    case 6:
    case 4:
    case 5:
      return 97;
    case 3:
    case 2:
    case 1:
      return 95;
    case 0:
      return 90;
    default:
      throw Error(y(358, a));
  }
}
function Uc(a, b) {
  var c = a.pendingLanes;
  if (c === 0)
    return F = 0;
  var d = 0, e = 0, f = a.expiredLanes, g = a.suspendedLanes, h = a.pingedLanes;
  if (f !== 0)
    d = f, e = F = 15;
  else if (f = c & 134217727, f !== 0) {
    var k = f & ~g;
    k !== 0 ? (d = Rc(k), e = F) : (h &= f, h !== 0 && (d = Rc(h), e = F));
  } else
    f = c & ~g, f !== 0 ? (d = Rc(f), e = F) : h !== 0 && (d = Rc(h), e = F);
  if (d === 0)
    return 0;
  d = 31 - Vc(d);
  d = c & ((0 > d ? 0 : 1 << d) << 1) - 1;
  if (b !== 0 && b !== d && (b & g) === 0) {
    Rc(b);
    if (e <= F)
      return b;
    F = e;
  }
  b = a.entangledLanes;
  if (b !== 0)
    for (a = a.entanglements, b &= d; 0 < b; )
      c = 31 - Vc(b), e = 1 << c, d |= a[c], b &= ~e;
  return d;
}
function Wc(a) {
  a = a.pendingLanes & -1073741825;
  return a !== 0 ? a : a & 1073741824 ? 1073741824 : 0;
}
function Xc(a, b) {
  switch (a) {
    case 15:
      return 1;
    case 14:
      return 2;
    case 12:
      return a = Yc(24 & ~b), a === 0 ? Xc(10, b) : a;
    case 10:
      return a = Yc(192 & ~b), a === 0 ? Xc(8, b) : a;
    case 8:
      return a = Yc(3584 & ~b), a === 0 && (a = Yc(4186112 & ~b), a === 0 && (a = 512)), a;
    case 2:
      return b = Yc(805306368 & ~b), b === 0 && (b = 268435456), b;
  }
  throw Error(y(358, a));
}
function Yc(a) {
  return a & -a;
}
function Zc(a) {
  for (var b = [], c = 0; 31 > c; c++)
    b.push(a);
  return b;
}
function $c(a, b, c) {
  a.pendingLanes |= b;
  var d = b - 1;
  a.suspendedLanes &= d;
  a.pingedLanes &= d;
  a = a.eventTimes;
  b = 31 - Vc(b);
  a[b] = c;
}
var Vc = Math.clz32 ? Math.clz32 : ad, bd = Math.log, cd = Math.LN2;
function ad(a) {
  return a === 0 ? 32 : 31 - (bd(a) / cd | 0) | 0;
}
var dd = r.unstable_UserBlockingPriority, ed = r.unstable_runWithPriority, fd = true;
function gd(a, b, c, d) {
  Kb || Ib();
  var e = hd, f = Kb;
  Kb = true;
  try {
    Hb(e, a, b, c, d);
  } finally {
    (Kb = f) || Mb();
  }
}
function id(a, b, c, d) {
  ed(dd, hd.bind(null, a, b, c, d));
}
function hd(a, b, c, d) {
  if (fd) {
    var e;
    if ((e = (b & 4) === 0) && 0 < jc.length && -1 < qc.indexOf(a))
      a = rc(null, a, b, c, d), jc.push(a);
    else {
      var f = yc(a, b, c, d);
      if (f === null)
        e && sc(a, d);
      else {
        if (e) {
          if (-1 < qc.indexOf(a)) {
            a = rc(f, a, b, c, d);
            jc.push(a);
            return;
          }
          if (uc(f, a, b, c, d))
            return;
          sc(a, d);
        }
        jd(a, b, d, null, c);
      }
    }
  }
}
function yc(a, b, c, d) {
  var e = xb(d);
  e = wc(e);
  if (e !== null) {
    var f = Zb(e);
    if (f === null)
      e = null;
    else {
      var g = f.tag;
      if (g === 13) {
        e = $b(f);
        if (e !== null)
          return e;
        e = null;
      } else if (g === 3) {
        if (f.stateNode.hydrate)
          return f.tag === 3 ? f.stateNode.containerInfo : null;
        e = null;
      } else
        f !== e && (e = null);
    }
  }
  jd(a, b, d, e, c);
  return null;
}
var kd = null, ld = null, md = null;
function nd() {
  if (md)
    return md;
  var a, b = ld, c = b.length, d, e = "value" in kd ? kd.value : kd.textContent, f = e.length;
  for (a = 0; a < c && b[a] === e[a]; a++)
    ;
  var g = c - a;
  for (d = 1; d <= g && b[c - d] === e[f - d]; d++)
    ;
  return md = e.slice(a, 1 < d ? 1 - d : void 0);
}
function od(a) {
  var b = a.keyCode;
  "charCode" in a ? (a = a.charCode, a === 0 && b === 13 && (a = 13)) : a = b;
  a === 10 && (a = 13);
  return 32 <= a || a === 13 ? a : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a) {
  function b(b2, d, e, f, g) {
    this._reactName = b2;
    this._targetInst = e;
    this.type = d;
    this.nativeEvent = f;
    this.target = g;
    this.currentTarget = null;
    for (var c in a)
      a.hasOwnProperty(c) && (b2 = a[c], this[c] = b2 ? b2(f) : f[c]);
    this.isDefaultPrevented = (f.defaultPrevented != null ? f.defaultPrevented : f.returnValue === false) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  m(b.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a2 = this.nativeEvent;
    a2 && (a2.preventDefault ? a2.preventDefault() : typeof a2.returnValue !== "unknown" && (a2.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a2 = this.nativeEvent;
    a2 && (a2.stopPropagation ? a2.stopPropagation() : typeof a2.cancelBubble !== "unknown" && (a2.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
  return a.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = m({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = m({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
  return a.relatedTarget === void 0 ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
}, movementX: function(a) {
  if ("movementX" in a)
    return a.movementX;
  a !== yd && (yd && a.type === "mousemove" ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
  return wd;
}, movementY: function(a) {
  return "movementY" in a ? a.movementY : xd;
} }), Bd = rd(Ad), Cd = m({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = m({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = m({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = m({}, sd, { clipboardData: function(a) {
  return "clipboardData" in a ? a.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = m({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a) {
  var b = this.nativeEvent;
  return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : false;
}
function zd() {
  return Pd;
}
var Qd = m({}, ud, { key: function(a) {
  if (a.key) {
    var b = Md[a.key] || a.key;
    if (b !== "Unidentified")
      return b;
  }
  return a.type === "keypress" ? (a = od(a), a === 13 ? "Enter" : String.fromCharCode(a)) : a.type === "keydown" || a.type === "keyup" ? Nd[a.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
  return a.type === "keypress" ? od(a) : 0;
}, keyCode: function(a) {
  return a.type === "keydown" || a.type === "keyup" ? a.keyCode : 0;
}, which: function(a) {
  return a.type === "keypress" ? od(a) : a.type === "keydown" || a.type === "keyup" ? a.keyCode : 0;
} }), Rd = rd(Qd), Sd = m({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = m({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = m({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = m({}, Ad, {
  deltaX: function(a) {
    return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
  },
  deltaY: function(a) {
    return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = fa && "CompositionEvent" in window, be = null;
fa && "documentMode" in document && (be = document.documentMode);
var ce = fa && "TextEvent" in window && !be, de = fa && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
function ge(a, b) {
  switch (a) {
    case "keyup":
      return $d.indexOf(b.keyCode) !== -1;
    case "keydown":
      return b.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he(a) {
  a = a.detail;
  return typeof a === "object" && "data" in a ? a.data : null;
}
var ie = false;
function je(a, b) {
  switch (a) {
    case "compositionend":
      return he(b);
    case "keypress":
      if (b.which !== 32)
        return null;
      fe = true;
      return ee;
    case "textInput":
      return a = b.data, a === ee && fe ? null : a;
    default:
      return null;
  }
}
function ke(a, b) {
  if (ie)
    return a === "compositionend" || !ae && ge(a, b) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
  switch (a) {
    case "paste":
      return null;
    case "keypress":
      if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
        if (b.char && 1 < b.char.length)
          return b.char;
        if (b.which)
          return String.fromCharCode(b.which);
      }
      return null;
    case "compositionend":
      return de && b.locale !== "ko" ? null : b.data;
    default:
      return null;
  }
}
var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me(a) {
  var b = a && a.nodeName && a.nodeName.toLowerCase();
  return b === "input" ? !!le[a.type] : b === "textarea" ? true : false;
}
function ne(a, b, c, d) {
  Eb(d);
  b = oe(b, "onChange");
  0 < b.length && (c = new td("onChange", "change", null, c, d), a.push({ event: c, listeners: b }));
}
var pe = null, qe = null;
function re(a) {
  se(a, 0);
}
function te(a) {
  var b = ue(a);
  if (Wa(b))
    return a;
}
function ve(a, b) {
  if (a === "change")
    return b;
}
var we = false;
if (fa) {
  var xe;
  if (fa) {
    var ye = "oninput" in document;
    if (!ye) {
      var ze = document.createElement("div");
      ze.setAttribute("oninput", "return;");
      ye = typeof ze.oninput === "function";
    }
    xe = ye;
  } else
    xe = false;
  we = xe && (!document.documentMode || 9 < document.documentMode);
}
function Ae() {
  pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
}
function Be(a) {
  if (a.propertyName === "value" && te(qe)) {
    var b = [];
    ne(b, qe, a, xb(a));
    a = re;
    if (Kb)
      a(b);
    else {
      Kb = true;
      try {
        Gb(a, b);
      } finally {
        Kb = false, Mb();
      }
    }
  }
}
function Ce(a, b, c) {
  a === "focusin" ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be)) : a === "focusout" && Ae();
}
function De(a) {
  if (a === "selectionchange" || a === "keyup" || a === "keydown")
    return te(qe);
}
function Ee(a, b) {
  if (a === "click")
    return te(b);
}
function Fe(a, b) {
  if (a === "input" || a === "change")
    return te(b);
}
function Ge(a, b) {
  return a === b && (a !== 0 || 1 / a === 1 / b) || a !== a && b !== b;
}
var He = typeof Object.is === "function" ? Object.is : Ge, Ie = Object.prototype.hasOwnProperty;
function Je(a, b) {
  if (He(a, b))
    return true;
  if (typeof a !== "object" || a === null || typeof b !== "object" || b === null)
    return false;
  var c = Object.keys(a), d = Object.keys(b);
  if (c.length !== d.length)
    return false;
  for (d = 0; d < c.length; d++)
    if (!Ie.call(b, c[d]) || !He(a[c[d]], b[c[d]]))
      return false;
  return true;
}
function Ke(a) {
  for (; a && a.firstChild; )
    a = a.firstChild;
  return a;
}
function Le(a, b) {
  var c = Ke(a);
  a = 0;
  for (var d; c; ) {
    if (c.nodeType === 3) {
      d = a + c.textContent.length;
      if (a <= b && d >= b)
        return { node: c, offset: b - a };
      a = d;
    }
    a: {
      for (; c; ) {
        if (c.nextSibling) {
          c = c.nextSibling;
          break a;
        }
        c = c.parentNode;
      }
      c = void 0;
    }
    c = Ke(c);
  }
}
function Me(a, b) {
  return a && b ? a === b ? true : a && a.nodeType === 3 ? false : b && b.nodeType === 3 ? Me(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : false : false;
}
function Ne() {
  for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement; ) {
    try {
      var c = typeof b.contentWindow.location.href === "string";
    } catch (d) {
      c = false;
    }
    if (c)
      a = b.contentWindow;
    else
      break;
    b = Xa(a.document);
  }
  return b;
}
function Oe(a) {
  var b = a && a.nodeName && a.nodeName.toLowerCase();
  return b && (b === "input" && (a.type === "text" || a.type === "search" || a.type === "tel" || a.type === "url" || a.type === "password") || b === "textarea" || a.contentEditable === "true");
}
var Pe = fa && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
function Ue(a, b, c) {
  var d = c.window === c ? c.document : c.nodeType === 9 ? c : c.ownerDocument;
  Te || Qe == null || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Oe(d) ? d = { start: d.selectionStart, end: d.selectionEnd } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = { anchorNode: d.anchorNode, anchorOffset: d.anchorOffset, focusNode: d.focusNode, focusOffset: d.focusOffset }), Se && Je(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c), a.push({ event: b, listeners: d }), b.target = Qe)));
}
Pc("cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focusin focus focusout blur input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "), 0);
Pc("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "), 1);
Pc(Oc, 2);
for (var Ve = "change selectionchange textInput compositionstart compositionend compositionupdate".split(" "), We = 0; We < Ve.length; We++)
  Nc.set(Ve[We], 0);
ea("onMouseEnter", ["mouseout", "mouseover"]);
ea("onMouseLeave", ["mouseout", "mouseover"]);
ea("onPointerEnter", ["pointerout", "pointerover"]);
ea("onPointerLeave", ["pointerout", "pointerover"]);
da("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
da("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
da("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
da("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
da("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
da("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var Xe = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), Ye = new Set("cancel close invalid load scroll toggle".split(" ").concat(Xe));
function Ze(a, b, c) {
  var d = a.type || "unknown-event";
  a.currentTarget = c;
  Yb(d, b, void 0, a);
  a.currentTarget = null;
}
function se(a, b) {
  b = (b & 4) !== 0;
  for (var c = 0; c < a.length; c++) {
    var d = a[c], e = d.event;
    d = d.listeners;
    a: {
      var f = void 0;
      if (b)
        for (var g = d.length - 1; 0 <= g; g--) {
          var h = d[g], k = h.instance, l2 = h.currentTarget;
          h = h.listener;
          if (k !== f && e.isPropagationStopped())
            break a;
          Ze(e, h, l2);
          f = k;
        }
      else
        for (g = 0; g < d.length; g++) {
          h = d[g];
          k = h.instance;
          l2 = h.currentTarget;
          h = h.listener;
          if (k !== f && e.isPropagationStopped())
            break a;
          Ze(e, h, l2);
          f = k;
        }
    }
  }
  if (Ub)
    throw a = Vb, Ub = false, Vb = null, a;
}
function G(a, b) {
  var c = $e(b), d = a + "__bubble";
  c.has(d) || (af(b, a, 2, false), c.add(d));
}
var bf = "_reactListening" + Math.random().toString(36).slice(2);
function cf(a) {
  a[bf] || (a[bf] = true, ba.forEach(function(b) {
    Ye.has(b) || df(b, false, a, null);
    df(b, true, a, null);
  }));
}
function df(a, b, c, d) {
  var e = 4 < arguments.length && arguments[4] !== void 0 ? arguments[4] : 0, f = c;
  a === "selectionchange" && c.nodeType !== 9 && (f = c.ownerDocument);
  if (d !== null && !b && Ye.has(a)) {
    if (a !== "scroll")
      return;
    e |= 2;
    f = d;
  }
  var g = $e(f), h = a + "__" + (b ? "capture" : "bubble");
  g.has(h) || (b && (e |= 4), af(f, a, e, b), g.add(h));
}
function af(a, b, c, d) {
  var e = Nc.get(b);
  switch (e === void 0 ? 2 : e) {
    case 0:
      e = gd;
      break;
    case 1:
      e = id;
      break;
    default:
      e = hd;
  }
  c = e.bind(null, b, c, a);
  e = void 0;
  !Pb || b !== "touchstart" && b !== "touchmove" && b !== "wheel" || (e = true);
  d ? e !== void 0 ? a.addEventListener(b, c, { capture: true, passive: e }) : a.addEventListener(b, c, true) : e !== void 0 ? a.addEventListener(b, c, { passive: e }) : a.addEventListener(b, c, false);
}
function jd(a, b, c, d, e) {
  var f = d;
  if ((b & 1) === 0 && (b & 2) === 0 && d !== null)
    a:
      for (; ; ) {
        if (d === null)
          return;
        var g = d.tag;
        if (g === 3 || g === 4) {
          var h = d.stateNode.containerInfo;
          if (h === e || h.nodeType === 8 && h.parentNode === e)
            break;
          if (g === 4)
            for (g = d.return; g !== null; ) {
              var k = g.tag;
              if (k === 3 || k === 4) {
                if (k = g.stateNode.containerInfo, k === e || k.nodeType === 8 && k.parentNode === e)
                  return;
              }
              g = g.return;
            }
          for (; h !== null; ) {
            g = wc(h);
            if (g === null)
              return;
            k = g.tag;
            if (k === 5 || k === 6) {
              d = f = g;
              continue a;
            }
            h = h.parentNode;
          }
        }
        d = d.return;
      }
  Nb(function() {
    var d2 = f, e2 = xb(c), g2 = [];
    a: {
      var h2 = Mc.get(a);
      if (h2 !== void 0) {
        var k2 = td, x2 = a;
        switch (a) {
          case "keypress":
            if (od(c) === 0)
              break a;
          case "keydown":
          case "keyup":
            k2 = Rd;
            break;
          case "focusin":
            x2 = "focus";
            k2 = Fd;
            break;
          case "focusout":
            x2 = "blur";
            k2 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k2 = Fd;
            break;
          case "click":
            if (c.button === 2)
              break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k2 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k2 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k2 = Vd;
            break;
          case Ic:
          case Jc:
          case Kc:
            k2 = Hd;
            break;
          case Lc:
            k2 = Xd;
            break;
          case "scroll":
            k2 = vd;
            break;
          case "wheel":
            k2 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k2 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k2 = Td;
        }
        var w = (b & 4) !== 0, z2 = !w && a === "scroll", u2 = w ? h2 !== null ? h2 + "Capture" : null : h2;
        w = [];
        for (var t2 = d2, q2; t2 !== null; ) {
          q2 = t2;
          var v2 = q2.stateNode;
          q2.tag === 5 && v2 !== null && (q2 = v2, u2 !== null && (v2 = Ob(t2, u2), v2 != null && w.push(ef(t2, v2, q2))));
          if (z2)
            break;
          t2 = t2.return;
        }
        0 < w.length && (h2 = new k2(h2, x2, null, c, e2), g2.push({ event: h2, listeners: w }));
      }
    }
    if ((b & 7) === 0) {
      a: {
        h2 = a === "mouseover" || a === "pointerover";
        k2 = a === "mouseout" || a === "pointerout";
        if (h2 && (b & 16) === 0 && (x2 = c.relatedTarget || c.fromElement) && (wc(x2) || x2[ff]))
          break a;
        if (k2 || h2) {
          h2 = e2.window === e2 ? e2 : (h2 = e2.ownerDocument) ? h2.defaultView || h2.parentWindow : window;
          if (k2) {
            if (x2 = c.relatedTarget || c.toElement, k2 = d2, x2 = x2 ? wc(x2) : null, x2 !== null && (z2 = Zb(x2), x2 !== z2 || x2.tag !== 5 && x2.tag !== 6))
              x2 = null;
          } else
            k2 = null, x2 = d2;
          if (k2 !== x2) {
            w = Bd;
            v2 = "onMouseLeave";
            u2 = "onMouseEnter";
            t2 = "mouse";
            if (a === "pointerout" || a === "pointerover")
              w = Td, v2 = "onPointerLeave", u2 = "onPointerEnter", t2 = "pointer";
            z2 = k2 == null ? h2 : ue(k2);
            q2 = x2 == null ? h2 : ue(x2);
            h2 = new w(v2, t2 + "leave", k2, c, e2);
            h2.target = z2;
            h2.relatedTarget = q2;
            v2 = null;
            wc(e2) === d2 && (w = new w(u2, t2 + "enter", x2, c, e2), w.target = q2, w.relatedTarget = z2, v2 = w);
            z2 = v2;
            if (k2 && x2)
              b: {
                w = k2;
                u2 = x2;
                t2 = 0;
                for (q2 = w; q2; q2 = gf(q2))
                  t2++;
                q2 = 0;
                for (v2 = u2; v2; v2 = gf(v2))
                  q2++;
                for (; 0 < t2 - q2; )
                  w = gf(w), t2--;
                for (; 0 < q2 - t2; )
                  u2 = gf(u2), q2--;
                for (; t2--; ) {
                  if (w === u2 || u2 !== null && w === u2.alternate)
                    break b;
                  w = gf(w);
                  u2 = gf(u2);
                }
                w = null;
              }
            else
              w = null;
            k2 !== null && hf(g2, h2, k2, w, false);
            x2 !== null && z2 !== null && hf(g2, z2, x2, w, true);
          }
        }
      }
      a: {
        h2 = d2 ? ue(d2) : window;
        k2 = h2.nodeName && h2.nodeName.toLowerCase();
        if (k2 === "select" || k2 === "input" && h2.type === "file")
          var J2 = ve;
        else if (me(h2))
          if (we)
            J2 = Fe;
          else {
            J2 = De;
            var K2 = Ce;
          }
        else
          (k2 = h2.nodeName) && k2.toLowerCase() === "input" && (h2.type === "checkbox" || h2.type === "radio") && (J2 = Ee);
        if (J2 && (J2 = J2(a, d2))) {
          ne(g2, J2, c, e2);
          break a;
        }
        K2 && K2(a, h2, d2);
        a === "focusout" && (K2 = h2._wrapperState) && K2.controlled && h2.type === "number" && bb(h2, "number", h2.value);
      }
      K2 = d2 ? ue(d2) : window;
      switch (a) {
        case "focusin":
          if (me(K2) || K2.contentEditable === "true")
            Qe = K2, Re = d2, Se = null;
          break;
        case "focusout":
          Se = Re = Qe = null;
          break;
        case "mousedown":
          Te = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te = false;
          Ue(g2, c, e2);
          break;
        case "selectionchange":
          if (Pe)
            break;
        case "keydown":
        case "keyup":
          Ue(g2, c, e2);
      }
      var Q2;
      if (ae)
        b: {
          switch (a) {
            case "compositionstart":
              var L2 = "onCompositionStart";
              break b;
            case "compositionend":
              L2 = "onCompositionEnd";
              break b;
            case "compositionupdate":
              L2 = "onCompositionUpdate";
              break b;
          }
          L2 = void 0;
        }
      else
        ie ? ge(a, c) && (L2 = "onCompositionEnd") : a === "keydown" && c.keyCode === 229 && (L2 = "onCompositionStart");
      L2 && (de && c.locale !== "ko" && (ie || L2 !== "onCompositionStart" ? L2 === "onCompositionEnd" && ie && (Q2 = nd()) : (kd = e2, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), K2 = oe(d2, L2), 0 < K2.length && (L2 = new Ld(L2, a, null, c, e2), g2.push({ event: L2, listeners: K2 }), Q2 ? L2.data = Q2 : (Q2 = he(c), Q2 !== null && (L2.data = Q2))));
      if (Q2 = ce ? je(a, c) : ke(a, c))
        d2 = oe(d2, "onBeforeInput"), 0 < d2.length && (e2 = new Ld("onBeforeInput", "beforeinput", null, c, e2), g2.push({ event: e2, listeners: d2 }), e2.data = Q2);
    }
    se(g2, b);
  });
}
function ef(a, b, c) {
  return { instance: a, listener: b, currentTarget: c };
}
function oe(a, b) {
  for (var c = b + "Capture", d = []; a !== null; ) {
    var e = a, f = e.stateNode;
    e.tag === 5 && f !== null && (e = f, f = Ob(a, c), f != null && d.unshift(ef(a, f, e)), f = Ob(a, b), f != null && d.push(ef(a, f, e)));
    a = a.return;
  }
  return d;
}
function gf(a) {
  if (a === null)
    return null;
  do
    a = a.return;
  while (a && a.tag !== 5);
  return a ? a : null;
}
function hf(a, b, c, d, e) {
  for (var f = b._reactName, g = []; c !== null && c !== d; ) {
    var h = c, k = h.alternate, l2 = h.stateNode;
    if (k !== null && k === d)
      break;
    h.tag === 5 && l2 !== null && (h = l2, e ? (k = Ob(c, f), k != null && g.unshift(ef(c, k, h))) : e || (k = Ob(c, f), k != null && g.push(ef(c, k, h))));
    c = c.return;
  }
  g.length !== 0 && a.push({ event: b, listeners: g });
}
function jf() {
}
var kf = null, lf = null;
function mf(a, b) {
  switch (a) {
    case "button":
    case "input":
    case "select":
    case "textarea":
      return !!b.autoFocus;
  }
  return false;
}
function nf(a, b) {
  return a === "textarea" || a === "option" || a === "noscript" || typeof b.children === "string" || typeof b.children === "number" || typeof b.dangerouslySetInnerHTML === "object" && b.dangerouslySetInnerHTML !== null && b.dangerouslySetInnerHTML.__html != null;
}
var of = typeof setTimeout === "function" ? setTimeout : void 0, pf = typeof clearTimeout === "function" ? clearTimeout : void 0;
function qf(a) {
  a.nodeType === 1 ? a.textContent = "" : a.nodeType === 9 && (a = a.body, a != null && (a.textContent = ""));
}
function rf(a) {
  for (; a != null; a = a.nextSibling) {
    var b = a.nodeType;
    if (b === 1 || b === 3)
      break;
  }
  return a;
}
function sf(a) {
  a = a.previousSibling;
  for (var b = 0; a; ) {
    if (a.nodeType === 8) {
      var c = a.data;
      if (c === "$" || c === "$!" || c === "$?") {
        if (b === 0)
          return a;
        b--;
      } else
        c === "/$" && b++;
    }
    a = a.previousSibling;
  }
  return null;
}
var tf = 0;
function uf(a) {
  return { $$typeof: Ga, toString: a, valueOf: a };
}
var vf = Math.random().toString(36).slice(2), wf = "__reactFiber$" + vf, xf = "__reactProps$" + vf, ff = "__reactContainer$" + vf, yf = "__reactEvents$" + vf;
function wc(a) {
  var b = a[wf];
  if (b)
    return b;
  for (var c = a.parentNode; c; ) {
    if (b = c[ff] || c[wf]) {
      c = b.alternate;
      if (b.child !== null || c !== null && c.child !== null)
        for (a = sf(a); a !== null; ) {
          if (c = a[wf])
            return c;
          a = sf(a);
        }
      return b;
    }
    a = c;
    c = a.parentNode;
  }
  return null;
}
function Cb(a) {
  a = a[wf] || a[ff];
  return !a || a.tag !== 5 && a.tag !== 6 && a.tag !== 13 && a.tag !== 3 ? null : a;
}
function ue(a) {
  if (a.tag === 5 || a.tag === 6)
    return a.stateNode;
  throw Error(y(33));
}
function Db(a) {
  return a[xf] || null;
}
function $e(a) {
  var b = a[yf];
  b === void 0 && (b = a[yf] = /* @__PURE__ */ new Set());
  return b;
}
var zf = [], Af = -1;
function Bf(a) {
  return { current: a };
}
function H(a) {
  0 > Af || (a.current = zf[Af], zf[Af] = null, Af--);
}
function I(a, b) {
  Af++;
  zf[Af] = a.current;
  a.current = b;
}
var Cf = {}, M = Bf(Cf), N = Bf(false), Df = Cf;
function Ef(a, b) {
  var c = a.type.contextTypes;
  if (!c)
    return Cf;
  var d = a.stateNode;
  if (d && d.__reactInternalMemoizedUnmaskedChildContext === b)
    return d.__reactInternalMemoizedMaskedChildContext;
  var e = {}, f;
  for (f in c)
    e[f] = b[f];
  d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
  return e;
}
function Ff(a) {
  a = a.childContextTypes;
  return a !== null && a !== void 0;
}
function Gf() {
  H(N);
  H(M);
}
function Hf(a, b, c) {
  if (M.current !== Cf)
    throw Error(y(168));
  I(M, b);
  I(N, c);
}
function If(a, b, c) {
  var d = a.stateNode;
  a = b.childContextTypes;
  if (typeof d.getChildContext !== "function")
    return c;
  d = d.getChildContext();
  for (var e in d)
    if (!(e in a))
      throw Error(y(108, Ra(b) || "Unknown", e));
  return m({}, c, d);
}
function Jf(a) {
  a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Cf;
  Df = M.current;
  I(M, a);
  I(N, N.current);
  return true;
}
function Kf(a, b, c) {
  var d = a.stateNode;
  if (!d)
    throw Error(y(169));
  c ? (a = If(a, b, Df), d.__reactInternalMemoizedMergedChildContext = a, H(N), H(M), I(M, a)) : H(N);
  I(N, c);
}
var Lf = null, Mf = null, Nf = r.unstable_runWithPriority, Of = r.unstable_scheduleCallback, Pf = r.unstable_cancelCallback, Qf = r.unstable_shouldYield, Rf = r.unstable_requestPaint, Sf = r.unstable_now, Tf = r.unstable_getCurrentPriorityLevel, Uf = r.unstable_ImmediatePriority, Vf = r.unstable_UserBlockingPriority, Wf = r.unstable_NormalPriority, Xf = r.unstable_LowPriority, Yf = r.unstable_IdlePriority, Zf = {}, $f = Rf !== void 0 ? Rf : function() {
}, ag = null, bg = null, cg = false, dg = Sf(), O = 1e4 > dg ? Sf : function() {
  return Sf() - dg;
};
function eg() {
  switch (Tf()) {
    case Uf:
      return 99;
    case Vf:
      return 98;
    case Wf:
      return 97;
    case Xf:
      return 96;
    case Yf:
      return 95;
    default:
      throw Error(y(332));
  }
}
function fg(a) {
  switch (a) {
    case 99:
      return Uf;
    case 98:
      return Vf;
    case 97:
      return Wf;
    case 96:
      return Xf;
    case 95:
      return Yf;
    default:
      throw Error(y(332));
  }
}
function gg(a, b) {
  a = fg(a);
  return Nf(a, b);
}
function hg(a, b, c) {
  a = fg(a);
  return Of(a, b, c);
}
function ig() {
  if (bg !== null) {
    var a = bg;
    bg = null;
    Pf(a);
  }
  jg();
}
function jg() {
  if (!cg && ag !== null) {
    cg = true;
    var a = 0;
    try {
      var b = ag;
      gg(99, function() {
        for (; a < b.length; a++) {
          var c = b[a];
          do
            c = c(true);
          while (c !== null);
        }
      });
      ag = null;
    } catch (c) {
      throw ag !== null && (ag = ag.slice(a + 1)), Of(Uf, ig), c;
    } finally {
      cg = false;
    }
  }
}
var kg = ra.ReactCurrentBatchConfig;
function lg(a, b) {
  if (a && a.defaultProps) {
    b = m({}, b);
    a = a.defaultProps;
    for (var c in a)
      b[c] === void 0 && (b[c] = a[c]);
    return b;
  }
  return b;
}
var mg = Bf(null), ng = null, og = null, pg = null;
function qg() {
  pg = og = ng = null;
}
function rg(a) {
  var b = mg.current;
  H(mg);
  a.type._context._currentValue = b;
}
function sg(a, b) {
  for (; a !== null; ) {
    var c = a.alternate;
    if ((a.childLanes & b) === b)
      if (c === null || (c.childLanes & b) === b)
        break;
      else
        c.childLanes |= b;
    else
      a.childLanes |= b, c !== null && (c.childLanes |= b);
    a = a.return;
  }
}
function tg(a, b) {
  ng = a;
  pg = og = null;
  a = a.dependencies;
  a !== null && a.firstContext !== null && ((a.lanes & b) !== 0 && (ug = true), a.firstContext = null);
}
function vg(a, b) {
  if (pg !== a && b !== false && b !== 0) {
    if (typeof b !== "number" || b === 1073741823)
      pg = a, b = 1073741823;
    b = { context: a, observedBits: b, next: null };
    if (og === null) {
      if (ng === null)
        throw Error(y(308));
      og = b;
      ng.dependencies = { lanes: 0, firstContext: b, responders: null };
    } else
      og = og.next = b;
  }
  return a._currentValue;
}
var wg = false;
function xg(a) {
  a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null }, effects: null };
}
function yg(a, b) {
  a = a.updateQueue;
  b.updateQueue === a && (b.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
}
function zg(a, b) {
  return { eventTime: a, lane: b, tag: 0, payload: null, callback: null, next: null };
}
function Ag(a, b) {
  a = a.updateQueue;
  if (a !== null) {
    a = a.shared;
    var c = a.pending;
    c === null ? b.next = b : (b.next = c.next, c.next = b);
    a.pending = b;
  }
}
function Bg(a, b) {
  var c = a.updateQueue, d = a.alternate;
  if (d !== null && (d = d.updateQueue, c === d)) {
    var e = null, f = null;
    c = c.firstBaseUpdate;
    if (c !== null) {
      do {
        var g = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };
        f === null ? e = f = g : f = f.next = g;
        c = c.next;
      } while (c !== null);
      f === null ? e = f = b : f = f.next = b;
    } else
      e = f = b;
    c = { baseState: d.baseState, firstBaseUpdate: e, lastBaseUpdate: f, shared: d.shared, effects: d.effects };
    a.updateQueue = c;
    return;
  }
  a = c.lastBaseUpdate;
  a === null ? c.firstBaseUpdate = b : a.next = b;
  c.lastBaseUpdate = b;
}
function Cg(a, b, c, d) {
  var e = a.updateQueue;
  wg = false;
  var f = e.firstBaseUpdate, g = e.lastBaseUpdate, h = e.shared.pending;
  if (h !== null) {
    e.shared.pending = null;
    var k = h, l2 = k.next;
    k.next = null;
    g === null ? f = l2 : g.next = l2;
    g = k;
    var n2 = a.alternate;
    if (n2 !== null) {
      n2 = n2.updateQueue;
      var A2 = n2.lastBaseUpdate;
      A2 !== g && (A2 === null ? n2.firstBaseUpdate = l2 : A2.next = l2, n2.lastBaseUpdate = k);
    }
  }
  if (f !== null) {
    A2 = e.baseState;
    g = 0;
    n2 = l2 = k = null;
    do {
      h = f.lane;
      var p2 = f.eventTime;
      if ((d & h) === h) {
        n2 !== null && (n2 = n2.next = {
          eventTime: p2,
          lane: 0,
          tag: f.tag,
          payload: f.payload,
          callback: f.callback,
          next: null
        });
        a: {
          var C2 = a, x2 = f;
          h = b;
          p2 = c;
          switch (x2.tag) {
            case 1:
              C2 = x2.payload;
              if (typeof C2 === "function") {
                A2 = C2.call(p2, A2, h);
                break a;
              }
              A2 = C2;
              break a;
            case 3:
              C2.flags = C2.flags & -4097 | 64;
            case 0:
              C2 = x2.payload;
              h = typeof C2 === "function" ? C2.call(p2, A2, h) : C2;
              if (h === null || h === void 0)
                break a;
              A2 = m({}, A2, h);
              break a;
            case 2:
              wg = true;
          }
        }
        f.callback !== null && (a.flags |= 32, h = e.effects, h === null ? e.effects = [f] : h.push(f));
      } else
        p2 = { eventTime: p2, lane: h, tag: f.tag, payload: f.payload, callback: f.callback, next: null }, n2 === null ? (l2 = n2 = p2, k = A2) : n2 = n2.next = p2, g |= h;
      f = f.next;
      if (f === null)
        if (h = e.shared.pending, h === null)
          break;
        else
          f = h.next, h.next = null, e.lastBaseUpdate = h, e.shared.pending = null;
    } while (1);
    n2 === null && (k = A2);
    e.baseState = k;
    e.firstBaseUpdate = l2;
    e.lastBaseUpdate = n2;
    Dg |= g;
    a.lanes = g;
    a.memoizedState = A2;
  }
}
function Eg(a, b, c) {
  a = b.effects;
  b.effects = null;
  if (a !== null)
    for (b = 0; b < a.length; b++) {
      var d = a[b], e = d.callback;
      if (e !== null) {
        d.callback = null;
        d = c;
        if (typeof e !== "function")
          throw Error(y(191, e));
        e.call(d);
      }
    }
}
var Fg = new aa.Component().refs;
function Gg(a, b, c, d) {
  b = a.memoizedState;
  c = c(d, b);
  c = c === null || c === void 0 ? b : m({}, b, c);
  a.memoizedState = c;
  a.lanes === 0 && (a.updateQueue.baseState = c);
}
var Kg = { isMounted: function(a) {
  return (a = a._reactInternals) ? Zb(a) === a : false;
}, enqueueSetState: function(a, b, c) {
  a = a._reactInternals;
  var d = Hg(), e = Ig(a), f = zg(d, e);
  f.payload = b;
  c !== void 0 && c !== null && (f.callback = c);
  Ag(a, f);
  Jg(a, e, d);
}, enqueueReplaceState: function(a, b, c) {
  a = a._reactInternals;
  var d = Hg(), e = Ig(a), f = zg(d, e);
  f.tag = 1;
  f.payload = b;
  c !== void 0 && c !== null && (f.callback = c);
  Ag(a, f);
  Jg(a, e, d);
}, enqueueForceUpdate: function(a, b) {
  a = a._reactInternals;
  var c = Hg(), d = Ig(a), e = zg(c, d);
  e.tag = 2;
  b !== void 0 && b !== null && (e.callback = b);
  Ag(a, e);
  Jg(a, d, c);
} };
function Lg(a, b, c, d, e, f, g) {
  a = a.stateNode;
  return typeof a.shouldComponentUpdate === "function" ? a.shouldComponentUpdate(d, f, g) : b.prototype && b.prototype.isPureReactComponent ? !Je(c, d) || !Je(e, f) : true;
}
function Mg(a, b, c) {
  var d = false, e = Cf;
  var f = b.contextType;
  typeof f === "object" && f !== null ? f = vg(f) : (e = Ff(b) ? Df : M.current, d = b.contextTypes, f = (d = d !== null && d !== void 0) ? Ef(a, e) : Cf);
  b = new b(c, f);
  a.memoizedState = b.state !== null && b.state !== void 0 ? b.state : null;
  b.updater = Kg;
  a.stateNode = b;
  b._reactInternals = a;
  d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f);
  return b;
}
function Ng(a, b, c, d) {
  a = b.state;
  typeof b.componentWillReceiveProps === "function" && b.componentWillReceiveProps(c, d);
  typeof b.UNSAFE_componentWillReceiveProps === "function" && b.UNSAFE_componentWillReceiveProps(c, d);
  b.state !== a && Kg.enqueueReplaceState(b, b.state, null);
}
function Og(a, b, c, d) {
  var e = a.stateNode;
  e.props = c;
  e.state = a.memoizedState;
  e.refs = Fg;
  xg(a);
  var f = b.contextType;
  typeof f === "object" && f !== null ? e.context = vg(f) : (f = Ff(b) ? Df : M.current, e.context = Ef(a, f));
  Cg(a, c, e, d);
  e.state = a.memoizedState;
  f = b.getDerivedStateFromProps;
  typeof f === "function" && (Gg(a, b, f, c), e.state = a.memoizedState);
  typeof b.getDerivedStateFromProps === "function" || typeof e.getSnapshotBeforeUpdate === "function" || typeof e.UNSAFE_componentWillMount !== "function" && typeof e.componentWillMount !== "function" || (b = e.state, typeof e.componentWillMount === "function" && e.componentWillMount(), typeof e.UNSAFE_componentWillMount === "function" && e.UNSAFE_componentWillMount(), b !== e.state && Kg.enqueueReplaceState(e, e.state, null), Cg(a, c, e, d), e.state = a.memoizedState);
  typeof e.componentDidMount === "function" && (a.flags |= 4);
}
var Pg = Array.isArray;
function Qg(a, b, c) {
  a = c.ref;
  if (a !== null && typeof a !== "function" && typeof a !== "object") {
    if (c._owner) {
      c = c._owner;
      if (c) {
        if (c.tag !== 1)
          throw Error(y(309));
        var d = c.stateNode;
      }
      if (!d)
        throw Error(y(147, a));
      var e = "" + a;
      if (b !== null && b.ref !== null && typeof b.ref === "function" && b.ref._stringRef === e)
        return b.ref;
      b = function(a2) {
        var b2 = d.refs;
        b2 === Fg && (b2 = d.refs = {});
        a2 === null ? delete b2[e] : b2[e] = a2;
      };
      b._stringRef = e;
      return b;
    }
    if (typeof a !== "string")
      throw Error(y(284));
    if (!c._owner)
      throw Error(y(290, a));
  }
  return a;
}
function Rg(a, b) {
  if (a.type !== "textarea")
    throw Error(y(31, Object.prototype.toString.call(b) === "[object Object]" ? "object with keys {" + Object.keys(b).join(", ") + "}" : b));
}
function Sg(a) {
  function b(b2, c2) {
    if (a) {
      var d2 = b2.lastEffect;
      d2 !== null ? (d2.nextEffect = c2, b2.lastEffect = c2) : b2.firstEffect = b2.lastEffect = c2;
      c2.nextEffect = null;
      c2.flags = 8;
    }
  }
  function c(c2, d2) {
    if (!a)
      return null;
    for (; d2 !== null; )
      b(c2, d2), d2 = d2.sibling;
    return null;
  }
  function d(a2, b2) {
    for (a2 = /* @__PURE__ */ new Map(); b2 !== null; )
      b2.key !== null ? a2.set(b2.key, b2) : a2.set(b2.index, b2), b2 = b2.sibling;
    return a2;
  }
  function e(a2, b2) {
    a2 = Tg(a2, b2);
    a2.index = 0;
    a2.sibling = null;
    return a2;
  }
  function f(b2, c2, d2) {
    b2.index = d2;
    if (!a)
      return c2;
    d2 = b2.alternate;
    if (d2 !== null)
      return d2 = d2.index, d2 < c2 ? (b2.flags = 2, c2) : d2;
    b2.flags = 2;
    return c2;
  }
  function g(b2) {
    a && b2.alternate === null && (b2.flags = 2);
    return b2;
  }
  function h(a2, b2, c2, d2) {
    if (b2 === null || b2.tag !== 6)
      return b2 = Ug(c2, a2.mode, d2), b2.return = a2, b2;
    b2 = e(b2, c2);
    b2.return = a2;
    return b2;
  }
  function k(a2, b2, c2, d2) {
    if (b2 !== null && b2.elementType === c2.type)
      return d2 = e(b2, c2.props), d2.ref = Qg(a2, b2, c2), d2.return = a2, d2;
    d2 = Vg(c2.type, c2.key, c2.props, null, a2.mode, d2);
    d2.ref = Qg(a2, b2, c2);
    d2.return = a2;
    return d2;
  }
  function l2(a2, b2, c2, d2) {
    if (b2 === null || b2.tag !== 4 || b2.stateNode.containerInfo !== c2.containerInfo || b2.stateNode.implementation !== c2.implementation)
      return b2 = Wg(c2, a2.mode, d2), b2.return = a2, b2;
    b2 = e(b2, c2.children || []);
    b2.return = a2;
    return b2;
  }
  function n2(a2, b2, c2, d2, f2) {
    if (b2 === null || b2.tag !== 7)
      return b2 = Xg(c2, a2.mode, d2, f2), b2.return = a2, b2;
    b2 = e(b2, c2);
    b2.return = a2;
    return b2;
  }
  function A2(a2, b2, c2) {
    if (typeof b2 === "string" || typeof b2 === "number")
      return b2 = Ug("" + b2, a2.mode, c2), b2.return = a2, b2;
    if (typeof b2 === "object" && b2 !== null) {
      switch (b2.$$typeof) {
        case sa:
          return c2 = Vg(b2.type, b2.key, b2.props, null, a2.mode, c2), c2.ref = Qg(a2, null, b2), c2.return = a2, c2;
        case ta:
          return b2 = Wg(b2, a2.mode, c2), b2.return = a2, b2;
      }
      if (Pg(b2) || La(b2))
        return b2 = Xg(b2, a2.mode, c2, null), b2.return = a2, b2;
      Rg(a2, b2);
    }
    return null;
  }
  function p2(a2, b2, c2, d2) {
    var e2 = b2 !== null ? b2.key : null;
    if (typeof c2 === "string" || typeof c2 === "number")
      return e2 !== null ? null : h(a2, b2, "" + c2, d2);
    if (typeof c2 === "object" && c2 !== null) {
      switch (c2.$$typeof) {
        case sa:
          return c2.key === e2 ? c2.type === ua ? n2(a2, b2, c2.props.children, d2, e2) : k(a2, b2, c2, d2) : null;
        case ta:
          return c2.key === e2 ? l2(a2, b2, c2, d2) : null;
      }
      if (Pg(c2) || La(c2))
        return e2 !== null ? null : n2(a2, b2, c2, d2, null);
      Rg(a2, c2);
    }
    return null;
  }
  function C2(a2, b2, c2, d2, e2) {
    if (typeof d2 === "string" || typeof d2 === "number")
      return a2 = a2.get(c2) || null, h(b2, a2, "" + d2, e2);
    if (typeof d2 === "object" && d2 !== null) {
      switch (d2.$$typeof) {
        case sa:
          return a2 = a2.get(d2.key === null ? c2 : d2.key) || null, d2.type === ua ? n2(b2, a2, d2.props.children, e2, d2.key) : k(b2, a2, d2, e2);
        case ta:
          return a2 = a2.get(d2.key === null ? c2 : d2.key) || null, l2(b2, a2, d2, e2);
      }
      if (Pg(d2) || La(d2))
        return a2 = a2.get(c2) || null, n2(b2, a2, d2, e2, null);
      Rg(b2, d2);
    }
    return null;
  }
  function x2(e2, g2, h2, k2) {
    for (var l3 = null, t2 = null, u2 = g2, z2 = g2 = 0, q2 = null; u2 !== null && z2 < h2.length; z2++) {
      u2.index > z2 ? (q2 = u2, u2 = null) : q2 = u2.sibling;
      var n3 = p2(e2, u2, h2[z2], k2);
      if (n3 === null) {
        u2 === null && (u2 = q2);
        break;
      }
      a && u2 && n3.alternate === null && b(e2, u2);
      g2 = f(n3, g2, z2);
      t2 === null ? l3 = n3 : t2.sibling = n3;
      t2 = n3;
      u2 = q2;
    }
    if (z2 === h2.length)
      return c(e2, u2), l3;
    if (u2 === null) {
      for (; z2 < h2.length; z2++)
        u2 = A2(e2, h2[z2], k2), u2 !== null && (g2 = f(u2, g2, z2), t2 === null ? l3 = u2 : t2.sibling = u2, t2 = u2);
      return l3;
    }
    for (u2 = d(e2, u2); z2 < h2.length; z2++)
      q2 = C2(u2, e2, z2, h2[z2], k2), q2 !== null && (a && q2.alternate !== null && u2.delete(q2.key === null ? z2 : q2.key), g2 = f(q2, g2, z2), t2 === null ? l3 = q2 : t2.sibling = q2, t2 = q2);
    a && u2.forEach(function(a2) {
      return b(e2, a2);
    });
    return l3;
  }
  function w(e2, g2, h2, k2) {
    var l3 = La(h2);
    if (typeof l3 !== "function")
      throw Error(y(150));
    h2 = l3.call(h2);
    if (h2 == null)
      throw Error(y(151));
    for (var t2 = l3 = null, u2 = g2, z2 = g2 = 0, q2 = null, n3 = h2.next(); u2 !== null && !n3.done; z2++, n3 = h2.next()) {
      u2.index > z2 ? (q2 = u2, u2 = null) : q2 = u2.sibling;
      var w2 = p2(e2, u2, n3.value, k2);
      if (w2 === null) {
        u2 === null && (u2 = q2);
        break;
      }
      a && u2 && w2.alternate === null && b(e2, u2);
      g2 = f(w2, g2, z2);
      t2 === null ? l3 = w2 : t2.sibling = w2;
      t2 = w2;
      u2 = q2;
    }
    if (n3.done)
      return c(e2, u2), l3;
    if (u2 === null) {
      for (; !n3.done; z2++, n3 = h2.next())
        n3 = A2(e2, n3.value, k2), n3 !== null && (g2 = f(n3, g2, z2), t2 === null ? l3 = n3 : t2.sibling = n3, t2 = n3);
      return l3;
    }
    for (u2 = d(e2, u2); !n3.done; z2++, n3 = h2.next())
      n3 = C2(u2, e2, z2, n3.value, k2), n3 !== null && (a && n3.alternate !== null && u2.delete(n3.key === null ? z2 : n3.key), g2 = f(n3, g2, z2), t2 === null ? l3 = n3 : t2.sibling = n3, t2 = n3);
    a && u2.forEach(function(a2) {
      return b(e2, a2);
    });
    return l3;
  }
  return function(a2, d2, f2, h2) {
    var k2 = typeof f2 === "object" && f2 !== null && f2.type === ua && f2.key === null;
    k2 && (f2 = f2.props.children);
    var l3 = typeof f2 === "object" && f2 !== null;
    if (l3)
      switch (f2.$$typeof) {
        case sa:
          a: {
            l3 = f2.key;
            for (k2 = d2; k2 !== null; ) {
              if (k2.key === l3) {
                switch (k2.tag) {
                  case 7:
                    if (f2.type === ua) {
                      c(a2, k2.sibling);
                      d2 = e(k2, f2.props.children);
                      d2.return = a2;
                      a2 = d2;
                      break a;
                    }
                    break;
                  default:
                    if (k2.elementType === f2.type) {
                      c(a2, k2.sibling);
                      d2 = e(k2, f2.props);
                      d2.ref = Qg(a2, k2, f2);
                      d2.return = a2;
                      a2 = d2;
                      break a;
                    }
                }
                c(a2, k2);
                break;
              } else
                b(a2, k2);
              k2 = k2.sibling;
            }
            f2.type === ua ? (d2 = Xg(f2.props.children, a2.mode, h2, f2.key), d2.return = a2, a2 = d2) : (h2 = Vg(f2.type, f2.key, f2.props, null, a2.mode, h2), h2.ref = Qg(a2, d2, f2), h2.return = a2, a2 = h2);
          }
          return g(a2);
        case ta:
          a: {
            for (k2 = f2.key; d2 !== null; ) {
              if (d2.key === k2)
                if (d2.tag === 4 && d2.stateNode.containerInfo === f2.containerInfo && d2.stateNode.implementation === f2.implementation) {
                  c(a2, d2.sibling);
                  d2 = e(d2, f2.children || []);
                  d2.return = a2;
                  a2 = d2;
                  break a;
                } else {
                  c(a2, d2);
                  break;
                }
              else
                b(a2, d2);
              d2 = d2.sibling;
            }
            d2 = Wg(f2, a2.mode, h2);
            d2.return = a2;
            a2 = d2;
          }
          return g(a2);
      }
    if (typeof f2 === "string" || typeof f2 === "number")
      return f2 = "" + f2, d2 !== null && d2.tag === 6 ? (c(a2, d2.sibling), d2 = e(d2, f2), d2.return = a2, a2 = d2) : (c(a2, d2), d2 = Ug(f2, a2.mode, h2), d2.return = a2, a2 = d2), g(a2);
    if (Pg(f2))
      return x2(a2, d2, f2, h2);
    if (La(f2))
      return w(a2, d2, f2, h2);
    l3 && Rg(a2, f2);
    if (typeof f2 === "undefined" && !k2)
      switch (a2.tag) {
        case 1:
        case 22:
        case 0:
        case 11:
        case 15:
          throw Error(y(152, Ra(a2.type) || "Component"));
      }
    return c(a2, d2);
  };
}
var Yg = Sg(true), Zg = Sg(false), $g = {}, ah = Bf($g), bh = Bf($g), ch = Bf($g);
function dh(a) {
  if (a === $g)
    throw Error(y(174));
  return a;
}
function eh(a, b) {
  I(ch, b);
  I(bh, a);
  I(ah, $g);
  a = b.nodeType;
  switch (a) {
    case 9:
    case 11:
      b = (b = b.documentElement) ? b.namespaceURI : mb(null, "");
      break;
    default:
      a = a === 8 ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = mb(b, a);
  }
  H(ah);
  I(ah, b);
}
function fh() {
  H(ah);
  H(bh);
  H(ch);
}
function gh(a) {
  dh(ch.current);
  var b = dh(ah.current);
  var c = mb(b, a.type);
  b !== c && (I(bh, a), I(ah, c));
}
function hh(a) {
  bh.current === a && (H(ah), H(bh));
}
var P = Bf(0);
function ih(a) {
  for (var b = a; b !== null; ) {
    if (b.tag === 13) {
      var c = b.memoizedState;
      if (c !== null && (c = c.dehydrated, c === null || c.data === "$?" || c.data === "$!"))
        return b;
    } else if (b.tag === 19 && b.memoizedProps.revealOrder !== void 0) {
      if ((b.flags & 64) !== 0)
        return b;
    } else if (b.child !== null) {
      b.child.return = b;
      b = b.child;
      continue;
    }
    if (b === a)
      break;
    for (; b.sibling === null; ) {
      if (b.return === null || b.return === a)
        return null;
      b = b.return;
    }
    b.sibling.return = b.return;
    b = b.sibling;
  }
  return null;
}
var jh = null, kh = null, lh = false;
function mh(a, b) {
  var c = nh(5, null, null, 0);
  c.elementType = "DELETED";
  c.type = "DELETED";
  c.stateNode = b;
  c.return = a;
  c.flags = 8;
  a.lastEffect !== null ? (a.lastEffect.nextEffect = c, a.lastEffect = c) : a.firstEffect = a.lastEffect = c;
}
function oh(a, b) {
  switch (a.tag) {
    case 5:
      var c = a.type;
      b = b.nodeType !== 1 || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
      return b !== null ? (a.stateNode = b, true) : false;
    case 6:
      return b = a.pendingProps === "" || b.nodeType !== 3 ? null : b, b !== null ? (a.stateNode = b, true) : false;
    case 13:
      return false;
    default:
      return false;
  }
}
function ph(a) {
  if (lh) {
    var b = kh;
    if (b) {
      var c = b;
      if (!oh(a, b)) {
        b = rf(c.nextSibling);
        if (!b || !oh(a, b)) {
          a.flags = a.flags & -1025 | 2;
          lh = false;
          jh = a;
          return;
        }
        mh(jh, c);
      }
      jh = a;
      kh = rf(b.firstChild);
    } else
      a.flags = a.flags & -1025 | 2, lh = false, jh = a;
  }
}
function qh(a) {
  for (a = a.return; a !== null && a.tag !== 5 && a.tag !== 3 && a.tag !== 13; )
    a = a.return;
  jh = a;
}
function rh(a) {
  if (a !== jh)
    return false;
  if (!lh)
    return qh(a), lh = true, false;
  var b = a.type;
  if (a.tag !== 5 || b !== "head" && b !== "body" && !nf(b, a.memoizedProps))
    for (b = kh; b; )
      mh(a, b), b = rf(b.nextSibling);
  qh(a);
  if (a.tag === 13) {
    a = a.memoizedState;
    a = a !== null ? a.dehydrated : null;
    if (!a)
      throw Error(y(317));
    a: {
      a = a.nextSibling;
      for (b = 0; a; ) {
        if (a.nodeType === 8) {
          var c = a.data;
          if (c === "/$") {
            if (b === 0) {
              kh = rf(a.nextSibling);
              break a;
            }
            b--;
          } else
            c !== "$" && c !== "$!" && c !== "$?" || b++;
        }
        a = a.nextSibling;
      }
      kh = null;
    }
  } else
    kh = jh ? rf(a.stateNode.nextSibling) : null;
  return true;
}
function sh() {
  kh = jh = null;
  lh = false;
}
var th = [];
function uh() {
  for (var a = 0; a < th.length; a++)
    th[a]._workInProgressVersionPrimary = null;
  th.length = 0;
}
var vh = ra.ReactCurrentDispatcher, wh = ra.ReactCurrentBatchConfig, xh = 0, R = null, S = null, T = null, yh = false, zh = false;
function Ah() {
  throw Error(y(321));
}
function Bh(a, b) {
  if (b === null)
    return false;
  for (var c = 0; c < b.length && c < a.length; c++)
    if (!He(a[c], b[c]))
      return false;
  return true;
}
function Ch(a, b, c, d, e, f) {
  xh = f;
  R = b;
  b.memoizedState = null;
  b.updateQueue = null;
  b.lanes = 0;
  vh.current = a === null || a.memoizedState === null ? Dh : Eh;
  a = c(d, e);
  if (zh) {
    f = 0;
    do {
      zh = false;
      if (!(25 > f))
        throw Error(y(301));
      f += 1;
      T = S = null;
      b.updateQueue = null;
      vh.current = Fh;
      a = c(d, e);
    } while (zh);
  }
  vh.current = Gh;
  b = S !== null && S.next !== null;
  xh = 0;
  T = S = R = null;
  yh = false;
  if (b)
    throw Error(y(300));
  return a;
}
function Hh() {
  var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  T === null ? R.memoizedState = T = a : T = T.next = a;
  return T;
}
function Ih() {
  if (S === null) {
    var a = R.alternate;
    a = a !== null ? a.memoizedState : null;
  } else
    a = S.next;
  var b = T === null ? R.memoizedState : T.next;
  if (b !== null)
    T = b, S = a;
  else {
    if (a === null)
      throw Error(y(310));
    S = a;
    a = { memoizedState: S.memoizedState, baseState: S.baseState, baseQueue: S.baseQueue, queue: S.queue, next: null };
    T === null ? R.memoizedState = T = a : T = T.next = a;
  }
  return T;
}
function Jh(a, b) {
  return typeof b === "function" ? b(a) : b;
}
function Kh(a) {
  var b = Ih(), c = b.queue;
  if (c === null)
    throw Error(y(311));
  c.lastRenderedReducer = a;
  var d = S, e = d.baseQueue, f = c.pending;
  if (f !== null) {
    if (e !== null) {
      var g = e.next;
      e.next = f.next;
      f.next = g;
    }
    d.baseQueue = e = f;
    c.pending = null;
  }
  if (e !== null) {
    e = e.next;
    d = d.baseState;
    var h = g = f = null, k = e;
    do {
      var l2 = k.lane;
      if ((xh & l2) === l2)
        h !== null && (h = h.next = { lane: 0, action: k.action, eagerReducer: k.eagerReducer, eagerState: k.eagerState, next: null }), d = k.eagerReducer === a ? k.eagerState : a(d, k.action);
      else {
        var n2 = {
          lane: l2,
          action: k.action,
          eagerReducer: k.eagerReducer,
          eagerState: k.eagerState,
          next: null
        };
        h === null ? (g = h = n2, f = d) : h = h.next = n2;
        R.lanes |= l2;
        Dg |= l2;
      }
      k = k.next;
    } while (k !== null && k !== e);
    h === null ? f = d : h.next = g;
    He(d, b.memoizedState) || (ug = true);
    b.memoizedState = d;
    b.baseState = f;
    b.baseQueue = h;
    c.lastRenderedState = d;
  }
  return [b.memoizedState, c.dispatch];
}
function Lh(a) {
  var b = Ih(), c = b.queue;
  if (c === null)
    throw Error(y(311));
  c.lastRenderedReducer = a;
  var d = c.dispatch, e = c.pending, f = b.memoizedState;
  if (e !== null) {
    c.pending = null;
    var g = e = e.next;
    do
      f = a(f, g.action), g = g.next;
    while (g !== e);
    He(f, b.memoizedState) || (ug = true);
    b.memoizedState = f;
    b.baseQueue === null && (b.baseState = f);
    c.lastRenderedState = f;
  }
  return [f, d];
}
function Mh(a, b, c) {
  var d = b._getVersion;
  d = d(b._source);
  var e = b._workInProgressVersionPrimary;
  if (e !== null)
    a = e === d;
  else if (a = a.mutableReadLanes, a = (xh & a) === a)
    b._workInProgressVersionPrimary = d, th.push(b);
  if (a)
    return c(b._source);
  th.push(b);
  throw Error(y(350));
}
function Nh(a, b, c, d) {
  var e = U;
  if (e === null)
    throw Error(y(349));
  var f = b._getVersion, g = f(b._source), h = vh.current, k = h.useState(function() {
    return Mh(e, b, c);
  }), l2 = k[1], n2 = k[0];
  k = T;
  var A2 = a.memoizedState, p2 = A2.refs, C2 = p2.getSnapshot, x2 = A2.source;
  A2 = A2.subscribe;
  var w = R;
  a.memoizedState = { refs: p2, source: b, subscribe: d };
  h.useEffect(function() {
    p2.getSnapshot = c;
    p2.setSnapshot = l2;
    var a2 = f(b._source);
    if (!He(g, a2)) {
      a2 = c(b._source);
      He(n2, a2) || (l2(a2), a2 = Ig(w), e.mutableReadLanes |= a2 & e.pendingLanes);
      a2 = e.mutableReadLanes;
      e.entangledLanes |= a2;
      for (var d2 = e.entanglements, h2 = a2; 0 < h2; ) {
        var k2 = 31 - Vc(h2), v2 = 1 << k2;
        d2[k2] |= a2;
        h2 &= ~v2;
      }
    }
  }, [c, b, d]);
  h.useEffect(function() {
    return d(b._source, function() {
      var a2 = p2.getSnapshot, c2 = p2.setSnapshot;
      try {
        c2(a2(b._source));
        var d2 = Ig(w);
        e.mutableReadLanes |= d2 & e.pendingLanes;
      } catch (q2) {
        c2(function() {
          throw q2;
        });
      }
    });
  }, [b, d]);
  He(C2, c) && He(x2, b) && He(A2, d) || (a = { pending: null, dispatch: null, lastRenderedReducer: Jh, lastRenderedState: n2 }, a.dispatch = l2 = Oh.bind(null, R, a), k.queue = a, k.baseQueue = null, n2 = Mh(e, b, c), k.memoizedState = k.baseState = n2);
  return n2;
}
function Ph(a, b, c) {
  var d = Ih();
  return Nh(d, a, b, c);
}
function Qh(a) {
  var b = Hh();
  typeof a === "function" && (a = a());
  b.memoizedState = b.baseState = a;
  a = b.queue = { pending: null, dispatch: null, lastRenderedReducer: Jh, lastRenderedState: a };
  a = a.dispatch = Oh.bind(null, R, a);
  return [b.memoizedState, a];
}
function Rh(a, b, c, d) {
  a = { tag: a, create: b, destroy: c, deps: d, next: null };
  b = R.updateQueue;
  b === null ? (b = { lastEffect: null }, R.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, c === null ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a));
  return a;
}
function Sh(a) {
  var b = Hh();
  a = { current: a };
  return b.memoizedState = a;
}
function Th() {
  return Ih().memoizedState;
}
function Uh(a, b, c, d) {
  var e = Hh();
  R.flags |= a;
  e.memoizedState = Rh(1 | b, c, void 0, d === void 0 ? null : d);
}
function Vh(a, b, c, d) {
  var e = Ih();
  d = d === void 0 ? null : d;
  var f = void 0;
  if (S !== null) {
    var g = S.memoizedState;
    f = g.destroy;
    if (d !== null && Bh(d, g.deps)) {
      Rh(b, c, f, d);
      return;
    }
  }
  R.flags |= a;
  e.memoizedState = Rh(1 | b, c, f, d);
}
function Wh(a, b) {
  return Uh(516, 4, a, b);
}
function Xh(a, b) {
  return Vh(516, 4, a, b);
}
function Yh(a, b) {
  return Vh(4, 2, a, b);
}
function Zh(a, b) {
  if (typeof b === "function")
    return a = a(), b(a), function() {
      b(null);
    };
  if (b !== null && b !== void 0)
    return a = a(), b.current = a, function() {
      b.current = null;
    };
}
function $h(a, b, c) {
  c = c !== null && c !== void 0 ? c.concat([a]) : null;
  return Vh(4, 2, Zh.bind(null, b, a), c);
}
function ai() {
}
function bi(a, b) {
  var c = Ih();
  b = b === void 0 ? null : b;
  var d = c.memoizedState;
  if (d !== null && b !== null && Bh(b, d[1]))
    return d[0];
  c.memoizedState = [a, b];
  return a;
}
function ci(a, b) {
  var c = Ih();
  b = b === void 0 ? null : b;
  var d = c.memoizedState;
  if (d !== null && b !== null && Bh(b, d[1]))
    return d[0];
  a = a();
  c.memoizedState = [a, b];
  return a;
}
function di(a, b) {
  var c = eg();
  gg(98 > c ? 98 : c, function() {
    a(true);
  });
  gg(97 < c ? 97 : c, function() {
    var c2 = wh.transition;
    wh.transition = 1;
    try {
      a(false), b();
    } finally {
      wh.transition = c2;
    }
  });
}
function Oh(a, b, c) {
  var d = Hg(), e = Ig(a), f = { lane: e, action: c, eagerReducer: null, eagerState: null, next: null }, g = b.pending;
  g === null ? f.next = f : (f.next = g.next, g.next = f);
  b.pending = f;
  g = a.alternate;
  if (a === R || g !== null && g === R)
    zh = yh = true;
  else {
    if (a.lanes === 0 && (g === null || g.lanes === 0) && (g = b.lastRenderedReducer, g !== null))
      try {
        var h = b.lastRenderedState, k = g(h, c);
        f.eagerReducer = g;
        f.eagerState = k;
        if (He(k, h))
          return;
      } catch (l2) {
      } finally {
      }
    Jg(a, e, d);
  }
}
var Gh = { readContext: vg, useCallback: Ah, useContext: Ah, useEffect: Ah, useImperativeHandle: Ah, useLayoutEffect: Ah, useMemo: Ah, useReducer: Ah, useRef: Ah, useState: Ah, useDebugValue: Ah, useDeferredValue: Ah, useTransition: Ah, useMutableSource: Ah, useOpaqueIdentifier: Ah, unstable_isNewReconciler: false }, Dh = { readContext: vg, useCallback: function(a, b) {
  Hh().memoizedState = [a, b === void 0 ? null : b];
  return a;
}, useContext: vg, useEffect: Wh, useImperativeHandle: function(a, b, c) {
  c = c !== null && c !== void 0 ? c.concat([a]) : null;
  return Uh(4, 2, Zh.bind(null, b, a), c);
}, useLayoutEffect: function(a, b) {
  return Uh(4, 2, a, b);
}, useMemo: function(a, b) {
  var c = Hh();
  b = b === void 0 ? null : b;
  a = a();
  c.memoizedState = [a, b];
  return a;
}, useReducer: function(a, b, c) {
  var d = Hh();
  b = c !== void 0 ? c(b) : b;
  d.memoizedState = d.baseState = b;
  a = d.queue = { pending: null, dispatch: null, lastRenderedReducer: a, lastRenderedState: b };
  a = a.dispatch = Oh.bind(null, R, a);
  return [d.memoizedState, a];
}, useRef: Sh, useState: Qh, useDebugValue: ai, useDeferredValue: function(a) {
  var b = Qh(a), c = b[0], d = b[1];
  Wh(function() {
    var b2 = wh.transition;
    wh.transition = 1;
    try {
      d(a);
    } finally {
      wh.transition = b2;
    }
  }, [a]);
  return c;
}, useTransition: function() {
  var a = Qh(false), b = a[0];
  a = di.bind(null, a[1]);
  Sh(a);
  return [a, b];
}, useMutableSource: function(a, b, c) {
  var d = Hh();
  d.memoizedState = { refs: { getSnapshot: b, setSnapshot: null }, source: a, subscribe: c };
  return Nh(d, a, b, c);
}, useOpaqueIdentifier: function() {
  if (lh) {
    var a = false, b = uf(function() {
      a || (a = true, c("r:" + (tf++).toString(36)));
      throw Error(y(355));
    }), c = Qh(b)[1];
    (R.mode & 2) === 0 && (R.flags |= 516, Rh(5, function() {
      c("r:" + (tf++).toString(36));
    }, void 0, null));
    return b;
  }
  b = "r:" + (tf++).toString(36);
  Qh(b);
  return b;
}, unstable_isNewReconciler: false }, Eh = { readContext: vg, useCallback: bi, useContext: vg, useEffect: Xh, useImperativeHandle: $h, useLayoutEffect: Yh, useMemo: ci, useReducer: Kh, useRef: Th, useState: function() {
  return Kh(Jh);
}, useDebugValue: ai, useDeferredValue: function(a) {
  var b = Kh(Jh), c = b[0], d = b[1];
  Xh(function() {
    var b2 = wh.transition;
    wh.transition = 1;
    try {
      d(a);
    } finally {
      wh.transition = b2;
    }
  }, [a]);
  return c;
}, useTransition: function() {
  var a = Kh(Jh)[0];
  return [
    Th().current,
    a
  ];
}, useMutableSource: Ph, useOpaqueIdentifier: function() {
  return Kh(Jh)[0];
}, unstable_isNewReconciler: false }, Fh = { readContext: vg, useCallback: bi, useContext: vg, useEffect: Xh, useImperativeHandle: $h, useLayoutEffect: Yh, useMemo: ci, useReducer: Lh, useRef: Th, useState: function() {
  return Lh(Jh);
}, useDebugValue: ai, useDeferredValue: function(a) {
  var b = Lh(Jh), c = b[0], d = b[1];
  Xh(function() {
    var b2 = wh.transition;
    wh.transition = 1;
    try {
      d(a);
    } finally {
      wh.transition = b2;
    }
  }, [a]);
  return c;
}, useTransition: function() {
  var a = Lh(Jh)[0];
  return [
    Th().current,
    a
  ];
}, useMutableSource: Ph, useOpaqueIdentifier: function() {
  return Lh(Jh)[0];
}, unstable_isNewReconciler: false }, ei = ra.ReactCurrentOwner, ug = false;
function fi(a, b, c, d) {
  b.child = a === null ? Zg(b, null, c, d) : Yg(b, a.child, c, d);
}
function gi(a, b, c, d, e) {
  c = c.render;
  var f = b.ref;
  tg(b, e);
  d = Ch(a, b, c, d, f, e);
  if (a !== null && !ug)
    return b.updateQueue = a.updateQueue, b.flags &= -517, a.lanes &= ~e, hi(a, b, e);
  b.flags |= 1;
  fi(a, b, d, e);
  return b.child;
}
function ii(a, b, c, d, e, f) {
  if (a === null) {
    var g = c.type;
    if (typeof g === "function" && !ji(g) && g.defaultProps === void 0 && c.compare === null && c.defaultProps === void 0)
      return b.tag = 15, b.type = g, ki(a, b, g, d, e, f);
    a = Vg(c.type, null, d, b, b.mode, f);
    a.ref = b.ref;
    a.return = b;
    return b.child = a;
  }
  g = a.child;
  if ((e & f) === 0 && (e = g.memoizedProps, c = c.compare, c = c !== null ? c : Je, c(e, d) && a.ref === b.ref))
    return hi(a, b, f);
  b.flags |= 1;
  a = Tg(g, d);
  a.ref = b.ref;
  a.return = b;
  return b.child = a;
}
function ki(a, b, c, d, e, f) {
  if (a !== null && Je(a.memoizedProps, d) && a.ref === b.ref)
    if (ug = false, (f & e) !== 0)
      (a.flags & 16384) !== 0 && (ug = true);
    else
      return b.lanes = a.lanes, hi(a, b, f);
  return li(a, b, c, d, f);
}
function mi(a, b, c) {
  var d = b.pendingProps, e = d.children, f = a !== null ? a.memoizedState : null;
  if (d.mode === "hidden" || d.mode === "unstable-defer-without-hiding")
    if ((b.mode & 4) === 0)
      b.memoizedState = { baseLanes: 0 }, ni(b, c);
    else if ((c & 1073741824) !== 0)
      b.memoizedState = { baseLanes: 0 }, ni(b, f !== null ? f.baseLanes : c);
    else
      return a = f !== null ? f.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = { baseLanes: a }, ni(b, a), null;
  else
    f !== null ? (d = f.baseLanes | c, b.memoizedState = null) : d = c, ni(b, d);
  fi(a, b, e, c);
  return b.child;
}
function oi(a, b) {
  var c = b.ref;
  if (a === null && c !== null || a !== null && a.ref !== c)
    b.flags |= 128;
}
function li(a, b, c, d, e) {
  var f = Ff(c) ? Df : M.current;
  f = Ef(b, f);
  tg(b, e);
  c = Ch(a, b, c, d, f, e);
  if (a !== null && !ug)
    return b.updateQueue = a.updateQueue, b.flags &= -517, a.lanes &= ~e, hi(a, b, e);
  b.flags |= 1;
  fi(a, b, c, e);
  return b.child;
}
function pi(a, b, c, d, e) {
  if (Ff(c)) {
    var f = true;
    Jf(b);
  } else
    f = false;
  tg(b, e);
  if (b.stateNode === null)
    a !== null && (a.alternate = null, b.alternate = null, b.flags |= 2), Mg(b, c, d), Og(b, c, d, e), d = true;
  else if (a === null) {
    var g = b.stateNode, h = b.memoizedProps;
    g.props = h;
    var k = g.context, l2 = c.contextType;
    typeof l2 === "object" && l2 !== null ? l2 = vg(l2) : (l2 = Ff(c) ? Df : M.current, l2 = Ef(b, l2));
    var n2 = c.getDerivedStateFromProps, A2 = typeof n2 === "function" || typeof g.getSnapshotBeforeUpdate === "function";
    A2 || typeof g.UNSAFE_componentWillReceiveProps !== "function" && typeof g.componentWillReceiveProps !== "function" || (h !== d || k !== l2) && Ng(b, g, d, l2);
    wg = false;
    var p2 = b.memoizedState;
    g.state = p2;
    Cg(b, d, g, e);
    k = b.memoizedState;
    h !== d || p2 !== k || N.current || wg ? (typeof n2 === "function" && (Gg(b, c, n2, d), k = b.memoizedState), (h = wg || Lg(b, c, h, d, p2, k, l2)) ? (A2 || typeof g.UNSAFE_componentWillMount !== "function" && typeof g.componentWillMount !== "function" || (typeof g.componentWillMount === "function" && g.componentWillMount(), typeof g.UNSAFE_componentWillMount === "function" && g.UNSAFE_componentWillMount()), typeof g.componentDidMount === "function" && (b.flags |= 4)) : (typeof g.componentDidMount === "function" && (b.flags |= 4), b.memoizedProps = d, b.memoizedState = k), g.props = d, g.state = k, g.context = l2, d = h) : (typeof g.componentDidMount === "function" && (b.flags |= 4), d = false);
  } else {
    g = b.stateNode;
    yg(a, b);
    h = b.memoizedProps;
    l2 = b.type === b.elementType ? h : lg(b.type, h);
    g.props = l2;
    A2 = b.pendingProps;
    p2 = g.context;
    k = c.contextType;
    typeof k === "object" && k !== null ? k = vg(k) : (k = Ff(c) ? Df : M.current, k = Ef(b, k));
    var C2 = c.getDerivedStateFromProps;
    (n2 = typeof C2 === "function" || typeof g.getSnapshotBeforeUpdate === "function") || typeof g.UNSAFE_componentWillReceiveProps !== "function" && typeof g.componentWillReceiveProps !== "function" || (h !== A2 || p2 !== k) && Ng(b, g, d, k);
    wg = false;
    p2 = b.memoizedState;
    g.state = p2;
    Cg(b, d, g, e);
    var x2 = b.memoizedState;
    h !== A2 || p2 !== x2 || N.current || wg ? (typeof C2 === "function" && (Gg(b, c, C2, d), x2 = b.memoizedState), (l2 = wg || Lg(b, c, l2, d, p2, x2, k)) ? (n2 || typeof g.UNSAFE_componentWillUpdate !== "function" && typeof g.componentWillUpdate !== "function" || (typeof g.componentWillUpdate === "function" && g.componentWillUpdate(d, x2, k), typeof g.UNSAFE_componentWillUpdate === "function" && g.UNSAFE_componentWillUpdate(d, x2, k)), typeof g.componentDidUpdate === "function" && (b.flags |= 4), typeof g.getSnapshotBeforeUpdate === "function" && (b.flags |= 256)) : (typeof g.componentDidUpdate !== "function" || h === a.memoizedProps && p2 === a.memoizedState || (b.flags |= 4), typeof g.getSnapshotBeforeUpdate !== "function" || h === a.memoizedProps && p2 === a.memoizedState || (b.flags |= 256), b.memoizedProps = d, b.memoizedState = x2), g.props = d, g.state = x2, g.context = k, d = l2) : (typeof g.componentDidUpdate !== "function" || h === a.memoizedProps && p2 === a.memoizedState || (b.flags |= 4), typeof g.getSnapshotBeforeUpdate !== "function" || h === a.memoizedProps && p2 === a.memoizedState || (b.flags |= 256), d = false);
  }
  return qi(a, b, c, d, f, e);
}
function qi(a, b, c, d, e, f) {
  oi(a, b);
  var g = (b.flags & 64) !== 0;
  if (!d && !g)
    return e && Kf(b, c, false), hi(a, b, f);
  d = b.stateNode;
  ei.current = b;
  var h = g && typeof c.getDerivedStateFromError !== "function" ? null : d.render();
  b.flags |= 1;
  a !== null && g ? (b.child = Yg(b, a.child, null, f), b.child = Yg(b, null, h, f)) : fi(a, b, h, f);
  b.memoizedState = d.state;
  e && Kf(b, c, true);
  return b.child;
}
function ri(a) {
  var b = a.stateNode;
  b.pendingContext ? Hf(a, b.pendingContext, b.pendingContext !== b.context) : b.context && Hf(a, b.context, false);
  eh(a, b.containerInfo);
}
var si = { dehydrated: null, retryLane: 0 };
function ti(a, b, c) {
  var d = b.pendingProps, e = P.current, f = false, g;
  (g = (b.flags & 64) !== 0) || (g = a !== null && a.memoizedState === null ? false : (e & 2) !== 0);
  g ? (f = true, b.flags &= -65) : a !== null && a.memoizedState === null || d.fallback === void 0 || d.unstable_avoidThisFallback === true || (e |= 1);
  I(P, e & 1);
  if (a === null) {
    d.fallback !== void 0 && ph(b);
    a = d.children;
    e = d.fallback;
    if (f)
      return a = ui(b, a, e, c), b.child.memoizedState = { baseLanes: c }, b.memoizedState = si, a;
    if (typeof d.unstable_expectedLoadTime === "number")
      return a = ui(b, a, e, c), b.child.memoizedState = { baseLanes: c }, b.memoizedState = si, b.lanes = 33554432, a;
    c = vi({ mode: "visible", children: a }, b.mode, c, null);
    c.return = b;
    return b.child = c;
  }
  if (a.memoizedState !== null) {
    if (f)
      return d = wi(a, b, d.children, d.fallback, c), f = b.child, e = a.child.memoizedState, f.memoizedState = e === null ? { baseLanes: c } : { baseLanes: e.baseLanes | c }, f.childLanes = a.childLanes & ~c, b.memoizedState = si, d;
    c = xi(a, b, d.children, c);
    b.memoizedState = null;
    return c;
  }
  if (f)
    return d = wi(a, b, d.children, d.fallback, c), f = b.child, e = a.child.memoizedState, f.memoizedState = e === null ? { baseLanes: c } : { baseLanes: e.baseLanes | c }, f.childLanes = a.childLanes & ~c, b.memoizedState = si, d;
  c = xi(a, b, d.children, c);
  b.memoizedState = null;
  return c;
}
function ui(a, b, c, d) {
  var e = a.mode, f = a.child;
  b = { mode: "hidden", children: b };
  (e & 2) === 0 && f !== null ? (f.childLanes = 0, f.pendingProps = b) : f = vi(b, e, 0, null);
  c = Xg(c, e, d, null);
  f.return = a;
  c.return = a;
  f.sibling = c;
  a.child = f;
  return c;
}
function xi(a, b, c, d) {
  var e = a.child;
  a = e.sibling;
  c = Tg(e, { mode: "visible", children: c });
  (b.mode & 2) === 0 && (c.lanes = d);
  c.return = b;
  c.sibling = null;
  a !== null && (a.nextEffect = null, a.flags = 8, b.firstEffect = b.lastEffect = a);
  return b.child = c;
}
function wi(a, b, c, d, e) {
  var f = b.mode, g = a.child;
  a = g.sibling;
  var h = { mode: "hidden", children: c };
  (f & 2) === 0 && b.child !== g ? (c = b.child, c.childLanes = 0, c.pendingProps = h, g = c.lastEffect, g !== null ? (b.firstEffect = c.firstEffect, b.lastEffect = g, g.nextEffect = null) : b.firstEffect = b.lastEffect = null) : c = Tg(g, h);
  a !== null ? d = Tg(a, d) : (d = Xg(d, f, e, null), d.flags |= 2);
  d.return = b;
  c.return = b;
  c.sibling = d;
  b.child = c;
  return d;
}
function yi(a, b) {
  a.lanes |= b;
  var c = a.alternate;
  c !== null && (c.lanes |= b);
  sg(a.return, b);
}
function zi(a, b, c, d, e, f) {
  var g = a.memoizedState;
  g === null ? a.memoizedState = { isBackwards: b, rendering: null, renderingStartTime: 0, last: d, tail: c, tailMode: e, lastEffect: f } : (g.isBackwards = b, g.rendering = null, g.renderingStartTime = 0, g.last = d, g.tail = c, g.tailMode = e, g.lastEffect = f);
}
function Ai(a, b, c) {
  var d = b.pendingProps, e = d.revealOrder, f = d.tail;
  fi(a, b, d.children, c);
  d = P.current;
  if ((d & 2) !== 0)
    d = d & 1 | 2, b.flags |= 64;
  else {
    if (a !== null && (a.flags & 64) !== 0)
      a:
        for (a = b.child; a !== null; ) {
          if (a.tag === 13)
            a.memoizedState !== null && yi(a, c);
          else if (a.tag === 19)
            yi(a, c);
          else if (a.child !== null) {
            a.child.return = a;
            a = a.child;
            continue;
          }
          if (a === b)
            break a;
          for (; a.sibling === null; ) {
            if (a.return === null || a.return === b)
              break a;
            a = a.return;
          }
          a.sibling.return = a.return;
          a = a.sibling;
        }
    d &= 1;
  }
  I(P, d);
  if ((b.mode & 2) === 0)
    b.memoizedState = null;
  else
    switch (e) {
      case "forwards":
        c = b.child;
        for (e = null; c !== null; )
          a = c.alternate, a !== null && ih(a) === null && (e = c), c = c.sibling;
        c = e;
        c === null ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
        zi(b, false, e, c, f, b.lastEffect);
        break;
      case "backwards":
        c = null;
        e = b.child;
        for (b.child = null; e !== null; ) {
          a = e.alternate;
          if (a !== null && ih(a) === null) {
            b.child = e;
            break;
          }
          a = e.sibling;
          e.sibling = c;
          c = e;
          e = a;
        }
        zi(b, true, c, null, f, b.lastEffect);
        break;
      case "together":
        zi(b, false, null, null, void 0, b.lastEffect);
        break;
      default:
        b.memoizedState = null;
    }
  return b.child;
}
function hi(a, b, c) {
  a !== null && (b.dependencies = a.dependencies);
  Dg |= b.lanes;
  if ((c & b.childLanes) !== 0) {
    if (a !== null && b.child !== a.child)
      throw Error(y(153));
    if (b.child !== null) {
      a = b.child;
      c = Tg(a, a.pendingProps);
      b.child = c;
      for (c.return = b; a.sibling !== null; )
        a = a.sibling, c = c.sibling = Tg(a, a.pendingProps), c.return = b;
      c.sibling = null;
    }
    return b.child;
  }
  return null;
}
var Bi, Ci, Di, Ei;
Bi = function(a, b) {
  for (var c = b.child; c !== null; ) {
    if (c.tag === 5 || c.tag === 6)
      a.appendChild(c.stateNode);
    else if (c.tag !== 4 && c.child !== null) {
      c.child.return = c;
      c = c.child;
      continue;
    }
    if (c === b)
      break;
    for (; c.sibling === null; ) {
      if (c.return === null || c.return === b)
        return;
      c = c.return;
    }
    c.sibling.return = c.return;
    c = c.sibling;
  }
};
Ci = function() {
};
Di = function(a, b, c, d) {
  var e = a.memoizedProps;
  if (e !== d) {
    a = b.stateNode;
    dh(ah.current);
    var f = null;
    switch (c) {
      case "input":
        e = Ya(a, e);
        d = Ya(a, d);
        f = [];
        break;
      case "option":
        e = eb(a, e);
        d = eb(a, d);
        f = [];
        break;
      case "select":
        e = m({}, e, { value: void 0 });
        d = m({}, d, { value: void 0 });
        f = [];
        break;
      case "textarea":
        e = gb(a, e);
        d = gb(a, d);
        f = [];
        break;
      default:
        typeof e.onClick !== "function" && typeof d.onClick === "function" && (a.onclick = jf);
    }
    vb(c, d);
    var g;
    c = null;
    for (l2 in e)
      if (!d.hasOwnProperty(l2) && e.hasOwnProperty(l2) && e[l2] != null)
        if (l2 === "style") {
          var h = e[l2];
          for (g in h)
            h.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
        } else
          l2 !== "dangerouslySetInnerHTML" && l2 !== "children" && l2 !== "suppressContentEditableWarning" && l2 !== "suppressHydrationWarning" && l2 !== "autoFocus" && (ca.hasOwnProperty(l2) ? f || (f = []) : (f = f || []).push(l2, null));
    for (l2 in d) {
      var k = d[l2];
      h = e != null ? e[l2] : void 0;
      if (d.hasOwnProperty(l2) && k !== h && (k != null || h != null))
        if (l2 === "style")
          if (h) {
            for (g in h)
              !h.hasOwnProperty(g) || k && k.hasOwnProperty(g) || (c || (c = {}), c[g] = "");
            for (g in k)
              k.hasOwnProperty(g) && h[g] !== k[g] && (c || (c = {}), c[g] = k[g]);
          } else
            c || (f || (f = []), f.push(l2, c)), c = k;
        else
          l2 === "dangerouslySetInnerHTML" ? (k = k ? k.__html : void 0, h = h ? h.__html : void 0, k != null && h !== k && (f = f || []).push(l2, k)) : l2 === "children" ? typeof k !== "string" && typeof k !== "number" || (f = f || []).push(l2, "" + k) : l2 !== "suppressContentEditableWarning" && l2 !== "suppressHydrationWarning" && (ca.hasOwnProperty(l2) ? (k != null && l2 === "onScroll" && G("scroll", a), f || h === k || (f = [])) : typeof k === "object" && k !== null && k.$$typeof === Ga ? k.toString() : (f = f || []).push(l2, k));
    }
    c && (f = f || []).push("style", c);
    var l2 = f;
    if (b.updateQueue = l2)
      b.flags |= 4;
  }
};
Ei = function(a, b, c, d) {
  c !== d && (b.flags |= 4);
};
function Fi(a, b) {
  if (!lh)
    switch (a.tailMode) {
      case "hidden":
        b = a.tail;
        for (var c = null; b !== null; )
          b.alternate !== null && (c = b), b = b.sibling;
        c === null ? a.tail = null : c.sibling = null;
        break;
      case "collapsed":
        c = a.tail;
        for (var d = null; c !== null; )
          c.alternate !== null && (d = c), c = c.sibling;
        d === null ? b || a.tail === null ? a.tail = null : a.tail.sibling = null : d.sibling = null;
    }
}
function Gi(a, b, c) {
  var d = b.pendingProps;
  switch (b.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return null;
    case 1:
      return Ff(b.type) && Gf(), null;
    case 3:
      fh();
      H(N);
      H(M);
      uh();
      d = b.stateNode;
      d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
      if (a === null || a.child === null)
        rh(b) ? b.flags |= 4 : d.hydrate || (b.flags |= 256);
      Ci(b);
      return null;
    case 5:
      hh(b);
      var e = dh(ch.current);
      c = b.type;
      if (a !== null && b.stateNode != null)
        Di(a, b, c, d, e), a.ref !== b.ref && (b.flags |= 128);
      else {
        if (!d) {
          if (b.stateNode === null)
            throw Error(y(166));
          return null;
        }
        a = dh(ah.current);
        if (rh(b)) {
          d = b.stateNode;
          c = b.type;
          var f = b.memoizedProps;
          d[wf] = b;
          d[xf] = f;
          switch (c) {
            case "dialog":
              G("cancel", d);
              G("close", d);
              break;
            case "iframe":
            case "object":
            case "embed":
              G("load", d);
              break;
            case "video":
            case "audio":
              for (a = 0; a < Xe.length; a++)
                G(Xe[a], d);
              break;
            case "source":
              G("error", d);
              break;
            case "img":
            case "image":
            case "link":
              G("error", d);
              G("load", d);
              break;
            case "details":
              G("toggle", d);
              break;
            case "input":
              Za(d, f);
              G("invalid", d);
              break;
            case "select":
              d._wrapperState = { wasMultiple: !!f.multiple };
              G("invalid", d);
              break;
            case "textarea":
              hb(d, f), G("invalid", d);
          }
          vb(c, f);
          a = null;
          for (var g in f)
            f.hasOwnProperty(g) && (e = f[g], g === "children" ? typeof e === "string" ? d.textContent !== e && (a = ["children", e]) : typeof e === "number" && d.textContent !== "" + e && (a = ["children", "" + e]) : ca.hasOwnProperty(g) && e != null && g === "onScroll" && G("scroll", d));
          switch (c) {
            case "input":
              Va(d);
              cb(d, f, true);
              break;
            case "textarea":
              Va(d);
              jb(d);
              break;
            case "select":
            case "option":
              break;
            default:
              typeof f.onClick === "function" && (d.onclick = jf);
          }
          d = a;
          b.updateQueue = d;
          d !== null && (b.flags |= 4);
        } else {
          g = e.nodeType === 9 ? e : e.ownerDocument;
          a === kb.html && (a = lb(c));
          a === kb.html ? c === "script" ? (a = g.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : typeof d.is === "string" ? a = g.createElement(c, { is: d.is }) : (a = g.createElement(c), c === "select" && (g = a, d.multiple ? g.multiple = true : d.size && (g.size = d.size))) : a = g.createElementNS(a, c);
          a[wf] = b;
          a[xf] = d;
          Bi(a, b, false, false);
          b.stateNode = a;
          g = wb(c, d);
          switch (c) {
            case "dialog":
              G("cancel", a);
              G("close", a);
              e = d;
              break;
            case "iframe":
            case "object":
            case "embed":
              G("load", a);
              e = d;
              break;
            case "video":
            case "audio":
              for (e = 0; e < Xe.length; e++)
                G(Xe[e], a);
              e = d;
              break;
            case "source":
              G("error", a);
              e = d;
              break;
            case "img":
            case "image":
            case "link":
              G("error", a);
              G("load", a);
              e = d;
              break;
            case "details":
              G("toggle", a);
              e = d;
              break;
            case "input":
              Za(a, d);
              e = Ya(a, d);
              G("invalid", a);
              break;
            case "option":
              e = eb(a, d);
              break;
            case "select":
              a._wrapperState = { wasMultiple: !!d.multiple };
              e = m({}, d, { value: void 0 });
              G("invalid", a);
              break;
            case "textarea":
              hb(a, d);
              e = gb(a, d);
              G("invalid", a);
              break;
            default:
              e = d;
          }
          vb(c, e);
          var h = e;
          for (f in h)
            if (h.hasOwnProperty(f)) {
              var k = h[f];
              f === "style" ? tb(a, k) : f === "dangerouslySetInnerHTML" ? (k = k ? k.__html : void 0, k != null && ob(a, k)) : f === "children" ? typeof k === "string" ? (c !== "textarea" || k !== "") && pb(a, k) : typeof k === "number" && pb(a, "" + k) : f !== "suppressContentEditableWarning" && f !== "suppressHydrationWarning" && f !== "autoFocus" && (ca.hasOwnProperty(f) ? k != null && f === "onScroll" && G("scroll", a) : k != null && qa(a, f, k, g));
            }
          switch (c) {
            case "input":
              Va(a);
              cb(a, d, false);
              break;
            case "textarea":
              Va(a);
              jb(a);
              break;
            case "option":
              d.value != null && a.setAttribute("value", "" + Sa(d.value));
              break;
            case "select":
              a.multiple = !!d.multiple;
              f = d.value;
              f != null ? fb(a, !!d.multiple, f, false) : d.defaultValue != null && fb(a, !!d.multiple, d.defaultValue, true);
              break;
            default:
              typeof e.onClick === "function" && (a.onclick = jf);
          }
          mf(c, d) && (b.flags |= 4);
        }
        b.ref !== null && (b.flags |= 128);
      }
      return null;
    case 6:
      if (a && b.stateNode != null)
        Ei(a, b, a.memoizedProps, d);
      else {
        if (typeof d !== "string" && b.stateNode === null)
          throw Error(y(166));
        c = dh(ch.current);
        dh(ah.current);
        rh(b) ? (d = b.stateNode, c = b.memoizedProps, d[wf] = b, d.nodeValue !== c && (b.flags |= 4)) : (d = (c.nodeType === 9 ? c : c.ownerDocument).createTextNode(d), d[wf] = b, b.stateNode = d);
      }
      return null;
    case 13:
      H(P);
      d = b.memoizedState;
      if ((b.flags & 64) !== 0)
        return b.lanes = c, b;
      d = d !== null;
      c = false;
      a === null ? b.memoizedProps.fallback !== void 0 && rh(b) : c = a.memoizedState !== null;
      if (d && !c && (b.mode & 2) !== 0)
        if (a === null && b.memoizedProps.unstable_avoidThisFallback !== true || (P.current & 1) !== 0)
          V === 0 && (V = 3);
        else {
          if (V === 0 || V === 3)
            V = 4;
          U === null || (Dg & 134217727) === 0 && (Hi & 134217727) === 0 || Ii(U, W);
        }
      if (d || c)
        b.flags |= 4;
      return null;
    case 4:
      return fh(), Ci(b), a === null && cf(b.stateNode.containerInfo), null;
    case 10:
      return rg(b), null;
    case 17:
      return Ff(b.type) && Gf(), null;
    case 19:
      H(P);
      d = b.memoizedState;
      if (d === null)
        return null;
      f = (b.flags & 64) !== 0;
      g = d.rendering;
      if (g === null)
        if (f)
          Fi(d, false);
        else {
          if (V !== 0 || a !== null && (a.flags & 64) !== 0)
            for (a = b.child; a !== null; ) {
              g = ih(a);
              if (g !== null) {
                b.flags |= 64;
                Fi(d, false);
                f = g.updateQueue;
                f !== null && (b.updateQueue = f, b.flags |= 4);
                d.lastEffect === null && (b.firstEffect = null);
                b.lastEffect = d.lastEffect;
                d = c;
                for (c = b.child; c !== null; )
                  f = c, a = d, f.flags &= 2, f.nextEffect = null, f.firstEffect = null, f.lastEffect = null, g = f.alternate, g === null ? (f.childLanes = 0, f.lanes = a, f.child = null, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null, f.stateNode = null) : (f.childLanes = g.childLanes, f.lanes = g.lanes, f.child = g.child, f.memoizedProps = g.memoizedProps, f.memoizedState = g.memoizedState, f.updateQueue = g.updateQueue, f.type = g.type, a = g.dependencies, f.dependencies = a === null ? null : { lanes: a.lanes, firstContext: a.firstContext }), c = c.sibling;
                I(P, P.current & 1 | 2);
                return b.child;
              }
              a = a.sibling;
            }
          d.tail !== null && O() > Ji && (b.flags |= 64, f = true, Fi(d, false), b.lanes = 33554432);
        }
      else {
        if (!f)
          if (a = ih(g), a !== null) {
            if (b.flags |= 64, f = true, c = a.updateQueue, c !== null && (b.updateQueue = c, b.flags |= 4), Fi(d, true), d.tail === null && d.tailMode === "hidden" && !g.alternate && !lh)
              return b = b.lastEffect = d.lastEffect, b !== null && (b.nextEffect = null), null;
          } else
            2 * O() - d.renderingStartTime > Ji && c !== 1073741824 && (b.flags |= 64, f = true, Fi(d, false), b.lanes = 33554432);
        d.isBackwards ? (g.sibling = b.child, b.child = g) : (c = d.last, c !== null ? c.sibling = g : b.child = g, d.last = g);
      }
      return d.tail !== null ? (c = d.tail, d.rendering = c, d.tail = c.sibling, d.lastEffect = b.lastEffect, d.renderingStartTime = O(), c.sibling = null, b = P.current, I(P, f ? b & 1 | 2 : b & 1), c) : null;
    case 23:
    case 24:
      return Ki(), a !== null && a.memoizedState !== null !== (b.memoizedState !== null) && d.mode !== "unstable-defer-without-hiding" && (b.flags |= 4), null;
  }
  throw Error(y(156, b.tag));
}
function Li(a) {
  switch (a.tag) {
    case 1:
      Ff(a.type) && Gf();
      var b = a.flags;
      return b & 4096 ? (a.flags = b & -4097 | 64, a) : null;
    case 3:
      fh();
      H(N);
      H(M);
      uh();
      b = a.flags;
      if ((b & 64) !== 0)
        throw Error(y(285));
      a.flags = b & -4097 | 64;
      return a;
    case 5:
      return hh(a), null;
    case 13:
      return H(P), b = a.flags, b & 4096 ? (a.flags = b & -4097 | 64, a) : null;
    case 19:
      return H(P), null;
    case 4:
      return fh(), null;
    case 10:
      return rg(a), null;
    case 23:
    case 24:
      return Ki(), null;
    default:
      return null;
  }
}
function Mi(a, b) {
  try {
    var c = "", d = b;
    do
      c += Qa(d), d = d.return;
    while (d);
    var e = c;
  } catch (f) {
    e = "\nError generating stack: " + f.message + "\n" + f.stack;
  }
  return { value: a, source: b, stack: e };
}
function Ni(a, b) {
  try {
    console.error(b.value);
  } catch (c) {
    setTimeout(function() {
      throw c;
    });
  }
}
var Oi = typeof WeakMap === "function" ? WeakMap : Map;
function Pi(a, b, c) {
  c = zg(-1, c);
  c.tag = 3;
  c.payload = { element: null };
  var d = b.value;
  c.callback = function() {
    Qi || (Qi = true, Ri = d);
    Ni(a, b);
  };
  return c;
}
function Si(a, b, c) {
  c = zg(-1, c);
  c.tag = 3;
  var d = a.type.getDerivedStateFromError;
  if (typeof d === "function") {
    var e = b.value;
    c.payload = function() {
      Ni(a, b);
      return d(e);
    };
  }
  var f = a.stateNode;
  f !== null && typeof f.componentDidCatch === "function" && (c.callback = function() {
    typeof d !== "function" && (Ti === null ? Ti = /* @__PURE__ */ new Set([this]) : Ti.add(this), Ni(a, b));
    var c2 = b.stack;
    this.componentDidCatch(b.value, { componentStack: c2 !== null ? c2 : "" });
  });
  return c;
}
var Ui = typeof WeakSet === "function" ? WeakSet : Set;
function Vi(a) {
  var b = a.ref;
  if (b !== null)
    if (typeof b === "function")
      try {
        b(null);
      } catch (c) {
        Wi(a, c);
      }
    else
      b.current = null;
}
function Xi(a, b) {
  switch (b.tag) {
    case 0:
    case 11:
    case 15:
    case 22:
      return;
    case 1:
      if (b.flags & 256 && a !== null) {
        var c = a.memoizedProps, d = a.memoizedState;
        a = b.stateNode;
        b = a.getSnapshotBeforeUpdate(b.elementType === b.type ? c : lg(b.type, c), d);
        a.__reactInternalSnapshotBeforeUpdate = b;
      }
      return;
    case 3:
      b.flags & 256 && qf(b.stateNode.containerInfo);
      return;
    case 5:
    case 6:
    case 4:
    case 17:
      return;
  }
  throw Error(y(163));
}
function Yi(a, b, c) {
  switch (c.tag) {
    case 0:
    case 11:
    case 15:
    case 22:
      b = c.updateQueue;
      b = b !== null ? b.lastEffect : null;
      if (b !== null) {
        a = b = b.next;
        do {
          if ((a.tag & 3) === 3) {
            var d = a.create;
            a.destroy = d();
          }
          a = a.next;
        } while (a !== b);
      }
      b = c.updateQueue;
      b = b !== null ? b.lastEffect : null;
      if (b !== null) {
        a = b = b.next;
        do {
          var e = a;
          d = e.next;
          e = e.tag;
          (e & 4) !== 0 && (e & 1) !== 0 && (Zi(c, a), $i(c, a));
          a = d;
        } while (a !== b);
      }
      return;
    case 1:
      a = c.stateNode;
      c.flags & 4 && (b === null ? a.componentDidMount() : (d = c.elementType === c.type ? b.memoizedProps : lg(c.type, b.memoizedProps), a.componentDidUpdate(d, b.memoizedState, a.__reactInternalSnapshotBeforeUpdate)));
      b = c.updateQueue;
      b !== null && Eg(c, b, a);
      return;
    case 3:
      b = c.updateQueue;
      if (b !== null) {
        a = null;
        if (c.child !== null)
          switch (c.child.tag) {
            case 5:
              a = c.child.stateNode;
              break;
            case 1:
              a = c.child.stateNode;
          }
        Eg(c, b, a);
      }
      return;
    case 5:
      a = c.stateNode;
      b === null && c.flags & 4 && mf(c.type, c.memoizedProps) && a.focus();
      return;
    case 6:
      return;
    case 4:
      return;
    case 12:
      return;
    case 13:
      c.memoizedState === null && (c = c.alternate, c !== null && (c = c.memoizedState, c !== null && (c = c.dehydrated, c !== null && Cc(c))));
      return;
    case 19:
    case 17:
    case 20:
    case 21:
    case 23:
    case 24:
      return;
  }
  throw Error(y(163));
}
function aj(a, b) {
  for (var c = a; ; ) {
    if (c.tag === 5) {
      var d = c.stateNode;
      if (b)
        d = d.style, typeof d.setProperty === "function" ? d.setProperty("display", "none", "important") : d.display = "none";
      else {
        d = c.stateNode;
        var e = c.memoizedProps.style;
        e = e !== void 0 && e !== null && e.hasOwnProperty("display") ? e.display : null;
        d.style.display = sb("display", e);
      }
    } else if (c.tag === 6)
      c.stateNode.nodeValue = b ? "" : c.memoizedProps;
    else if ((c.tag !== 23 && c.tag !== 24 || c.memoizedState === null || c === a) && c.child !== null) {
      c.child.return = c;
      c = c.child;
      continue;
    }
    if (c === a)
      break;
    for (; c.sibling === null; ) {
      if (c.return === null || c.return === a)
        return;
      c = c.return;
    }
    c.sibling.return = c.return;
    c = c.sibling;
  }
}
function bj(a, b) {
  if (Mf && typeof Mf.onCommitFiberUnmount === "function")
    try {
      Mf.onCommitFiberUnmount(Lf, b);
    } catch (f) {
    }
  switch (b.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
    case 22:
      a = b.updateQueue;
      if (a !== null && (a = a.lastEffect, a !== null)) {
        var c = a = a.next;
        do {
          var d = c, e = d.destroy;
          d = d.tag;
          if (e !== void 0)
            if ((d & 4) !== 0)
              Zi(b, c);
            else {
              d = b;
              try {
                e();
              } catch (f) {
                Wi(d, f);
              }
            }
          c = c.next;
        } while (c !== a);
      }
      break;
    case 1:
      Vi(b);
      a = b.stateNode;
      if (typeof a.componentWillUnmount === "function")
        try {
          a.props = b.memoizedProps, a.state = b.memoizedState, a.componentWillUnmount();
        } catch (f) {
          Wi(b, f);
        }
      break;
    case 5:
      Vi(b);
      break;
    case 4:
      cj(a, b);
  }
}
function dj(a) {
  a.alternate = null;
  a.child = null;
  a.dependencies = null;
  a.firstEffect = null;
  a.lastEffect = null;
  a.memoizedProps = null;
  a.memoizedState = null;
  a.pendingProps = null;
  a.return = null;
  a.updateQueue = null;
}
function ej(a) {
  return a.tag === 5 || a.tag === 3 || a.tag === 4;
}
function fj(a) {
  a: {
    for (var b = a.return; b !== null; ) {
      if (ej(b))
        break a;
      b = b.return;
    }
    throw Error(y(160));
  }
  var c = b;
  b = c.stateNode;
  switch (c.tag) {
    case 5:
      var d = false;
      break;
    case 3:
      b = b.containerInfo;
      d = true;
      break;
    case 4:
      b = b.containerInfo;
      d = true;
      break;
    default:
      throw Error(y(161));
  }
  c.flags & 16 && (pb(b, ""), c.flags &= -17);
  a:
    b:
      for (c = a; ; ) {
        for (; c.sibling === null; ) {
          if (c.return === null || ej(c.return)) {
            c = null;
            break a;
          }
          c = c.return;
        }
        c.sibling.return = c.return;
        for (c = c.sibling; c.tag !== 5 && c.tag !== 6 && c.tag !== 18; ) {
          if (c.flags & 2)
            continue b;
          if (c.child === null || c.tag === 4)
            continue b;
          else
            c.child.return = c, c = c.child;
        }
        if (!(c.flags & 2)) {
          c = c.stateNode;
          break a;
        }
      }
  d ? gj(a, c, b) : hj(a, c, b);
}
function gj(a, b, c) {
  var d = a.tag, e = d === 5 || d === 6;
  if (e)
    a = e ? a.stateNode : a.stateNode.instance, b ? c.nodeType === 8 ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (c.nodeType === 8 ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, c !== null && c !== void 0 || b.onclick !== null || (b.onclick = jf));
  else if (d !== 4 && (a = a.child, a !== null))
    for (gj(a, b, c), a = a.sibling; a !== null; )
      gj(a, b, c), a = a.sibling;
}
function hj(a, b, c) {
  var d = a.tag, e = d === 5 || d === 6;
  if (e)
    a = e ? a.stateNode : a.stateNode.instance, b ? c.insertBefore(a, b) : c.appendChild(a);
  else if (d !== 4 && (a = a.child, a !== null))
    for (hj(a, b, c), a = a.sibling; a !== null; )
      hj(a, b, c), a = a.sibling;
}
function cj(a, b) {
  for (var c = b, d = false, e, f; ; ) {
    if (!d) {
      d = c.return;
      a:
        for (; ; ) {
          if (d === null)
            throw Error(y(160));
          e = d.stateNode;
          switch (d.tag) {
            case 5:
              f = false;
              break a;
            case 3:
              e = e.containerInfo;
              f = true;
              break a;
            case 4:
              e = e.containerInfo;
              f = true;
              break a;
          }
          d = d.return;
        }
      d = true;
    }
    if (c.tag === 5 || c.tag === 6) {
      a:
        for (var g = a, h = c, k = h; ; )
          if (bj(g, k), k.child !== null && k.tag !== 4)
            k.child.return = k, k = k.child;
          else {
            if (k === h)
              break a;
            for (; k.sibling === null; ) {
              if (k.return === null || k.return === h)
                break a;
              k = k.return;
            }
            k.sibling.return = k.return;
            k = k.sibling;
          }
      f ? (g = e, h = c.stateNode, g.nodeType === 8 ? g.parentNode.removeChild(h) : g.removeChild(h)) : e.removeChild(c.stateNode);
    } else if (c.tag === 4) {
      if (c.child !== null) {
        e = c.stateNode.containerInfo;
        f = true;
        c.child.return = c;
        c = c.child;
        continue;
      }
    } else if (bj(a, c), c.child !== null) {
      c.child.return = c;
      c = c.child;
      continue;
    }
    if (c === b)
      break;
    for (; c.sibling === null; ) {
      if (c.return === null || c.return === b)
        return;
      c = c.return;
      c.tag === 4 && (d = false);
    }
    c.sibling.return = c.return;
    c = c.sibling;
  }
}
function ij(a, b) {
  switch (b.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
    case 22:
      var c = b.updateQueue;
      c = c !== null ? c.lastEffect : null;
      if (c !== null) {
        var d = c = c.next;
        do
          (d.tag & 3) === 3 && (a = d.destroy, d.destroy = void 0, a !== void 0 && a()), d = d.next;
        while (d !== c);
      }
      return;
    case 1:
      return;
    case 5:
      c = b.stateNode;
      if (c != null) {
        d = b.memoizedProps;
        var e = a !== null ? a.memoizedProps : d;
        a = b.type;
        var f = b.updateQueue;
        b.updateQueue = null;
        if (f !== null) {
          c[xf] = d;
          a === "input" && d.type === "radio" && d.name != null && $a(c, d);
          wb(a, e);
          b = wb(a, d);
          for (e = 0; e < f.length; e += 2) {
            var g = f[e], h = f[e + 1];
            g === "style" ? tb(c, h) : g === "dangerouslySetInnerHTML" ? ob(c, h) : g === "children" ? pb(c, h) : qa(c, g, h, b);
          }
          switch (a) {
            case "input":
              ab(c, d);
              break;
            case "textarea":
              ib(c, d);
              break;
            case "select":
              a = c._wrapperState.wasMultiple, c._wrapperState.wasMultiple = !!d.multiple, f = d.value, f != null ? fb(c, !!d.multiple, f, false) : a !== !!d.multiple && (d.defaultValue != null ? fb(c, !!d.multiple, d.defaultValue, true) : fb(c, !!d.multiple, d.multiple ? [] : "", false));
          }
        }
      }
      return;
    case 6:
      if (b.stateNode === null)
        throw Error(y(162));
      b.stateNode.nodeValue = b.memoizedProps;
      return;
    case 3:
      c = b.stateNode;
      c.hydrate && (c.hydrate = false, Cc(c.containerInfo));
      return;
    case 12:
      return;
    case 13:
      b.memoizedState !== null && (jj = O(), aj(b.child, true));
      kj(b);
      return;
    case 19:
      kj(b);
      return;
    case 17:
      return;
    case 23:
    case 24:
      aj(b, b.memoizedState !== null);
      return;
  }
  throw Error(y(163));
}
function kj(a) {
  var b = a.updateQueue;
  if (b !== null) {
    a.updateQueue = null;
    var c = a.stateNode;
    c === null && (c = a.stateNode = new Ui());
    b.forEach(function(b2) {
      var d = lj.bind(null, a, b2);
      c.has(b2) || (c.add(b2), b2.then(d, d));
    });
  }
}
function mj(a, b) {
  return a !== null && (a = a.memoizedState, a === null || a.dehydrated !== null) ? (b = b.memoizedState, b !== null && b.dehydrated === null) : false;
}
var nj = Math.ceil, oj = ra.ReactCurrentDispatcher, pj = ra.ReactCurrentOwner, X = 0, U = null, Y = null, W = 0, qj = 0, rj = Bf(0), V = 0, sj = null, tj = 0, Dg = 0, Hi = 0, uj = 0, vj = null, jj = 0, Ji = Infinity;
function wj() {
  Ji = O() + 500;
}
var Z = null, Qi = false, Ri = null, Ti = null, xj = false, yj = null, zj = 90, Aj = [], Bj = [], Cj = null, Dj = 0, Ej = null, Fj = -1, Gj = 0, Hj = 0, Ij = null, Jj = false;
function Hg() {
  return (X & 48) !== 0 ? O() : Fj !== -1 ? Fj : Fj = O();
}
function Ig(a) {
  a = a.mode;
  if ((a & 2) === 0)
    return 1;
  if ((a & 4) === 0)
    return eg() === 99 ? 1 : 2;
  Gj === 0 && (Gj = tj);
  if (kg.transition !== 0) {
    Hj !== 0 && (Hj = vj !== null ? vj.pendingLanes : 0);
    a = Gj;
    var b = 4186112 & ~Hj;
    b &= -b;
    b === 0 && (a = 4186112 & ~a, b = a & -a, b === 0 && (b = 8192));
    return b;
  }
  a = eg();
  (X & 4) !== 0 && a === 98 ? a = Xc(12, Gj) : (a = Sc(a), a = Xc(a, Gj));
  return a;
}
function Jg(a, b, c) {
  if (50 < Dj)
    throw Dj = 0, Ej = null, Error(y(185));
  a = Kj(a, b);
  if (a === null)
    return null;
  $c(a, b, c);
  a === U && (Hi |= b, V === 4 && Ii(a, W));
  var d = eg();
  b === 1 ? (X & 8) !== 0 && (X & 48) === 0 ? Lj(a) : (Mj(a, c), X === 0 && (wj(), ig())) : ((X & 4) === 0 || d !== 98 && d !== 99 || (Cj === null ? Cj = /* @__PURE__ */ new Set([a]) : Cj.add(a)), Mj(a, c));
  vj = a;
}
function Kj(a, b) {
  a.lanes |= b;
  var c = a.alternate;
  c !== null && (c.lanes |= b);
  c = a;
  for (a = a.return; a !== null; )
    a.childLanes |= b, c = a.alternate, c !== null && (c.childLanes |= b), c = a, a = a.return;
  return c.tag === 3 ? c.stateNode : null;
}
function Mj(a, b) {
  for (var c = a.callbackNode, d = a.suspendedLanes, e = a.pingedLanes, f = a.expirationTimes, g = a.pendingLanes; 0 < g; ) {
    var h = 31 - Vc(g), k = 1 << h, l2 = f[h];
    if (l2 === -1) {
      if ((k & d) === 0 || (k & e) !== 0) {
        l2 = b;
        Rc(k);
        var n2 = F;
        f[h] = 10 <= n2 ? l2 + 250 : 6 <= n2 ? l2 + 5e3 : -1;
      }
    } else
      l2 <= b && (a.expiredLanes |= k);
    g &= ~k;
  }
  d = Uc(a, a === U ? W : 0);
  b = F;
  if (d === 0)
    c !== null && (c !== Zf && Pf(c), a.callbackNode = null, a.callbackPriority = 0);
  else {
    if (c !== null) {
      if (a.callbackPriority === b)
        return;
      c !== Zf && Pf(c);
    }
    b === 15 ? (c = Lj.bind(null, a), ag === null ? (ag = [c], bg = Of(Uf, jg)) : ag.push(c), c = Zf) : b === 14 ? c = hg(99, Lj.bind(null, a)) : (c = Tc(b), c = hg(c, Nj.bind(null, a)));
    a.callbackPriority = b;
    a.callbackNode = c;
  }
}
function Nj(a) {
  Fj = -1;
  Hj = Gj = 0;
  if ((X & 48) !== 0)
    throw Error(y(327));
  var b = a.callbackNode;
  if (Oj() && a.callbackNode !== b)
    return null;
  var c = Uc(a, a === U ? W : 0);
  if (c === 0)
    return null;
  var d = c;
  var e = X;
  X |= 16;
  var f = Pj();
  if (U !== a || W !== d)
    wj(), Qj(a, d);
  do
    try {
      Rj();
      break;
    } catch (h) {
      Sj(a, h);
    }
  while (1);
  qg();
  oj.current = f;
  X = e;
  Y !== null ? d = 0 : (U = null, W = 0, d = V);
  if ((tj & Hi) !== 0)
    Qj(a, 0);
  else if (d !== 0) {
    d === 2 && (X |= 64, a.hydrate && (a.hydrate = false, qf(a.containerInfo)), c = Wc(a), c !== 0 && (d = Tj(a, c)));
    if (d === 1)
      throw b = sj, Qj(a, 0), Ii(a, c), Mj(a, O()), b;
    a.finishedWork = a.current.alternate;
    a.finishedLanes = c;
    switch (d) {
      case 0:
      case 1:
        throw Error(y(345));
      case 2:
        Uj(a);
        break;
      case 3:
        Ii(a, c);
        if ((c & 62914560) === c && (d = jj + 500 - O(), 10 < d)) {
          if (Uc(a, 0) !== 0)
            break;
          e = a.suspendedLanes;
          if ((e & c) !== c) {
            Hg();
            a.pingedLanes |= a.suspendedLanes & e;
            break;
          }
          a.timeoutHandle = of(Uj.bind(null, a), d);
          break;
        }
        Uj(a);
        break;
      case 4:
        Ii(a, c);
        if ((c & 4186112) === c)
          break;
        d = a.eventTimes;
        for (e = -1; 0 < c; ) {
          var g = 31 - Vc(c);
          f = 1 << g;
          g = d[g];
          g > e && (e = g);
          c &= ~f;
        }
        c = e;
        c = O() - c;
        c = (120 > c ? 120 : 480 > c ? 480 : 1080 > c ? 1080 : 1920 > c ? 1920 : 3e3 > c ? 3e3 : 4320 > c ? 4320 : 1960 * nj(c / 1960)) - c;
        if (10 < c) {
          a.timeoutHandle = of(Uj.bind(null, a), c);
          break;
        }
        Uj(a);
        break;
      case 5:
        Uj(a);
        break;
      default:
        throw Error(y(329));
    }
  }
  Mj(a, O());
  return a.callbackNode === b ? Nj.bind(null, a) : null;
}
function Ii(a, b) {
  b &= ~uj;
  b &= ~Hi;
  a.suspendedLanes |= b;
  a.pingedLanes &= ~b;
  for (a = a.expirationTimes; 0 < b; ) {
    var c = 31 - Vc(b), d = 1 << c;
    a[c] = -1;
    b &= ~d;
  }
}
function Lj(a) {
  if ((X & 48) !== 0)
    throw Error(y(327));
  Oj();
  if (a === U && (a.expiredLanes & W) !== 0) {
    var b = W;
    var c = Tj(a, b);
    (tj & Hi) !== 0 && (b = Uc(a, b), c = Tj(a, b));
  } else
    b = Uc(a, 0), c = Tj(a, b);
  a.tag !== 0 && c === 2 && (X |= 64, a.hydrate && (a.hydrate = false, qf(a.containerInfo)), b = Wc(a), b !== 0 && (c = Tj(a, b)));
  if (c === 1)
    throw c = sj, Qj(a, 0), Ii(a, b), Mj(a, O()), c;
  a.finishedWork = a.current.alternate;
  a.finishedLanes = b;
  Uj(a);
  Mj(a, O());
  return null;
}
function Vj() {
  if (Cj !== null) {
    var a = Cj;
    Cj = null;
    a.forEach(function(a2) {
      a2.expiredLanes |= 24 & a2.pendingLanes;
      Mj(a2, O());
    });
  }
  ig();
}
function Wj(a, b) {
  var c = X;
  X |= 1;
  try {
    return a(b);
  } finally {
    X = c, X === 0 && (wj(), ig());
  }
}
function Xj(a, b) {
  var c = X;
  X &= -2;
  X |= 8;
  try {
    return a(b);
  } finally {
    X = c, X === 0 && (wj(), ig());
  }
}
function ni(a, b) {
  I(rj, qj);
  qj |= b;
  tj |= b;
}
function Ki() {
  qj = rj.current;
  H(rj);
}
function Qj(a, b) {
  a.finishedWork = null;
  a.finishedLanes = 0;
  var c = a.timeoutHandle;
  c !== -1 && (a.timeoutHandle = -1, pf(c));
  if (Y !== null)
    for (c = Y.return; c !== null; ) {
      var d = c;
      switch (d.tag) {
        case 1:
          d = d.type.childContextTypes;
          d !== null && d !== void 0 && Gf();
          break;
        case 3:
          fh();
          H(N);
          H(M);
          uh();
          break;
        case 5:
          hh(d);
          break;
        case 4:
          fh();
          break;
        case 13:
          H(P);
          break;
        case 19:
          H(P);
          break;
        case 10:
          rg(d);
          break;
        case 23:
        case 24:
          Ki();
      }
      c = c.return;
    }
  U = a;
  Y = Tg(a.current, null);
  W = qj = tj = b;
  V = 0;
  sj = null;
  uj = Hi = Dg = 0;
}
function Sj(a, b) {
  do {
    var c = Y;
    try {
      qg();
      vh.current = Gh;
      if (yh) {
        for (var d = R.memoizedState; d !== null; ) {
          var e = d.queue;
          e !== null && (e.pending = null);
          d = d.next;
        }
        yh = false;
      }
      xh = 0;
      T = S = R = null;
      zh = false;
      pj.current = null;
      if (c === null || c.return === null) {
        V = 1;
        sj = b;
        Y = null;
        break;
      }
      a: {
        var f = a, g = c.return, h = c, k = b;
        b = W;
        h.flags |= 2048;
        h.firstEffect = h.lastEffect = null;
        if (k !== null && typeof k === "object" && typeof k.then === "function") {
          var l2 = k;
          if ((h.mode & 2) === 0) {
            var n2 = h.alternate;
            n2 ? (h.updateQueue = n2.updateQueue, h.memoizedState = n2.memoizedState, h.lanes = n2.lanes) : (h.updateQueue = null, h.memoizedState = null);
          }
          var A2 = (P.current & 1) !== 0, p2 = g;
          do {
            var C2;
            if (C2 = p2.tag === 13) {
              var x2 = p2.memoizedState;
              if (x2 !== null)
                C2 = x2.dehydrated !== null ? true : false;
              else {
                var w = p2.memoizedProps;
                C2 = w.fallback === void 0 ? false : w.unstable_avoidThisFallback !== true ? true : A2 ? false : true;
              }
            }
            if (C2) {
              var z2 = p2.updateQueue;
              if (z2 === null) {
                var u2 = /* @__PURE__ */ new Set();
                u2.add(l2);
                p2.updateQueue = u2;
              } else
                z2.add(l2);
              if ((p2.mode & 2) === 0) {
                p2.flags |= 64;
                h.flags |= 16384;
                h.flags &= -2981;
                if (h.tag === 1)
                  if (h.alternate === null)
                    h.tag = 17;
                  else {
                    var t2 = zg(-1, 1);
                    t2.tag = 2;
                    Ag(h, t2);
                  }
                h.lanes |= 1;
                break a;
              }
              k = void 0;
              h = b;
              var q2 = f.pingCache;
              q2 === null ? (q2 = f.pingCache = new Oi(), k = /* @__PURE__ */ new Set(), q2.set(l2, k)) : (k = q2.get(l2), k === void 0 && (k = /* @__PURE__ */ new Set(), q2.set(l2, k)));
              if (!k.has(h)) {
                k.add(h);
                var v2 = Yj.bind(null, f, l2, h);
                l2.then(v2, v2);
              }
              p2.flags |= 4096;
              p2.lanes = b;
              break a;
            }
            p2 = p2.return;
          } while (p2 !== null);
          k = Error((Ra(h.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.");
        }
        V !== 5 && (V = 2);
        k = Mi(k, h);
        p2 = g;
        do {
          switch (p2.tag) {
            case 3:
              f = k;
              p2.flags |= 4096;
              b &= -b;
              p2.lanes |= b;
              var J2 = Pi(p2, f, b);
              Bg(p2, J2);
              break a;
            case 1:
              f = k;
              var K2 = p2.type, Q2 = p2.stateNode;
              if ((p2.flags & 64) === 0 && (typeof K2.getDerivedStateFromError === "function" || Q2 !== null && typeof Q2.componentDidCatch === "function" && (Ti === null || !Ti.has(Q2)))) {
                p2.flags |= 4096;
                b &= -b;
                p2.lanes |= b;
                var L2 = Si(p2, f, b);
                Bg(p2, L2);
                break a;
              }
          }
          p2 = p2.return;
        } while (p2 !== null);
      }
      Zj(c);
    } catch (va) {
      b = va;
      Y === c && c !== null && (Y = c = c.return);
      continue;
    }
    break;
  } while (1);
}
function Pj() {
  var a = oj.current;
  oj.current = Gh;
  return a === null ? Gh : a;
}
function Tj(a, b) {
  var c = X;
  X |= 16;
  var d = Pj();
  U === a && W === b || Qj(a, b);
  do
    try {
      ak();
      break;
    } catch (e) {
      Sj(a, e);
    }
  while (1);
  qg();
  X = c;
  oj.current = d;
  if (Y !== null)
    throw Error(y(261));
  U = null;
  W = 0;
  return V;
}
function ak() {
  for (; Y !== null; )
    bk(Y);
}
function Rj() {
  for (; Y !== null && !Qf(); )
    bk(Y);
}
function bk(a) {
  var b = ck(a.alternate, a, qj);
  a.memoizedProps = a.pendingProps;
  b === null ? Zj(a) : Y = b;
  pj.current = null;
}
function Zj(a) {
  var b = a;
  do {
    var c = b.alternate;
    a = b.return;
    if ((b.flags & 2048) === 0) {
      c = Gi(c, b, qj);
      if (c !== null) {
        Y = c;
        return;
      }
      c = b;
      if (c.tag !== 24 && c.tag !== 23 || c.memoizedState === null || (qj & 1073741824) !== 0 || (c.mode & 4) === 0) {
        for (var d = 0, e = c.child; e !== null; )
          d |= e.lanes | e.childLanes, e = e.sibling;
        c.childLanes = d;
      }
      a !== null && (a.flags & 2048) === 0 && (a.firstEffect === null && (a.firstEffect = b.firstEffect), b.lastEffect !== null && (a.lastEffect !== null && (a.lastEffect.nextEffect = b.firstEffect), a.lastEffect = b.lastEffect), 1 < b.flags && (a.lastEffect !== null ? a.lastEffect.nextEffect = b : a.firstEffect = b, a.lastEffect = b));
    } else {
      c = Li(b);
      if (c !== null) {
        c.flags &= 2047;
        Y = c;
        return;
      }
      a !== null && (a.firstEffect = a.lastEffect = null, a.flags |= 2048);
    }
    b = b.sibling;
    if (b !== null) {
      Y = b;
      return;
    }
    Y = b = a;
  } while (b !== null);
  V === 0 && (V = 5);
}
function Uj(a) {
  var b = eg();
  gg(99, dk.bind(null, a, b));
  return null;
}
function dk(a, b) {
  do
    Oj();
  while (yj !== null);
  if ((X & 48) !== 0)
    throw Error(y(327));
  var c = a.finishedWork;
  if (c === null)
    return null;
  a.finishedWork = null;
  a.finishedLanes = 0;
  if (c === a.current)
    throw Error(y(177));
  a.callbackNode = null;
  var d = c.lanes | c.childLanes, e = d, f = a.pendingLanes & ~e;
  a.pendingLanes = e;
  a.suspendedLanes = 0;
  a.pingedLanes = 0;
  a.expiredLanes &= e;
  a.mutableReadLanes &= e;
  a.entangledLanes &= e;
  e = a.entanglements;
  for (var g = a.eventTimes, h = a.expirationTimes; 0 < f; ) {
    var k = 31 - Vc(f), l2 = 1 << k;
    e[k] = 0;
    g[k] = -1;
    h[k] = -1;
    f &= ~l2;
  }
  Cj !== null && (d & 24) === 0 && Cj.has(a) && Cj.delete(a);
  a === U && (Y = U = null, W = 0);
  1 < c.flags ? c.lastEffect !== null ? (c.lastEffect.nextEffect = c, d = c.firstEffect) : d = c : d = c.firstEffect;
  if (d !== null) {
    e = X;
    X |= 32;
    pj.current = null;
    kf = fd;
    g = Ne();
    if (Oe(g)) {
      if ("selectionStart" in g)
        h = { start: g.selectionStart, end: g.selectionEnd };
      else
        a:
          if (h = (h = g.ownerDocument) && h.defaultView || window, (l2 = h.getSelection && h.getSelection()) && l2.rangeCount !== 0) {
            h = l2.anchorNode;
            f = l2.anchorOffset;
            k = l2.focusNode;
            l2 = l2.focusOffset;
            try {
              h.nodeType, k.nodeType;
            } catch (va) {
              h = null;
              break a;
            }
            var n2 = 0, A2 = -1, p2 = -1, C2 = 0, x2 = 0, w = g, z2 = null;
            b:
              for (; ; ) {
                for (var u2; ; ) {
                  w !== h || f !== 0 && w.nodeType !== 3 || (A2 = n2 + f);
                  w !== k || l2 !== 0 && w.nodeType !== 3 || (p2 = n2 + l2);
                  w.nodeType === 3 && (n2 += w.nodeValue.length);
                  if ((u2 = w.firstChild) === null)
                    break;
                  z2 = w;
                  w = u2;
                }
                for (; ; ) {
                  if (w === g)
                    break b;
                  z2 === h && ++C2 === f && (A2 = n2);
                  z2 === k && ++x2 === l2 && (p2 = n2);
                  if ((u2 = w.nextSibling) !== null)
                    break;
                  w = z2;
                  z2 = w.parentNode;
                }
                w = u2;
              }
            h = A2 === -1 || p2 === -1 ? null : { start: A2, end: p2 };
          } else
            h = null;
      h = h || { start: 0, end: 0 };
    } else
      h = null;
    lf = { focusedElem: g, selectionRange: h };
    fd = false;
    Ij = null;
    Jj = false;
    Z = d;
    do
      try {
        ek();
      } catch (va) {
        if (Z === null)
          throw Error(y(330));
        Wi(Z, va);
        Z = Z.nextEffect;
      }
    while (Z !== null);
    Ij = null;
    Z = d;
    do
      try {
        for (g = a; Z !== null; ) {
          var t2 = Z.flags;
          t2 & 16 && pb(Z.stateNode, "");
          if (t2 & 128) {
            var q2 = Z.alternate;
            if (q2 !== null) {
              var v2 = q2.ref;
              v2 !== null && (typeof v2 === "function" ? v2(null) : v2.current = null);
            }
          }
          switch (t2 & 1038) {
            case 2:
              fj(Z);
              Z.flags &= -3;
              break;
            case 6:
              fj(Z);
              Z.flags &= -3;
              ij(Z.alternate, Z);
              break;
            case 1024:
              Z.flags &= -1025;
              break;
            case 1028:
              Z.flags &= -1025;
              ij(Z.alternate, Z);
              break;
            case 4:
              ij(Z.alternate, Z);
              break;
            case 8:
              h = Z;
              cj(g, h);
              var J2 = h.alternate;
              dj(h);
              J2 !== null && dj(J2);
          }
          Z = Z.nextEffect;
        }
      } catch (va) {
        if (Z === null)
          throw Error(y(330));
        Wi(Z, va);
        Z = Z.nextEffect;
      }
    while (Z !== null);
    v2 = lf;
    q2 = Ne();
    t2 = v2.focusedElem;
    g = v2.selectionRange;
    if (q2 !== t2 && t2 && t2.ownerDocument && Me(t2.ownerDocument.documentElement, t2)) {
      g !== null && Oe(t2) && (q2 = g.start, v2 = g.end, v2 === void 0 && (v2 = q2), "selectionStart" in t2 ? (t2.selectionStart = q2, t2.selectionEnd = Math.min(v2, t2.value.length)) : (v2 = (q2 = t2.ownerDocument || document) && q2.defaultView || window, v2.getSelection && (v2 = v2.getSelection(), h = t2.textContent.length, J2 = Math.min(g.start, h), g = g.end === void 0 ? J2 : Math.min(g.end, h), !v2.extend && J2 > g && (h = g, g = J2, J2 = h), h = Le(t2, J2), f = Le(t2, g), h && f && (v2.rangeCount !== 1 || v2.anchorNode !== h.node || v2.anchorOffset !== h.offset || v2.focusNode !== f.node || v2.focusOffset !== f.offset) && (q2 = q2.createRange(), q2.setStart(h.node, h.offset), v2.removeAllRanges(), J2 > g ? (v2.addRange(q2), v2.extend(f.node, f.offset)) : (q2.setEnd(f.node, f.offset), v2.addRange(q2))))));
      q2 = [];
      for (v2 = t2; v2 = v2.parentNode; )
        v2.nodeType === 1 && q2.push({ element: v2, left: v2.scrollLeft, top: v2.scrollTop });
      typeof t2.focus === "function" && t2.focus();
      for (t2 = 0; t2 < q2.length; t2++)
        v2 = q2[t2], v2.element.scrollLeft = v2.left, v2.element.scrollTop = v2.top;
    }
    fd = !!kf;
    lf = kf = null;
    a.current = c;
    Z = d;
    do
      try {
        for (t2 = a; Z !== null; ) {
          var K2 = Z.flags;
          K2 & 36 && Yi(t2, Z.alternate, Z);
          if (K2 & 128) {
            q2 = void 0;
            var Q2 = Z.ref;
            if (Q2 !== null) {
              var L2 = Z.stateNode;
              switch (Z.tag) {
                case 5:
                  q2 = L2;
                  break;
                default:
                  q2 = L2;
              }
              typeof Q2 === "function" ? Q2(q2) : Q2.current = q2;
            }
          }
          Z = Z.nextEffect;
        }
      } catch (va) {
        if (Z === null)
          throw Error(y(330));
        Wi(Z, va);
        Z = Z.nextEffect;
      }
    while (Z !== null);
    Z = null;
    $f();
    X = e;
  } else
    a.current = c;
  if (xj)
    xj = false, yj = a, zj = b;
  else
    for (Z = d; Z !== null; )
      b = Z.nextEffect, Z.nextEffect = null, Z.flags & 8 && (K2 = Z, K2.sibling = null, K2.stateNode = null), Z = b;
  d = a.pendingLanes;
  d === 0 && (Ti = null);
  d === 1 ? a === Ej ? Dj++ : (Dj = 0, Ej = a) : Dj = 0;
  c = c.stateNode;
  if (Mf && typeof Mf.onCommitFiberRoot === "function")
    try {
      Mf.onCommitFiberRoot(Lf, c, void 0, (c.current.flags & 64) === 64);
    } catch (va) {
    }
  Mj(a, O());
  if (Qi)
    throw Qi = false, a = Ri, Ri = null, a;
  if ((X & 8) !== 0)
    return null;
  ig();
  return null;
}
function ek() {
  for (; Z !== null; ) {
    var a = Z.alternate;
    Jj || Ij === null || ((Z.flags & 8) !== 0 ? dc(Z, Ij) && (Jj = true) : Z.tag === 13 && mj(a, Z) && dc(Z, Ij) && (Jj = true));
    var b = Z.flags;
    (b & 256) !== 0 && Xi(a, Z);
    (b & 512) === 0 || xj || (xj = true, hg(97, function() {
      Oj();
      return null;
    }));
    Z = Z.nextEffect;
  }
}
function Oj() {
  if (zj !== 90) {
    var a = 97 < zj ? 97 : zj;
    zj = 90;
    return gg(a, fk);
  }
  return false;
}
function $i(a, b) {
  Aj.push(b, a);
  xj || (xj = true, hg(97, function() {
    Oj();
    return null;
  }));
}
function Zi(a, b) {
  Bj.push(b, a);
  xj || (xj = true, hg(97, function() {
    Oj();
    return null;
  }));
}
function fk() {
  if (yj === null)
    return false;
  var a = yj;
  yj = null;
  if ((X & 48) !== 0)
    throw Error(y(331));
  var b = X;
  X |= 32;
  var c = Bj;
  Bj = [];
  for (var d = 0; d < c.length; d += 2) {
    var e = c[d], f = c[d + 1], g = e.destroy;
    e.destroy = void 0;
    if (typeof g === "function")
      try {
        g();
      } catch (k) {
        if (f === null)
          throw Error(y(330));
        Wi(f, k);
      }
  }
  c = Aj;
  Aj = [];
  for (d = 0; d < c.length; d += 2) {
    e = c[d];
    f = c[d + 1];
    try {
      var h = e.create;
      e.destroy = h();
    } catch (k) {
      if (f === null)
        throw Error(y(330));
      Wi(f, k);
    }
  }
  for (h = a.current.firstEffect; h !== null; )
    a = h.nextEffect, h.nextEffect = null, h.flags & 8 && (h.sibling = null, h.stateNode = null), h = a;
  X = b;
  ig();
  return true;
}
function gk(a, b, c) {
  b = Mi(c, b);
  b = Pi(a, b, 1);
  Ag(a, b);
  b = Hg();
  a = Kj(a, 1);
  a !== null && ($c(a, 1, b), Mj(a, b));
}
function Wi(a, b) {
  if (a.tag === 3)
    gk(a, a, b);
  else
    for (var c = a.return; c !== null; ) {
      if (c.tag === 3) {
        gk(c, a, b);
        break;
      } else if (c.tag === 1) {
        var d = c.stateNode;
        if (typeof c.type.getDerivedStateFromError === "function" || typeof d.componentDidCatch === "function" && (Ti === null || !Ti.has(d))) {
          a = Mi(b, a);
          var e = Si(c, a, 1);
          Ag(c, e);
          e = Hg();
          c = Kj(c, 1);
          if (c !== null)
            $c(c, 1, e), Mj(c, e);
          else if (typeof d.componentDidCatch === "function" && (Ti === null || !Ti.has(d)))
            try {
              d.componentDidCatch(b, a);
            } catch (f) {
            }
          break;
        }
      }
      c = c.return;
    }
}
function Yj(a, b, c) {
  var d = a.pingCache;
  d !== null && d.delete(b);
  b = Hg();
  a.pingedLanes |= a.suspendedLanes & c;
  U === a && (W & c) === c && (V === 4 || V === 3 && (W & 62914560) === W && 500 > O() - jj ? Qj(a, 0) : uj |= c);
  Mj(a, b);
}
function lj(a, b) {
  var c = a.stateNode;
  c !== null && c.delete(b);
  b = 0;
  b === 0 && (b = a.mode, (b & 2) === 0 ? b = 1 : (b & 4) === 0 ? b = eg() === 99 ? 1 : 2 : (Gj === 0 && (Gj = tj), b = Yc(62914560 & ~Gj), b === 0 && (b = 4194304)));
  c = Hg();
  a = Kj(a, b);
  a !== null && ($c(a, b, c), Mj(a, c));
}
var ck;
ck = function(a, b, c) {
  var d = b.lanes;
  if (a !== null)
    if (a.memoizedProps !== b.pendingProps || N.current)
      ug = true;
    else if ((c & d) !== 0)
      ug = (a.flags & 16384) !== 0 ? true : false;
    else {
      ug = false;
      switch (b.tag) {
        case 3:
          ri(b);
          sh();
          break;
        case 5:
          gh(b);
          break;
        case 1:
          Ff(b.type) && Jf(b);
          break;
        case 4:
          eh(b, b.stateNode.containerInfo);
          break;
        case 10:
          d = b.memoizedProps.value;
          var e = b.type._context;
          I(mg, e._currentValue);
          e._currentValue = d;
          break;
        case 13:
          if (b.memoizedState !== null) {
            if ((c & b.child.childLanes) !== 0)
              return ti(a, b, c);
            I(P, P.current & 1);
            b = hi(a, b, c);
            return b !== null ? b.sibling : null;
          }
          I(P, P.current & 1);
          break;
        case 19:
          d = (c & b.childLanes) !== 0;
          if ((a.flags & 64) !== 0) {
            if (d)
              return Ai(a, b, c);
            b.flags |= 64;
          }
          e = b.memoizedState;
          e !== null && (e.rendering = null, e.tail = null, e.lastEffect = null);
          I(P, P.current);
          if (d)
            break;
          else
            return null;
        case 23:
        case 24:
          return b.lanes = 0, mi(a, b, c);
      }
      return hi(a, b, c);
    }
  else
    ug = false;
  b.lanes = 0;
  switch (b.tag) {
    case 2:
      d = b.type;
      a !== null && (a.alternate = null, b.alternate = null, b.flags |= 2);
      a = b.pendingProps;
      e = Ef(b, M.current);
      tg(b, c);
      e = Ch(null, b, d, a, e, c);
      b.flags |= 1;
      if (typeof e === "object" && e !== null && typeof e.render === "function" && e.$$typeof === void 0) {
        b.tag = 1;
        b.memoizedState = null;
        b.updateQueue = null;
        if (Ff(d)) {
          var f = true;
          Jf(b);
        } else
          f = false;
        b.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null;
        xg(b);
        var g = d.getDerivedStateFromProps;
        typeof g === "function" && Gg(b, d, g, a);
        e.updater = Kg;
        b.stateNode = e;
        e._reactInternals = b;
        Og(b, d, a, c);
        b = qi(null, b, d, true, f, c);
      } else
        b.tag = 0, fi(null, b, e, c), b = b.child;
      return b;
    case 16:
      e = b.elementType;
      a: {
        a !== null && (a.alternate = null, b.alternate = null, b.flags |= 2);
        a = b.pendingProps;
        f = e._init;
        e = f(e._payload);
        b.type = e;
        f = b.tag = hk(e);
        a = lg(e, a);
        switch (f) {
          case 0:
            b = li(null, b, e, a, c);
            break a;
          case 1:
            b = pi(null, b, e, a, c);
            break a;
          case 11:
            b = gi(null, b, e, a, c);
            break a;
          case 14:
            b = ii(null, b, e, lg(e.type, a), d, c);
            break a;
        }
        throw Error(y(306, e, ""));
      }
      return b;
    case 0:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), li(a, b, d, e, c);
    case 1:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), pi(a, b, d, e, c);
    case 3:
      ri(b);
      d = b.updateQueue;
      if (a === null || d === null)
        throw Error(y(282));
      d = b.pendingProps;
      e = b.memoizedState;
      e = e !== null ? e.element : null;
      yg(a, b);
      Cg(b, d, null, c);
      d = b.memoizedState.element;
      if (d === e)
        sh(), b = hi(a, b, c);
      else {
        e = b.stateNode;
        if (f = e.hydrate)
          kh = rf(b.stateNode.containerInfo.firstChild), jh = b, f = lh = true;
        if (f) {
          a = e.mutableSourceEagerHydrationData;
          if (a != null)
            for (e = 0; e < a.length; e += 2)
              f = a[e], f._workInProgressVersionPrimary = a[e + 1], th.push(f);
          c = Zg(b, null, d, c);
          for (b.child = c; c; )
            c.flags = c.flags & -3 | 1024, c = c.sibling;
        } else
          fi(a, b, d, c), sh();
        b = b.child;
      }
      return b;
    case 5:
      return gh(b), a === null && ph(b), d = b.type, e = b.pendingProps, f = a !== null ? a.memoizedProps : null, g = e.children, nf(d, e) ? g = null : f !== null && nf(d, f) && (b.flags |= 16), oi(a, b), fi(a, b, g, c), b.child;
    case 6:
      return a === null && ph(b), null;
    case 13:
      return ti(a, b, c);
    case 4:
      return eh(b, b.stateNode.containerInfo), d = b.pendingProps, a === null ? b.child = Yg(b, null, d, c) : fi(a, b, d, c), b.child;
    case 11:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), gi(a, b, d, e, c);
    case 7:
      return fi(a, b, b.pendingProps, c), b.child;
    case 8:
      return fi(a, b, b.pendingProps.children, c), b.child;
    case 12:
      return fi(a, b, b.pendingProps.children, c), b.child;
    case 10:
      a: {
        d = b.type._context;
        e = b.pendingProps;
        g = b.memoizedProps;
        f = e.value;
        var h = b.type._context;
        I(mg, h._currentValue);
        h._currentValue = f;
        if (g !== null)
          if (h = g.value, f = He(h, f) ? 0 : (typeof d._calculateChangedBits === "function" ? d._calculateChangedBits(h, f) : 1073741823) | 0, f === 0) {
            if (g.children === e.children && !N.current) {
              b = hi(a, b, c);
              break a;
            }
          } else
            for (h = b.child, h !== null && (h.return = b); h !== null; ) {
              var k = h.dependencies;
              if (k !== null) {
                g = h.child;
                for (var l2 = k.firstContext; l2 !== null; ) {
                  if (l2.context === d && (l2.observedBits & f) !== 0) {
                    h.tag === 1 && (l2 = zg(-1, c & -c), l2.tag = 2, Ag(h, l2));
                    h.lanes |= c;
                    l2 = h.alternate;
                    l2 !== null && (l2.lanes |= c);
                    sg(h.return, c);
                    k.lanes |= c;
                    break;
                  }
                  l2 = l2.next;
                }
              } else
                g = h.tag === 10 ? h.type === b.type ? null : h.child : h.child;
              if (g !== null)
                g.return = h;
              else
                for (g = h; g !== null; ) {
                  if (g === b) {
                    g = null;
                    break;
                  }
                  h = g.sibling;
                  if (h !== null) {
                    h.return = g.return;
                    g = h;
                    break;
                  }
                  g = g.return;
                }
              h = g;
            }
        fi(a, b, e.children, c);
        b = b.child;
      }
      return b;
    case 9:
      return e = b.type, f = b.pendingProps, d = f.children, tg(b, c), e = vg(e, f.unstable_observedBits), d = d(e), b.flags |= 1, fi(a, b, d, c), b.child;
    case 14:
      return e = b.type, f = lg(e, b.pendingProps), f = lg(e.type, f), ii(a, b, e, f, d, c);
    case 15:
      return ki(a, b, b.type, b.pendingProps, d, c);
    case 17:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), a !== null && (a.alternate = null, b.alternate = null, b.flags |= 2), b.tag = 1, Ff(d) ? (a = true, Jf(b)) : a = false, tg(b, c), Mg(b, d, e), Og(b, d, e, c), qi(null, b, d, true, a, c);
    case 19:
      return Ai(a, b, c);
    case 23:
      return mi(a, b, c);
    case 24:
      return mi(a, b, c);
  }
  throw Error(y(156, b.tag));
};
function ik(a, b, c, d) {
  this.tag = a;
  this.key = c;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d;
  this.flags = 0;
  this.lastEffect = this.firstEffect = this.nextEffect = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function nh(a, b, c, d) {
  return new ik(a, b, c, d);
}
function ji(a) {
  a = a.prototype;
  return !(!a || !a.isReactComponent);
}
function hk(a) {
  if (typeof a === "function")
    return ji(a) ? 1 : 0;
  if (a !== void 0 && a !== null) {
    a = a.$$typeof;
    if (a === Aa)
      return 11;
    if (a === Da)
      return 14;
  }
  return 2;
}
function Tg(a, b) {
  var c = a.alternate;
  c === null ? (c = nh(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.nextEffect = null, c.firstEffect = null, c.lastEffect = null);
  c.childLanes = a.childLanes;
  c.lanes = a.lanes;
  c.child = a.child;
  c.memoizedProps = a.memoizedProps;
  c.memoizedState = a.memoizedState;
  c.updateQueue = a.updateQueue;
  b = a.dependencies;
  c.dependencies = b === null ? null : { lanes: b.lanes, firstContext: b.firstContext };
  c.sibling = a.sibling;
  c.index = a.index;
  c.ref = a.ref;
  return c;
}
function Vg(a, b, c, d, e, f) {
  var g = 2;
  d = a;
  if (typeof a === "function")
    ji(a) && (g = 1);
  else if (typeof a === "string")
    g = 5;
  else
    a:
      switch (a) {
        case ua:
          return Xg(c.children, e, f, b);
        case Ha:
          g = 8;
          e |= 16;
          break;
        case wa:
          g = 8;
          e |= 1;
          break;
        case xa:
          return a = nh(12, c, b, e | 8), a.elementType = xa, a.type = xa, a.lanes = f, a;
        case Ba:
          return a = nh(13, c, b, e), a.type = Ba, a.elementType = Ba, a.lanes = f, a;
        case Ca:
          return a = nh(19, c, b, e), a.elementType = Ca, a.lanes = f, a;
        case Ia:
          return vi(c, e, f, b);
        case Ja:
          return a = nh(24, c, b, e), a.elementType = Ja, a.lanes = f, a;
        default:
          if (typeof a === "object" && a !== null)
            switch (a.$$typeof) {
              case ya:
                g = 10;
                break a;
              case za:
                g = 9;
                break a;
              case Aa:
                g = 11;
                break a;
              case Da:
                g = 14;
                break a;
              case Ea:
                g = 16;
                d = null;
                break a;
              case Fa:
                g = 22;
                break a;
            }
          throw Error(y(130, a == null ? a : typeof a, ""));
      }
  b = nh(g, c, b, e);
  b.elementType = a;
  b.type = d;
  b.lanes = f;
  return b;
}
function Xg(a, b, c, d) {
  a = nh(7, a, d, b);
  a.lanes = c;
  return a;
}
function vi(a, b, c, d) {
  a = nh(23, a, d, b);
  a.elementType = Ia;
  a.lanes = c;
  return a;
}
function Ug(a, b, c) {
  a = nh(6, a, null, b);
  a.lanes = c;
  return a;
}
function Wg(a, b, c) {
  b = nh(4, a.children !== null ? a.children : [], a.key, b);
  b.lanes = c;
  b.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
  return b;
}
function jk(a, b, c) {
  this.tag = b;
  this.containerInfo = a;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.pendingContext = this.context = null;
  this.hydrate = c;
  this.callbackNode = null;
  this.callbackPriority = 0;
  this.eventTimes = Zc(0);
  this.expirationTimes = Zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = Zc(0);
  this.mutableSourceEagerHydrationData = null;
}
function kk(a, b, c) {
  var d = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
  return { $$typeof: ta, key: d == null ? null : "" + d, children: a, containerInfo: b, implementation: c };
}
function lk(a, b, c, d) {
  var e = b.current, f = Hg(), g = Ig(e);
  a:
    if (c) {
      c = c._reactInternals;
      b: {
        if (Zb(c) !== c || c.tag !== 1)
          throw Error(y(170));
        var h = c;
        do {
          switch (h.tag) {
            case 3:
              h = h.stateNode.context;
              break b;
            case 1:
              if (Ff(h.type)) {
                h = h.stateNode.__reactInternalMemoizedMergedChildContext;
                break b;
              }
          }
          h = h.return;
        } while (h !== null);
        throw Error(y(171));
      }
      if (c.tag === 1) {
        var k = c.type;
        if (Ff(k)) {
          c = If(c, k, h);
          break a;
        }
      }
      c = h;
    } else
      c = Cf;
  b.context === null ? b.context = c : b.pendingContext = c;
  b = zg(f, g);
  b.payload = { element: a };
  d = d === void 0 ? null : d;
  d !== null && (b.callback = d);
  Ag(e, b);
  Jg(e, g, f);
  return g;
}
function mk(a) {
  a = a.current;
  if (!a.child)
    return null;
  switch (a.child.tag) {
    case 5:
      return a.child.stateNode;
    default:
      return a.child.stateNode;
  }
}
function nk(a, b) {
  a = a.memoizedState;
  if (a !== null && a.dehydrated !== null) {
    var c = a.retryLane;
    a.retryLane = c !== 0 && c < b ? c : b;
  }
}
function ok(a, b) {
  nk(a, b);
  (a = a.alternate) && nk(a, b);
}
function pk() {
  return null;
}
function qk(a, b, c) {
  var d = c != null && c.hydrationOptions != null && c.hydrationOptions.mutableSources || null;
  c = new jk(a, b, c != null && c.hydrate === true);
  b = nh(3, null, null, b === 2 ? 7 : b === 1 ? 3 : 0);
  c.current = b;
  b.stateNode = c;
  xg(b);
  a[ff] = c.current;
  cf(a.nodeType === 8 ? a.parentNode : a);
  if (d)
    for (a = 0; a < d.length; a++) {
      b = d[a];
      var e = b._getVersion;
      e = e(b._source);
      c.mutableSourceEagerHydrationData == null ? c.mutableSourceEagerHydrationData = [b, e] : c.mutableSourceEagerHydrationData.push(b, e);
    }
  this._internalRoot = c;
}
qk.prototype.render = function(a) {
  lk(a, this._internalRoot, null, null);
};
qk.prototype.unmount = function() {
  var a = this._internalRoot, b = a.containerInfo;
  lk(null, a, null, function() {
    b[ff] = null;
  });
};
function rk(a) {
  return !(!a || a.nodeType !== 1 && a.nodeType !== 9 && a.nodeType !== 11 && (a.nodeType !== 8 || a.nodeValue !== " react-mount-point-unstable "));
}
function sk(a, b) {
  b || (b = a ? a.nodeType === 9 ? a.documentElement : a.firstChild : null, b = !(!b || b.nodeType !== 1 || !b.hasAttribute("data-reactroot")));
  if (!b)
    for (var c; c = a.lastChild; )
      a.removeChild(c);
  return new qk(a, 0, b ? { hydrate: true } : void 0);
}
function tk(a, b, c, d, e) {
  var f = c._reactRootContainer;
  if (f) {
    var g = f._internalRoot;
    if (typeof e === "function") {
      var h = e;
      e = function() {
        var a2 = mk(g);
        h.call(a2);
      };
    }
    lk(b, g, a, e);
  } else {
    f = c._reactRootContainer = sk(c, d);
    g = f._internalRoot;
    if (typeof e === "function") {
      var k = e;
      e = function() {
        var a2 = mk(g);
        k.call(a2);
      };
    }
    Xj(function() {
      lk(b, g, a, e);
    });
  }
  return mk(g);
}
ec = function(a) {
  if (a.tag === 13) {
    var b = Hg();
    Jg(a, 4, b);
    ok(a, 4);
  }
};
fc = function(a) {
  if (a.tag === 13) {
    var b = Hg();
    Jg(a, 67108864, b);
    ok(a, 67108864);
  }
};
gc = function(a) {
  if (a.tag === 13) {
    var b = Hg(), c = Ig(a);
    Jg(a, c, b);
    ok(a, c);
  }
};
hc = function(a, b) {
  return b();
};
yb = function(a, b, c) {
  switch (b) {
    case "input":
      ab(a, c);
      b = c.name;
      if (c.type === "radio" && b != null) {
        for (c = a; c.parentNode; )
          c = c.parentNode;
        c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
        for (b = 0; b < c.length; b++) {
          var d = c[b];
          if (d !== a && d.form === a.form) {
            var e = Db(d);
            if (!e)
              throw Error(y(90));
            Wa(d);
            ab(d, e);
          }
        }
      }
      break;
    case "textarea":
      ib(a, c);
      break;
    case "select":
      b = c.value, b != null && fb(a, !!c.multiple, b, false);
  }
};
Gb = Wj;
Hb = function(a, b, c, d, e) {
  var f = X;
  X |= 4;
  try {
    return gg(98, a.bind(null, b, c, d, e));
  } finally {
    X = f, X === 0 && (wj(), ig());
  }
};
Ib = function() {
  (X & 49) === 0 && (Vj(), Oj());
};
Jb = function(a, b) {
  var c = X;
  X |= 2;
  try {
    return a(b);
  } finally {
    X = c, X === 0 && (wj(), ig());
  }
};
function uk(a, b) {
  var c = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
  if (!rk(b))
    throw Error(y(200));
  return kk(a, b, null, c);
}
var vk = { Events: [Cb, ue, Db, Eb, Fb, Oj, { current: false }] }, wk = { findFiberByHostInstance: wc, bundleType: 0, version: "17.0.2", rendererPackageName: "react-dom" };
var xk = { bundleType: wk.bundleType, version: wk.version, rendererPackageName: wk.rendererPackageName, rendererConfig: wk.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ra.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
  a = cc(a);
  return a === null ? null : a.stateNode;
}, findFiberByHostInstance: wk.findFiberByHostInstance || pk, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined") {
  var yk = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!yk.isDisabled && yk.supportsFiber)
    try {
      Lf = yk.inject(xk), Mf = yk;
    } catch (a) {
    }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = vk;
reactDom_production_min.createPortal = uk;
reactDom_production_min.findDOMNode = function(a) {
  if (a == null)
    return null;
  if (a.nodeType === 1)
    return a;
  var b = a._reactInternals;
  if (b === void 0) {
    if (typeof a.render === "function")
      throw Error(y(188));
    throw Error(y(268, Object.keys(a)));
  }
  a = cc(b);
  a = a === null ? null : a.stateNode;
  return a;
};
reactDom_production_min.flushSync = function(a, b) {
  var c = X;
  if ((c & 48) !== 0)
    return a(b);
  X |= 1;
  try {
    if (a)
      return gg(99, a.bind(null, b));
  } finally {
    X = c, ig();
  }
};
reactDom_production_min.hydrate = function(a, b, c) {
  if (!rk(b))
    throw Error(y(200));
  return tk(null, a, b, true, c);
};
reactDom_production_min.render = function(a, b, c) {
  if (!rk(b))
    throw Error(y(200));
  return tk(null, a, b, false, c);
};
reactDom_production_min.unmountComponentAtNode = function(a) {
  if (!rk(a))
    throw Error(y(40));
  return a._reactRootContainer ? (Xj(function() {
    tk(null, null, a, false, function() {
      a._reactRootContainer = null;
      a[ff] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Wj;
reactDom_production_min.unstable_createPortal = function(a, b) {
  return uk(a, b, 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null);
};
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a, b, c, d) {
  if (!rk(c))
    throw Error(y(200));
  if (a == null || a._reactInternals === void 0)
    throw Error(y(38));
  return tk(a, b, c, false, d);
};
reactDom_production_min.version = "17.0.2";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}
var ReactDOM = reactDom.exports;
var propTypes = { exports: {} };
var ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;
var ReactPropTypesSecret = ReactPropTypesSecret_1;
function emptyFunction() {
}
function emptyFunctionWithReset() {
}
emptyFunctionWithReset.resetWarningCache = emptyFunction;
var factoryWithThrowingShims = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      return;
    }
    var err = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
    err.name = "Invariant Violation";
    throw err;
  }
  shim.isRequired = shim;
  function getShim() {
    return shim;
  }
  var ReactPropTypes = {
    array: shim,
    bigint: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,
    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,
    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };
  ReactPropTypes.PropTypes = ReactPropTypes;
  return ReactPropTypes;
};
{
  propTypes.exports = factoryWithThrowingShims();
}
var __assign$1 = globalThis && globalThis.__assign || function() {
  __assign$1 = Object.assign || function(t2) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t2[p2] = s[p2];
    }
    return t2;
  };
  return __assign$1.apply(this, arguments);
};
var eventPropTypes = {
  onActivate: propTypes.exports.func,
  onAddUndo: propTypes.exports.func,
  onBeforeAddUndo: propTypes.exports.func,
  onBeforeExecCommand: propTypes.exports.func,
  onBeforeGetContent: propTypes.exports.func,
  onBeforeRenderUI: propTypes.exports.func,
  onBeforeSetContent: propTypes.exports.func,
  onBeforePaste: propTypes.exports.func,
  onBlur: propTypes.exports.func,
  onChange: propTypes.exports.func,
  onClearUndos: propTypes.exports.func,
  onClick: propTypes.exports.func,
  onContextMenu: propTypes.exports.func,
  onCopy: propTypes.exports.func,
  onCut: propTypes.exports.func,
  onDblclick: propTypes.exports.func,
  onDeactivate: propTypes.exports.func,
  onDirty: propTypes.exports.func,
  onDrag: propTypes.exports.func,
  onDragDrop: propTypes.exports.func,
  onDragEnd: propTypes.exports.func,
  onDragGesture: propTypes.exports.func,
  onDragOver: propTypes.exports.func,
  onDrop: propTypes.exports.func,
  onExecCommand: propTypes.exports.func,
  onFocus: propTypes.exports.func,
  onFocusIn: propTypes.exports.func,
  onFocusOut: propTypes.exports.func,
  onGetContent: propTypes.exports.func,
  onHide: propTypes.exports.func,
  onInit: propTypes.exports.func,
  onKeyDown: propTypes.exports.func,
  onKeyPress: propTypes.exports.func,
  onKeyUp: propTypes.exports.func,
  onLoadContent: propTypes.exports.func,
  onMouseDown: propTypes.exports.func,
  onMouseEnter: propTypes.exports.func,
  onMouseLeave: propTypes.exports.func,
  onMouseMove: propTypes.exports.func,
  onMouseOut: propTypes.exports.func,
  onMouseOver: propTypes.exports.func,
  onMouseUp: propTypes.exports.func,
  onNodeChange: propTypes.exports.func,
  onObjectResizeStart: propTypes.exports.func,
  onObjectResized: propTypes.exports.func,
  onObjectSelected: propTypes.exports.func,
  onPaste: propTypes.exports.func,
  onPostProcess: propTypes.exports.func,
  onPostRender: propTypes.exports.func,
  onPreProcess: propTypes.exports.func,
  onProgressState: propTypes.exports.func,
  onRedo: propTypes.exports.func,
  onRemove: propTypes.exports.func,
  onReset: propTypes.exports.func,
  onSaveContent: propTypes.exports.func,
  onSelectionChange: propTypes.exports.func,
  onSetAttrib: propTypes.exports.func,
  onSetContent: propTypes.exports.func,
  onShow: propTypes.exports.func,
  onSubmit: propTypes.exports.func,
  onUndo: propTypes.exports.func,
  onVisualAid: propTypes.exports.func
};
var EditorPropTypes = __assign$1({ apiKey: propTypes.exports.string, id: propTypes.exports.string, inline: propTypes.exports.bool, init: propTypes.exports.object, initialValue: propTypes.exports.string, onEditorChange: propTypes.exports.func, outputFormat: propTypes.exports.oneOf(["html", "text"]), value: propTypes.exports.string, tagName: propTypes.exports.string, cloudChannel: propTypes.exports.string, plugins: propTypes.exports.oneOfType([propTypes.exports.string, propTypes.exports.array]), toolbar: propTypes.exports.oneOfType([propTypes.exports.string, propTypes.exports.array]), disabled: propTypes.exports.bool, textareaName: propTypes.exports.string, tinymceScriptSrc: propTypes.exports.string, rollback: propTypes.exports.oneOfType([propTypes.exports.number, propTypes.exports.oneOf([false])]), scriptLoading: propTypes.exports.shape({
  async: propTypes.exports.bool,
  defer: propTypes.exports.bool,
  delay: propTypes.exports.number
}) }, eventPropTypes);
var isFunction = function(x2) {
  return typeof x2 === "function";
};
var isEventProp = function(name) {
  return name in eventPropTypes;
};
var eventAttrToEventName = function(attrName) {
  return attrName.substr(2);
};
var configHandlers2 = function(handlerLookup, on, off, adapter, prevProps, props, boundHandlers) {
  var prevEventKeys = Object.keys(prevProps).filter(isEventProp);
  var currEventKeys = Object.keys(props).filter(isEventProp);
  var removedKeys = prevEventKeys.filter(function(key) {
    return props[key] === void 0;
  });
  var addedKeys = currEventKeys.filter(function(key) {
    return prevProps[key] === void 0;
  });
  removedKeys.forEach(function(key) {
    var eventName = eventAttrToEventName(key);
    var wrappedHandler = boundHandlers[eventName];
    off(eventName, wrappedHandler);
    delete boundHandlers[eventName];
  });
  addedKeys.forEach(function(key) {
    var wrappedHandler = adapter(handlerLookup, key);
    var eventName = eventAttrToEventName(key);
    boundHandlers[eventName] = wrappedHandler;
    on(eventName, wrappedHandler);
  });
};
var configHandlers = function(editor, prevProps, props, boundHandlers, lookup) {
  return configHandlers2(lookup, editor.on.bind(editor), editor.off.bind(editor), function(handlerLookup, key) {
    return function(e) {
      var _a;
      return (_a = handlerLookup(key)) === null || _a === void 0 ? void 0 : _a(e, editor);
    };
  }, prevProps, props, boundHandlers);
};
var unique = 0;
var uuid = function(prefix) {
  var time = Date.now();
  var random = Math.floor(Math.random() * 1e9);
  unique++;
  return prefix + "_" + random + unique + String(time);
};
var isTextareaOrInput = function(element) {
  return element !== null && (element.tagName.toLowerCase() === "textarea" || element.tagName.toLowerCase() === "input");
};
var normalizePluginArray = function(plugins) {
  if (typeof plugins === "undefined" || plugins === "") {
    return [];
  }
  return Array.isArray(plugins) ? plugins : plugins.split(" ");
};
var mergePlugins = function(initPlugins, inputPlugins) {
  return normalizePluginArray(initPlugins).concat(normalizePluginArray(inputPlugins));
};
var isBeforeInputEventAvailable = function() {
  return window.InputEvent && typeof InputEvent.prototype.getTargetRanges === "function";
};
var isInDoc = function(elem) {
  if (!("isConnected" in Node.prototype)) {
    var current = elem;
    var parent_1 = elem.parentNode;
    while (parent_1 != null) {
      current = parent_1;
      parent_1 = current.parentNode;
    }
    return current === elem.ownerDocument;
  }
  return elem.isConnected;
};
var setMode = function(editor, mode) {
  if (editor !== void 0) {
    if (editor.mode != null && typeof editor.mode === "object" && typeof editor.mode.set === "function") {
      editor.mode.set(mode);
    } else {
      editor.setMode(mode);
    }
  }
};
var createState = function() {
  return {
    listeners: [],
    scriptId: uuid("tiny-script"),
    scriptLoading: false,
    scriptLoaded: false
  };
};
var CreateScriptLoader = function() {
  var state = createState();
  var injectScriptTag = function(scriptId, doc, url, async, defer, callback) {
    var scriptTag = doc.createElement("script");
    scriptTag.referrerPolicy = "origin";
    scriptTag.type = "application/javascript";
    scriptTag.id = scriptId;
    scriptTag.src = url;
    scriptTag.async = async;
    scriptTag.defer = defer;
    var handler = function() {
      scriptTag.removeEventListener("load", handler);
      callback();
    };
    scriptTag.addEventListener("load", handler);
    if (doc.head) {
      doc.head.appendChild(scriptTag);
    }
  };
  var load = function(doc, url, async, defer, delay, callback) {
    var scriptTagInjection = function() {
      return injectScriptTag(state.scriptId, doc, url, async, defer, function() {
        state.listeners.forEach(function(fn) {
          return fn();
        });
        state.scriptLoaded = true;
      });
    };
    if (state.scriptLoaded) {
      callback();
    } else {
      state.listeners.push(callback);
      if (!state.scriptLoading) {
        state.scriptLoading = true;
        if (delay > 0) {
          setTimeout(scriptTagInjection, delay);
        } else {
          scriptTagInjection();
        }
      }
    }
  };
  var reinitialize = function() {
    state = createState();
  };
  return {
    load,
    reinitialize
  };
};
var ScriptLoader = CreateScriptLoader();
var getGlobal = function() {
  return typeof window !== "undefined" ? window : global;
};
var getTinymce = function() {
  var global2 = getGlobal();
  return global2 && global2.tinymce ? global2.tinymce : null;
};
var __extends = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign = globalThis && globalThis.__assign || function() {
  __assign = Object.assign || function(t2) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t2[p2] = s[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
var changeEvents = function() {
  var _a, _b, _c;
  return ((_c = (_b = (_a = getTinymce()) === null || _a === void 0 ? void 0 : _a.Env) === null || _b === void 0 ? void 0 : _b.browser) === null || _c === void 0 ? void 0 : _c.isIE()) ? "change keyup compositionend setcontent" : "change input compositionend setcontent";
};
var beforeInputEvent = function() {
  return isBeforeInputEventAvailable() ? "beforeinput SelectionChange" : "SelectionChange";
};
var Editor = function(_super) {
  __extends(Editor2, _super);
  function Editor2(props) {
    var _this = this;
    var _a, _b, _c;
    _this = _super.call(this, props) || this;
    _this.rollbackTimer = void 0;
    _this.valueCursor = void 0;
    _this.rollbackChange = function() {
      var editor = _this.editor;
      var value = _this.props.value;
      if (editor && value && value !== _this.currentContent) {
        editor.undoManager.ignore(function() {
          editor.setContent(value);
          if (_this.valueCursor && (!_this.inline || editor.hasFocus())) {
            try {
              editor.selection.moveToBookmark(_this.valueCursor);
            } catch (e) {
            }
          }
        });
      }
      _this.rollbackTimer = void 0;
    };
    _this.handleBeforeInput = function(_evt) {
      if (_this.props.value !== void 0 && _this.props.value === _this.currentContent && _this.editor) {
        if (!_this.inline || _this.editor.hasFocus) {
          try {
            _this.valueCursor = _this.editor.selection.getBookmark(3);
          } catch (e) {
          }
        }
      }
    };
    _this.handleBeforeInputSpecial = function(evt) {
      if (evt.key === "Enter" || evt.key === "Backspace" || evt.key === "Delete") {
        _this.handleBeforeInput(evt);
      }
    };
    _this.handleEditorChange = function(_evt) {
      var editor = _this.editor;
      if (editor && editor.initialized) {
        var newContent = editor.getContent();
        if (_this.props.value !== void 0 && _this.props.value !== newContent && _this.props.rollback !== false) {
          if (!_this.rollbackTimer) {
            _this.rollbackTimer = window.setTimeout(_this.rollbackChange, typeof _this.props.rollback === "number" ? _this.props.rollback : 200);
          }
        }
        if (newContent !== _this.currentContent) {
          _this.currentContent = newContent;
          if (isFunction(_this.props.onEditorChange)) {
            var format = _this.props.outputFormat;
            var out = format === "html" ? newContent : editor.getContent({ format });
            _this.props.onEditorChange(out, editor);
          }
        }
      }
    };
    _this.handleEditorChangeSpecial = function(evt) {
      if (evt.key === "Backspace" || evt.key === "Delete") {
        _this.handleEditorChange(evt);
      }
    };
    _this.initialise = function(attempts) {
      var _a2, _b2, _c2;
      if (attempts === void 0) {
        attempts = 0;
      }
      var target = _this.elementRef.current;
      if (!target) {
        return;
      }
      if (!isInDoc(target)) {
        if (attempts === 0) {
          setTimeout(function() {
            return _this.initialise(1);
          }, 1);
        } else if (attempts < 100) {
          setTimeout(function() {
            return _this.initialise(attempts + 1);
          }, 100);
        } else {
          throw new Error("tinymce can only be initialised when in a document");
        }
        return;
      }
      var tinymce2 = getTinymce();
      if (!tinymce2) {
        throw new Error("tinymce should have been loaded into global scope");
      }
      var finalInit = __assign(__assign({}, _this.props.init), { selector: void 0, target, readonly: _this.props.disabled, inline: _this.inline, plugins: mergePlugins((_a2 = _this.props.init) === null || _a2 === void 0 ? void 0 : _a2.plugins, _this.props.plugins), toolbar: (_b2 = _this.props.toolbar) !== null && _b2 !== void 0 ? _b2 : (_c2 = _this.props.init) === null || _c2 === void 0 ? void 0 : _c2.toolbar, setup: function(editor) {
        _this.editor = editor;
        _this.bindHandlers({});
        if (_this.inline && !isTextareaOrInput(target)) {
          editor.once("PostRender", function(_evt) {
            editor.setContent(_this.getInitialValue(), { no_events: true });
          });
        }
        if (_this.props.init && isFunction(_this.props.init.setup)) {
          _this.props.init.setup(editor);
        }
      }, init_instance_callback: function(editor) {
        var _a3, _b3;
        var initialValue = _this.getInitialValue();
        _this.currentContent = (_a3 = _this.currentContent) !== null && _a3 !== void 0 ? _a3 : editor.getContent();
        if (_this.currentContent !== initialValue) {
          _this.currentContent = initialValue;
          editor.setContent(initialValue);
          editor.undoManager.clear();
          editor.undoManager.add();
          editor.setDirty(false);
        }
        var disabled = (_b3 = _this.props.disabled) !== null && _b3 !== void 0 ? _b3 : false;
        setMode(_this.editor, disabled ? "readonly" : "design");
        if (_this.props.init && isFunction(_this.props.init.init_instance_callback)) {
          _this.props.init.init_instance_callback(editor);
        }
      } });
      if (!_this.inline) {
        target.style.visibility = "";
      }
      if (isTextareaOrInput(target)) {
        target.value = _this.getInitialValue();
      }
      tinymce2.init(finalInit);
    };
    _this.id = _this.props.id || uuid("tiny-react");
    _this.elementRef = react.exports.createRef();
    _this.inline = (_c = (_a = _this.props.inline) !== null && _a !== void 0 ? _a : (_b = _this.props.init) === null || _b === void 0 ? void 0 : _b.inline) !== null && _c !== void 0 ? _c : false;
    _this.boundHandlers = {};
    return _this;
  }
  Editor2.prototype.componentDidUpdate = function(prevProps) {
    var _this = this;
    var _a, _b;
    if (this.rollbackTimer) {
      clearTimeout(this.rollbackTimer);
      this.rollbackTimer = void 0;
    }
    if (this.editor) {
      this.bindHandlers(prevProps);
      if (this.editor.initialized) {
        this.currentContent = (_a = this.currentContent) !== null && _a !== void 0 ? _a : this.editor.getContent();
        if (typeof this.props.initialValue === "string" && this.props.initialValue !== prevProps.initialValue) {
          this.editor.setContent(this.props.initialValue);
          this.editor.undoManager.clear();
          this.editor.undoManager.add();
          this.editor.setDirty(false);
        } else if (typeof this.props.value === "string" && this.props.value !== this.currentContent) {
          var localEditor_1 = this.editor;
          localEditor_1.undoManager.transact(function() {
            var cursor;
            if (!_this.inline || localEditor_1.hasFocus()) {
              try {
                cursor = localEditor_1.selection.getBookmark(3);
              } catch (e) {
              }
            }
            var valueCursor = _this.valueCursor;
            localEditor_1.setContent(_this.props.value);
            if (!_this.inline || localEditor_1.hasFocus()) {
              for (var _i = 0, _a2 = [cursor, valueCursor]; _i < _a2.length; _i++) {
                var bookmark = _a2[_i];
                if (bookmark) {
                  try {
                    localEditor_1.selection.moveToBookmark(bookmark);
                    _this.valueCursor = bookmark;
                    break;
                  } catch (e) {
                  }
                }
              }
            }
          });
        }
        if (this.props.disabled !== prevProps.disabled) {
          var disabled = (_b = this.props.disabled) !== null && _b !== void 0 ? _b : false;
          setMode(this.editor, disabled ? "readonly" : "design");
        }
      }
    }
  };
  Editor2.prototype.componentDidMount = function() {
    var _a, _b, _c, _d, _e, _f;
    if (getTinymce() !== null) {
      this.initialise();
    } else if (this.elementRef.current && this.elementRef.current.ownerDocument) {
      ScriptLoader.load(this.elementRef.current.ownerDocument, this.getScriptSrc(), (_b = (_a = this.props.scriptLoading) === null || _a === void 0 ? void 0 : _a.async) !== null && _b !== void 0 ? _b : false, (_d = (_c = this.props.scriptLoading) === null || _c === void 0 ? void 0 : _c.defer) !== null && _d !== void 0 ? _d : false, (_f = (_e = this.props.scriptLoading) === null || _e === void 0 ? void 0 : _e.delay) !== null && _f !== void 0 ? _f : 0, this.initialise);
    }
  };
  Editor2.prototype.componentWillUnmount = function() {
    var _this = this;
    var editor = this.editor;
    if (editor) {
      editor.off(changeEvents(), this.handleEditorChange);
      editor.off(beforeInputEvent(), this.handleBeforeInput);
      editor.off("keypress", this.handleEditorChangeSpecial);
      editor.off("keydown", this.handleBeforeInputSpecial);
      editor.off("NewBlock", this.handleEditorChange);
      Object.keys(this.boundHandlers).forEach(function(eventName) {
        editor.off(eventName, _this.boundHandlers[eventName]);
      });
      this.boundHandlers = {};
      editor.remove();
      this.editor = void 0;
    }
  };
  Editor2.prototype.render = function() {
    return this.inline ? this.renderInline() : this.renderIframe();
  };
  Editor2.prototype.renderInline = function() {
    var _a = this.props.tagName, tagName = _a === void 0 ? "div" : _a;
    return react.exports.createElement(tagName, {
      ref: this.elementRef,
      id: this.id
    });
  };
  Editor2.prototype.renderIframe = function() {
    return react.exports.createElement("textarea", {
      ref: this.elementRef,
      style: { visibility: "hidden" },
      name: this.props.textareaName,
      id: this.id
    });
  };
  Editor2.prototype.getScriptSrc = function() {
    if (typeof this.props.tinymceScriptSrc === "string") {
      return this.props.tinymceScriptSrc;
    } else {
      var channel = this.props.cloudChannel;
      var apiKey = this.props.apiKey ? this.props.apiKey : "no-api-key";
      return "https://cdn.tiny.cloud/1/".concat(apiKey, "/tinymce/").concat(channel, "/tinymce.min.js");
    }
  };
  Editor2.prototype.getInitialValue = function() {
    if (typeof this.props.initialValue === "string") {
      return this.props.initialValue;
    } else if (typeof this.props.value === "string") {
      return this.props.value;
    } else {
      return "";
    }
  };
  Editor2.prototype.bindHandlers = function(prevProps) {
    var _this = this;
    if (this.editor !== void 0) {
      configHandlers(this.editor, prevProps, this.props, this.boundHandlers, function(key) {
        return _this.props[key];
      });
      var isValueControlled = function(p2) {
        return p2.onEditorChange !== void 0 || p2.value !== void 0;
      };
      var wasControlled = isValueControlled(prevProps);
      var nowControlled = isValueControlled(this.props);
      if (!wasControlled && nowControlled) {
        this.editor.on(changeEvents(), this.handleEditorChange);
        this.editor.on(beforeInputEvent(), this.handleBeforeInput);
        this.editor.on("keydown", this.handleBeforeInputSpecial);
        this.editor.on("keyup", this.handleEditorChangeSpecial);
        this.editor.on("NewBlock", this.handleEditorChange);
      } else if (wasControlled && !nowControlled) {
        this.editor.off(changeEvents(), this.handleEditorChange);
        this.editor.off(beforeInputEvent(), this.handleBeforeInput);
        this.editor.off("keydown", this.handleBeforeInputSpecial);
        this.editor.off("keyup", this.handleEditorChangeSpecial);
        this.editor.off("NewBlock", this.handleEditorChange);
      }
    }
  };
  Editor2.propTypes = EditorPropTypes;
  Editor2.defaultProps = {
    cloudChannel: "5"
  };
  return Editor2;
}(react.exports.Component);
export { Editor as E, React as R, ReactDOM as a };
