;(function(){function _toConsumableArray(arr){return _arrayWithoutHoles(arr)||_iterableToArray(arr)||_unsupportedIterableToArray(arr)||_nonIterableSpread();}function _nonIterableSpread(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}function _iterableToArray(iter){if(typeof Symbol!=="undefined"&&iter[Symbol.iterator]!=null||iter["@@iterator"]!=null)return Array.from(iter);}function _arrayWithoutHoles(arr){if(Array.isArray(arr))return _arrayLikeToArray(arr);}function _slicedToArray(arr,i){return _arrayWithHoles(arr)||_iterableToArrayLimit(arr,i)||_unsupportedIterableToArray(arr,i)||_nonIterableRest();}function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}function _unsupportedIterableToArray(o,minLen){if(!o)return;if(typeof o==="string")return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);if(n==="Object"&&o.constructor)n=o.constructor.name;if(n==="Map"||n==="Set")return Array.from(o);if(n==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen);}function _arrayLikeToArray(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i];}return arr2;}function _iterableToArrayLimit(arr,i){var _i=arr==null?null:typeof Symbol!=="undefined"&&arr[Symbol.iterator]||arr["@@iterator"];if(_i==null)return;var _arr=[];var _n=true;var _d=false;var _s,_e;try{for(_i=_i.call(arr);!(_n=(_s=_i.next()).done);_n=true){_arr.push(_s.value);if(i&&_arr.length===i)break;}}catch(err){_d=true;_e=err;}finally{try{if(!_n&&_i["return"]!=null)_i["return"]();}finally{if(_d)throw _e;}}return _arr;}function _arrayWithHoles(arr){if(Array.isArray(arr))return arr;}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}function _typeof(obj){"@babel/helpers - typeof";return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(obj){return typeof obj;}:function(obj){return obj&&"function"==typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;},_typeof(obj);}System.register(['./vue-legacy.js'],function(exports){'use strict';var registerRuntimeCompiler,runtimeDom,effectScope,ref,markRaw,getCurrentInstance,inject,watch,reactive,isRef,isReactive,toRaw,onUnmounted,nextTick,toRefs,computed;return{setters:[function(module){registerRuntimeCompiler=module.r;runtimeDom=module.a;effectScope=module.e;ref=module.b;markRaw=module.m;getCurrentInstance=module.g;inject=module.i;watch=module.w;reactive=module.c;isRef=module.d;isReactive=module.f;toRaw=module.t;onUnmounted=module.o;nextTick=module.n;toRefs=module.h;computed=module.j;}],execute:function execute(){var _helperNameMap,_registerRuntimeHelpe;exports({c:createPinia,d:defineStore});/**
             * Make a map and return a function for checking if a key
             * is in that map.
             * IMPORTANT: all calls of this function must be prefixed with
             * \/\*#\_\_PURE\_\_\*\/
             * So that rollup can tree-shake them if necessary.
             */function makeMap(str,expectsLowerCase){var map=Object.create(null);var list=str.split(',');for(var i=0;i<list.length;i++){map[list[i]]=true;}return expectsLowerCase?function(val){return!!map[val.toLowerCase()];}:function(val){return!!map[val];};}var listDelimiterRE=/;(?![^(]*\))/g;var propertyDelimiterRE=/:(.+)/;function parseStringStyle(cssText){var ret={};cssText.split(listDelimiterRE).forEach(function(item){if(item){var tmp=item.split(propertyDelimiterRE);tmp.length>1&&(ret[tmp[0].trim()]=tmp[1].trim());}});return ret;}// These tag configs are shared between compiler-dom and runtime-dom, so they
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element
var HTML_TAGS='html,body,base,head,link,meta,style,title,address,article,aside,footer,'+'header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,'+'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,'+'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,'+'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,'+'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,'+'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,'+'option,output,progress,select,textarea,details,dialog,menu,'+'summary,template,blockquote,iframe,tfoot';// https://developer.mozilla.org/en-US/docs/Web/SVG/Element
var SVG_TAGS='svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,'+'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,'+'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,'+'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,'+'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,'+'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,'+'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,'+'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,'+'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,'+'text,textPath,title,tspan,unknown,use,view';var VOID_TAGS='area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';/**
             * Compiler only.
             * Do NOT use in runtime code paths unless behind `("production" !== 'production')` flag.
             */var isHTMLTag=/*#__PURE__*/makeMap(HTML_TAGS);/**
             * Compiler only.
             * Do NOT use in runtime code paths unless behind `("production" !== 'production')` flag.
             */var isSVGTag=/*#__PURE__*/makeMap(SVG_TAGS);/**
             * Compiler only.
             * Do NOT use in runtime code paths unless behind `("production" !== 'production')` flag.
             */var isVoidTag=/*#__PURE__*/makeMap(VOID_TAGS);var EMPTY_OBJ={};var NOOP=function NOOP(){};/**
             * Always return false.
             */var NO=function NO(){return false;};var onRE=/^on[^a-z]/;var isOn=function isOn(key){return onRE.test(key);};var extend=Object.assign;var isArray=Array.isArray;var isString=function isString(val){return typeof val==='string';};var isSymbol=function isSymbol(val){return _typeof(val)==='symbol';};var isObject=function isObject(val){return val!==null&&_typeof(val)==='object';};var isReservedProp=/*#__PURE__*/makeMap(// the leading comma is intentional so empty string "" is also included
',key,ref,ref_for,ref_key,'+'onVnodeBeforeMount,onVnodeMounted,'+'onVnodeBeforeUpdate,onVnodeUpdated,'+'onVnodeBeforeUnmount,onVnodeUnmounted');var isBuiltInDirective=/*#__PURE__*/makeMap('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo');var cacheStringFunction$1=function cacheStringFunction$1(fn){var cache=Object.create(null);return function(str){var hit=cache[str];return hit||(cache[str]=fn(str));};};var camelizeRE$1=/-(\w)/g;/**
             * @private
             */var camelize$1=cacheStringFunction$1(function(str){return str.replace(camelizeRE$1,function(_,c){return c?c.toUpperCase():'';});});var hyphenateRE=/\B([A-Z])/g;/**
             * @private
             */var hyphenate=cacheStringFunction$1(function(str){return str.replace(hyphenateRE,'-$1').toLowerCase();});/**
             * @private
             */var capitalize=cacheStringFunction$1(function(str){return str.charAt(0).toUpperCase()+str.slice(1);});/**
             * @private
             */var toHandlerKey=cacheStringFunction$1(function(str){return str?"on".concat(capitalize(str)):"";});function defaultOnError(error){throw error;}function defaultOnWarn(msg){}function createCompilerError(code,loc,messages,additionalMessage){var msg=code;var error=new SyntaxError(String(msg));error.code=code;error.loc=loc;return error;}var FRAGMENT=Symbol("");var TELEPORT=Symbol("");var SUSPENSE=Symbol("");var KEEP_ALIVE=Symbol("");var BASE_TRANSITION=Symbol("");var OPEN_BLOCK=Symbol("");var CREATE_BLOCK=Symbol("");var CREATE_ELEMENT_BLOCK=Symbol("");var CREATE_VNODE=Symbol("");var CREATE_ELEMENT_VNODE=Symbol("");var CREATE_COMMENT=Symbol("");var CREATE_TEXT=Symbol("");var CREATE_STATIC=Symbol("");var RESOLVE_COMPONENT=Symbol("");var RESOLVE_DYNAMIC_COMPONENT=Symbol("");var RESOLVE_DIRECTIVE=Symbol("");var RESOLVE_FILTER=Symbol("");var WITH_DIRECTIVES=Symbol("");var RENDER_LIST=Symbol("");var RENDER_SLOT=Symbol("");var CREATE_SLOTS=Symbol("");var TO_DISPLAY_STRING=Symbol("");var MERGE_PROPS=Symbol("");var NORMALIZE_CLASS=Symbol("");var NORMALIZE_STYLE=Symbol("");var NORMALIZE_PROPS=Symbol("");var GUARD_REACTIVE_PROPS=Symbol("");var TO_HANDLERS=Symbol("");var CAMELIZE=Symbol("");var CAPITALIZE=Symbol("");var TO_HANDLER_KEY=Symbol("");var SET_BLOCK_TRACKING=Symbol("");var PUSH_SCOPE_ID=Symbol("");var POP_SCOPE_ID=Symbol("");var WITH_CTX=Symbol("");var UNREF=Symbol("");var IS_REF=Symbol("");var WITH_MEMO=Symbol("");var IS_MEMO_SAME=Symbol("");// Name mapping for runtime helpers that need to be imported from 'vue' in
// generated code. Make sure these are correctly exported in the runtime!
// Using `any` here because TS doesn't allow symbols as index type.
var helperNameMap=(_helperNameMap={},_defineProperty(_helperNameMap,FRAGMENT,"Fragment"),_defineProperty(_helperNameMap,TELEPORT,"Teleport"),_defineProperty(_helperNameMap,SUSPENSE,"Suspense"),_defineProperty(_helperNameMap,KEEP_ALIVE,"KeepAlive"),_defineProperty(_helperNameMap,BASE_TRANSITION,"BaseTransition"),_defineProperty(_helperNameMap,OPEN_BLOCK,"openBlock"),_defineProperty(_helperNameMap,CREATE_BLOCK,"createBlock"),_defineProperty(_helperNameMap,CREATE_ELEMENT_BLOCK,"createElementBlock"),_defineProperty(_helperNameMap,CREATE_VNODE,"createVNode"),_defineProperty(_helperNameMap,CREATE_ELEMENT_VNODE,"createElementVNode"),_defineProperty(_helperNameMap,CREATE_COMMENT,"createCommentVNode"),_defineProperty(_helperNameMap,CREATE_TEXT,"createTextVNode"),_defineProperty(_helperNameMap,CREATE_STATIC,"createStaticVNode"),_defineProperty(_helperNameMap,RESOLVE_COMPONENT,"resolveComponent"),_defineProperty(_helperNameMap,RESOLVE_DYNAMIC_COMPONENT,"resolveDynamicComponent"),_defineProperty(_helperNameMap,RESOLVE_DIRECTIVE,"resolveDirective"),_defineProperty(_helperNameMap,RESOLVE_FILTER,"resolveFilter"),_defineProperty(_helperNameMap,WITH_DIRECTIVES,"withDirectives"),_defineProperty(_helperNameMap,RENDER_LIST,"renderList"),_defineProperty(_helperNameMap,RENDER_SLOT,"renderSlot"),_defineProperty(_helperNameMap,CREATE_SLOTS,"createSlots"),_defineProperty(_helperNameMap,TO_DISPLAY_STRING,"toDisplayString"),_defineProperty(_helperNameMap,MERGE_PROPS,"mergeProps"),_defineProperty(_helperNameMap,NORMALIZE_CLASS,"normalizeClass"),_defineProperty(_helperNameMap,NORMALIZE_STYLE,"normalizeStyle"),_defineProperty(_helperNameMap,NORMALIZE_PROPS,"normalizeProps"),_defineProperty(_helperNameMap,GUARD_REACTIVE_PROPS,"guardReactiveProps"),_defineProperty(_helperNameMap,TO_HANDLERS,"toHandlers"),_defineProperty(_helperNameMap,CAMELIZE,"camelize"),_defineProperty(_helperNameMap,CAPITALIZE,"capitalize"),_defineProperty(_helperNameMap,TO_HANDLER_KEY,"toHandlerKey"),_defineProperty(_helperNameMap,SET_BLOCK_TRACKING,"setBlockTracking"),_defineProperty(_helperNameMap,PUSH_SCOPE_ID,"pushScopeId"),_defineProperty(_helperNameMap,POP_SCOPE_ID,"popScopeId"),_defineProperty(_helperNameMap,WITH_CTX,"withCtx"),_defineProperty(_helperNameMap,UNREF,"unref"),_defineProperty(_helperNameMap,IS_REF,"isRef"),_defineProperty(_helperNameMap,WITH_MEMO,"withMemo"),_defineProperty(_helperNameMap,IS_MEMO_SAME,"isMemoSame"),_helperNameMap);function registerRuntimeHelpers(helpers){Object.getOwnPropertySymbols(helpers).forEach(function(s){helperNameMap[s]=helpers[s];});}// AST Utilities ---------------------------------------------------------------
// Some expressions, e.g. sequence and conditional expressions, are never
// associated with template nodes, so their source locations are just a stub.
// Container types like CompoundExpression also don't need a real location.
var locStub={source:'',start:{line:1,column:1,offset:0},end:{line:1,column:1,offset:0}};function createRoot(children){var loc=arguments.length>1&&arguments[1]!==undefined?arguments[1]:locStub;return{type:0/* ROOT */,children:children,helpers:[],components:[],directives:[],hoists:[],imports:[],cached:0,temps:0,codegenNode:undefined,loc:loc};}function createVNodeCall(context,tag,props,children,patchFlag,dynamicProps,directives){var isBlock=arguments.length>7&&arguments[7]!==undefined?arguments[7]:false;var disableTracking=arguments.length>8&&arguments[8]!==undefined?arguments[8]:false;var isComponent=arguments.length>9&&arguments[9]!==undefined?arguments[9]:false;var loc=arguments.length>10&&arguments[10]!==undefined?arguments[10]:locStub;if(context){if(isBlock){context.helper(OPEN_BLOCK);context.helper(getVNodeBlockHelper(context.inSSR,isComponent));}else{context.helper(getVNodeHelper(context.inSSR,isComponent));}if(directives){context.helper(WITH_DIRECTIVES);}}return{type:13/* VNODE_CALL */,tag:tag,props:props,children:children,patchFlag:patchFlag,dynamicProps:dynamicProps,directives:directives,isBlock:isBlock,disableTracking:disableTracking,isComponent:isComponent,loc:loc};}function createArrayExpression(elements){var loc=arguments.length>1&&arguments[1]!==undefined?arguments[1]:locStub;return{type:17/* JS_ARRAY_EXPRESSION */,loc:loc,elements:elements};}function createObjectExpression(properties){var loc=arguments.length>1&&arguments[1]!==undefined?arguments[1]:locStub;return{type:15/* JS_OBJECT_EXPRESSION */,loc:loc,properties:properties};}function createObjectProperty(key,value){return{type:16/* JS_PROPERTY */,loc:locStub,key:isString(key)?createSimpleExpression(key,true):key,value:value};}function createSimpleExpression(content){var isStatic=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;var loc=arguments.length>2&&arguments[2]!==undefined?arguments[2]:locStub;var constType=arguments.length>3&&arguments[3]!==undefined?arguments[3]:0;return{type:4/* SIMPLE_EXPRESSION */,loc:loc,content:content,isStatic:isStatic,constType:isStatic?3/* CAN_STRINGIFY */:constType};}function createCompoundExpression(children){var loc=arguments.length>1&&arguments[1]!==undefined?arguments[1]:locStub;return{type:8/* COMPOUND_EXPRESSION */,loc:loc,children:children};}function createCallExpression(callee){var args=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];var loc=arguments.length>2&&arguments[2]!==undefined?arguments[2]:locStub;return{type:14/* JS_CALL_EXPRESSION */,loc:loc,callee:callee,arguments:args};}function createFunctionExpression(params){var returns=arguments.length>1&&arguments[1]!==undefined?arguments[1]:undefined;var newline=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;var isSlot=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;var loc=arguments.length>4&&arguments[4]!==undefined?arguments[4]:locStub;return{type:18/* JS_FUNCTION_EXPRESSION */,params:params,returns:returns,newline:newline,isSlot:isSlot,loc:loc};}function createConditionalExpression(test,consequent,alternate){var newline=arguments.length>3&&arguments[3]!==undefined?arguments[3]:true;return{type:19/* JS_CONDITIONAL_EXPRESSION */,test:test,consequent:consequent,alternate:alternate,newline:newline,loc:locStub};}function createCacheExpression(index,value){var isVNode=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;return{type:20/* JS_CACHE_EXPRESSION */,index:index,value:value,isVNode:isVNode,loc:locStub};}function createBlockStatement(body){return{type:21/* JS_BLOCK_STATEMENT */,body:body,loc:locStub};}var isStaticExp=function isStaticExp(p){return p.type===4/* SIMPLE_EXPRESSION */&&p.isStatic;};var isBuiltInType=function isBuiltInType(tag,expected){return tag===expected||tag===hyphenate(expected);};function isCoreComponent(tag){if(isBuiltInType(tag,'Teleport')){return TELEPORT;}else if(isBuiltInType(tag,'Suspense')){return SUSPENSE;}else if(isBuiltInType(tag,'KeepAlive')){return KEEP_ALIVE;}else if(isBuiltInType(tag,'BaseTransition')){return BASE_TRANSITION;}}var nonIdentifierRE=/^\d|[^\$\w]/;var isSimpleIdentifier=function isSimpleIdentifier(name){return!nonIdentifierRE.test(name);};var validFirstIdentCharRE=/[A-Za-z_$\xA0-\uFFFF]/;var validIdentCharRE=/[\.\?\w$\xA0-\uFFFF]/;var whitespaceRE=/\s+[.[]\s*|\s*[.[]\s+/g;/**
             * Simple lexer to check if an expression is a member expression. This is
             * lax and only checks validity at the root level (i.e. does not validate exps
             * inside square brackets), but it's ok since these are only used on template
             * expressions and false positives are invalid expressions in the first place.
             */var isMemberExpressionBrowser=function isMemberExpressionBrowser(path){// remove whitespaces around . or [ first
path=path.trim().replace(whitespaceRE,function(s){return s.trim();});var state=0/* inMemberExp */;var stateStack=[];var currentOpenBracketCount=0;var currentOpenParensCount=0;var currentStringType=null;for(var i=0;i<path.length;i++){var char=path.charAt(i);switch(state){case 0/* inMemberExp */:if(char==='['){stateStack.push(state);state=1/* inBrackets */;currentOpenBracketCount++;}else if(char==='('){stateStack.push(state);state=2/* inParens */;currentOpenParensCount++;}else if(!(i===0?validFirstIdentCharRE:validIdentCharRE).test(char)){return false;}break;case 1/* inBrackets */:if(char==="'"||char==="\""||char==='`'){stateStack.push(state);state=3/* inString */;currentStringType=char;}else if(char==="["){currentOpenBracketCount++;}else if(char==="]"){if(! --currentOpenBracketCount){state=stateStack.pop();}}break;case 2/* inParens */:if(char==="'"||char==="\""||char==='`'){stateStack.push(state);state=3/* inString */;currentStringType=char;}else if(char==="("){currentOpenParensCount++;}else if(char===")"){// if the exp ends as a call then it should not be considered valid
if(i===path.length-1){return false;}if(! --currentOpenParensCount){state=stateStack.pop();}}break;case 3/* inString */:if(char===currentStringType){state=stateStack.pop();currentStringType=null;}break;}}return!currentOpenBracketCount&&!currentOpenParensCount;};var isMemberExpression=isMemberExpressionBrowser;function getInnerRange(loc,offset,length){var source=loc.source.slice(offset,offset+length);var newLoc={source:source,start:advancePositionWithClone(loc.start,loc.source,offset),end:loc.end};if(length!=null){newLoc.end=advancePositionWithClone(loc.start,loc.source,offset+length);}return newLoc;}function advancePositionWithClone(pos,source){var numberOfCharacters=arguments.length>2&&arguments[2]!==undefined?arguments[2]:source.length;return advancePositionWithMutation(extend({},pos),source,numberOfCharacters);}// advance by mutation without cloning (for performance reasons), since this
// gets called a lot in the parser
function advancePositionWithMutation(pos,source){var numberOfCharacters=arguments.length>2&&arguments[2]!==undefined?arguments[2]:source.length;var linesCount=0;var lastNewLinePos=-1;for(var i=0;i<numberOfCharacters;i++){if(source.charCodeAt(i)===10/* newline char code */){linesCount++;lastNewLinePos=i;}}pos.offset+=numberOfCharacters;pos.line+=linesCount;pos.column=lastNewLinePos===-1?pos.column+numberOfCharacters:numberOfCharacters-lastNewLinePos;return pos;}function findDir(node,name){var allowEmpty=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;for(var i=0;i<node.props.length;i++){var p=node.props[i];if(p.type===7/* DIRECTIVE */&&(allowEmpty||p.exp)&&(isString(name)?p.name===name:name.test(p.name))){return p;}}}function findProp(node,name){var dynamicOnly=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;var allowEmpty=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;for(var i=0;i<node.props.length;i++){var p=node.props[i];if(p.type===6/* ATTRIBUTE */){if(dynamicOnly)continue;if(p.name===name&&(p.value||allowEmpty)){return p;}}else if(p.name==='bind'&&(p.exp||allowEmpty)&&isStaticArgOf(p.arg,name)){return p;}}}function isStaticArgOf(arg,name){return!!(arg&&isStaticExp(arg)&&arg.content===name);}function hasDynamicKeyVBind(node){return node.props.some(function(p){return p.type===7/* DIRECTIVE */&&p.name==='bind'&&(!p.arg||// v-bind="obj"
p.arg.type!==4/* SIMPLE_EXPRESSION */||// v-bind:[_ctx.foo]
!p.arg.isStatic);}// v-bind:[foo]
);}function isText(node){return node.type===5/* INTERPOLATION */||node.type===2/* TEXT */;}function isVSlot(p){return p.type===7/* DIRECTIVE */&&p.name==='slot';}function isTemplateNode(node){return node.type===1/* ELEMENT */&&node.tagType===3/* TEMPLATE */;}function isSlotOutlet(node){return node.type===1/* ELEMENT */&&node.tagType===2/* SLOT */;}function getVNodeHelper(ssr,isComponent){return ssr||isComponent?CREATE_VNODE:CREATE_ELEMENT_VNODE;}function getVNodeBlockHelper(ssr,isComponent){return ssr||isComponent?CREATE_BLOCK:CREATE_ELEMENT_BLOCK;}var propsHelperSet=new Set([NORMALIZE_PROPS,GUARD_REACTIVE_PROPS]);function getUnnormalizedProps(props){var callPath=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];if(props&&!isString(props)&&props.type===14/* JS_CALL_EXPRESSION */){var callee=props.callee;if(!isString(callee)&&propsHelperSet.has(callee)){return getUnnormalizedProps(props.arguments[0],callPath.concat(props));}}return[props,callPath];}function injectProp(node,prop,context){var propsWithInjection;/**
                 * 1. mergeProps(...)
                 * 2. toHandlers(...)
                 * 3. normalizeProps(...)
                 * 4. normalizeProps(guardReactiveProps(...))
                 *
                 * we need to get the real props before normalization
                 */var props=node.type===13/* VNODE_CALL */?node.props:node.arguments[2];var callPath=[];var parentCall;if(props&&!isString(props)&&props.type===14/* JS_CALL_EXPRESSION */){var ret=getUnnormalizedProps(props);props=ret[0];callPath=ret[1];parentCall=callPath[callPath.length-1];}if(props==null||isString(props)){propsWithInjection=createObjectExpression([prop]);}else if(props.type===14/* JS_CALL_EXPRESSION */){// merged props... add ours
// only inject key to object literal if it's the first argument so that
// if doesn't override user provided keys
var first=props.arguments[0];if(!isString(first)&&first.type===15/* JS_OBJECT_EXPRESSION */){first.properties.unshift(prop);}else{if(props.callee===TO_HANDLERS){// #2366
propsWithInjection=createCallExpression(context.helper(MERGE_PROPS),[createObjectExpression([prop]),props]);}else{props.arguments.unshift(createObjectExpression([prop]));}}!propsWithInjection&&(propsWithInjection=props);}else if(props.type===15/* JS_OBJECT_EXPRESSION */){var alreadyExists=false;// check existing key to avoid overriding user provided keys
if(prop.key.type===4/* SIMPLE_EXPRESSION */){var propKeyName=prop.key.content;alreadyExists=props.properties.some(function(p){return p.key.type===4/* SIMPLE_EXPRESSION */&&p.key.content===propKeyName;});}if(!alreadyExists){props.properties.unshift(prop);}propsWithInjection=props;}else{// single v-bind with expression, return a merged replacement
propsWithInjection=createCallExpression(context.helper(MERGE_PROPS),[createObjectExpression([prop]),props]);// in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(props))`,
// it will be rewritten as `normalizeProps(mergeProps({ key: 0 }, props))`,
// the `guardReactiveProps` will no longer be needed
if(parentCall&&parentCall.callee===GUARD_REACTIVE_PROPS){parentCall=callPath[callPath.length-2];}}if(node.type===13/* VNODE_CALL */){if(parentCall){parentCall.arguments[0]=propsWithInjection;}else{node.props=propsWithInjection;}}else{if(parentCall){parentCall.arguments[0]=propsWithInjection;}else{node.arguments[2]=propsWithInjection;}}}function toValidAssetId(name,type){// see issue#4422, we need adding identifier on validAssetId if variable `name` has specific character
return"_".concat(type,"_").concat(name.replace(/[^\w]/g,function(searchValue,replaceValue){return searchValue==='-'?'_':name.charCodeAt(replaceValue).toString();}));}function getMemoedVNodeCall(node){if(node.type===14/* JS_CALL_EXPRESSION */&&node.callee===WITH_MEMO){return node.arguments[1].returns;}else{return node;}}function makeBlock(node,_ref){var helper=_ref.helper,removeHelper=_ref.removeHelper,inSSR=_ref.inSSR;if(!node.isBlock){node.isBlock=true;removeHelper(getVNodeHelper(inSSR,node.isComponent));helper(OPEN_BLOCK);helper(getVNodeBlockHelper(inSSR,node.isComponent));}}function getCompatValue(key,context){var config=context.options?context.options.compatConfig:context.compatConfig;var value=config&&config[key];if(key==='MODE'){return value||3;// compiler defaults to v3 behavior
}else{return value;}}function isCompatEnabled(key,context){var mode=getCompatValue('MODE',context);var value=getCompatValue(key,context);// in v3 mode, only enable if explicitly set to true
// otherwise enable for any non-false value
return mode===3?value===true:value!==false;}function checkCompatEnabled(key,context,loc){var enabled=isCompatEnabled(key,context);return enabled;}// The default decoder only provides escapes for characters reserved as part of
// the template syntax, and is only used if the custom renderer did not provide
// a platform-specific decoder.
var decodeRE=/&(gt|lt|amp|apos|quot);/g;var decodeMap={gt:'>',lt:'<',amp:'&',apos:"'",quot:'"'};var defaultParserOptions={delimiters:["{{","}}"],getNamespace:function getNamespace(){return 0;}/* HTML */,getTextMode:function getTextMode(){return 0;}/* DATA */,isVoidTag:NO,isPreTag:NO,isCustomElement:NO,decodeEntities:function decodeEntities(rawText){return rawText.replace(decodeRE,function(_,p1){return decodeMap[p1];});},onError:defaultOnError,onWarn:defaultOnWarn,comments:"production"!=='production'};function baseParse(content){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var context=createParserContext(content,options);var start=getCursor(context);return createRoot(parseChildren(context,0/* DATA */,[]),getSelection(context,start));}function createParserContext(content,rawOptions){var options=extend({},defaultParserOptions);var key;for(key in rawOptions){// @ts-ignore
options[key]=rawOptions[key]===undefined?defaultParserOptions[key]:rawOptions[key];}return{options:options,column:1,line:1,offset:0,originalSource:content,source:content,inPre:false,inVPre:false,onWarn:options.onWarn};}function parseChildren(context,mode,ancestors){var parent=last(ancestors);var ns=parent?parent.ns:0/* HTML */;var nodes=[];while(!isEnd(context,mode,ancestors)){var s=context.source;var node=undefined;if(mode===0/* DATA */||mode===1/* RCDATA */){if(!context.inVPre&&startsWith(s,context.options.delimiters[0])){// '{{'
node=parseInterpolation(context,mode);}else if(mode===0/* DATA */&&s[0]==='<'){// https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state
if(s.length===1){emitError(context,5/* EOF_BEFORE_TAG_NAME */,1);}else if(s[1]==='!'){// https://html.spec.whatwg.org/multipage/parsing.html#markup-declaration-open-state
if(startsWith(s,'<!--')){node=parseComment(context);}else if(startsWith(s,'<!DOCTYPE')){// Ignore DOCTYPE by a limitation.
node=parseBogusComment(context);}else if(startsWith(s,'<![CDATA[')){if(ns!==0/* HTML */){node=parseCDATA(context,ancestors);}else{emitError(context,1/* CDATA_IN_HTML_CONTENT */);node=parseBogusComment(context);}}else{emitError(context,11/* INCORRECTLY_OPENED_COMMENT */);node=parseBogusComment(context);}}else if(s[1]==='/'){// https://html.spec.whatwg.org/multipage/parsing.html#end-tag-open-state
if(s.length===2){emitError(context,5/* EOF_BEFORE_TAG_NAME */,2);}else if(s[2]==='>'){emitError(context,14/* MISSING_END_TAG_NAME */,2);advanceBy(context,3);continue;}else if(/[a-z]/i.test(s[2])){emitError(context,23/* X_INVALID_END_TAG */);parseTag(context,1/* End */,parent);continue;}else{emitError(context,12/* INVALID_FIRST_CHARACTER_OF_TAG_NAME */,2);node=parseBogusComment(context);}}else if(/[a-z]/i.test(s[1])){node=parseElement(context,ancestors);// 2.x <template> with no directive compat
if(isCompatEnabled("COMPILER_NATIVE_TEMPLATE"/* COMPILER_NATIVE_TEMPLATE */,context)&&node&&node.tag==='template'&&!node.props.some(function(p){return p.type===7/* DIRECTIVE */&&isSpecialTemplateDirective(p.name);})){node=node.children;}}else if(s[1]==='?'){emitError(context,21/* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */,1);node=parseBogusComment(context);}else{emitError(context,12/* INVALID_FIRST_CHARACTER_OF_TAG_NAME */,1);}}}if(!node){node=parseText(context,mode);}if(isArray(node)){for(var i=0;i<node.length;i++){pushNode(nodes,node[i]);}}else{pushNode(nodes,node);}}// Whitespace handling strategy like v2
var removedWhitespace=false;if(mode!==2/* RAWTEXT */&&mode!==1/* RCDATA */){var shouldCondense=context.options.whitespace!=='preserve';for(var _i=0;_i<nodes.length;_i++){var _node2=nodes[_i];if(!context.inPre&&_node2.type===2/* TEXT */){if(!/[^\t\r\n\f ]/.test(_node2.content)){var prev=nodes[_i-1];var next=nodes[_i+1];// Remove if:
// - the whitespace is the first or last node, or:
// - (condense mode) the whitespace is adjacent to a comment, or:
// - (condense mode) the whitespace is between two elements AND contains newline
if(!prev||!next||shouldCondense&&(prev.type===3/* COMMENT */||next.type===3/* COMMENT */||prev.type===1/* ELEMENT */&&next.type===1/* ELEMENT */&&/[\r\n]/.test(_node2.content))){removedWhitespace=true;nodes[_i]=null;}else{// Otherwise, the whitespace is condensed into a single space
_node2.content=' ';}}else if(shouldCondense){// in condense mode, consecutive whitespaces in text are condensed
// down to a single space.
_node2.content=_node2.content.replace(/[\t\r\n\f ]+/g,' ');}}// Remove comment nodes if desired by configuration.
else if(_node2.type===3/* COMMENT */&&!context.options.comments){removedWhitespace=true;nodes[_i]=null;}}if(context.inPre&&parent&&context.options.isPreTag(parent.tag)){// remove leading newline per html spec
// https://html.spec.whatwg.org/multipage/grouping-content.html#the-pre-element
var first=nodes[0];if(first&&first.type===2/* TEXT */){first.content=first.content.replace(/^\r?\n/,'');}}}return removedWhitespace?nodes.filter(Boolean):nodes;}function pushNode(nodes,node){if(node.type===2/* TEXT */){var prev=last(nodes);// Merge if both this and the previous node are text and those are
// consecutive. This happens for cases like "a < b".
if(prev&&prev.type===2/* TEXT */&&prev.loc.end.offset===node.loc.start.offset){prev.content+=node.content;prev.loc.end=node.loc.end;prev.loc.source+=node.loc.source;return;}}nodes.push(node);}function parseCDATA(context,ancestors){advanceBy(context,9);var nodes=parseChildren(context,3/* CDATA */,ancestors);if(context.source.length===0){emitError(context,6/* EOF_IN_CDATA */);}else{advanceBy(context,3);}return nodes;}function parseComment(context){var start=getCursor(context);var content;// Regular comment.
var match=/--(\!)?>/.exec(context.source);if(!match){content=context.source.slice(4);advanceBy(context,context.source.length);emitError(context,7/* EOF_IN_COMMENT */);}else{if(match.index<=3){emitError(context,0/* ABRUPT_CLOSING_OF_EMPTY_COMMENT */);}if(match[1]){emitError(context,10/* INCORRECTLY_CLOSED_COMMENT */);}content=context.source.slice(4,match.index);// Advancing with reporting nested comments.
var s=context.source.slice(0,match.index);var prevIndex=1,nestedIndex=0;while((nestedIndex=s.indexOf('<!--',prevIndex))!==-1){advanceBy(context,nestedIndex-prevIndex+1);if(nestedIndex+4<s.length){emitError(context,16/* NESTED_COMMENT */);}prevIndex=nestedIndex+1;}advanceBy(context,match.index+match[0].length-prevIndex+1);}return{type:3/* COMMENT */,content:content,loc:getSelection(context,start)};}function parseBogusComment(context){var start=getCursor(context);var contentStart=context.source[1]==='?'?1:2;var content;var closeIndex=context.source.indexOf('>');if(closeIndex===-1){content=context.source.slice(contentStart);advanceBy(context,context.source.length);}else{content=context.source.slice(contentStart,closeIndex);advanceBy(context,closeIndex+1);}return{type:3/* COMMENT */,content:content,loc:getSelection(context,start)};}function parseElement(context,ancestors){// Start tag.
var wasInPre=context.inPre;var wasInVPre=context.inVPre;var parent=last(ancestors);var element=parseTag(context,0/* Start */,parent);var isPreBoundary=context.inPre&&!wasInPre;var isVPreBoundary=context.inVPre&&!wasInVPre;if(element.isSelfClosing||context.options.isVoidTag(element.tag)){// #4030 self-closing <pre> tag
if(isPreBoundary){context.inPre=false;}if(isVPreBoundary){context.inVPre=false;}return element;}// Children.
ancestors.push(element);var mode=context.options.getTextMode(element,parent);var children=parseChildren(context,mode,ancestors);ancestors.pop();// 2.x inline-template compat
{var inlineTemplateProp=element.props.find(function(p){return p.type===6/* ATTRIBUTE */&&p.name==='inline-template';});if(inlineTemplateProp&&checkCompatEnabled("COMPILER_INLINE_TEMPLATE"/* COMPILER_INLINE_TEMPLATE */,context,inlineTemplateProp.loc)){var loc=getSelection(context,element.loc.end);inlineTemplateProp.value={type:2/* TEXT */,content:loc.source,loc:loc};}}element.children=children;// End tag.
if(startsWithEndTagOpen(context.source,element.tag)){parseTag(context,1/* End */,parent);}else{emitError(context,24/* X_MISSING_END_TAG */,0,element.loc.start);if(context.source.length===0&&element.tag.toLowerCase()==='script'){var first=children[0];if(first&&startsWith(first.loc.source,'<!--')){emitError(context,8/* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */);}}}element.loc=getSelection(context,element.loc.start);if(isPreBoundary){context.inPre=false;}if(isVPreBoundary){context.inVPre=false;}return element;}var isSpecialTemplateDirective=/*#__PURE__*/makeMap("if,else,else-if,for,slot");function parseTag(context,type,parent){// Tag open.
var start=getCursor(context);var match=/^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source);var tag=match[1];var ns=context.options.getNamespace(tag,parent);advanceBy(context,match[0].length);advanceSpaces(context);// save current state in case we need to re-parse attributes with v-pre
var cursor=getCursor(context);var currentSource=context.source;// check <pre> tag
if(context.options.isPreTag(tag)){context.inPre=true;}// Attributes.
var props=parseAttributes(context,type);// check v-pre
if(type===0/* Start */&&!context.inVPre&&props.some(function(p){return p.type===7/* DIRECTIVE */&&p.name==='pre';})){context.inVPre=true;// reset context
extend(context,cursor);context.source=currentSource;// re-parse attrs and filter out v-pre itself
props=parseAttributes(context,type).filter(function(p){return p.name!=='v-pre';});}// Tag close.
var isSelfClosing=false;if(context.source.length===0){emitError(context,9/* EOF_IN_TAG */);}else{isSelfClosing=startsWith(context.source,'/>');if(type===1/* End */&&isSelfClosing){emitError(context,4/* END_TAG_WITH_TRAILING_SOLIDUS */);}advanceBy(context,isSelfClosing?2:1);}if(type===1/* End */){return;}var tagType=0/* ELEMENT */;if(!context.inVPre){if(tag==='slot'){tagType=2/* SLOT */;}else if(tag==='template'){if(props.some(function(p){return p.type===7/* DIRECTIVE */&&isSpecialTemplateDirective(p.name);})){tagType=3/* TEMPLATE */;}}else if(isComponent(tag,props,context)){tagType=1/* COMPONENT */;}}return{type:1/* ELEMENT */,ns:ns,tag:tag,tagType:tagType,props:props,isSelfClosing:isSelfClosing,children:[],loc:getSelection(context,start),codegenNode:undefined// to be created during transform phase
};}function isComponent(tag,props,context){var options=context.options;if(options.isCustomElement(tag)){return false;}if(tag==='component'||/^[A-Z]/.test(tag)||isCoreComponent(tag)||options.isBuiltInComponent&&options.isBuiltInComponent(tag)||options.isNativeTag&&!options.isNativeTag(tag)){return true;}// at this point the tag should be a native tag, but check for potential "is"
// casting
for(var i=0;i<props.length;i++){var p=props[i];if(p.type===6/* ATTRIBUTE */){if(p.name==='is'&&p.value){if(p.value.content.startsWith('vue:')){return true;}else if(checkCompatEnabled("COMPILER_IS_ON_ELEMENT"/* COMPILER_IS_ON_ELEMENT */,context,p.loc)){return true;}}}else{// directive
// v-is (TODO Deprecate)
if(p.name==='is'){return true;}else if(// :is on plain element - only treat as component in compat mode
p.name==='bind'&&isStaticArgOf(p.arg,'is')&&true&&checkCompatEnabled("COMPILER_IS_ON_ELEMENT"/* COMPILER_IS_ON_ELEMENT */,context,p.loc)){return true;}}}}function parseAttributes(context,type){var props=[];var attributeNames=new Set();while(context.source.length>0&&!startsWith(context.source,'>')&&!startsWith(context.source,'/>')){if(startsWith(context.source,'/')){emitError(context,22/* UNEXPECTED_SOLIDUS_IN_TAG */);advanceBy(context,1);advanceSpaces(context);continue;}if(type===1/* End */){emitError(context,3/* END_TAG_WITH_ATTRIBUTES */);}var attr=parseAttribute(context,attributeNames);// Trim whitespace between class
// https://github.com/vuejs/core/issues/4251
if(attr.type===6/* ATTRIBUTE */&&attr.value&&attr.name==='class'){attr.value.content=attr.value.content.replace(/\s+/g,' ').trim();}if(type===0/* Start */){props.push(attr);}if(/^[^\t\r\n\f />]/.test(context.source)){emitError(context,15/* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */);}advanceSpaces(context);}return props;}function parseAttribute(context,nameSet){// Name.
var start=getCursor(context);var match=/^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context.source);var name=match[0];if(nameSet.has(name)){emitError(context,2/* DUPLICATE_ATTRIBUTE */);}nameSet.add(name);if(name[0]==='='){emitError(context,19/* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */);}{var pattern=/["'<]/g;var m;while(m=pattern.exec(name)){emitError(context,17/* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */,m.index);}}advanceBy(context,name.length);// Value
var value=undefined;if(/^[\t\r\n\f ]*=/.test(context.source)){advanceSpaces(context);advanceBy(context,1);advanceSpaces(context);value=parseAttributeValue(context);if(!value){emitError(context,13/* MISSING_ATTRIBUTE_VALUE */);}}var loc=getSelection(context,start);if(!context.inVPre&&/^(v-[A-Za-z0-9-]|:|\.|@|#)/.test(name)){var _match=/(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(name);var isPropShorthand=startsWith(name,'.');var dirName=_match[1]||(isPropShorthand||startsWith(name,':')?'bind':startsWith(name,'@')?'on':'slot');var arg;if(_match[2]){var isSlot=dirName==='slot';var startOffset=name.lastIndexOf(_match[2]);var _loc=getSelection(context,getNewPosition(context,start,startOffset),getNewPosition(context,start,startOffset+_match[2].length+(isSlot&&_match[3]||'').length));var content=_match[2];var isStatic=true;if(content.startsWith('[')){isStatic=false;if(!content.endsWith(']')){emitError(context,27/* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */);content=content.slice(1);}else{content=content.slice(1,content.length-1);}}else if(isSlot){// #1241 special case for v-slot: vuetify relies extensively on slot
// names containing dots. v-slot doesn't have any modifiers and Vue 2.x
// supports such usage so we are keeping it consistent with 2.x.
content+=_match[3]||'';}arg={type:4/* SIMPLE_EXPRESSION */,content:content,isStatic:isStatic,constType:isStatic?3/* CAN_STRINGIFY */:0/* NOT_CONSTANT */,loc:_loc};}if(value&&value.isQuoted){var valueLoc=value.loc;valueLoc.start.offset++;valueLoc.start.column++;valueLoc.end=advancePositionWithClone(valueLoc.start,value.content);valueLoc.source=valueLoc.source.slice(1,-1);}var modifiers=_match[3]?_match[3].slice(1).split('.'):[];if(isPropShorthand)modifiers.push('prop');// 2.x compat v-bind:foo.sync -> v-model:foo
if(dirName==='bind'&&arg){if(modifiers.includes('sync')&&checkCompatEnabled("COMPILER_V_BIND_SYNC"/* COMPILER_V_BIND_SYNC */,context,loc,arg.loc.source)){dirName='model';modifiers.splice(modifiers.indexOf('sync'),1);}}return{type:7/* DIRECTIVE */,name:dirName,exp:value&&{type:4/* SIMPLE_EXPRESSION */,content:value.content,isStatic:false,// Treat as non-constant by default. This can be potentially set to
// other values by `transformExpression` to make it eligible for hoisting.
constType:0/* NOT_CONSTANT */,loc:value.loc},arg:arg,modifiers:modifiers,loc:loc};}// missing directive name or illegal directive name
if(!context.inVPre&&startsWith(name,'v-')){emitError(context,26/* X_MISSING_DIRECTIVE_NAME */);}return{type:6/* ATTRIBUTE */,name:name,value:value&&{type:2/* TEXT */,content:value.content,loc:value.loc},loc:loc};}function parseAttributeValue(context){var start=getCursor(context);var content;var quote=context.source[0];var isQuoted=quote==="\""||quote==="'";if(isQuoted){// Quoted value.
advanceBy(context,1);var endIndex=context.source.indexOf(quote);if(endIndex===-1){content=parseTextData(context,context.source.length,4/* ATTRIBUTE_VALUE */);}else{content=parseTextData(context,endIndex,4/* ATTRIBUTE_VALUE */);advanceBy(context,1);}}else{// Unquoted
var match=/^[^\t\r\n\f >]+/.exec(context.source);if(!match){return undefined;}var unexpectedChars=/["'<=`]/g;var m;while(m=unexpectedChars.exec(match[0])){emitError(context,18/* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */,m.index);}content=parseTextData(context,match[0].length,4/* ATTRIBUTE_VALUE */);}return{content:content,isQuoted:isQuoted,loc:getSelection(context,start)};}function parseInterpolation(context,mode){var _context$options$deli=_slicedToArray(context.options.delimiters,2),open=_context$options$deli[0],close=_context$options$deli[1];var closeIndex=context.source.indexOf(close,open.length);if(closeIndex===-1){emitError(context,25/* X_MISSING_INTERPOLATION_END */);return undefined;}var start=getCursor(context);advanceBy(context,open.length);var innerStart=getCursor(context);var innerEnd=getCursor(context);var rawContentLength=closeIndex-open.length;var rawContent=context.source.slice(0,rawContentLength);var preTrimContent=parseTextData(context,rawContentLength,mode);var content=preTrimContent.trim();var startOffset=preTrimContent.indexOf(content);if(startOffset>0){advancePositionWithMutation(innerStart,rawContent,startOffset);}var endOffset=rawContentLength-(preTrimContent.length-content.length-startOffset);advancePositionWithMutation(innerEnd,rawContent,endOffset);advanceBy(context,close.length);return{type:5/* INTERPOLATION */,content:{type:4/* SIMPLE_EXPRESSION */,isStatic:false,// Set `isConstant` to false by default and will decide in transformExpression
constType:0/* NOT_CONSTANT */,content:content,loc:getSelection(context,innerStart,innerEnd)},loc:getSelection(context,start)};}function parseText(context,mode){var endTokens=mode===3/* CDATA */?[']]>']:['<',context.options.delimiters[0]];var endIndex=context.source.length;for(var i=0;i<endTokens.length;i++){var index=context.source.indexOf(endTokens[i],1);if(index!==-1&&endIndex>index){endIndex=index;}}var start=getCursor(context);var content=parseTextData(context,endIndex,mode);return{type:2/* TEXT */,content:content,loc:getSelection(context,start)};}/**
             * Get text data with a given length from the current location.
             * This translates HTML entities in the text data.
             */function parseTextData(context,length,mode){var rawText=context.source.slice(0,length);advanceBy(context,length);if(mode===2/* RAWTEXT */||mode===3/* CDATA */||!rawText.includes('&')){return rawText;}else{// DATA or RCDATA containing "&"". Entity decoding required.
return context.options.decodeEntities(rawText,mode===4/* ATTRIBUTE_VALUE */);}}function getCursor(context){var column=context.column,line=context.line,offset=context.offset;return{column:column,line:line,offset:offset};}function getSelection(context,start,end){end=end||getCursor(context);return{start:start,end:end,source:context.originalSource.slice(start.offset,end.offset)};}function last(xs){return xs[xs.length-1];}function startsWith(source,searchString){return source.startsWith(searchString);}function advanceBy(context,numberOfCharacters){var source=context.source;advancePositionWithMutation(context,source,numberOfCharacters);context.source=source.slice(numberOfCharacters);}function advanceSpaces(context){var match=/^[\t\r\n\f ]+/.exec(context.source);if(match){advanceBy(context,match[0].length);}}function getNewPosition(context,start,numberOfCharacters){return advancePositionWithClone(start,context.originalSource.slice(start.offset,numberOfCharacters),numberOfCharacters);}function emitError(context,code,offset){var loc=arguments.length>3&&arguments[3]!==undefined?arguments[3]:getCursor(context);if(offset){loc.offset+=offset;loc.column+=offset;}context.options.onError(createCompilerError(code,{start:loc,end:loc,source:''}));}function isEnd(context,mode,ancestors){var s=context.source;switch(mode){case 0/* DATA */:if(startsWith(s,'</')){// TODO: probably bad performance
for(var i=ancestors.length-1;i>=0;--i){if(startsWithEndTagOpen(s,ancestors[i].tag)){return true;}}}break;case 1/* RCDATA */:case 2/* RAWTEXT */:{var parent=last(ancestors);if(parent&&startsWithEndTagOpen(s,parent.tag)){return true;}break;}case 3/* CDATA */:if(startsWith(s,']]>')){return true;}break;}return!s;}function startsWithEndTagOpen(source,tag){return startsWith(source,'</')&&source.slice(2,2+tag.length).toLowerCase()===tag.toLowerCase()&&/[\t\r\n\f />]/.test(source[2+tag.length]||'>');}function hoistStatic(root,context){walk(root,context,// Root node is unfortunately non-hoistable due to potential parent
// fallthrough attributes.
isSingleElementRoot(root,root.children[0]));}function isSingleElementRoot(root,child){var children=root.children;return children.length===1&&child.type===1/* ELEMENT */&&!isSlotOutlet(child);}function walk(node,context){var doNotHoistNode=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;var children=node.children;var originalCount=children.length;var hoistedCount=0;for(var i=0;i<children.length;i++){var child=children[i];// only plain elements & text calls are eligible for hoisting.
if(child.type===1/* ELEMENT */&&child.tagType===0/* ELEMENT */){var constantType=doNotHoistNode?0/* NOT_CONSTANT */:getConstantType(child,context);if(constantType>0/* NOT_CONSTANT */){if(constantType>=2/* CAN_HOIST */){child.codegenNode.patchFlag=-1/* HOISTED */+"";child.codegenNode=context.hoist(child.codegenNode);hoistedCount++;continue;}}else{// node may contain dynamic children, but its props may be eligible for
// hoisting.
var codegenNode=child.codegenNode;if(codegenNode.type===13/* VNODE_CALL */){var flag=getPatchFlag(codegenNode);if((!flag||flag===512/* NEED_PATCH */||flag===1/* TEXT */)&&getGeneratedPropsConstantType(child,context)>=2/* CAN_HOIST */){var props=getNodeProps(child);if(props){codegenNode.props=context.hoist(props);}}if(codegenNode.dynamicProps){codegenNode.dynamicProps=context.hoist(codegenNode.dynamicProps);}}}}else if(child.type===12/* TEXT_CALL */&&getConstantType(child.content,context)>=2/* CAN_HOIST */){child.codegenNode=context.hoist(child.codegenNode);hoistedCount++;}// walk further
if(child.type===1/* ELEMENT */){var _isComponent=child.tagType===1/* COMPONENT */;if(_isComponent){context.scopes.vSlot++;}walk(child,context);if(_isComponent){context.scopes.vSlot--;}}else if(child.type===11/* FOR */){// Do not hoist v-for single child because it has to be a block
walk(child,context,child.children.length===1);}else if(child.type===9/* IF */){for(var _i2=0;_i2<child.branches.length;_i2++){// Do not hoist v-if single child because it has to be a block
walk(child.branches[_i2],context,child.branches[_i2].children.length===1);}}}if(hoistedCount&&context.transformHoist){context.transformHoist(children,context,node);}// all children were hoisted - the entire children array is hoistable.
if(hoistedCount&&hoistedCount===originalCount&&node.type===1/* ELEMENT */&&node.tagType===0/* ELEMENT */&&node.codegenNode&&node.codegenNode.type===13/* VNODE_CALL */&&isArray(node.codegenNode.children)){node.codegenNode.children=context.hoist(createArrayExpression(node.codegenNode.children));}}function getConstantType(node,context){var constantCache=context.constantCache;switch(node.type){case 1/* ELEMENT */:if(node.tagType!==0/* ELEMENT */){return 0/* NOT_CONSTANT */;}var cached=constantCache.get(node);if(cached!==undefined){return cached;}var codegenNode=node.codegenNode;if(codegenNode.type!==13/* VNODE_CALL */){return 0/* NOT_CONSTANT */;}if(codegenNode.isBlock&&node.tag!=='svg'&&node.tag!=='foreignObject'){return 0/* NOT_CONSTANT */;}var flag=getPatchFlag(codegenNode);if(!flag){var _returnType=3/* CAN_STRINGIFY */;// Element itself has no patch flag. However we still need to check:
// 1. Even for a node with no patch flag, it is possible for it to contain
// non-hoistable expressions that refers to scope variables, e.g. compiler
// injected keys or cached event handlers. Therefore we need to always
// check the codegenNode's props to be sure.
var generatedPropsType=getGeneratedPropsConstantType(node,context);if(generatedPropsType===0/* NOT_CONSTANT */){constantCache.set(node,0/* NOT_CONSTANT */);return 0/* NOT_CONSTANT */;}if(generatedPropsType<_returnType){_returnType=generatedPropsType;}// 2. its children.
for(var i=0;i<node.children.length;i++){var childType=getConstantType(node.children[i],context);if(childType===0/* NOT_CONSTANT */){constantCache.set(node,0/* NOT_CONSTANT */);return 0/* NOT_CONSTANT */;}if(childType<_returnType){_returnType=childType;}}// 3. if the type is not already CAN_SKIP_PATCH which is the lowest non-0
// type, check if any of the props can cause the type to be lowered
// we can skip can_patch because it's guaranteed by the absence of a
// patchFlag.
if(_returnType>1/* CAN_SKIP_PATCH */){for(var _i3=0;_i3<node.props.length;_i3++){var p=node.props[_i3];if(p.type===7/* DIRECTIVE */&&p.name==='bind'&&p.exp){var expType=getConstantType(p.exp,context);if(expType===0/* NOT_CONSTANT */){constantCache.set(node,0/* NOT_CONSTANT */);return 0/* NOT_CONSTANT */;}if(expType<_returnType){_returnType=expType;}}}}// only svg/foreignObject could be block here, however if they are
// static then they don't need to be blocks since there will be no
// nested updates.
if(codegenNode.isBlock){// except set custom directives.
for(var _i4=0;_i4<node.props.length;_i4++){var _p2=node.props[_i4];if(_p2.type===7/* DIRECTIVE */){constantCache.set(node,0/* NOT_CONSTANT */);return 0/* NOT_CONSTANT */;}}context.removeHelper(OPEN_BLOCK);context.removeHelper(getVNodeBlockHelper(context.inSSR,codegenNode.isComponent));codegenNode.isBlock=false;context.helper(getVNodeHelper(context.inSSR,codegenNode.isComponent));}constantCache.set(node,_returnType);return _returnType;}else{constantCache.set(node,0/* NOT_CONSTANT */);return 0/* NOT_CONSTANT */;}case 2/* TEXT */:case 3/* COMMENT */:return 3/* CAN_STRINGIFY */;case 9/* IF */:case 11/* FOR */:case 10/* IF_BRANCH */:return 0/* NOT_CONSTANT */;case 5/* INTERPOLATION */:case 12/* TEXT_CALL */:return getConstantType(node.content,context);case 4/* SIMPLE_EXPRESSION */:return node.constType;case 8/* COMPOUND_EXPRESSION */:var returnType=3/* CAN_STRINGIFY */;for(var _i5=0;_i5<node.children.length;_i5++){var child=node.children[_i5];if(isString(child)||isSymbol(child)){continue;}var _childType=getConstantType(child,context);if(_childType===0/* NOT_CONSTANT */){return 0/* NOT_CONSTANT */;}else if(_childType<returnType){returnType=_childType;}}return returnType;default:return 0/* NOT_CONSTANT */;}}var allowHoistedHelperSet=new Set([NORMALIZE_CLASS,NORMALIZE_STYLE,NORMALIZE_PROPS,GUARD_REACTIVE_PROPS]);function getConstantTypeOfHelperCall(value,context){if(value.type===14/* JS_CALL_EXPRESSION */&&!isString(value.callee)&&allowHoistedHelperSet.has(value.callee)){var arg=value.arguments[0];if(arg.type===4/* SIMPLE_EXPRESSION */){return getConstantType(arg,context);}else if(arg.type===14/* JS_CALL_EXPRESSION */){// in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(exp))`
return getConstantTypeOfHelperCall(arg,context);}}return 0/* NOT_CONSTANT */;}function getGeneratedPropsConstantType(node,context){var returnType=3/* CAN_STRINGIFY */;var props=getNodeProps(node);if(props&&props.type===15/* JS_OBJECT_EXPRESSION */){var properties=props.properties;for(var i=0;i<properties.length;i++){var _properties$i=properties[i],key=_properties$i.key,value=_properties$i.value;var keyType=getConstantType(key,context);if(keyType===0/* NOT_CONSTANT */){return keyType;}if(keyType<returnType){returnType=keyType;}var valueType=void 0;if(value.type===4/* SIMPLE_EXPRESSION */){valueType=getConstantType(value,context);}else if(value.type===14/* JS_CALL_EXPRESSION */){// some helper calls can be hoisted,
// such as the `normalizeProps` generated by the compiler for pre-normalize class,
// in this case we need to respect the ConstantType of the helper's arguments
valueType=getConstantTypeOfHelperCall(value,context);}else{valueType=0/* NOT_CONSTANT */;}if(valueType===0/* NOT_CONSTANT */){return valueType;}if(valueType<returnType){returnType=valueType;}}}return returnType;}function getNodeProps(node){var codegenNode=node.codegenNode;if(codegenNode.type===13/* VNODE_CALL */){return codegenNode.props;}}function getPatchFlag(node){var flag=node.patchFlag;return flag?parseInt(flag,10):undefined;}function createTransformContext(root,_ref2){var _ref2$filename=_ref2.filename,filename=_ref2$filename===void 0?'':_ref2$filename,_ref2$prefixIdentifie=_ref2.prefixIdentifiers,prefixIdentifiers=_ref2$prefixIdentifie===void 0?false:_ref2$prefixIdentifie,_ref2$hoistStatic=_ref2.hoistStatic,hoistStatic=_ref2$hoistStatic===void 0?false:_ref2$hoistStatic,_ref2$cacheHandlers=_ref2.cacheHandlers,cacheHandlers=_ref2$cacheHandlers===void 0?false:_ref2$cacheHandlers,_ref2$nodeTransforms=_ref2.nodeTransforms,nodeTransforms=_ref2$nodeTransforms===void 0?[]:_ref2$nodeTransforms,_ref2$directiveTransf=_ref2.directiveTransforms,directiveTransforms=_ref2$directiveTransf===void 0?{}:_ref2$directiveTransf,_ref2$transformHoist=_ref2.transformHoist,transformHoist=_ref2$transformHoist===void 0?null:_ref2$transformHoist,_ref2$isBuiltInCompon=_ref2.isBuiltInComponent,isBuiltInComponent=_ref2$isBuiltInCompon===void 0?NOOP:_ref2$isBuiltInCompon,_ref2$isCustomElement=_ref2.isCustomElement,isCustomElement=_ref2$isCustomElement===void 0?NOOP:_ref2$isCustomElement,_ref2$expressionPlugi=_ref2.expressionPlugins,expressionPlugins=_ref2$expressionPlugi===void 0?[]:_ref2$expressionPlugi,_ref2$scopeId=_ref2.scopeId,scopeId=_ref2$scopeId===void 0?null:_ref2$scopeId,_ref2$slotted=_ref2.slotted,slotted=_ref2$slotted===void 0?true:_ref2$slotted,_ref2$ssr=_ref2.ssr,ssr=_ref2$ssr===void 0?false:_ref2$ssr,_ref2$inSSR=_ref2.inSSR,inSSR=_ref2$inSSR===void 0?false:_ref2$inSSR,_ref2$ssrCssVars=_ref2.ssrCssVars,ssrCssVars=_ref2$ssrCssVars===void 0?"":_ref2$ssrCssVars,_ref2$bindingMetadata=_ref2.bindingMetadata,bindingMetadata=_ref2$bindingMetadata===void 0?EMPTY_OBJ:_ref2$bindingMetadata,_ref2$inline=_ref2.inline,inline=_ref2$inline===void 0?false:_ref2$inline,_ref2$isTS=_ref2.isTS,isTS=_ref2$isTS===void 0?false:_ref2$isTS,_ref2$onError=_ref2.onError,onError=_ref2$onError===void 0?defaultOnError:_ref2$onError,_ref2$onWarn=_ref2.onWarn,onWarn=_ref2$onWarn===void 0?defaultOnWarn:_ref2$onWarn,compatConfig=_ref2.compatConfig;var nameMatch=filename.replace(/\?.*$/,'').match(/([^/\\]+)\.\w+$/);var context={// options
selfName:nameMatch&&capitalize(camelize$1(nameMatch[1])),prefixIdentifiers:prefixIdentifiers,hoistStatic:hoistStatic,cacheHandlers:cacheHandlers,nodeTransforms:nodeTransforms,directiveTransforms:directiveTransforms,transformHoist:transformHoist,isBuiltInComponent:isBuiltInComponent,isCustomElement:isCustomElement,expressionPlugins:expressionPlugins,scopeId:scopeId,slotted:slotted,ssr:ssr,inSSR:inSSR,ssrCssVars:ssrCssVars,bindingMetadata:bindingMetadata,inline:inline,isTS:isTS,onError:onError,onWarn:onWarn,compatConfig:compatConfig,// state
root:root,helpers:new Map(),components:new Set(),directives:new Set(),hoists:[],imports:[],constantCache:new Map(),temps:0,cached:0,identifiers:Object.create(null),scopes:{vFor:0,vSlot:0,vPre:0,vOnce:0},parent:null,currentNode:root,childIndex:0,inVOnce:false,// methods
helper:function helper(name){var count=context.helpers.get(name)||0;context.helpers.set(name,count+1);return name;},removeHelper:function removeHelper(name){var count=context.helpers.get(name);if(count){var currentCount=count-1;if(!currentCount){context.helpers.delete(name);}else{context.helpers.set(name,currentCount);}}},helperString:function helperString(name){return"_".concat(helperNameMap[context.helper(name)]);},replaceNode:function replaceNode(node){context.parent.children[context.childIndex]=context.currentNode=node;},removeNode:function removeNode(node){var list=context.parent.children;var removalIndex=node?list.indexOf(node):context.currentNode?context.childIndex:-1;if(!node||node===context.currentNode){// current node removed
context.currentNode=null;context.onNodeRemoved();}else{// sibling node removed
if(context.childIndex>removalIndex){context.childIndex--;context.onNodeRemoved();}}context.parent.children.splice(removalIndex,1);},onNodeRemoved:function onNodeRemoved(){},addIdentifiers:function addIdentifiers(exp){},removeIdentifiers:function removeIdentifiers(exp){},hoist:function hoist(exp){if(isString(exp))exp=createSimpleExpression(exp);context.hoists.push(exp);var identifier=createSimpleExpression("_hoisted_".concat(context.hoists.length),false,exp.loc,2/* CAN_HOIST */);identifier.hoisted=exp;return identifier;},cache:function cache(exp){var isVNode=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;return createCacheExpression(context.cached++,exp,isVNode);}};{context.filters=new Set();}return context;}function transform(root,options){var context=createTransformContext(root,options);traverseNode(root,context);if(options.hoistStatic){hoistStatic(root,context);}if(!options.ssr){createRootCodegen(root,context);}// finalize meta information
root.helpers=_toConsumableArray(context.helpers.keys());root.components=_toConsumableArray(context.components);root.directives=_toConsumableArray(context.directives);root.imports=context.imports;root.hoists=context.hoists;root.temps=context.temps;root.cached=context.cached;{root.filters=_toConsumableArray(context.filters);}}function createRootCodegen(root,context){var helper=context.helper;var children=root.children;if(children.length===1){var child=children[0];// if the single child is an element, turn it into a block.
if(isSingleElementRoot(root,child)&&child.codegenNode){// single element root is never hoisted so codegenNode will never be
// SimpleExpressionNode
var codegenNode=child.codegenNode;if(codegenNode.type===13/* VNODE_CALL */){makeBlock(codegenNode,context);}root.codegenNode=codegenNode;}else{// - single <slot/>, IfNode, ForNode: already blocks.
// - single text node: always patched.
// root codegen falls through via genNode()
root.codegenNode=child;}}else if(children.length>1){// root has multiple nodes - return a fragment block.
var patchFlag=64/* STABLE_FRAGMENT */;root.codegenNode=createVNodeCall(context,helper(FRAGMENT),undefined,root.children,patchFlag+"",undefined,undefined,true,undefined,false/* isComponent */);}else;}function traverseChildren(parent,context){var i=0;var nodeRemoved=function nodeRemoved(){i--;};for(;i<parent.children.length;i++){var child=parent.children[i];if(isString(child))continue;context.parent=parent;context.childIndex=i;context.onNodeRemoved=nodeRemoved;traverseNode(child,context);}}function traverseNode(node,context){context.currentNode=node;// apply transform plugins
var nodeTransforms=context.nodeTransforms;var exitFns=[];for(var _i6=0;_i6<nodeTransforms.length;_i6++){var onExit=nodeTransforms[_i6](node,context);if(onExit){if(isArray(onExit)){exitFns.push.apply(exitFns,_toConsumableArray(onExit));}else{exitFns.push(onExit);}}if(!context.currentNode){// node was removed
return;}else{// node may have been replaced
node=context.currentNode;}}switch(node.type){case 3/* COMMENT */:if(!context.ssr){// inject import for the Comment symbol, which is needed for creating
// comment nodes with `createVNode`
context.helper(CREATE_COMMENT);}break;case 5/* INTERPOLATION */:// no need to traverse, but we need to inject toString helper
if(!context.ssr){context.helper(TO_DISPLAY_STRING);}break;// for container types, further traverse downwards
case 9/* IF */:for(var _i7=0;_i7<node.branches.length;_i7++){traverseNode(node.branches[_i7],context);}break;case 10/* IF_BRANCH */:case 11/* FOR */:case 1/* ELEMENT */:case 0/* ROOT */:traverseChildren(node,context);break;}// exit transforms
context.currentNode=node;var i=exitFns.length;while(i--){exitFns[i]();}}function createStructuralDirectiveTransform(name,fn){var matches=isString(name)?function(n){return n===name;}:function(n){return name.test(n);};return function(node,context){if(node.type===1/* ELEMENT */){var props=node.props;// structural directive transforms are not concerned with slots
// as they are handled separately in vSlot.ts
if(node.tagType===3/* TEMPLATE */&&props.some(isVSlot)){return;}var exitFns=[];for(var i=0;i<props.length;i++){var prop=props[i];if(prop.type===7/* DIRECTIVE */&&matches(prop.name)){// structural directives are removed to avoid infinite recursion
// also we remove them *before* applying so that it can further
// traverse itself in case it moves the node around
props.splice(i,1);i--;var onExit=fn(node,prop,context);if(onExit)exitFns.push(onExit);}}return exitFns;}};}var PURE_ANNOTATION="/*#__PURE__*/";var aliasHelper=function aliasHelper(s){return"".concat(helperNameMap[s],": _").concat(helperNameMap[s]);};function createCodegenContext(ast,_ref3){var _ref3$mode=_ref3.mode,mode=_ref3$mode===void 0?'function':_ref3$mode,_ref3$prefixIdentifie=_ref3.prefixIdentifiers,prefixIdentifiers=_ref3$prefixIdentifie===void 0?mode==='module':_ref3$prefixIdentifie,_ref3$sourceMap=_ref3.sourceMap,sourceMap=_ref3$sourceMap===void 0?false:_ref3$sourceMap,_ref3$filename=_ref3.filename,filename=_ref3$filename===void 0?"template.vue.html":_ref3$filename,_ref3$scopeId=_ref3.scopeId,scopeId=_ref3$scopeId===void 0?null:_ref3$scopeId,_ref3$optimizeImports=_ref3.optimizeImports,optimizeImports=_ref3$optimizeImports===void 0?false:_ref3$optimizeImports,_ref3$runtimeGlobalNa=_ref3.runtimeGlobalName,runtimeGlobalName=_ref3$runtimeGlobalNa===void 0?"Vue":_ref3$runtimeGlobalNa,_ref3$runtimeModuleNa=_ref3.runtimeModuleName,runtimeModuleName=_ref3$runtimeModuleNa===void 0?"vue":_ref3$runtimeModuleNa,_ref3$ssrRuntimeModul=_ref3.ssrRuntimeModuleName,ssrRuntimeModuleName=_ref3$ssrRuntimeModul===void 0?'vue/server-renderer':_ref3$ssrRuntimeModul,_ref3$ssr=_ref3.ssr,ssr=_ref3$ssr===void 0?false:_ref3$ssr,_ref3$isTS=_ref3.isTS,isTS=_ref3$isTS===void 0?false:_ref3$isTS,_ref3$inSSR=_ref3.inSSR,inSSR=_ref3$inSSR===void 0?false:_ref3$inSSR;var context={mode:mode,prefixIdentifiers:prefixIdentifiers,sourceMap:sourceMap,filename:filename,scopeId:scopeId,optimizeImports:optimizeImports,runtimeGlobalName:runtimeGlobalName,runtimeModuleName:runtimeModuleName,ssrRuntimeModuleName:ssrRuntimeModuleName,ssr:ssr,isTS:isTS,inSSR:inSSR,source:ast.loc.source,code:"",column:1,line:1,offset:0,indentLevel:0,pure:false,map:undefined,helper:function helper(key){return"_".concat(helperNameMap[key]);},push:function push(code,node){context.code+=code;},indent:function indent(){_newline(++context.indentLevel);},deindent:function deindent(){var withoutNewLine=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;if(withoutNewLine){--context.indentLevel;}else{_newline(--context.indentLevel);}},newline:function newline(){_newline(context.indentLevel);}};function _newline(n){context.push('\n'+"  ".repeat(n));}return context;}function generate(ast){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var context=createCodegenContext(ast,options);if(options.onContextCreated)options.onContextCreated(context);var mode=context.mode,push=context.push,prefixIdentifiers=context.prefixIdentifiers,indent=context.indent,deindent=context.deindent,newline=context.newline,scopeId=context.scopeId,ssr=context.ssr;var hasHelpers=ast.helpers.length>0;var useWithBlock=!prefixIdentifiers&&mode!=='module';// preambles
// in setup() inline mode, the preamble is generated in a sub context
// and returned separately.
var preambleContext=context;{genFunctionPreamble(ast,preambleContext);}// enter render function
var functionName=ssr?"ssrRender":"render";var args=ssr?['_ctx','_push','_parent','_attrs']:['_ctx','_cache'];var signature=args.join(', ');{push("function ".concat(functionName,"(").concat(signature,") {"));}indent();if(useWithBlock){push("with (_ctx) {");indent();// function mode const declarations should be inside with block
// also they should be renamed to avoid collision with user properties
if(hasHelpers){push("const { ".concat(ast.helpers.map(aliasHelper).join(', ')," } = _Vue"));push("\n");newline();}}// generate asset resolution statements
if(ast.components.length){genAssets(ast.components,'component',context);if(ast.directives.length||ast.temps>0){newline();}}if(ast.directives.length){genAssets(ast.directives,'directive',context);if(ast.temps>0){newline();}}if(ast.filters&&ast.filters.length){newline();genAssets(ast.filters,'filter',context);newline();}if(ast.temps>0){push("let ");for(var i=0;i<ast.temps;i++){push("".concat(i>0?", ":"","_temp").concat(i));}}if(ast.components.length||ast.directives.length||ast.temps){push("\n");newline();}// generate the VNode tree expression
if(!ssr){push("return ");}if(ast.codegenNode){genNode(ast.codegenNode,context);}else{push("null");}if(useWithBlock){deindent();push("}");}deindent();push("}");return{ast:ast,code:context.code,preamble:"",// SourceMapGenerator does have toJSON() method but it's not in the types
map:context.map?context.map.toJSON():undefined};}function genFunctionPreamble(ast,context){var ssr=context.ssr,prefixIdentifiers=context.prefixIdentifiers,push=context.push,newline=context.newline,runtimeModuleName=context.runtimeModuleName,runtimeGlobalName=context.runtimeGlobalName,ssrRuntimeModuleName=context.ssrRuntimeModuleName;var VueBinding=runtimeGlobalName;// Generate const declaration for helpers
// In prefix mode, we place the const declaration at top so it's done
// only once; But if we not prefixing, we place the declaration inside the
// with block so it doesn't incur the `in` check cost for every helper access.
if(ast.helpers.length>0){{// "with" mode.
// save Vue in a separate variable to avoid collision
push("const _Vue = ".concat(VueBinding,"\n"));// in "with" mode, helpers are declared inside the with block to avoid
// has check cost, but hoists are lifted out of the function - we need
// to provide the helper here.
if(ast.hoists.length){var staticHelpers=[CREATE_VNODE,CREATE_ELEMENT_VNODE,CREATE_COMMENT,CREATE_TEXT,CREATE_STATIC].filter(function(helper){return ast.helpers.includes(helper);}).map(aliasHelper).join(', ');push("const { ".concat(staticHelpers," } = _Vue\n"));}}}genHoists(ast.hoists,context);newline();push("return ");}function genAssets(assets,type,_ref4){var helper=_ref4.helper,push=_ref4.push,newline=_ref4.newline,isTS=_ref4.isTS;var resolver=helper(type==='filter'?RESOLVE_FILTER:type==='component'?RESOLVE_COMPONENT:RESOLVE_DIRECTIVE);for(var i=0;i<assets.length;i++){var id=assets[i];// potential component implicit self-reference inferred from SFC filename
var maybeSelfReference=id.endsWith('__self');if(maybeSelfReference){id=id.slice(0,-6);}push("const ".concat(toValidAssetId(id,type)," = ").concat(resolver,"(").concat(JSON.stringify(id)).concat(maybeSelfReference?", true":"",")").concat(isTS?"!":""));if(i<assets.length-1){newline();}}}function genHoists(hoists,context){if(!hoists.length){return;}context.pure=true;var push=context.push,newline=context.newline,helper=context.helper,scopeId=context.scopeId,mode=context.mode;newline();for(var i=0;i<hoists.length;i++){var exp=hoists[i];if(exp){push("const _hoisted_".concat(i+1," = ",""));genNode(exp,context);newline();}}context.pure=false;}function genNodeListAsArray(nodes,context){var multilines=nodes.length>3||"production"!=='production';context.push("[");multilines&&context.indent();genNodeList(nodes,context,multilines);multilines&&context.deindent();context.push("]");}function genNodeList(nodes,context){var multilines=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;var comma=arguments.length>3&&arguments[3]!==undefined?arguments[3]:true;var push=context.push,newline=context.newline;for(var i=0;i<nodes.length;i++){var node=nodes[i];if(isString(node)){push(node);}else if(isArray(node)){genNodeListAsArray(node,context);}else{genNode(node,context);}if(i<nodes.length-1){if(multilines){comma&&push(',');newline();}else{comma&&push(', ');}}}}function genNode(node,context){if(isString(node)){context.push(node);return;}if(isSymbol(node)){context.push(context.helper(node));return;}switch(node.type){case 1/* ELEMENT */:case 9/* IF */:case 11/* FOR */:genNode(node.codegenNode,context);break;case 2/* TEXT */:genText(node,context);break;case 4/* SIMPLE_EXPRESSION */:genExpression(node,context);break;case 5/* INTERPOLATION */:genInterpolation(node,context);break;case 12/* TEXT_CALL */:genNode(node.codegenNode,context);break;case 8/* COMPOUND_EXPRESSION */:genCompoundExpression(node,context);break;case 3/* COMMENT */:genComment(node,context);break;case 13/* VNODE_CALL */:genVNodeCall(node,context);break;case 14/* JS_CALL_EXPRESSION */:genCallExpression(node,context);break;case 15/* JS_OBJECT_EXPRESSION */:genObjectExpression(node,context);break;case 17/* JS_ARRAY_EXPRESSION */:genArrayExpression(node,context);break;case 18/* JS_FUNCTION_EXPRESSION */:genFunctionExpression(node,context);break;case 19/* JS_CONDITIONAL_EXPRESSION */:genConditionalExpression(node,context);break;case 20/* JS_CACHE_EXPRESSION */:genCacheExpression(node,context);break;case 21/* JS_BLOCK_STATEMENT */:genNodeList(node.body,context,true,false);break;}}function genText(node,context){context.push(JSON.stringify(node.content),node);}function genExpression(node,context){var content=node.content,isStatic=node.isStatic;context.push(isStatic?JSON.stringify(content):content,node);}function genInterpolation(node,context){var push=context.push,helper=context.helper,pure=context.pure;if(pure)push(PURE_ANNOTATION);push("".concat(helper(TO_DISPLAY_STRING),"("));genNode(node.content,context);push(")");}function genCompoundExpression(node,context){for(var i=0;i<node.children.length;i++){var child=node.children[i];if(isString(child)){context.push(child);}else{genNode(child,context);}}}function genExpressionAsPropertyKey(node,context){var push=context.push;if(node.type===8/* COMPOUND_EXPRESSION */){push("[");genCompoundExpression(node,context);push("]");}else if(node.isStatic){// only quote keys if necessary
var text=isSimpleIdentifier(node.content)?node.content:JSON.stringify(node.content);push(text,node);}else{push("[".concat(node.content,"]"),node);}}function genComment(node,context){var push=context.push,helper=context.helper,pure=context.pure;if(pure){push(PURE_ANNOTATION);}push("".concat(helper(CREATE_COMMENT),"(").concat(JSON.stringify(node.content),")"),node);}function genVNodeCall(node,context){var push=context.push,helper=context.helper,pure=context.pure;var tag=node.tag,props=node.props,children=node.children,patchFlag=node.patchFlag,dynamicProps=node.dynamicProps,directives=node.directives,isBlock=node.isBlock,disableTracking=node.disableTracking,isComponent=node.isComponent;if(directives){push(helper(WITH_DIRECTIVES)+"(");}if(isBlock){push("(".concat(helper(OPEN_BLOCK),"(").concat(disableTracking?"true":"","), "));}if(pure){push(PURE_ANNOTATION);}var callHelper=isBlock?getVNodeBlockHelper(context.inSSR,isComponent):getVNodeHelper(context.inSSR,isComponent);push(helper(callHelper)+"(",node);genNodeList(genNullableArgs([tag,props,children,patchFlag,dynamicProps]),context);push(")");if(isBlock){push(")");}if(directives){push(", ");genNode(directives,context);push(")");}}function genNullableArgs(args){var i=args.length;while(i--){if(args[i]!=null)break;}return args.slice(0,i+1).map(function(arg){return arg||"null";});}// JavaScript
function genCallExpression(node,context){var push=context.push,helper=context.helper,pure=context.pure;var callee=isString(node.callee)?node.callee:helper(node.callee);if(pure){push(PURE_ANNOTATION);}push(callee+"(",node);genNodeList(node.arguments,context);push(")");}function genObjectExpression(node,context){var push=context.push,indent=context.indent,deindent=context.deindent,newline=context.newline;var properties=node.properties;if(!properties.length){push("{}",node);return;}var multilines=properties.length>1||"production"!=='production';push(multilines?"{":"{ ");multilines&&indent();for(var i=0;i<properties.length;i++){var _properties$i2=properties[i],key=_properties$i2.key,value=_properties$i2.value;// key
genExpressionAsPropertyKey(key,context);push(": ");// value
genNode(value,context);if(i<properties.length-1){// will only reach this if it's multilines
push(",");newline();}}multilines&&deindent();push(multilines?"}":" }");}function genArrayExpression(node,context){genNodeListAsArray(node.elements,context);}function genFunctionExpression(node,context){var push=context.push,indent=context.indent,deindent=context.deindent;var params=node.params,returns=node.returns,body=node.body,newline=node.newline,isSlot=node.isSlot;if(isSlot){// wrap slot functions with owner context
push("_".concat(helperNameMap[WITH_CTX],"("));}push("(",node);if(isArray(params)){genNodeList(params,context);}else if(params){genNode(params,context);}push(") => ");if(newline||body){push("{");indent();}if(returns){if(newline){push("return ");}if(isArray(returns)){genNodeListAsArray(returns,context);}else{genNode(returns,context);}}else if(body){genNode(body,context);}if(newline||body){deindent();push("}");}if(isSlot){if(node.isNonScopedSlot){push(", undefined, true");}push(")");}}function genConditionalExpression(node,context){var test=node.test,consequent=node.consequent,alternate=node.alternate,needNewline=node.newline;var push=context.push,indent=context.indent,deindent=context.deindent,newline=context.newline;if(test.type===4/* SIMPLE_EXPRESSION */){var needsParens=!isSimpleIdentifier(test.content);needsParens&&push("(");genExpression(test,context);needsParens&&push(")");}else{push("(");genNode(test,context);push(")");}needNewline&&indent();context.indentLevel++;needNewline||push(" ");push("? ");genNode(consequent,context);context.indentLevel--;needNewline&&newline();needNewline||push(" ");push(": ");var isNested=alternate.type===19/* JS_CONDITIONAL_EXPRESSION */;if(!isNested){context.indentLevel++;}genNode(alternate,context);if(!isNested){context.indentLevel--;}needNewline&&deindent(true/* without newline */);}function genCacheExpression(node,context){var push=context.push,helper=context.helper,indent=context.indent,deindent=context.deindent,newline=context.newline;push("_cache[".concat(node.index,"] || ("));if(node.isVNode){indent();push("".concat(helper(SET_BLOCK_TRACKING),"(-1),"));newline();}push("_cache[".concat(node.index,"] = "));genNode(node.value,context);if(node.isVNode){push(",");newline();push("".concat(helper(SET_BLOCK_TRACKING),"(1),"));newline();push("_cache[".concat(node.index,"]"));deindent();}push(")");}// these keywords should not appear inside expressions, but operators like
// typeof, instanceof and in are allowed
new RegExp('\\b'+('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,'+'super,throw,while,yield,delete,export,import,return,switch,default,'+'extends,finally,continue,debugger,function,arguments,typeof,void').split(',').join('\\b|\\b')+'\\b');var transformIf=createStructuralDirectiveTransform(/^(if|else|else-if)$/,function(node,dir,context){return processIf(node,dir,context,function(ifNode,branch,isRoot){// #1587: We need to dynamically increment the key based on the current
// node's sibling nodes, since chained v-if/else branches are
// rendered at the same depth
var siblings=context.parent.children;var i=siblings.indexOf(ifNode);var key=0;while(i-->=0){var sibling=siblings[i];if(sibling&&sibling.type===9/* IF */){key+=sibling.branches.length;}}// Exit callback. Complete the codegenNode when all children have been
// transformed.
return function(){if(isRoot){ifNode.codegenNode=createCodegenNodeForBranch(branch,key,context);}else{// attach this branch's codegen node to the v-if root.
var parentCondition=getParentCondition(ifNode.codegenNode);parentCondition.alternate=createCodegenNodeForBranch(branch,key+ifNode.branches.length-1,context);}};});});// target-agnostic transform used for both Client and SSR
function processIf(node,dir,context,processCodegen){if(dir.name!=='else'&&(!dir.exp||!dir.exp.content.trim())){var loc=dir.exp?dir.exp.loc:node.loc;context.onError(createCompilerError(28/* X_V_IF_NO_EXPRESSION */,dir.loc));dir.exp=createSimpleExpression("true",false,loc);}if(dir.name==='if'){var branch=createIfBranch(node,dir);var ifNode={type:9/* IF */,loc:node.loc,branches:[branch]};context.replaceNode(ifNode);if(processCodegen){return processCodegen(ifNode,branch,true);}}else{// locate the adjacent v-if
var siblings=context.parent.children;var i=siblings.indexOf(node);while(i-->=-1){var sibling=siblings[i];if(sibling&&sibling.type===2/* TEXT */&&!sibling.content.trim().length){context.removeNode(sibling);continue;}if(sibling&&sibling.type===9/* IF */){// Check if v-else was followed by v-else-if
if(dir.name==='else-if'&&sibling.branches[sibling.branches.length-1].condition===undefined){context.onError(createCompilerError(30/* X_V_ELSE_NO_ADJACENT_IF */,node.loc));}// move the node to the if node's branches
context.removeNode();var _branch=createIfBranch(node,dir);sibling.branches.push(_branch);var onExit=processCodegen&&processCodegen(sibling,_branch,false);// since the branch was removed, it will not be traversed.
// make sure to traverse here.
traverseNode(_branch,context);// call on exit
if(onExit)onExit();// make sure to reset currentNode after traversal to indicate this
// node has been removed.
context.currentNode=null;}else{context.onError(createCompilerError(30/* X_V_ELSE_NO_ADJACENT_IF */,node.loc));}break;}}}function createIfBranch(node,dir){var isTemplateIf=node.tagType===3/* TEMPLATE */;return{type:10/* IF_BRANCH */,loc:node.loc,condition:dir.name==='else'?undefined:dir.exp,children:isTemplateIf&&!findDir(node,'for')?node.children:[node],userKey:findProp(node,"key"),isTemplateIf:isTemplateIf};}function createCodegenNodeForBranch(branch,keyIndex,context){if(branch.condition){return createConditionalExpression(branch.condition,createChildrenCodegenNode(branch,keyIndex,context),// make sure to pass in asBlock: true so that the comment node call
// closes the current block.
createCallExpression(context.helper(CREATE_COMMENT),['""','true']));}else{return createChildrenCodegenNode(branch,keyIndex,context);}}function createChildrenCodegenNode(branch,keyIndex,context){var helper=context.helper;var keyProperty=createObjectProperty("key",createSimpleExpression("".concat(keyIndex),false,locStub,2/* CAN_HOIST */));var children=branch.children;var firstChild=children[0];var needFragmentWrapper=children.length!==1||firstChild.type!==1/* ELEMENT */;if(needFragmentWrapper){if(children.length===1&&firstChild.type===11/* FOR */){// optimize away nested fragments when child is a ForNode
var vnodeCall=firstChild.codegenNode;injectProp(vnodeCall,keyProperty,context);return vnodeCall;}else{var patchFlag=64/* STABLE_FRAGMENT */;return createVNodeCall(context,helper(FRAGMENT),createObjectExpression([keyProperty]),children,patchFlag+"",undefined,undefined,true,false,false/* isComponent */,branch.loc);}}else{var ret=firstChild.codegenNode;var _vnodeCall=getMemoedVNodeCall(ret);// Change createVNode to createBlock.
if(_vnodeCall.type===13/* VNODE_CALL */){makeBlock(_vnodeCall,context);}// inject branch key
injectProp(_vnodeCall,keyProperty,context);return ret;}}function getParentCondition(node){while(true){if(node.type===19/* JS_CONDITIONAL_EXPRESSION */){if(node.alternate.type===19/* JS_CONDITIONAL_EXPRESSION */){node=node.alternate;}else{return node;}}else if(node.type===20/* JS_CACHE_EXPRESSION */){node=node.value;}}}var transformFor=createStructuralDirectiveTransform('for',function(node,dir,context){var helper=context.helper,removeHelper=context.removeHelper;return processFor(node,dir,context,function(forNode){// create the loop render function expression now, and add the
// iterator on exit after all children have been traversed
var renderExp=createCallExpression(helper(RENDER_LIST),[forNode.source]);var isTemplate=isTemplateNode(node);var memo=findDir(node,'memo');var keyProp=findProp(node,"key");var keyExp=keyProp&&(keyProp.type===6/* ATTRIBUTE */?createSimpleExpression(keyProp.value.content,true):keyProp.exp);var keyProperty=keyProp?createObjectProperty("key",keyExp):null;var isStableFragment=forNode.source.type===4/* SIMPLE_EXPRESSION */&&forNode.source.constType>0/* NOT_CONSTANT */;var fragmentFlag=isStableFragment?64/* STABLE_FRAGMENT */:keyProp?128/* KEYED_FRAGMENT */:256/* UNKEYED_FRAGMENT */;forNode.codegenNode=createVNodeCall(context,helper(FRAGMENT),undefined,renderExp,fragmentFlag+"",undefined,undefined,true/* isBlock */,!isStableFragment/* disableTracking */,false/* isComponent */,node.loc);return function(){// finish the codegen now that all children have been traversed
var childBlock;var children=forNode.children;var needFragmentWrapper=children.length!==1||children[0].type!==1/* ELEMENT */;var slotOutlet=isSlotOutlet(node)?node:isTemplate&&node.children.length===1&&isSlotOutlet(node.children[0])?node.children[0]// api-extractor somehow fails to infer this
:null;if(slotOutlet){// <slot v-for="..."> or <template v-for="..."><slot/></template>
childBlock=slotOutlet.codegenNode;if(isTemplate&&keyProperty){// <template v-for="..." :key="..."><slot/></template>
// we need to inject the key to the renderSlot() call.
// the props for renderSlot is passed as the 3rd argument.
injectProp(childBlock,keyProperty,context);}}else if(needFragmentWrapper){// <template v-for="..."> with text or multi-elements
// should generate a fragment block for each loop
childBlock=createVNodeCall(context,helper(FRAGMENT),keyProperty?createObjectExpression([keyProperty]):undefined,node.children,64/* STABLE_FRAGMENT */+"",undefined,undefined,true,undefined,false/* isComponent */);}else{// Normal element v-for. Directly use the child's codegenNode
// but mark it as a block.
childBlock=children[0].codegenNode;if(isTemplate&&keyProperty){injectProp(childBlock,keyProperty,context);}if(childBlock.isBlock!==!isStableFragment){if(childBlock.isBlock){// switch from block to vnode
removeHelper(OPEN_BLOCK);removeHelper(getVNodeBlockHelper(context.inSSR,childBlock.isComponent));}else{// switch from vnode to block
removeHelper(getVNodeHelper(context.inSSR,childBlock.isComponent));}}childBlock.isBlock=!isStableFragment;if(childBlock.isBlock){helper(OPEN_BLOCK);helper(getVNodeBlockHelper(context.inSSR,childBlock.isComponent));}else{helper(getVNodeHelper(context.inSSR,childBlock.isComponent));}}if(memo){var loop=createFunctionExpression(createForLoopParams(forNode.parseResult,[createSimpleExpression("_cached")]));loop.body=createBlockStatement([createCompoundExpression(["const _memo = (",memo.exp,")"]),createCompoundExpression(["if (_cached"].concat(_toConsumableArray(keyExp?[" && _cached.key === ",keyExp]:[]),[" && ".concat(context.helperString(IS_MEMO_SAME),"(_cached, _memo)) return _cached")])),createCompoundExpression(["const _item = ",childBlock]),createSimpleExpression("_item.memo = _memo"),createSimpleExpression("return _item")]);renderExp.arguments.push(loop,createSimpleExpression("_cache"),createSimpleExpression(String(context.cached++)));}else{renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult),childBlock,true/* force newline */));}};});});// target-agnostic transform used for both Client and SSR
function processFor(node,dir,context,processCodegen){if(!dir.exp){context.onError(createCompilerError(31/* X_V_FOR_NO_EXPRESSION */,dir.loc));return;}var parseResult=parseForExpression(// can only be simple expression because vFor transform is applied
// before expression transform.
dir.exp);if(!parseResult){context.onError(createCompilerError(32/* X_V_FOR_MALFORMED_EXPRESSION */,dir.loc));return;}var addIdentifiers=context.addIdentifiers,removeIdentifiers=context.removeIdentifiers,scopes=context.scopes;var source=parseResult.source,value=parseResult.value,key=parseResult.key,index=parseResult.index;var forNode={type:11/* FOR */,loc:dir.loc,source:source,valueAlias:value,keyAlias:key,objectIndexAlias:index,parseResult:parseResult,children:isTemplateNode(node)?node.children:[node]};context.replaceNode(forNode);// bookkeeping
scopes.vFor++;var onExit=processCodegen&&processCodegen(forNode);return function(){scopes.vFor--;if(onExit)onExit();};}var forAliasRE=/([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;// This regex doesn't cover the case if key or index aliases have destructuring,
// but those do not make sense in the first place, so this works in practice.
var forIteratorRE=/,([^,\}\]]*)(?:,([^,\}\]]*))?$/;var stripParensRE=/^\(|\)$/g;function parseForExpression(input,context){var loc=input.loc;var exp=input.content;var inMatch=exp.match(forAliasRE);if(!inMatch)return;var _inMatch=_slicedToArray(inMatch,3),LHS=_inMatch[1],RHS=_inMatch[2];var result={source:createAliasExpression(loc,RHS.trim(),exp.indexOf(RHS,LHS.length)),value:undefined,key:undefined,index:undefined};var valueContent=LHS.trim().replace(stripParensRE,'').trim();var trimmedOffset=LHS.indexOf(valueContent);var iteratorMatch=valueContent.match(forIteratorRE);if(iteratorMatch){valueContent=valueContent.replace(forIteratorRE,'').trim();var keyContent=iteratorMatch[1].trim();var keyOffset;if(keyContent){keyOffset=exp.indexOf(keyContent,trimmedOffset+valueContent.length);result.key=createAliasExpression(loc,keyContent,keyOffset);}if(iteratorMatch[2]){var indexContent=iteratorMatch[2].trim();if(indexContent){result.index=createAliasExpression(loc,indexContent,exp.indexOf(indexContent,result.key?keyOffset+keyContent.length:trimmedOffset+valueContent.length));}}}if(valueContent){result.value=createAliasExpression(loc,valueContent,trimmedOffset);}return result;}function createAliasExpression(range,content,offset){return createSimpleExpression(content,false,getInnerRange(range,offset,content.length));}function createForLoopParams(_ref5){var value=_ref5.value,key=_ref5.key,index=_ref5.index;var memoArgs=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];return createParamsList([value,key,index].concat(_toConsumableArray(memoArgs)));}function createParamsList(args){var i=args.length;while(i--){if(args[i])break;}return args.slice(0,i+1).map(function(arg,i){return arg||createSimpleExpression("_".repeat(i+1),false);});}var defaultFallback=createSimpleExpression("undefined",false);// A NodeTransform that:
// 1. Tracks scope identifiers for scoped slots so that they don't get prefixed
//    by transformExpression. This is only applied in non-browser builds with
//    { prefixIdentifiers: true }.
// 2. Track v-slot depths so that we know a slot is inside another slot.
//    Note the exit callback is executed before buildSlots() on the same node,
//    so only nested slots see positive numbers.
var trackSlotScopes=function trackSlotScopes(node,context){if(node.type===1/* ELEMENT */&&(node.tagType===1/* COMPONENT */||node.tagType===3/* TEMPLATE */)){// We are only checking non-empty v-slot here
// since we only care about slots that introduce scope variables.
var vSlot=findDir(node,'slot');if(vSlot){vSlot.exp;context.scopes.vSlot++;return function(){context.scopes.vSlot--;};}}};var buildClientSlotFn=function buildClientSlotFn(props,children,loc){return createFunctionExpression(props,children,false/* newline */,true/* isSlot */,children.length?children[0].loc:loc);};// Instead of being a DirectiveTransform, v-slot processing is called during
// transformElement to build the slots object for a component.
function buildSlots(node,context){var buildSlotFn=arguments.length>2&&arguments[2]!==undefined?arguments[2]:buildClientSlotFn;context.helper(WITH_CTX);var children=node.children,loc=node.loc;var slotsProperties=[];var dynamicSlots=[];// If the slot is inside a v-for or another v-slot, force it to be dynamic
// since it likely uses a scope variable.
var hasDynamicSlots=context.scopes.vSlot>0||context.scopes.vFor>0;// 1. Check for slot with slotProps on component itself.
//    <Comp v-slot="{ prop }"/>
var onComponentSlot=findDir(node,'slot',true);if(onComponentSlot){var arg=onComponentSlot.arg,exp=onComponentSlot.exp;if(arg&&!isStaticExp(arg)){hasDynamicSlots=true;}slotsProperties.push(createObjectProperty(arg||createSimpleExpression('default',true),buildSlotFn(exp,children,loc)));}// 2. Iterate through children and check for template slots
//    <template v-slot:foo="{ prop }">
var hasTemplateSlots=false;var hasNamedDefaultSlot=false;var implicitDefaultChildren=[];var seenSlotNames=new Set();for(var i=0;i<children.length;i++){var slotElement=children[i];var slotDir=void 0;if(!isTemplateNode(slotElement)||!(slotDir=findDir(slotElement,'slot',true))){// not a <template v-slot>, skip.
if(slotElement.type!==3/* COMMENT */){implicitDefaultChildren.push(slotElement);}continue;}if(onComponentSlot){// already has on-component slot - this is incorrect usage.
context.onError(createCompilerError(37/* X_V_SLOT_MIXED_SLOT_USAGE */,slotDir.loc));break;}hasTemplateSlots=true;var slotChildren=slotElement.children,slotLoc=slotElement.loc;var _slotDir=slotDir,_slotDir$arg=_slotDir.arg,slotName=_slotDir$arg===void 0?createSimpleExpression("default",true):_slotDir$arg,slotProps=_slotDir.exp,dirLoc=_slotDir.loc;// check if name is dynamic.
var staticSlotName=void 0;if(isStaticExp(slotName)){staticSlotName=slotName?slotName.content:"default";}else{hasDynamicSlots=true;}var slotFunction=buildSlotFn(slotProps,slotChildren,slotLoc);// check if this slot is conditional (v-if/v-for)
var vIf=void 0;var vElse=void 0;var vFor=void 0;if(vIf=findDir(slotElement,'if')){hasDynamicSlots=true;dynamicSlots.push(createConditionalExpression(vIf.exp,buildDynamicSlot(slotName,slotFunction),defaultFallback));}else if(vElse=findDir(slotElement,/^else(-if)?$/,true/* allowEmpty */)){// find adjacent v-if
var j=i;var prev=void 0;while(j--){prev=children[j];if(prev.type!==3/* COMMENT */){break;}}if(prev&&isTemplateNode(prev)&&findDir(prev,'if')){// remove node
children.splice(i,1);i--;// attach this slot to previous conditional
var conditional=dynamicSlots[dynamicSlots.length-1];while(conditional.alternate.type===19/* JS_CONDITIONAL_EXPRESSION */){conditional=conditional.alternate;}conditional.alternate=vElse.exp?createConditionalExpression(vElse.exp,buildDynamicSlot(slotName,slotFunction),defaultFallback):buildDynamicSlot(slotName,slotFunction);}else{context.onError(createCompilerError(30/* X_V_ELSE_NO_ADJACENT_IF */,vElse.loc));}}else if(vFor=findDir(slotElement,'for')){hasDynamicSlots=true;var parseResult=vFor.parseResult||parseForExpression(vFor.exp);if(parseResult){// Render the dynamic slots as an array and add it to the createSlot()
// args. The runtime knows how to handle it appropriately.
dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST),[parseResult.source,createFunctionExpression(createForLoopParams(parseResult),buildDynamicSlot(slotName,slotFunction),true/* force newline */)]));}else{context.onError(createCompilerError(32/* X_V_FOR_MALFORMED_EXPRESSION */,vFor.loc));}}else{// check duplicate static names
if(staticSlotName){if(seenSlotNames.has(staticSlotName)){context.onError(createCompilerError(38/* X_V_SLOT_DUPLICATE_SLOT_NAMES */,dirLoc));continue;}seenSlotNames.add(staticSlotName);if(staticSlotName==='default'){hasNamedDefaultSlot=true;}}slotsProperties.push(createObjectProperty(slotName,slotFunction));}}if(!onComponentSlot){var buildDefaultSlotProperty=function buildDefaultSlotProperty(props,children){var fn=buildSlotFn(props,children,loc);if(context.compatConfig){fn.isNonScopedSlot=true;}return createObjectProperty("default",fn);};if(!hasTemplateSlots){// implicit default slot (on component)
slotsProperties.push(buildDefaultSlotProperty(undefined,children));}else if(implicitDefaultChildren.length&&// #3766
// with whitespace: 'preserve', whitespaces between slots will end up in
// implicitDefaultChildren. Ignore if all implicit children are whitespaces.
implicitDefaultChildren.some(function(node){return isNonWhitespaceContent(node);})){// implicit default slot (mixed with named slots)
if(hasNamedDefaultSlot){context.onError(createCompilerError(39/* X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */,implicitDefaultChildren[0].loc));}else{slotsProperties.push(buildDefaultSlotProperty(undefined,implicitDefaultChildren));}}}var slotFlag=hasDynamicSlots?2/* DYNAMIC */:hasForwardedSlots(node.children)?3/* FORWARDED */:1/* STABLE */;var slots=createObjectExpression(slotsProperties.concat(createObjectProperty("_",// 2 = compiled but dynamic = can skip normalization, but must run diff
// 1 = compiled and static = can skip normalization AND diff as optimized
createSimpleExpression(slotFlag+"",false))),loc);if(dynamicSlots.length){slots=createCallExpression(context.helper(CREATE_SLOTS),[slots,createArrayExpression(dynamicSlots)]);}return{slots:slots,hasDynamicSlots:hasDynamicSlots};}function buildDynamicSlot(name,fn){return createObjectExpression([createObjectProperty("name",name),createObjectProperty("fn",fn)]);}function hasForwardedSlots(children){for(var i=0;i<children.length;i++){var child=children[i];switch(child.type){case 1/* ELEMENT */:if(child.tagType===2/* SLOT */||hasForwardedSlots(child.children)){return true;}break;case 9/* IF */:if(hasForwardedSlots(child.branches))return true;break;case 10/* IF_BRANCH */:case 11/* FOR */:if(hasForwardedSlots(child.children))return true;break;}}return false;}function isNonWhitespaceContent(node){if(node.type!==2/* TEXT */&&node.type!==12/* TEXT_CALL */)return true;return node.type===2/* TEXT */?!!node.content.trim():isNonWhitespaceContent(node.content);}// some directive transforms (e.g. v-model) may return a symbol for runtime
// import, which should be used instead of a resolveDirective call.
var directiveImportMap=new WeakMap();// generate a JavaScript AST for this element's codegen
var transformElement=function transformElement(node,context){// perform the work on exit, after all child expressions have been
// processed and merged.
return function postTransformElement(){node=context.currentNode;if(!(node.type===1/* ELEMENT */&&(node.tagType===0/* ELEMENT */||node.tagType===1/* COMPONENT */))){return;}var _node3=node,tag=_node3.tag,props=_node3.props;var isComponent=node.tagType===1/* COMPONENT */;// The goal of the transform is to create a codegenNode implementing the
// VNodeCall interface.
var vnodeTag=isComponent?resolveComponentType(node,context):"\"".concat(tag,"\"");var isDynamicComponent=isObject(vnodeTag)&&vnodeTag.callee===RESOLVE_DYNAMIC_COMPONENT;var vnodeProps;var vnodeChildren;var vnodePatchFlag;var patchFlag=0;var vnodeDynamicProps;var dynamicPropNames;var vnodeDirectives;var shouldUseBlock=// dynamic component may resolve to plain elements
isDynamicComponent||vnodeTag===TELEPORT||vnodeTag===SUSPENSE||!isComponent&&(// <svg> and <foreignObject> must be forced into blocks so that block
// updates inside get proper isSVG flag at runtime. (#639, #643)
// This is technically web-specific, but splitting the logic out of core
// leads to too much unnecessary complexity.
tag==='svg'||tag==='foreignObject');// props
if(props.length>0){var propsBuildResult=buildProps(node,context,undefined,isComponent,isDynamicComponent);vnodeProps=propsBuildResult.props;patchFlag=propsBuildResult.patchFlag;dynamicPropNames=propsBuildResult.dynamicPropNames;var directives=propsBuildResult.directives;vnodeDirectives=directives&&directives.length?createArrayExpression(directives.map(function(dir){return buildDirectiveArgs(dir,context);})):undefined;if(propsBuildResult.shouldUseBlock){shouldUseBlock=true;}}// children
if(node.children.length>0){if(vnodeTag===KEEP_ALIVE){// Although a built-in component, we compile KeepAlive with raw children
// instead of slot functions so that it can be used inside Transition
// or other Transition-wrapping HOCs.
// To ensure correct updates with block optimizations, we need to:
// 1. Force keep-alive into a block. This avoids its children being
//    collected by a parent block.
shouldUseBlock=true;// 2. Force keep-alive to always be updated, since it uses raw children.
patchFlag|=1024/* DYNAMIC_SLOTS */;}var shouldBuildAsSlots=isComponent&&// Teleport is not a real component and has dedicated runtime handling
vnodeTag!==TELEPORT&&// explained above.
vnodeTag!==KEEP_ALIVE;if(shouldBuildAsSlots){var _buildSlots=buildSlots(node,context),slots=_buildSlots.slots,hasDynamicSlots=_buildSlots.hasDynamicSlots;vnodeChildren=slots;if(hasDynamicSlots){patchFlag|=1024/* DYNAMIC_SLOTS */;}}else if(node.children.length===1&&vnodeTag!==TELEPORT){var child=node.children[0];var type=child.type;// check for dynamic text children
var hasDynamicTextChild=type===5/* INTERPOLATION */||type===8/* COMPOUND_EXPRESSION */;if(hasDynamicTextChild&&getConstantType(child,context)===0/* NOT_CONSTANT */){patchFlag|=1/* TEXT */;}// pass directly if the only child is a text node
// (plain / interpolation / expression)
if(hasDynamicTextChild||type===2/* TEXT */){vnodeChildren=child;}else{vnodeChildren=node.children;}}else{vnodeChildren=node.children;}}// patchFlag & dynamicPropNames
if(patchFlag!==0){{vnodePatchFlag=String(patchFlag);}if(dynamicPropNames&&dynamicPropNames.length){vnodeDynamicProps=stringifyDynamicPropNames(dynamicPropNames);}}node.codegenNode=createVNodeCall(context,vnodeTag,vnodeProps,vnodeChildren,vnodePatchFlag,vnodeDynamicProps,vnodeDirectives,!!shouldUseBlock,false/* disableTracking */,isComponent,node.loc);};};function resolveComponentType(node,context){var ssr=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;var tag=node.tag;// 1. dynamic component
var isExplicitDynamic=isComponentTag(tag);var isProp=findProp(node,'is');if(isProp){if(isExplicitDynamic||isCompatEnabled("COMPILER_IS_ON_ELEMENT"/* COMPILER_IS_ON_ELEMENT */,context)){var exp=isProp.type===6/* ATTRIBUTE */?isProp.value&&createSimpleExpression(isProp.value.content,true):isProp.exp;if(exp){return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT),[exp]);}}else if(isProp.type===6/* ATTRIBUTE */&&isProp.value.content.startsWith('vue:')){// <button is="vue:xxx">
// if not <component>, only is value that starts with "vue:" will be
// treated as component by the parse phase and reach here, unless it's
// compat mode where all is values are considered components
tag=isProp.value.content.slice(4);}}// 1.5 v-is (TODO: Deprecate)
var isDir=!isExplicitDynamic&&findDir(node,'is');if(isDir&&isDir.exp){return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT),[isDir.exp]);}// 2. built-in components (Teleport, Transition, KeepAlive, Suspense...)
var builtIn=isCoreComponent(tag)||context.isBuiltInComponent(tag);if(builtIn){// built-ins are simply fallthroughs / have special handling during ssr
// so we don't need to import their runtime equivalents
if(!ssr)context.helper(builtIn);return builtIn;}// 5. user component (resolve)
context.helper(RESOLVE_COMPONENT);context.components.add(tag);return toValidAssetId(tag,"component");}function buildProps(node,context){var props=arguments.length>2&&arguments[2]!==undefined?arguments[2]:node.props;var isComponent=arguments.length>3?arguments[3]:undefined;var isDynamicComponent=arguments.length>4?arguments[4]:undefined;var ssr=arguments.length>5&&arguments[5]!==undefined?arguments[5]:false;var tag=node.tag,elementLoc=node.loc,children=node.children;var properties=[];var mergeArgs=[];var runtimeDirectives=[];var hasChildren=children.length>0;var shouldUseBlock=false;// patchFlag analysis
var patchFlag=0;var hasRef=false;var hasClassBinding=false;var hasStyleBinding=false;var hasHydrationEventBinding=false;var hasDynamicKeys=false;var hasVnodeHook=false;var dynamicPropNames=[];var analyzePatchFlag=function analyzePatchFlag(_ref6){var key=_ref6.key,value=_ref6.value;if(isStaticExp(key)){var name=key.content;var isEventHandler=isOn(name);if(isEventHandler&&(!isComponent||isDynamicComponent)&&// omit the flag for click handlers because hydration gives click
// dedicated fast path.
name.toLowerCase()!=='onclick'&&// omit v-model handlers
name!=='onUpdate:modelValue'&&// omit onVnodeXXX hooks
!isReservedProp(name)){hasHydrationEventBinding=true;}if(isEventHandler&&isReservedProp(name)){hasVnodeHook=true;}if(value.type===20/* JS_CACHE_EXPRESSION */||(value.type===4/* SIMPLE_EXPRESSION */||value.type===8/* COMPOUND_EXPRESSION */)&&getConstantType(value,context)>0){// skip if the prop is a cached handler or has constant value
return;}if(name==='ref'){hasRef=true;}else if(name==='class'){hasClassBinding=true;}else if(name==='style'){hasStyleBinding=true;}else if(name!=='key'&&!dynamicPropNames.includes(name)){dynamicPropNames.push(name);}// treat the dynamic class and style binding of the component as dynamic props
if(isComponent&&(name==='class'||name==='style')&&!dynamicPropNames.includes(name)){dynamicPropNames.push(name);}}else{hasDynamicKeys=true;}};for(var i=0;i<props.length;i++){// static attribute
var prop=props[i];if(prop.type===6/* ATTRIBUTE */){var loc=prop.loc,name=prop.name,value=prop.value;var isStatic=true;if(name==='ref'){hasRef=true;if(context.scopes.vFor>0){properties.push(createObjectProperty(createSimpleExpression('ref_for',true),createSimpleExpression('true')));}}// skip is on <component>, or is="vue:xxx"
if(name==='is'&&(isComponentTag(tag)||value&&value.content.startsWith('vue:')||isCompatEnabled("COMPILER_IS_ON_ELEMENT"/* COMPILER_IS_ON_ELEMENT */,context))){continue;}properties.push(createObjectProperty(createSimpleExpression(name,true,getInnerRange(loc,0,name.length)),createSimpleExpression(value?value.content:'',isStatic,value?value.loc:loc)));}else{// directives
var _name=prop.name,arg=prop.arg,exp=prop.exp,_loc2=prop.loc;var isVBind=_name==='bind';var isVOn=_name==='on';// skip v-slot - it is handled by its dedicated transform.
if(_name==='slot'){if(!isComponent){context.onError(createCompilerError(40/* X_V_SLOT_MISPLACED */,_loc2));}continue;}// skip v-once/v-memo - they are handled by dedicated transforms.
if(_name==='once'||_name==='memo'){continue;}// skip v-is and :is on <component>
if(_name==='is'||isVBind&&isStaticArgOf(arg,'is')&&(isComponentTag(tag)||isCompatEnabled("COMPILER_IS_ON_ELEMENT"/* COMPILER_IS_ON_ELEMENT */,context))){continue;}// skip v-on in SSR compilation
if(isVOn&&ssr){continue;}if(// #938: elements with dynamic keys should be forced into blocks
isVBind&&isStaticArgOf(arg,'key')||// inline before-update hooks need to force block so that it is invoked
// before children
isVOn&&hasChildren&&isStaticArgOf(arg,'vue:before-update')){shouldUseBlock=true;}if(isVBind&&isStaticArgOf(arg,'ref')&&context.scopes.vFor>0){properties.push(createObjectProperty(createSimpleExpression('ref_for',true),createSimpleExpression('true')));}// special case for v-bind and v-on with no argument
if(!arg&&(isVBind||isVOn)){hasDynamicKeys=true;if(exp){if(properties.length){mergeArgs.push(createObjectExpression(dedupeProperties(properties),elementLoc));properties=[];}if(isVBind){{if(isCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER"/* COMPILER_V_BIND_OBJECT_ORDER */,context)){mergeArgs.unshift(exp);continue;}}mergeArgs.push(exp);}else{// v-on="obj" -> toHandlers(obj)
mergeArgs.push({type:14/* JS_CALL_EXPRESSION */,loc:_loc2,callee:context.helper(TO_HANDLERS),arguments:[exp]});}}else{context.onError(createCompilerError(isVBind?34/* X_V_BIND_NO_EXPRESSION */:35/* X_V_ON_NO_EXPRESSION */,_loc2));}continue;}var directiveTransform=context.directiveTransforms[_name];if(directiveTransform){var _properties;// has built-in directive transform.
var _directiveTransform=directiveTransform(prop,node,context),_props=_directiveTransform.props,needRuntime=_directiveTransform.needRuntime;!ssr&&_props.forEach(analyzePatchFlag);(_properties=properties).push.apply(_properties,_toConsumableArray(_props));if(needRuntime){runtimeDirectives.push(prop);if(isSymbol(needRuntime)){directiveImportMap.set(prop,needRuntime);}}}else if(!isBuiltInDirective(_name)){// no built-in transform, this is a user custom directive.
runtimeDirectives.push(prop);// custom dirs may use beforeUpdate so they need to force blocks
// to ensure before-update gets called before children update
if(hasChildren){shouldUseBlock=true;}}}}var propsExpression=undefined;// has v-bind="object" or v-on="object", wrap with mergeProps
if(mergeArgs.length){if(properties.length){mergeArgs.push(createObjectExpression(dedupeProperties(properties),elementLoc));}if(mergeArgs.length>1){propsExpression=createCallExpression(context.helper(MERGE_PROPS),mergeArgs,elementLoc);}else{// single v-bind with nothing else - no need for a mergeProps call
propsExpression=mergeArgs[0];}}else if(properties.length){propsExpression=createObjectExpression(dedupeProperties(properties),elementLoc);}// patchFlag analysis
if(hasDynamicKeys){patchFlag|=16/* FULL_PROPS */;}else{if(hasClassBinding&&!isComponent){patchFlag|=2/* CLASS */;}if(hasStyleBinding&&!isComponent){patchFlag|=4/* STYLE */;}if(dynamicPropNames.length){patchFlag|=8/* PROPS */;}if(hasHydrationEventBinding){patchFlag|=32/* HYDRATE_EVENTS */;}}if(!shouldUseBlock&&(patchFlag===0||patchFlag===32/* HYDRATE_EVENTS */)&&(hasRef||hasVnodeHook||runtimeDirectives.length>0)){patchFlag|=512/* NEED_PATCH */;}// pre-normalize props, SSR is skipped for now
if(!context.inSSR&&propsExpression){switch(propsExpression.type){case 15/* JS_OBJECT_EXPRESSION */:// means that there is no v-bind,
// but still need to deal with dynamic key binding
var classKeyIndex=-1;var styleKeyIndex=-1;var hasDynamicKey=false;for(var _i8=0;_i8<propsExpression.properties.length;_i8++){var key=propsExpression.properties[_i8].key;if(isStaticExp(key)){if(key.content==='class'){classKeyIndex=_i8;}else if(key.content==='style'){styleKeyIndex=_i8;}}else if(!key.isHandlerKey){hasDynamicKey=true;}}var classProp=propsExpression.properties[classKeyIndex];var styleProp=propsExpression.properties[styleKeyIndex];// no dynamic key
if(!hasDynamicKey){if(classProp&&!isStaticExp(classProp.value)){classProp.value=createCallExpression(context.helper(NORMALIZE_CLASS),[classProp.value]);}if(styleProp&&(// the static style is compiled into an object,
// so use `hasStyleBinding` to ensure that it is a dynamic style binding
hasStyleBinding||styleProp.value.type===4/* SIMPLE_EXPRESSION */&&styleProp.value.content.trim()[0]==="["||// v-bind:style and style both exist,
// v-bind:style with static literal object
styleProp.value.type===17/* JS_ARRAY_EXPRESSION */)){styleProp.value=createCallExpression(context.helper(NORMALIZE_STYLE),[styleProp.value]);}}else{// dynamic key binding, wrap with `normalizeProps`
propsExpression=createCallExpression(context.helper(NORMALIZE_PROPS),[propsExpression]);}break;case 14/* JS_CALL_EXPRESSION */:// mergeProps call, do nothing
break;default:// single v-bind
propsExpression=createCallExpression(context.helper(NORMALIZE_PROPS),[createCallExpression(context.helper(GUARD_REACTIVE_PROPS),[propsExpression])]);break;}}return{props:propsExpression,directives:runtimeDirectives,patchFlag:patchFlag,dynamicPropNames:dynamicPropNames,shouldUseBlock:shouldUseBlock};}// Dedupe props in an object literal.
// Literal duplicated attributes would have been warned during the parse phase,
// however, it's possible to encounter duplicated `onXXX` handlers with different
// modifiers. We also need to merge static and dynamic class / style attributes.
// - onXXX handlers / style: merge into array
// - class: merge into single expression with concatenation
function dedupeProperties(properties){var knownProps=new Map();var deduped=[];for(var i=0;i<properties.length;i++){var prop=properties[i];// dynamic keys are always allowed
if(prop.key.type===8/* COMPOUND_EXPRESSION */||!prop.key.isStatic){deduped.push(prop);continue;}var name=prop.key.content;var existing=knownProps.get(name);if(existing){if(name==='style'||name==='class'||isOn(name)){mergeAsArray(existing,prop);}// unexpected duplicate, should have emitted error during parse
}else{knownProps.set(name,prop);deduped.push(prop);}}return deduped;}function mergeAsArray(existing,incoming){if(existing.value.type===17/* JS_ARRAY_EXPRESSION */){existing.value.elements.push(incoming.value);}else{existing.value=createArrayExpression([existing.value,incoming.value],existing.loc);}}function buildDirectiveArgs(dir,context){var dirArgs=[];var runtime=directiveImportMap.get(dir);if(runtime){// built-in directive with runtime
dirArgs.push(context.helperString(runtime));}else{{// inject statement for resolving directive
context.helper(RESOLVE_DIRECTIVE);context.directives.add(dir.name);dirArgs.push(toValidAssetId(dir.name,"directive"));}}var loc=dir.loc;if(dir.exp)dirArgs.push(dir.exp);if(dir.arg){if(!dir.exp){dirArgs.push("void 0");}dirArgs.push(dir.arg);}if(Object.keys(dir.modifiers).length){if(!dir.arg){if(!dir.exp){dirArgs.push("void 0");}dirArgs.push("void 0");}var trueExpression=createSimpleExpression("true",false,loc);dirArgs.push(createObjectExpression(dir.modifiers.map(function(modifier){return createObjectProperty(modifier,trueExpression);}),loc));}return createArrayExpression(dirArgs,dir.loc);}function stringifyDynamicPropNames(props){var propsNamesString="[";for(var i=0,l=props.length;i<l;i++){propsNamesString+=JSON.stringify(props[i]);if(i<l-1)propsNamesString+=', ';}return propsNamesString+"]";}function isComponentTag(tag){return tag==='component'||tag==='Component';}var cacheStringFunction=function cacheStringFunction(fn){var cache=Object.create(null);return function(str){var hit=cache[str];return hit||(cache[str]=fn(str));};};var camelizeRE=/-(\w)/g;/**
             * @private
             */var camelize=cacheStringFunction(function(str){return str.replace(camelizeRE,function(_,c){return c?c.toUpperCase():'';});});var transformSlotOutlet=function transformSlotOutlet(node,context){if(isSlotOutlet(node)){var children=node.children,loc=node.loc;var _processSlotOutlet=processSlotOutlet(node,context),slotName=_processSlotOutlet.slotName,slotProps=_processSlotOutlet.slotProps;var slotArgs=[context.prefixIdentifiers?"_ctx.$slots":"$slots",slotName,'{}','undefined','true'];var expectedLen=2;if(slotProps){slotArgs[2]=slotProps;expectedLen=3;}if(children.length){slotArgs[3]=createFunctionExpression([],children,false,false,loc);expectedLen=4;}if(context.scopeId&&!context.slotted){expectedLen=5;}slotArgs.splice(expectedLen);// remove unused arguments
node.codegenNode=createCallExpression(context.helper(RENDER_SLOT),slotArgs,loc);}};function processSlotOutlet(node,context){var slotName="\"default\"";var slotProps=undefined;var nonNameProps=[];for(var i=0;i<node.props.length;i++){var p=node.props[i];if(p.type===6/* ATTRIBUTE */){if(p.value){if(p.name==='name'){slotName=JSON.stringify(p.value.content);}else{p.name=camelize(p.name);nonNameProps.push(p);}}}else{if(p.name==='bind'&&isStaticArgOf(p.arg,'name')){if(p.exp)slotName=p.exp;}else{if(p.name==='bind'&&p.arg&&isStaticExp(p.arg)){p.arg.content=camelize(p.arg.content);}nonNameProps.push(p);}}}if(nonNameProps.length>0){var _buildProps=buildProps(node,context,nonNameProps,false,false),props=_buildProps.props,directives=_buildProps.directives;slotProps=props;if(directives.length){context.onError(createCompilerError(36/* X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */,directives[0].loc));}}return{slotName:slotName,slotProps:slotProps};}var fnExpRE=/^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/;var transformOn$1=function transformOn$1(dir,node,context,augmentor){var loc=dir.loc,modifiers=dir.modifiers,arg=dir.arg;if(!dir.exp&&!modifiers.length){context.onError(createCompilerError(35/* X_V_ON_NO_EXPRESSION */,loc));}var eventName;if(arg.type===4/* SIMPLE_EXPRESSION */){if(arg.isStatic){var rawName=arg.content;// TODO deprecate @vnodeXXX usage
if(rawName.startsWith('vue:')){rawName="vnode-".concat(rawName.slice(4));}// for all event listeners, auto convert it to camelCase. See issue #2249
eventName=createSimpleExpression(toHandlerKey(camelize$1(rawName)),true,arg.loc);}else{// #2388
eventName=createCompoundExpression(["".concat(context.helperString(TO_HANDLER_KEY),"("),arg,")"]);}}else{// already a compound expression.
eventName=arg;eventName.children.unshift("".concat(context.helperString(TO_HANDLER_KEY),"("));eventName.children.push(")");}// handler processing
var exp=dir.exp;if(exp&&!exp.content.trim()){exp=undefined;}var shouldCache=context.cacheHandlers&&!exp&&!context.inVOnce;if(exp){var isMemberExp=isMemberExpression(exp.content);var isInlineStatement=!(isMemberExp||fnExpRE.test(exp.content));var hasMultipleStatements=exp.content.includes(";");if(isInlineStatement||shouldCache&&isMemberExp){// wrap inline statement in a function expression
exp=createCompoundExpression(["".concat(isInlineStatement?"$event":"".concat("","(...args)")," => ").concat(hasMultipleStatements?"{":"("),exp,hasMultipleStatements?"}":")"]);}}var ret={props:[createObjectProperty(eventName,exp||createSimpleExpression("() => {}",false,loc))]};// apply extended compiler augmentor
if(augmentor){ret=augmentor(ret);}if(shouldCache){// cache handlers so that it's always the same handler being passed down.
// this avoids unnecessary re-renders when users use inline handlers on
// components.
ret.props[0].value=context.cache(ret.props[0].value);}// mark the key as handler for props normalization check
ret.props.forEach(function(p){return p.key.isHandlerKey=true;});return ret;};// v-bind without arg is handled directly in ./transformElements.ts due to it affecting
// codegen for the entire props object. This transform here is only for v-bind
// *with* args.
var transformBind=function transformBind(dir,_node,context){var exp=dir.exp,modifiers=dir.modifiers,loc=dir.loc;var arg=dir.arg;if(arg.type!==4/* SIMPLE_EXPRESSION */){arg.children.unshift("(");arg.children.push(") || \"\"");}else if(!arg.isStatic){arg.content="".concat(arg.content," || \"\"");}// .sync is replaced by v-model:arg
if(modifiers.includes('camel')){if(arg.type===4/* SIMPLE_EXPRESSION */){if(arg.isStatic){arg.content=camelize$1(arg.content);}else{arg.content="".concat(context.helperString(CAMELIZE),"(").concat(arg.content,")");}}else{arg.children.unshift("".concat(context.helperString(CAMELIZE),"("));arg.children.push(")");}}if(!context.inSSR){if(modifiers.includes('prop')){injectPrefix(arg,'.');}if(modifiers.includes('attr')){injectPrefix(arg,'^');}}if(!exp||exp.type===4/* SIMPLE_EXPRESSION */&&!exp.content.trim()){context.onError(createCompilerError(34/* X_V_BIND_NO_EXPRESSION */,loc));return{props:[createObjectProperty(arg,createSimpleExpression('',true,loc))]};}return{props:[createObjectProperty(arg,exp)]};};var injectPrefix=function injectPrefix(arg,prefix){if(arg.type===4/* SIMPLE_EXPRESSION */){if(arg.isStatic){arg.content=prefix+arg.content;}else{arg.content="`".concat(prefix,"${").concat(arg.content,"}`");}}else{arg.children.unshift("'".concat(prefix,"' + ("));arg.children.push(")");}};// Merge adjacent text nodes and expressions into a single expression
// e.g. <div>abc {{ d }} {{ e }}</div> should have a single expression node as child.
var transformText=function transformText(node,context){if(node.type===0/* ROOT */||node.type===1/* ELEMENT */||node.type===11/* FOR */||node.type===10/* IF_BRANCH */){// perform the transform on node exit so that all expressions have already
// been processed.
return function(){var children=node.children;var currentContainer=undefined;var hasText=false;for(var i=0;i<children.length;i++){var child=children[i];if(isText(child)){hasText=true;for(var j=i+1;j<children.length;j++){var next=children[j];if(isText(next)){if(!currentContainer){currentContainer=children[i]=createCompoundExpression([child],child.loc);}// merge adjacent text node into current
currentContainer.children.push(" + ",next);children.splice(j,1);j--;}else{currentContainer=undefined;break;}}}}if(!hasText||// if this is a plain element with a single text child, leave it
// as-is since the runtime has dedicated fast path for this by directly
// setting textContent of the element.
// for component root it's always normalized anyway.
children.length===1&&(node.type===0/* ROOT */||node.type===1/* ELEMENT */&&node.tagType===0/* ELEMENT */&&// #3756
// custom directives can potentially add DOM elements arbitrarily,
// we need to avoid setting textContent of the element at runtime
// to avoid accidentally overwriting the DOM elements added
// by the user through custom directives.
!node.props.find(function(p){return p.type===7/* DIRECTIVE */&&!context.directiveTransforms[p.name];})&&// in compat mode, <template> tags with no special directives
// will be rendered as a fragment so its children must be
// converted into vnodes.
!(node.tag==='template'))){return;}// pre-convert text nodes into createTextVNode(text) calls to avoid
// runtime normalization.
for(var _i9=0;_i9<children.length;_i9++){var _child=children[_i9];if(isText(_child)||_child.type===8/* COMPOUND_EXPRESSION */){var callArgs=[];// createTextVNode defaults to single whitespace, so if it is a
// single space the code could be an empty call to save bytes.
if(_child.type!==2/* TEXT */||_child.content!==' '){callArgs.push(_child);}// mark dynamic text with flag so it gets patched inside a block
if(!context.ssr&&getConstantType(_child,context)===0/* NOT_CONSTANT */){callArgs.push(1/* TEXT */+"");}children[_i9]={type:12/* TEXT_CALL */,content:_child,loc:_child.loc,codegenNode:createCallExpression(context.helper(CREATE_TEXT),callArgs)};}}};}};var seen=new WeakSet();var transformOnce=function transformOnce(node,context){if(node.type===1/* ELEMENT */&&findDir(node,'once',true)){if(seen.has(node)||context.inVOnce){return;}seen.add(node);context.inVOnce=true;context.helper(SET_BLOCK_TRACKING);return function(){context.inVOnce=false;var cur=context.currentNode;if(cur.codegenNode){cur.codegenNode=context.cache(cur.codegenNode,true/* isVNode */);}};}};var transformModel$1=function transformModel$1(dir,node,context){var exp=dir.exp,arg=dir.arg;if(!exp){context.onError(createCompilerError(41/* X_V_MODEL_NO_EXPRESSION */,dir.loc));return createTransformProps();}var rawExp=exp.loc.source;var expString=exp.type===4/* SIMPLE_EXPRESSION */?exp.content:rawExp;// im SFC <script setup> inline mode, the exp may have been transformed into
// _unref(exp)
context.bindingMetadata[rawExp];var maybeRef=!true/* SETUP_CONST */;if(!expString.trim()||!isMemberExpression(expString)&&!maybeRef){context.onError(createCompilerError(42/* X_V_MODEL_MALFORMED_EXPRESSION */,exp.loc));return createTransformProps();}var propName=arg?arg:createSimpleExpression('modelValue',true);var eventName=arg?isStaticExp(arg)?"onUpdate:".concat(arg.content):createCompoundExpression(['"onUpdate:" + ',arg]):"onUpdate:modelValue";var assignmentExp;var eventArg=context.isTS?"($event: any)":"$event";{assignmentExp=createCompoundExpression(["".concat(eventArg," => (("),exp,") = $event)"]);}var props=[// modelValue: foo
createObjectProperty(propName,dir.exp),// "onUpdate:modelValue": $event => (foo = $event)
createObjectProperty(eventName,assignmentExp)];// modelModifiers: { foo: true, "bar-baz": true }
if(dir.modifiers.length&&node.tagType===1/* COMPONENT */){var modifiers=dir.modifiers.map(function(m){return(isSimpleIdentifier(m)?m:JSON.stringify(m))+": true";}).join(", ");var modifiersKey=arg?isStaticExp(arg)?"".concat(arg.content,"Modifiers"):createCompoundExpression([arg,' + "Modifiers"']):"modelModifiers";props.push(createObjectProperty(modifiersKey,createSimpleExpression("{ ".concat(modifiers," }"),false,dir.loc,2/* CAN_HOIST */)));}return createTransformProps(props);};function createTransformProps(){var props=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];return{props:props};}var validDivisionCharRE=/[\w).+\-_$\]]/;var transformFilter=function transformFilter(node,context){if(!isCompatEnabled("COMPILER_FILTER"/* COMPILER_FILTERS */,context)){return;}if(node.type===5/* INTERPOLATION */){// filter rewrite is applied before expression transform so only
// simple expressions are possible at this stage
rewriteFilter(node.content,context);}if(node.type===1/* ELEMENT */){node.props.forEach(function(prop){if(prop.type===7/* DIRECTIVE */&&prop.name!=='for'&&prop.exp){rewriteFilter(prop.exp,context);}});}};function rewriteFilter(node,context){if(node.type===4/* SIMPLE_EXPRESSION */){parseFilter(node,context);}else{for(var i=0;i<node.children.length;i++){var child=node.children[i];if(_typeof(child)!=='object')continue;if(child.type===4/* SIMPLE_EXPRESSION */){parseFilter(child,context);}else if(child.type===8/* COMPOUND_EXPRESSION */){rewriteFilter(node,context);}else if(child.type===5/* INTERPOLATION */){rewriteFilter(child.content,context);}}}}function parseFilter(node,context){var exp=node.content;var inSingle=false;var inDouble=false;var inTemplateString=false;var inRegex=false;var curly=0;var square=0;var paren=0;var lastFilterIndex=0;var c,prev,i,expression,filters=[];for(i=0;i<exp.length;i++){prev=c;c=exp.charCodeAt(i);if(inSingle){if(c===0x27&&prev!==0x5c)inSingle=false;}else if(inDouble){if(c===0x22&&prev!==0x5c)inDouble=false;}else if(inTemplateString){if(c===0x60&&prev!==0x5c)inTemplateString=false;}else if(inRegex){if(c===0x2f&&prev!==0x5c)inRegex=false;}else if(c===0x7c&&// pipe
exp.charCodeAt(i+1)!==0x7c&&exp.charCodeAt(i-1)!==0x7c&&!curly&&!square&&!paren){if(expression===undefined){// first filter, end of expression
lastFilterIndex=i+1;expression=exp.slice(0,i).trim();}else{pushFilter();}}else{switch(c){case 0x22:inDouble=true;break;// "
case 0x27:inSingle=true;break;// '
case 0x60:inTemplateString=true;break;// `
case 0x28:paren++;break;// (
case 0x29:paren--;break;// )
case 0x5b:square++;break;// [
case 0x5d:square--;break;// ]
case 0x7b:curly++;break;// {
case 0x7d:curly--;break;// }
}if(c===0x2f){// /
var j=i-1;var p=void 0;// find first non-whitespace prev char
for(;j>=0;j--){p=exp.charAt(j);if(p!==' ')break;}if(!p||!validDivisionCharRE.test(p)){inRegex=true;}}}}if(expression===undefined){expression=exp.slice(0,i).trim();}else if(lastFilterIndex!==0){pushFilter();}function pushFilter(){filters.push(exp.slice(lastFilterIndex,i).trim());lastFilterIndex=i+1;}if(filters.length){for(i=0;i<filters.length;i++){expression=wrapFilter(expression,filters[i],context);}node.content=expression;}}function wrapFilter(exp,filter,context){context.helper(RESOLVE_FILTER);var i=filter.indexOf('(');if(i<0){context.filters.add(filter);return"".concat(toValidAssetId(filter,'filter'),"(").concat(exp,")");}else{var name=filter.slice(0,i);var args=filter.slice(i+1);context.filters.add(name);return"".concat(toValidAssetId(name,'filter'),"(").concat(exp).concat(args!==')'?','+args:args);}}var seen$1=new WeakSet();var transformMemo=function transformMemo(node,context){if(node.type===1/* ELEMENT */){var dir=findDir(node,'memo');if(!dir||seen$1.has(node)){return;}seen$1.add(node);return function(){var codegenNode=node.codegenNode||context.currentNode.codegenNode;if(codegenNode&&codegenNode.type===13/* VNODE_CALL */){// non-component sub tree should be turned into a block
if(node.tagType!==1/* COMPONENT */){makeBlock(codegenNode,context);}node.codegenNode=createCallExpression(context.helper(WITH_MEMO),[dir.exp,createFunctionExpression(undefined,codegenNode),"_cache",String(context.cached++)]);}};}};function getBaseTransformPreset(prefixIdentifiers){return[[transformOnce,transformIf,transformMemo,transformFor].concat([transformFilter],[],[transformSlotOutlet,transformElement,trackSlotScopes,transformText]),{on:transformOn$1,bind:transformBind,model:transformModel$1}];}// we name it `baseCompile` so that higher order compilers like
// @vue/compiler-dom can export `compile` while re-exporting everything else.
function baseCompile(template){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var onError=options.onError||defaultOnError;var isModuleMode=options.mode==='module';/* istanbul ignore if */{if(options.prefixIdentifiers===true){onError(createCompilerError(46/* X_PREFIX_ID_NOT_SUPPORTED */));}else if(isModuleMode){onError(createCompilerError(47/* X_MODULE_MODE_NOT_SUPPORTED */));}}var prefixIdentifiers=!true;if(options.cacheHandlers){onError(createCompilerError(48/* X_CACHE_HANDLER_NOT_SUPPORTED */));}if(options.scopeId&&!isModuleMode){onError(createCompilerError(49/* X_SCOPE_ID_NOT_SUPPORTED */));}var ast=isString(template)?baseParse(template,options):template;var _getBaseTransformPres=getBaseTransformPreset(),_getBaseTransformPres2=_slicedToArray(_getBaseTransformPres,2),nodeTransforms=_getBaseTransformPres2[0],directiveTransforms=_getBaseTransformPres2[1];transform(ast,extend({},options,{prefixIdentifiers:prefixIdentifiers,nodeTransforms:[].concat(_toConsumableArray(nodeTransforms),_toConsumableArray(options.nodeTransforms||[])),directiveTransforms:extend({},directiveTransforms,options.directiveTransforms||{}// user transforms
)}));return generate(ast,extend({},options,{prefixIdentifiers:prefixIdentifiers}));}var noopDirectiveTransform=function noopDirectiveTransform(){return{props:[]};};var V_MODEL_RADIO=Symbol("");var V_MODEL_CHECKBOX=Symbol("");var V_MODEL_TEXT=Symbol("");var V_MODEL_SELECT=Symbol("");var V_MODEL_DYNAMIC=Symbol("");var V_ON_WITH_MODIFIERS=Symbol("");var V_ON_WITH_KEYS=Symbol("");var V_SHOW=Symbol("");var TRANSITION=Symbol("");var TRANSITION_GROUP=Symbol("");registerRuntimeHelpers((_registerRuntimeHelpe={},_defineProperty(_registerRuntimeHelpe,V_MODEL_RADIO,"vModelRadio"),_defineProperty(_registerRuntimeHelpe,V_MODEL_CHECKBOX,"vModelCheckbox"),_defineProperty(_registerRuntimeHelpe,V_MODEL_TEXT,"vModelText"),_defineProperty(_registerRuntimeHelpe,V_MODEL_SELECT,"vModelSelect"),_defineProperty(_registerRuntimeHelpe,V_MODEL_DYNAMIC,"vModelDynamic"),_defineProperty(_registerRuntimeHelpe,V_ON_WITH_MODIFIERS,"withModifiers"),_defineProperty(_registerRuntimeHelpe,V_ON_WITH_KEYS,"withKeys"),_defineProperty(_registerRuntimeHelpe,V_SHOW,"vShow"),_defineProperty(_registerRuntimeHelpe,TRANSITION,"Transition"),_defineProperty(_registerRuntimeHelpe,TRANSITION_GROUP,"TransitionGroup"),_registerRuntimeHelpe));/* eslint-disable no-restricted-globals */var decoder;function decodeHtmlBrowser(raw){var asAttr=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;if(!decoder){decoder=document.createElement('div');}if(asAttr){decoder.innerHTML="<div foo=\"".concat(raw.replace(/"/g,'&quot;'),"\">");return decoder.children[0].getAttribute('foo');}else{decoder.innerHTML=raw;return decoder.textContent;}}var isRawTextContainer=/*#__PURE__*/makeMap('style,iframe,script,noscript',true);var parserOptions={isVoidTag:isVoidTag,isNativeTag:function isNativeTag(tag){return isHTMLTag(tag)||isSVGTag(tag);},isPreTag:function isPreTag(tag){return tag==='pre';},decodeEntities:decodeHtmlBrowser,isBuiltInComponent:function isBuiltInComponent(tag){if(isBuiltInType(tag,"Transition")){return TRANSITION;}else if(isBuiltInType(tag,"TransitionGroup")){return TRANSITION_GROUP;}},// https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
getNamespace:function getNamespace(tag,parent){var ns=parent?parent.ns:0/* HTML */;if(parent&&ns===2/* MATH_ML */){if(parent.tag==='annotation-xml'){if(tag==='svg'){return 1/* SVG */;}if(parent.props.some(function(a){return a.type===6/* ATTRIBUTE */&&a.name==='encoding'&&a.value!=null&&(a.value.content==='text/html'||a.value.content==='application/xhtml+xml');})){ns=0/* HTML */;}}else if(/^m(?:[ions]|text)$/.test(parent.tag)&&tag!=='mglyph'&&tag!=='malignmark'){ns=0/* HTML */;}}else if(parent&&ns===1/* SVG */){if(parent.tag==='foreignObject'||parent.tag==='desc'||parent.tag==='title'){ns=0/* HTML */;}}if(ns===0/* HTML */){if(tag==='svg'){return 1/* SVG */;}if(tag==='math'){return 2/* MATH_ML */;}}return ns;},// https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments
getTextMode:function getTextMode(_ref7){var tag=_ref7.tag,ns=_ref7.ns;if(ns===0/* HTML */){if(tag==='textarea'||tag==='title'){return 1/* RCDATA */;}if(isRawTextContainer(tag)){return 2/* RAWTEXT */;}}return 0/* DATA */;}};// Parse inline CSS strings for static style attributes into an object.
// This is a NodeTransform since it works on the static `style` attribute and
// converts it into a dynamic equivalent:
// style="color: red" -> :style='{ "color": "red" }'
// It is then processed by `transformElement` and included in the generated
// props.
var transformStyle=function transformStyle(node){if(node.type===1/* ELEMENT */){node.props.forEach(function(p,i){if(p.type===6/* ATTRIBUTE */&&p.name==='style'&&p.value){// replace p with an expression node
node.props[i]={type:7/* DIRECTIVE */,name:"bind",arg:createSimpleExpression("style",true,p.loc),exp:parseInlineCSS(p.value.content,p.loc),modifiers:[],loc:p.loc};}});}};var parseInlineCSS=function parseInlineCSS(cssText,loc){var normalized=parseStringStyle(cssText);return createSimpleExpression(JSON.stringify(normalized),false,loc,3/* CAN_STRINGIFY */);};function createDOMCompilerError(code,loc){return createCompilerError(code,loc);}var transformVHtml=function transformVHtml(dir,node,context){var exp=dir.exp,loc=dir.loc;if(!exp){context.onError(createDOMCompilerError(50/* X_V_HTML_NO_EXPRESSION */,loc));}if(node.children.length){context.onError(createDOMCompilerError(51/* X_V_HTML_WITH_CHILDREN */,loc));node.children.length=0;}return{props:[createObjectProperty(createSimpleExpression("innerHTML",true,loc),exp||createSimpleExpression('',true))]};};var transformVText=function transformVText(dir,node,context){var exp=dir.exp,loc=dir.loc;if(!exp){context.onError(createDOMCompilerError(52/* X_V_TEXT_NO_EXPRESSION */,loc));}if(node.children.length){context.onError(createDOMCompilerError(53/* X_V_TEXT_WITH_CHILDREN */,loc));node.children.length=0;}return{props:[createObjectProperty(createSimpleExpression("textContent",true),exp?getConstantType(exp,context)>0?exp:createCallExpression(context.helperString(TO_DISPLAY_STRING),[exp],loc):createSimpleExpression('',true))]};};var transformModel=function transformModel(dir,node,context){var baseResult=transformModel$1(dir,node,context);// base transform has errors OR component v-model (only need props)
if(!baseResult.props.length||node.tagType===1/* COMPONENT */){return baseResult;}if(dir.arg){context.onError(createDOMCompilerError(55/* X_V_MODEL_ARG_ON_ELEMENT */,dir.arg.loc));}var tag=node.tag;var isCustomElement=context.isCustomElement(tag);if(tag==='input'||tag==='textarea'||tag==='select'||isCustomElement){var directiveToUse=V_MODEL_TEXT;var isInvalidType=false;if(tag==='input'||isCustomElement){var type=findProp(node,"type");if(type){if(type.type===7/* DIRECTIVE */){// :type="foo"
directiveToUse=V_MODEL_DYNAMIC;}else if(type.value){switch(type.value.content){case'radio':directiveToUse=V_MODEL_RADIO;break;case'checkbox':directiveToUse=V_MODEL_CHECKBOX;break;case'file':isInvalidType=true;context.onError(createDOMCompilerError(56/* X_V_MODEL_ON_FILE_INPUT_ELEMENT */,dir.loc));break;}}}else if(hasDynamicKeyVBind(node)){// element has bindings with dynamic keys, which can possibly contain
// "type".
directiveToUse=V_MODEL_DYNAMIC;}else;}else if(tag==='select'){directiveToUse=V_MODEL_SELECT;}else;// inject runtime directive
// by returning the helper symbol via needRuntime
// the import will replaced a resolveDirective call.
if(!isInvalidType){baseResult.needRuntime=context.helper(directiveToUse);}}else{context.onError(createDOMCompilerError(54/* X_V_MODEL_ON_INVALID_ELEMENT */,dir.loc));}// native vmodel doesn't need the `modelValue` props since they are also
// passed to the runtime as `binding.value`. removing it reduces code size.
baseResult.props=baseResult.props.filter(function(p){return!(p.key.type===4/* SIMPLE_EXPRESSION */&&p.key.content==='modelValue');});return baseResult;};var isEventOptionModifier=/*#__PURE__*/makeMap("passive,once,capture");var isNonKeyModifier=/*#__PURE__*/makeMap(// event propagation management
"stop,prevent,self,"+// system modifiers + exact
"ctrl,shift,alt,meta,exact,"+// mouse
"middle");// left & right could be mouse or key modifiers based on event type
var maybeKeyModifier=/*#__PURE__*/makeMap('left,right');var isKeyboardEvent=/*#__PURE__*/makeMap("onkeyup,onkeydown,onkeypress",true);var resolveModifiers=function resolveModifiers(key,modifiers,context,loc){var keyModifiers=[];var nonKeyModifiers=[];var eventOptionModifiers=[];for(var i=0;i<modifiers.length;i++){var modifier=modifiers[i];if(modifier==='native'&&checkCompatEnabled("COMPILER_V_ON_NATIVE"/* COMPILER_V_ON_NATIVE */,context)){eventOptionModifiers.push(modifier);}else if(isEventOptionModifier(modifier)){// eventOptionModifiers: modifiers for addEventListener() options,
// e.g. .passive & .capture
eventOptionModifiers.push(modifier);}else{// runtimeModifiers: modifiers that needs runtime guards
if(maybeKeyModifier(modifier)){if(isStaticExp(key)){if(isKeyboardEvent(key.content)){keyModifiers.push(modifier);}else{nonKeyModifiers.push(modifier);}}else{keyModifiers.push(modifier);nonKeyModifiers.push(modifier);}}else{if(isNonKeyModifier(modifier)){nonKeyModifiers.push(modifier);}else{keyModifiers.push(modifier);}}}}return{keyModifiers:keyModifiers,nonKeyModifiers:nonKeyModifiers,eventOptionModifiers:eventOptionModifiers};};var transformClick=function transformClick(key,event){var isStaticClick=isStaticExp(key)&&key.content.toLowerCase()==='onclick';return isStaticClick?createSimpleExpression(event,true):key.type!==4/* SIMPLE_EXPRESSION */?createCompoundExpression(["(",key,") === \"onClick\" ? \"".concat(event,"\" : ("),key,")"]):key;};var transformOn=function transformOn(dir,node,context){return transformOn$1(dir,node,context,function(baseResult){var modifiers=dir.modifiers;if(!modifiers.length)return baseResult;var _baseResult$props$=baseResult.props[0],key=_baseResult$props$.key,handlerExp=_baseResult$props$.value;var _resolveModifiers=resolveModifiers(key,modifiers,context,dir.loc),keyModifiers=_resolveModifiers.keyModifiers,nonKeyModifiers=_resolveModifiers.nonKeyModifiers,eventOptionModifiers=_resolveModifiers.eventOptionModifiers;// normalize click.right and click.middle since they don't actually fire
if(nonKeyModifiers.includes('right')){key=transformClick(key,"onContextmenu");}if(nonKeyModifiers.includes('middle')){key=transformClick(key,"onMouseup");}if(nonKeyModifiers.length){handlerExp=createCallExpression(context.helper(V_ON_WITH_MODIFIERS),[handlerExp,JSON.stringify(nonKeyModifiers)]);}if(keyModifiers.length&&(// if event name is dynamic, always wrap with keys guard
!isStaticExp(key)||isKeyboardEvent(key.content))){handlerExp=createCallExpression(context.helper(V_ON_WITH_KEYS),[handlerExp,JSON.stringify(keyModifiers)]);}if(eventOptionModifiers.length){var modifierPostfix=eventOptionModifiers.map(capitalize).join('');key=isStaticExp(key)?createSimpleExpression("".concat(key.content).concat(modifierPostfix),true):createCompoundExpression(["(",key,") + \"".concat(modifierPostfix,"\"")]);}return{props:[createObjectProperty(key,handlerExp)]};});};var transformShow=function transformShow(dir,node,context){var exp=dir.exp,loc=dir.loc;if(!exp){context.onError(createDOMCompilerError(58/* X_V_SHOW_NO_EXPRESSION */,loc));}return{props:[],needRuntime:context.helper(V_SHOW)};};var ignoreSideEffectTags=function ignoreSideEffectTags(node,context){if(node.type===1/* ELEMENT */&&node.tagType===0/* ELEMENT */&&(node.tag==='script'||node.tag==='style')){context.onError(createDOMCompilerError(60/* X_IGNORED_SIDE_EFFECT_TAG */,node.loc));context.removeNode();}};var DOMNodeTransforms=[transformStyle].concat([]);var DOMDirectiveTransforms={cloak:noopDirectiveTransform,html:transformVHtml,text:transformVText,model:transformModel,on:transformOn,show:transformShow};function compile(template){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};return baseCompile(template,extend({},parserOptions,options,{nodeTransforms:[// ignore <script> and <tag>
// this is not put inside DOMNodeTransforms because that list is used
// by compiler-ssr to generate vnode fallback branches
ignoreSideEffectTags].concat(_toConsumableArray(DOMNodeTransforms),_toConsumableArray(options.nodeTransforms||[])),directiveTransforms:extend({},DOMDirectiveTransforms,options.directiveTransforms||{}),transformHoist:null}));}var compileCache=Object.create(null);function compileToFunction(template,options){if(!isString(template)){if(template.nodeType){template=template.innerHTML;}else{return NOOP;}}var key=template;var cached=compileCache[key];if(cached){return cached;}if(template[0]==='#'){var el=document.querySelector(template);// __UNSAFE__
// Reason: potential execution of JS expressions in in-DOM template.
// The user must make sure the in-DOM template is trusted. If it's rendered
// by the server, the template should not contain any user data.
template=el?el.innerHTML:"";}var _compile=compile(template,extend({hoistStatic:true,onError:undefined,onWarn:NOOP},options)),code=_compile.code;// The wildcard import results in a huge object with every export
// with keys that cannot be mangled, and can be quite heavy size-wise.
// In the global build we know `Vue` is available globally so we can avoid
// the wildcard object.
var render=new Function('Vue',code)(runtimeDom);render._rc=true;return compileCache[key]=render;}registerRuntimeCompiler(compileToFunction);var isVue2=false;/*!
              * pinia v2.0.14
              * (c) 2022 Eduardo San Martin Morote
              * @license MIT
              */ /**
             * setActivePinia must be called to handle SSR at the top of functions like
             * `fetch`, `setup`, `serverPrefetch` and others
             */var activePinia;/**
             * Sets or unsets the active pinia. Used in SSR and internally when calling
             * actions and getters
             *
             * @param pinia - Pinia instance
             */var setActivePinia=function setActivePinia(pinia){return activePinia=pinia;};var piniaSymbol=/* istanbul ignore next */Symbol();function isPlainObject(// eslint-disable-next-line @typescript-eslint/no-explicit-any
o){return o&&_typeof(o)==='object'&&Object.prototype.toString.call(o)==='[object Object]'&&typeof o.toJSON!=='function';}// type DeepReadonly<T> = { readonly [P in keyof T]: DeepReadonly<T[P]> }
// TODO: can we change these to numbers?
/**
             * Possible types for SubscriptionCallback
             */var MutationType;(function(MutationType){/**
                 * Direct mutation of the state:
                 *
                 * - `store.name = 'new name'`
                 * - `store.$state.name = 'new name'`
                 * - `store.list.push('new item')`
                 */MutationType["direct"]="direct";/**
                 * Mutated the state with `$patch` and an object
                 *
                 * - `store.$patch({ name: 'newName' })`
                 */MutationType["patchObject"]="patch object";/**
                 * Mutated the state with `$patch` and a function
                 *
                 * - `store.$patch(state => state.name = 'newName')`
                 */MutationType["patchFunction"]="patch function";// maybe reset? for $state = {} and $reset
})(MutationType||(MutationType={}));/**
             * Creates a Pinia instance to be used by the application
             */function createPinia(){var scope=effectScope(true);// NOTE: here we could check the window object for a state and directly set it
// if there is anything like it with Vue 3 SSR
var state=scope.run(function(){return ref({});});var _p=[];// plugins added before calling app.use(pinia)
var toBeInstalled=[];var pinia=markRaw({install:function install(app){// this allows calling useStore() outside of a component setup after
// installing pinia's plugin
setActivePinia(pinia);{pinia._a=app;app.provide(piniaSymbol,pinia);app.config.globalProperties.$pinia=pinia;toBeInstalled.forEach(function(plugin){return _p.push(plugin);});toBeInstalled=[];}},use:function use(plugin){if(!this._a&&!isVue2){toBeInstalled.push(plugin);}else{_p.push(plugin);}return this;},_p:_p,// it's actually undefined here
// @ts-expect-error
_a:null,_e:scope,_s:new Map(),state:state});return pinia;}var noop=function noop(){};function addSubscription(subscriptions,callback,detached){var onCleanup=arguments.length>3&&arguments[3]!==undefined?arguments[3]:noop;subscriptions.push(callback);var removeSubscription=function removeSubscription(){var idx=subscriptions.indexOf(callback);if(idx>-1){subscriptions.splice(idx,1);onCleanup();}};if(!detached&&getCurrentInstance()){onUnmounted(removeSubscription);}return removeSubscription;}function triggerSubscriptions(subscriptions){for(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}subscriptions.slice().forEach(function(callback){callback.apply(void 0,args);});}function mergeReactiveObjects(target,patchToApply){// no need to go through symbols because they cannot be serialized anyway
for(var key in patchToApply){if(!patchToApply.hasOwnProperty(key))continue;var subPatch=patchToApply[key];var targetValue=target[key];if(isPlainObject(targetValue)&&isPlainObject(subPatch)&&target.hasOwnProperty(key)&&!isRef(subPatch)&&!isReactive(subPatch)){target[key]=mergeReactiveObjects(targetValue,subPatch);}else{// @ts-expect-error: subPatch is a valid value
target[key]=subPatch;}}return target;}var skipHydrateSymbol=/* istanbul ignore next */Symbol();function shouldHydrate(obj){return!isPlainObject(obj)||!obj.hasOwnProperty(skipHydrateSymbol);}var assign=Object.assign;function isComputed(o){return!!(isRef(o)&&o.effect);}function createOptionsStore(id,options,pinia,hot){var state=options.state,actions=options.actions,getters=options.getters;var initialState=pinia.state.value[id];var store;function setup(){if(!initialState&&!("production"!=='production')){/* istanbul ignore if */{pinia.state.value[id]=state?state():{};}}// avoid creating a state in pinia.state.value
var localState=toRefs(pinia.state.value[id]);return assign(localState,actions,Object.keys(getters||{}).reduce(function(computedGetters,name){computedGetters[name]=markRaw(computed(function(){setActivePinia(pinia);// it was created just before
var store=pinia._s.get(id);// @ts-expect-error
// return getters![name].call(context, context)
// TODO: avoid reading the getter while assigning with a global variable
return getters[name].call(store,store);}));return computedGetters;},{}));}store=createSetupStore(id,setup,options,pinia,hot,true);store.$reset=function $reset(){var newState=state?state():{};// we use a patch to group all changes into one single subscription
this.$patch(function($state){assign($state,newState);});};return store;}function createSetupStore($id,setup){var options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};var pinia=arguments.length>3?arguments[3]:undefined;var hot=arguments.length>4?arguments[4]:undefined;var isOptionsStore=arguments.length>5?arguments[5]:undefined;var scope;var optionsForPlugin=assign({actions:{}},options);// watcher options for $subscribe
var $subscribeOptions={deep:true// flush: 'post',
};// internal state
var isListening;// set to true at the end
var isSyncListening;// set to true at the end
var subscriptions=markRaw([]);var actionSubscriptions=markRaw([]);var debuggerEvents;var initialState=pinia.state.value[$id];// avoid setting the state for option stores are it is set
// by the setup
if(!isOptionsStore&&!initialState&&!("production"!=='production')){/* istanbul ignore if */{pinia.state.value[$id]={};}}ref({});// avoid triggering too many listeners
// https://github.com/vuejs/pinia/issues/1129
var activeListener;function $patch(partialStateOrMutator){var subscriptionMutation;isListening=isSyncListening=false;if(typeof partialStateOrMutator==='function'){partialStateOrMutator(pinia.state.value[$id]);subscriptionMutation={type:MutationType.patchFunction,storeId:$id,events:debuggerEvents};}else{mergeReactiveObjects(pinia.state.value[$id],partialStateOrMutator);subscriptionMutation={type:MutationType.patchObject,payload:partialStateOrMutator,storeId:$id,events:debuggerEvents};}var myListenerId=activeListener=Symbol();nextTick().then(function(){if(activeListener===myListenerId){isListening=true;}});isSyncListening=true;// because we paused the watcher, we need to manually call the subscriptions
triggerSubscriptions(subscriptions,subscriptionMutation,pinia.state.value[$id]);}/* istanbul ignore next */var $reset=noop;function $dispose(){scope.stop();subscriptions=[];actionSubscriptions=[];pinia._s.delete($id);}/**
                 * Wraps an action to handle subscriptions.
                 *
                 * @param name - name of the action
                 * @param action - action to wrap
                 * @returns a wrapped action to handle subscriptions
                 */function wrapAction(name,action){return function(){setActivePinia(pinia);var args=Array.from(arguments);var afterCallbackList=[];var onErrorCallbackList=[];function after(callback){afterCallbackList.push(callback);}function onError(callback){onErrorCallbackList.push(callback);}// @ts-expect-error
triggerSubscriptions(actionSubscriptions,{args:args,name:name,store:store,after:after,onError:onError});var ret;try{ret=action.apply(this&&this.$id===$id?this:store,args);// handle sync errors
}catch(error){triggerSubscriptions(onErrorCallbackList,error);throw error;}if(ret instanceof Promise){return ret.then(function(value){triggerSubscriptions(afterCallbackList,value);return value;}).catch(function(error){triggerSubscriptions(onErrorCallbackList,error);return Promise.reject(error);});}// allow the afterCallback to override the return value
triggerSubscriptions(afterCallbackList,ret);return ret;};}var partialStore={_p:pinia,// _s: scope,
$id:$id,$onAction:addSubscription.bind(null,actionSubscriptions),$patch:$patch,$reset:$reset,$subscribe:function $subscribe(callback){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var removeSubscription=addSubscription(subscriptions,callback,options.detached,function(){return stopWatcher();});var stopWatcher=scope.run(function(){return watch(function(){return pinia.state.value[$id];},function(state){if(options.flush==='sync'?isSyncListening:isListening){callback({storeId:$id,type:MutationType.direct,events:debuggerEvents},state);}},assign({},$subscribeOptions,options));});return removeSubscription;},$dispose:$dispose};var store=reactive(assign({},partialStore// must be added later
// setupStore
));// store the partial store now so the setup of stores can instantiate each other before they are finished without
// creating infinite loops.
pinia._s.set($id,store);// TODO: idea create skipSerialize that marks properties as non serializable and they are skipped
var setupStore=pinia._e.run(function(){scope=effectScope();return scope.run(function(){return setup();});});// overwrite existing actions to support $onAction
for(var key in setupStore){var prop=setupStore[key];if(isRef(prop)&&!isComputed(prop)||isReactive(prop)){// mark it as a piece of state to be serialized
if(!isOptionsStore){// in setup stores we must hydrate the state and sync pinia state tree with the refs the user just created
if(initialState&&shouldHydrate(prop)){if(isRef(prop)){prop.value=initialState[key];}else{// probably a reactive object, lets recursively assign
mergeReactiveObjects(prop,initialState[key]);}}// transfer the ref to the pinia state to keep everything in sync
/* istanbul ignore if */{pinia.state.value[$id][key]=prop;}}// action
}else if(typeof prop==='function'){// @ts-expect-error: we are overriding the function we avoid wrapping if
var actionValue=wrapAction(key,prop);// this a hot module replacement store because the hotUpdate method needs
// to do it with the right context
/* istanbul ignore if */{// @ts-expect-error
setupStore[key]=actionValue;}// list actions so they can be used in plugins
// @ts-expect-error
optionsForPlugin.actions[key]=prop;}else;}// add the state, getters, and action properties
/* istanbul ignore if */{assign(store,setupStore);// allows retrieving reactive objects with `storeToRefs()`. Must be called after assigning to the reactive object.
// Make `storeToRefs()` work with `reactive()` #799
assign(toRaw(store),setupStore);}// use this instead of a computed with setter to be able to create it anywhere
// without linking the computed lifespan to wherever the store is first
// created.
Object.defineProperty(store,'$state',{get:function get(){return pinia.state.value[$id];},set:function set(state){$patch(function($state){assign($state,state);});}});// apply all plugins
pinia._p.forEach(function(extender){/* istanbul ignore else */{assign(store,scope.run(function(){return extender({store:store,app:pinia._a,pinia:pinia,options:optionsForPlugin});}));}});// only apply hydrate to option stores with an initial state in pinia
if(initialState&&isOptionsStore&&options.hydrate){options.hydrate(store.$state,initialState);}isListening=true;isSyncListening=true;return store;}function defineStore(// TODO: add proper types from above
idOrOptions,setup,setupOptions){var id;var options;var isSetupStore=typeof setup==='function';if(typeof idOrOptions==='string'){id=idOrOptions;// the option store setup will contain the actual options in this case
options=isSetupStore?setupOptions:setup;}else{options=idOrOptions;id=idOrOptions.id;}function useStore(pinia,hot){var currentInstance=getCurrentInstance();pinia=// in test mode, ignore the argument provided as we can always retrieve a
// pinia instance with getActivePinia()
pinia||currentInstance&&inject(piniaSymbol);if(pinia)setActivePinia(pinia);pinia=activePinia;if(!pinia._s.has(id)){// creating the store registers it in `pinia._s`
if(isSetupStore){createSetupStore(id,setup,options,pinia);}else{createOptionsStore(id,options,pinia);}}var store=pinia._s.get(id);// StoreGeneric cannot be casted towards Store
return store;}useStore.$id=id;return useStore;}}};});})();
