import { e as commonjsGlobal, f as defineComponent, t as toRefs, g as ref, w as watch, h as onMounted, i as onBeforeUnmount, j as onActivated, k as onDeactivated, l as h, n as nextTick } from "./index.9136f505.js";
var content_min = "";
var tinymce$2 = { exports: {} };
(function(module) {
  (function() {
    var typeOf = function(x) {
      if (x === null) {
        return "null";
      }
      if (x === void 0) {
        return "undefined";
      }
      var t = typeof x;
      if (t === "object" && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === "Array")) {
        return "array";
      }
      if (t === "object" && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === "String")) {
        return "string";
      }
      return t;
    };
    var isEquatableType = function(x) {
      return [
        "undefined",
        "boolean",
        "number",
        "string",
        "function",
        "xml",
        "null"
      ].indexOf(x) !== -1;
    };
    var sort = function(xs, compareFn) {
      var clone2 = Array.prototype.slice.call(xs);
      return clone2.sort(compareFn);
    };
    var contramap = function(eqa, f) {
      return eq(function(x, y) {
        return eqa.eq(f(x), f(y));
      });
    };
    var eq = function(f) {
      return { eq: f };
    };
    var tripleEq = eq(function(x, y) {
      return x === y;
    });
    var eqString = tripleEq;
    var eqArray = function(eqa) {
      return eq(function(x, y) {
        if (x.length !== y.length) {
          return false;
        }
        var len = x.length;
        for (var i = 0; i < len; i++) {
          if (!eqa.eq(x[i], y[i])) {
            return false;
          }
        }
        return true;
      });
    };
    var eqSortedArray = function(eqa, compareFn) {
      return contramap(eqArray(eqa), function(xs) {
        return sort(xs, compareFn);
      });
    };
    var eqRecord = function(eqa) {
      return eq(function(x, y) {
        var kx = Object.keys(x);
        var ky = Object.keys(y);
        if (!eqSortedArray(eqString).eq(kx, ky)) {
          return false;
        }
        var len = kx.length;
        for (var i = 0; i < len; i++) {
          var q = kx[i];
          if (!eqa.eq(x[q], y[q])) {
            return false;
          }
        }
        return true;
      });
    };
    var eqAny = eq(function(x, y) {
      if (x === y) {
        return true;
      }
      var tx = typeOf(x);
      var ty = typeOf(y);
      if (tx !== ty) {
        return false;
      }
      if (isEquatableType(tx)) {
        return x === y;
      } else if (tx === "array") {
        return eqArray(eqAny).eq(x, y);
      } else if (tx === "object") {
        return eqRecord(eqAny).eq(x, y);
      }
      return false;
    });
    var typeOf$1 = function(x) {
      var t = typeof x;
      if (x === null) {
        return "null";
      } else if (t === "object" && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === "Array")) {
        return "array";
      } else if (t === "object" && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === "String")) {
        return "string";
      } else {
        return t;
      }
    };
    var isType = function(type2) {
      return function(value2) {
        return typeOf$1(value2) === type2;
      };
    };
    var isSimpleType = function(type2) {
      return function(value2) {
        return typeof value2 === type2;
      };
    };
    var eq$1 = function(t) {
      return function(a) {
        return t === a;
      };
    };
    var isString = isType("string");
    var isObject = isType("object");
    var isArray = isType("array");
    var isNull = eq$1(null);
    var isBoolean = isSimpleType("boolean");
    var isUndefined = eq$1(void 0);
    var isNullable = function(a) {
      return a === null || a === void 0;
    };
    var isNonNullable = function(a) {
      return !isNullable(a);
    };
    var isFunction = isSimpleType("function");
    var isNumber = isSimpleType("number");
    var noop = function() {
    };
    var compose = function(fa, fb) {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return fa(fb.apply(null, args));
      };
    };
    var compose1 = function(fbc, fab) {
      return function(a) {
        return fbc(fab(a));
      };
    };
    var constant = function(value2) {
      return function() {
        return value2;
      };
    };
    var identity = function(x) {
      return x;
    };
    function curry(fn) {
      var initialArgs = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        initialArgs[_i - 1] = arguments[_i];
      }
      return function() {
        var restArgs = [];
        for (var _i2 = 0; _i2 < arguments.length; _i2++) {
          restArgs[_i2] = arguments[_i2];
        }
        var all2 = initialArgs.concat(restArgs);
        return fn.apply(null, all2);
      };
    }
    var not = function(f) {
      return function(t) {
        return !f(t);
      };
    };
    var die = function(msg) {
      return function() {
        throw new Error(msg);
      };
    };
    var apply = function(f) {
      return f();
    };
    var call = function(f) {
      f();
    };
    var never = constant(false);
    var always = constant(true);
    var none = function() {
      return NONE;
    };
    var NONE = function() {
      var eq2 = function(o) {
        return o.isNone();
      };
      var call2 = function(thunk) {
        return thunk();
      };
      var id = function(n) {
        return n;
      };
      var me = {
        fold: function(n, _s) {
          return n();
        },
        is: never,
        isSome: never,
        isNone: always,
        getOr: id,
        getOrThunk: call2,
        getOrDie: function(msg) {
          throw new Error(msg || "error: getOrDie called on none.");
        },
        getOrNull: constant(null),
        getOrUndefined: constant(void 0),
        or: id,
        orThunk: call2,
        map: none,
        each: noop,
        bind: none,
        exists: never,
        forall: always,
        filter: none,
        equals: eq2,
        equals_: eq2,
        toArray: function() {
          return [];
        },
        toString: constant("none()")
      };
      return me;
    }();
    var some = function(a) {
      var constant_a = constant(a);
      var self2 = function() {
        return me;
      };
      var bind2 = function(f) {
        return f(a);
      };
      var me = {
        fold: function(n, s) {
          return s(a);
        },
        is: function(v) {
          return a === v;
        },
        isSome: always,
        isNone: never,
        getOr: constant_a,
        getOrThunk: constant_a,
        getOrDie: constant_a,
        getOrNull: constant_a,
        getOrUndefined: constant_a,
        or: self2,
        orThunk: self2,
        map: function(f) {
          return some(f(a));
        },
        each: function(f) {
          f(a);
        },
        bind: bind2,
        exists: bind2,
        forall: bind2,
        filter: function(f) {
          return f(a) ? me : NONE;
        },
        toArray: function() {
          return [a];
        },
        toString: function() {
          return "some(" + a + ")";
        },
        equals: function(o) {
          return o.is(a);
        },
        equals_: function(o, elementEq) {
          return o.fold(never, function(b) {
            return elementEq(a, b);
          });
        }
      };
      return me;
    };
    var from = function(value2) {
      return value2 === null || value2 === void 0 ? NONE : some(value2);
    };
    var Optional = {
      some,
      none,
      from
    };
    var nativeSlice = Array.prototype.slice;
    var nativeIndexOf = Array.prototype.indexOf;
    var nativePush = Array.prototype.push;
    var rawIndexOf = function(ts, t) {
      return nativeIndexOf.call(ts, t);
    };
    var indexOf = function(xs, x) {
      var r2 = rawIndexOf(xs, x);
      return r2 === -1 ? Optional.none() : Optional.some(r2);
    };
    var contains = function(xs, x) {
      return rawIndexOf(xs, x) > -1;
    };
    var exists = function(xs, pred) {
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        if (pred(x, i)) {
          return true;
        }
      }
      return false;
    };
    var map = function(xs, f) {
      var len = xs.length;
      var r2 = new Array(len);
      for (var i = 0; i < len; i++) {
        var x = xs[i];
        r2[i] = f(x, i);
      }
      return r2;
    };
    var each = function(xs, f) {
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        f(x, i);
      }
    };
    var eachr = function(xs, f) {
      for (var i = xs.length - 1; i >= 0; i--) {
        var x = xs[i];
        f(x, i);
      }
    };
    var partition = function(xs, pred) {
      var pass = [];
      var fail = [];
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        var arr2 = pred(x, i) ? pass : fail;
        arr2.push(x);
      }
      return {
        pass,
        fail
      };
    };
    var filter = function(xs, pred) {
      var r2 = [];
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        if (pred(x, i)) {
          r2.push(x);
        }
      }
      return r2;
    };
    var foldr = function(xs, f, acc) {
      eachr(xs, function(x) {
        acc = f(acc, x);
      });
      return acc;
    };
    var foldl = function(xs, f, acc) {
      each(xs, function(x) {
        acc = f(acc, x);
      });
      return acc;
    };
    var findUntil = function(xs, pred, until) {
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        if (pred(x, i)) {
          return Optional.some(x);
        } else if (until(x, i)) {
          break;
        }
      }
      return Optional.none();
    };
    var find = function(xs, pred) {
      return findUntil(xs, pred, never);
    };
    var findIndex = function(xs, pred) {
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        if (pred(x, i)) {
          return Optional.some(i);
        }
      }
      return Optional.none();
    };
    var flatten = function(xs) {
      var r2 = [];
      for (var i = 0, len = xs.length; i < len; ++i) {
        if (!isArray(xs[i])) {
          throw new Error("Arr.flatten item " + i + " was not an array, input: " + xs);
        }
        nativePush.apply(r2, xs[i]);
      }
      return r2;
    };
    var bind = function(xs, f) {
      return flatten(map(xs, f));
    };
    var forall = function(xs, pred) {
      for (var i = 0, len = xs.length; i < len; ++i) {
        var x = xs[i];
        if (pred(x, i) !== true) {
          return false;
        }
      }
      return true;
    };
    var reverse = function(xs) {
      var r2 = nativeSlice.call(xs, 0);
      r2.reverse();
      return r2;
    };
    var difference = function(a1, a2) {
      return filter(a1, function(x) {
        return !contains(a2, x);
      });
    };
    var mapToObject = function(xs, f) {
      var r2 = {};
      for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        r2[String(x)] = f(x, i);
      }
      return r2;
    };
    var sort$1 = function(xs, comparator) {
      var copy = nativeSlice.call(xs, 0);
      copy.sort(comparator);
      return copy;
    };
    var get = function(xs, i) {
      return i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();
    };
    var head = function(xs) {
      return get(xs, 0);
    };
    var last = function(xs) {
      return get(xs, xs.length - 1);
    };
    var from$1 = isFunction(Array.from) ? Array.from : function(x) {
      return nativeSlice.call(x);
    };
    var findMap = function(arr2, f) {
      for (var i = 0; i < arr2.length; i++) {
        var r2 = f(arr2[i], i);
        if (r2.isSome()) {
          return r2;
        }
      }
      return Optional.none();
    };
    var keys = Object.keys;
    var hasOwnProperty = Object.hasOwnProperty;
    var each$1 = function(obj, f) {
      var props = keys(obj);
      for (var k = 0, len = props.length; k < len; k++) {
        var i = props[k];
        var x = obj[i];
        f(x, i);
      }
    };
    var map$1 = function(obj, f) {
      return tupleMap(obj, function(x, i) {
        return {
          k: i,
          v: f(x, i)
        };
      });
    };
    var tupleMap = function(obj, f) {
      var r2 = {};
      each$1(obj, function(x, i) {
        var tuple = f(x, i);
        r2[tuple.k] = tuple.v;
      });
      return r2;
    };
    var objAcc = function(r2) {
      return function(x, i) {
        r2[i] = x;
      };
    };
    var internalFilter = function(obj, pred, onTrue, onFalse) {
      var r2 = {};
      each$1(obj, function(x, i) {
        (pred(x, i) ? onTrue : onFalse)(x, i);
      });
      return r2;
    };
    var bifilter = function(obj, pred) {
      var t = {};
      var f = {};
      internalFilter(obj, pred, objAcc(t), objAcc(f));
      return {
        t,
        f
      };
    };
    var filter$1 = function(obj, pred) {
      var t = {};
      internalFilter(obj, pred, objAcc(t), noop);
      return t;
    };
    var mapToArray = function(obj, f) {
      var r2 = [];
      each$1(obj, function(value2, name2) {
        r2.push(f(value2, name2));
      });
      return r2;
    };
    var values = function(obj) {
      return mapToArray(obj, function(v) {
        return v;
      });
    };
    var get$1 = function(obj, key) {
      return has(obj, key) ? Optional.from(obj[key]) : Optional.none();
    };
    var has = function(obj, key) {
      return hasOwnProperty.call(obj, key);
    };
    var hasNonNullableKey = function(obj, key) {
      return has(obj, key) && obj[key] !== void 0 && obj[key] !== null;
    };
    var equal = function(a1, a2, eq2) {
      if (eq2 === void 0) {
        eq2 = eqAny;
      }
      return eqRecord(eq2).eq(a1, a2);
    };
    var isArray$1 = Array.isArray;
    var toArray = function(obj) {
      if (!isArray$1(obj)) {
        var array = [];
        for (var i = 0, l = obj.length; i < l; i++) {
          array[i] = obj[i];
        }
        return array;
      } else {
        return obj;
      }
    };
    var each$2 = function(o, cb, s) {
      var n, l;
      if (!o) {
        return false;
      }
      s = s || o;
      if (o.length !== void 0) {
        for (n = 0, l = o.length; n < l; n++) {
          if (cb.call(s, o[n], n, o) === false) {
            return false;
          }
        }
      } else {
        for (n in o) {
          if (o.hasOwnProperty(n)) {
            if (cb.call(s, o[n], n, o) === false) {
              return false;
            }
          }
        }
      }
      return true;
    };
    var map$2 = function(array, callback) {
      var out = [];
      each$2(array, function(item, index) {
        out.push(callback(item, index, array));
      });
      return out;
    };
    var filter$2 = function(a, f) {
      var o = [];
      each$2(a, function(v, index) {
        if (!f || f(v, index, a)) {
          o.push(v);
        }
      });
      return o;
    };
    var indexOf$1 = function(a, v) {
      if (a) {
        for (var i = 0, l = a.length; i < l; i++) {
          if (a[i] === v) {
            return i;
          }
        }
      }
      return -1;
    };
    var reduce = function(collection, iteratee, accumulator, thisArg) {
      var acc = isUndefined(accumulator) ? collection[0] : accumulator;
      for (var i = 0; i < collection.length; i++) {
        acc = iteratee.call(thisArg, acc, collection[i], i);
      }
      return acc;
    };
    var findIndex$1 = function(array, predicate, thisArg) {
      var i, l;
      for (i = 0, l = array.length; i < l; i++) {
        if (predicate.call(thisArg, array[i], i, array)) {
          return i;
        }
      }
      return -1;
    };
    var last$1 = function(collection) {
      return collection[collection.length - 1];
    };
    var __assign2 = function() {
      __assign2 = Object.assign || function __assign3(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign2.apply(this, arguments);
    };
    function __rest(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    }
    function __spreadArrays() {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++)
        s += arguments[i].length;
      for (var r2 = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r2[k] = a[j];
      return r2;
    }
    var cached = function(f) {
      var called = false;
      var r2;
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (!called) {
          called = true;
          r2 = f.apply(null, args);
        }
        return r2;
      };
    };
    var DeviceType = function(os2, browser2, userAgent2, mediaMatch2) {
      var isiPad = os2.isiOS() && /ipad/i.test(userAgent2) === true;
      var isiPhone = os2.isiOS() && !isiPad;
      var isMobile = os2.isiOS() || os2.isAndroid();
      var isTouch2 = isMobile || mediaMatch2("(pointer:coarse)");
      var isTablet2 = isiPad || !isiPhone && isMobile && mediaMatch2("(min-device-width:768px)");
      var isPhone2 = isiPhone || isMobile && !isTablet2;
      var iOSwebview = browser2.isSafari() && os2.isiOS() && /safari/i.test(userAgent2) === false;
      var isDesktop = !isPhone2 && !isTablet2 && !iOSwebview;
      return {
        isiPad: constant(isiPad),
        isiPhone: constant(isiPhone),
        isTablet: constant(isTablet2),
        isPhone: constant(isPhone2),
        isTouch: constant(isTouch2),
        isAndroid: os2.isAndroid,
        isiOS: os2.isiOS,
        isWebView: constant(iOSwebview),
        isDesktop: constant(isDesktop)
      };
    };
    var firstMatch = function(regexes, s) {
      for (var i = 0; i < regexes.length; i++) {
        var x = regexes[i];
        if (x.test(s)) {
          return x;
        }
      }
      return void 0;
    };
    var find$1 = function(regexes, agent) {
      var r2 = firstMatch(regexes, agent);
      if (!r2) {
        return {
          major: 0,
          minor: 0
        };
      }
      var group = function(i) {
        return Number(agent.replace(r2, "$" + i));
      };
      return nu(group(1), group(2));
    };
    var detect = function(versionRegexes, agent) {
      var cleanedAgent = String(agent).toLowerCase();
      if (versionRegexes.length === 0) {
        return unknown();
      }
      return find$1(versionRegexes, cleanedAgent);
    };
    var unknown = function() {
      return nu(0, 0);
    };
    var nu = function(major, minor) {
      return {
        major,
        minor
      };
    };
    var Version = {
      nu,
      detect,
      unknown
    };
    var detect$1 = function(candidates, userAgent2) {
      var agent = String(userAgent2).toLowerCase();
      return find(candidates, function(candidate) {
        return candidate.search(agent);
      });
    };
    var detectBrowser = function(browsers2, userAgent2) {
      return detect$1(browsers2, userAgent2).map(function(browser2) {
        var version = Version.detect(browser2.versionRegexes, userAgent2);
        return {
          current: browser2.name,
          version
        };
      });
    };
    var detectOs = function(oses2, userAgent2) {
      return detect$1(oses2, userAgent2).map(function(os2) {
        var version = Version.detect(os2.versionRegexes, userAgent2);
        return {
          current: os2.name,
          version
        };
      });
    };
    var UaString = {
      detectBrowser,
      detectOs
    };
    var removeFromStart = function(str, numChars) {
      return str.substring(numChars);
    };
    var checkRange = function(str, substr, start2) {
      return substr === "" || str.length >= substr.length && str.substr(start2, start2 + substr.length) === substr;
    };
    var removeLeading = function(str, prefix) {
      return startsWith(str, prefix) ? removeFromStart(str, prefix.length) : str;
    };
    var contains$1 = function(str, substr) {
      return str.indexOf(substr) !== -1;
    };
    var startsWith = function(str, prefix) {
      return checkRange(str, prefix, 0);
    };
    var blank = function(r2) {
      return function(s) {
        return s.replace(r2, "");
      };
    };
    var trim = blank(/^\s+|\s+$/g);
    var lTrim = blank(/^\s+/g);
    var rTrim = blank(/\s+$/g);
    var isNotEmpty = function(s) {
      return s.length > 0;
    };
    var normalVersionRegex = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/;
    var checkContains = function(target) {
      return function(uastring) {
        return contains$1(uastring, target);
      };
    };
    var browsers = [
      {
        name: "Edge",
        versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
        search: function(uastring) {
          return contains$1(uastring, "edge/") && contains$1(uastring, "chrome") && contains$1(uastring, "safari") && contains$1(uastring, "applewebkit");
        }
      },
      {
        name: "Chrome",
        versionRegexes: [
          /.*?chrome\/([0-9]+)\.([0-9]+).*/,
          normalVersionRegex
        ],
        search: function(uastring) {
          return contains$1(uastring, "chrome") && !contains$1(uastring, "chromeframe");
        }
      },
      {
        name: "IE",
        versionRegexes: [
          /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
          /.*?rv:([0-9]+)\.([0-9]+).*/
        ],
        search: function(uastring) {
          return contains$1(uastring, "msie") || contains$1(uastring, "trident");
        }
      },
      {
        name: "Opera",
        versionRegexes: [
          normalVersionRegex,
          /.*?opera\/([0-9]+)\.([0-9]+).*/
        ],
        search: checkContains("opera")
      },
      {
        name: "Firefox",
        versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
        search: checkContains("firefox")
      },
      {
        name: "Safari",
        versionRegexes: [
          normalVersionRegex,
          /.*?cpu os ([0-9]+)_([0-9]+).*/
        ],
        search: function(uastring) {
          return (contains$1(uastring, "safari") || contains$1(uastring, "mobile/")) && contains$1(uastring, "applewebkit");
        }
      }
    ];
    var oses = [
      {
        name: "Windows",
        search: checkContains("win"),
        versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
      },
      {
        name: "iOS",
        search: function(uastring) {
          return contains$1(uastring, "iphone") || contains$1(uastring, "ipad");
        },
        versionRegexes: [
          /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
          /.*cpu os ([0-9]+)_([0-9]+).*/,
          /.*cpu iphone os ([0-9]+)_([0-9]+).*/
        ]
      },
      {
        name: "Android",
        search: checkContains("android"),
        versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
      },
      {
        name: "OSX",
        search: checkContains("mac os x"),
        versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
      },
      {
        name: "Linux",
        search: checkContains("linux"),
        versionRegexes: []
      },
      {
        name: "Solaris",
        search: checkContains("sunos"),
        versionRegexes: []
      },
      {
        name: "FreeBSD",
        search: checkContains("freebsd"),
        versionRegexes: []
      },
      {
        name: "ChromeOS",
        search: checkContains("cros"),
        versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
      }
    ];
    var PlatformInfo = {
      browsers: constant(browsers),
      oses: constant(oses)
    };
    var edge = "Edge";
    var chrome = "Chrome";
    var ie = "IE";
    var opera = "Opera";
    var firefox = "Firefox";
    var safari = "Safari";
    var unknown$1 = function() {
      return nu$1({
        current: void 0,
        version: Version.unknown()
      });
    };
    var nu$1 = function(info) {
      var current = info.current;
      var version = info.version;
      var isBrowser = function(name2) {
        return function() {
          return current === name2;
        };
      };
      return {
        current,
        version,
        isEdge: isBrowser(edge),
        isChrome: isBrowser(chrome),
        isIE: isBrowser(ie),
        isOpera: isBrowser(opera),
        isFirefox: isBrowser(firefox),
        isSafari: isBrowser(safari)
      };
    };
    var Browser = {
      unknown: unknown$1,
      nu: nu$1,
      edge: constant(edge),
      chrome: constant(chrome),
      ie: constant(ie),
      opera: constant(opera),
      firefox: constant(firefox),
      safari: constant(safari)
    };
    var windows = "Windows";
    var ios = "iOS";
    var android = "Android";
    var linux = "Linux";
    var osx = "OSX";
    var solaris = "Solaris";
    var freebsd = "FreeBSD";
    var chromeos = "ChromeOS";
    var unknown$2 = function() {
      return nu$2({
        current: void 0,
        version: Version.unknown()
      });
    };
    var nu$2 = function(info) {
      var current = info.current;
      var version = info.version;
      var isOS = function(name2) {
        return function() {
          return current === name2;
        };
      };
      return {
        current,
        version,
        isWindows: isOS(windows),
        isiOS: isOS(ios),
        isAndroid: isOS(android),
        isOSX: isOS(osx),
        isLinux: isOS(linux),
        isSolaris: isOS(solaris),
        isFreeBSD: isOS(freebsd),
        isChromeOS: isOS(chromeos)
      };
    };
    var OperatingSystem = {
      unknown: unknown$2,
      nu: nu$2,
      windows: constant(windows),
      ios: constant(ios),
      android: constant(android),
      linux: constant(linux),
      osx: constant(osx),
      solaris: constant(solaris),
      freebsd: constant(freebsd),
      chromeos: constant(chromeos)
    };
    var detect$2 = function(userAgent2, mediaMatch2) {
      var browsers2 = PlatformInfo.browsers();
      var oses2 = PlatformInfo.oses();
      var browser2 = UaString.detectBrowser(browsers2, userAgent2).fold(Browser.unknown, Browser.nu);
      var os2 = UaString.detectOs(oses2, userAgent2).fold(OperatingSystem.unknown, OperatingSystem.nu);
      var deviceType2 = DeviceType(os2, browser2, userAgent2, mediaMatch2);
      return {
        browser: browser2,
        os: os2,
        deviceType: deviceType2
      };
    };
    var PlatformDetection = { detect: detect$2 };
    var mediaMatch = function(query) {
      return window.matchMedia(query).matches;
    };
    var platform = cached(function() {
      return PlatformDetection.detect(navigator.userAgent, mediaMatch);
    });
    var detect$3 = function() {
      return platform();
    };
    var userAgent = navigator.userAgent;
    var platform$1 = detect$3();
    var browser = platform$1.browser;
    var os = platform$1.os;
    var deviceType = platform$1.deviceType;
    var webkit = /WebKit/.test(userAgent) && !browser.isEdge();
    var fileApi = "FormData" in window && "FileReader" in window && "URL" in window && !!URL.createObjectURL;
    var windowsPhone = userAgent.indexOf("Windows Phone") !== -1;
    var Env = {
      opera: browser.isOpera(),
      webkit,
      ie: browser.isIE() || browser.isEdge() ? browser.version.major : false,
      gecko: browser.isFirefox(),
      mac: os.isOSX() || os.isiOS(),
      iOS: deviceType.isiPad() || deviceType.isiPhone(),
      android: os.isAndroid(),
      contentEditable: true,
      transparentSrc: "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
      caretAfter: true,
      range: window.getSelection && "Range" in window,
      documentMode: browser.isIE() ? document.documentMode || 7 : 10,
      fileApi,
      ceFalse: true,
      cacheSuffix: null,
      container: null,
      experimentalShadowDom: false,
      canHaveCSP: !browser.isIE(),
      desktop: deviceType.isDesktop(),
      windowsPhone,
      browser: {
        current: browser.current,
        version: browser.version,
        isChrome: browser.isChrome,
        isEdge: browser.isEdge,
        isFirefox: browser.isFirefox,
        isIE: browser.isIE,
        isOpera: browser.isOpera,
        isSafari: browser.isSafari
      },
      os: {
        current: os.current,
        version: os.version,
        isAndroid: os.isAndroid,
        isChromeOS: os.isChromeOS,
        isFreeBSD: os.isFreeBSD,
        isiOS: os.isiOS,
        isLinux: os.isLinux,
        isOSX: os.isOSX,
        isSolaris: os.isSolaris,
        isWindows: os.isWindows
      },
      deviceType: {
        isDesktop: deviceType.isDesktop,
        isiPad: deviceType.isiPad,
        isiPhone: deviceType.isiPhone,
        isPhone: deviceType.isPhone,
        isTablet: deviceType.isTablet,
        isTouch: deviceType.isTouch,
        isWebView: deviceType.isWebView
      }
    };
    var whiteSpaceRegExp = /^\s*|\s*$/g;
    var trim$1 = function(str) {
      return str === null || str === void 0 ? "" : ("" + str).replace(whiteSpaceRegExp, "");
    };
    var is = function(obj, type2) {
      if (!type2) {
        return obj !== void 0;
      }
      if (type2 === "array" && isArray$1(obj)) {
        return true;
      }
      return typeof obj === type2;
    };
    var makeMap = function(items, delim, map2) {
      var i;
      items = items || [];
      delim = delim || ",";
      if (typeof items === "string") {
        items = items.split(delim);
      }
      map2 = map2 || {};
      i = items.length;
      while (i--) {
        map2[items[i]] = {};
      }
      return map2;
    };
    var hasOwnProperty$1 = function(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    };
    var create = function(s, p, root) {
      var self2 = this;
      var sp, scn, c, de = 0;
      s = /^((static) )?([\w.]+)(:([\w.]+))?/.exec(s);
      var cn = s[3].match(/(^|\.)(\w+)$/i)[2];
      var ns = self2.createNS(s[3].replace(/\.\w+$/, ""), root);
      if (ns[cn]) {
        return;
      }
      if (s[2] === "static") {
        ns[cn] = p;
        if (this.onCreate) {
          this.onCreate(s[2], s[3], ns[cn]);
        }
        return;
      }
      if (!p[cn]) {
        p[cn] = function() {
        };
        de = 1;
      }
      ns[cn] = p[cn];
      self2.extend(ns[cn].prototype, p);
      if (s[5]) {
        sp = self2.resolve(s[5]).prototype;
        scn = s[5].match(/\.(\w+)$/i)[1];
        c = ns[cn];
        if (de) {
          ns[cn] = function() {
            return sp[scn].apply(this, arguments);
          };
        } else {
          ns[cn] = function() {
            this.parent = sp[scn];
            return c.apply(this, arguments);
          };
        }
        ns[cn].prototype[cn] = ns[cn];
        self2.each(sp, function(f, n) {
          ns[cn].prototype[n] = sp[n];
        });
        self2.each(p, function(f, n) {
          if (sp[n]) {
            ns[cn].prototype[n] = function() {
              this.parent = sp[n];
              return f.apply(this, arguments);
            };
          } else {
            if (n !== cn) {
              ns[cn].prototype[n] = f;
            }
          }
        });
      }
      self2.each(p.static, function(f, n) {
        ns[cn][n] = f;
      });
    };
    var extend = function(obj) {
      var exts = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        exts[_i - 1] = arguments[_i];
      }
      for (var i = 0; i < exts.length; i++) {
        var ext = exts[i];
        for (var name_1 in ext) {
          if (ext.hasOwnProperty(name_1)) {
            var value2 = ext[name_1];
            if (value2 !== void 0) {
              obj[name_1] = value2;
            }
          }
        }
      }
      return obj;
    };
    var walk = function(o, f, n, s) {
      s = s || this;
      if (o) {
        if (n) {
          o = o[n];
        }
        each$2(o, function(o2, i) {
          if (f.call(s, o2, i, n) === false) {
            return false;
          }
          walk(o2, f, n, s);
        });
      }
    };
    var createNS = function(n, o) {
      var i, v;
      o = o || window;
      n = n.split(".");
      for (i = 0; i < n.length; i++) {
        v = n[i];
        if (!o[v]) {
          o[v] = {};
        }
        o = o[v];
      }
      return o;
    };
    var resolve = function(n, o) {
      var i, l;
      o = o || window;
      n = n.split(".");
      for (i = 0, l = n.length; i < l; i++) {
        o = o[n[i]];
        if (!o) {
          break;
        }
      }
      return o;
    };
    var explode = function(s, d) {
      if (!s || is(s, "array")) {
        return s;
      }
      return map$2(s.split(d || ","), trim$1);
    };
    var _addCacheSuffix = function(url) {
      var cacheSuffix = Env.cacheSuffix;
      if (cacheSuffix) {
        url += (url.indexOf("?") === -1 ? "?" : "&") + cacheSuffix;
      }
      return url;
    };
    var Tools = {
      trim: trim$1,
      isArray: isArray$1,
      is,
      toArray,
      makeMap,
      each: each$2,
      map: map$2,
      grep: filter$2,
      inArray: indexOf$1,
      hasOwn: hasOwnProperty$1,
      extend,
      create,
      walk,
      createNS,
      resolve,
      explode,
      _addCacheSuffix
    };
    var fromHtml = function(html, scope) {
      var doc2 = scope || document;
      var div = doc2.createElement("div");
      div.innerHTML = html;
      if (!div.hasChildNodes() || div.childNodes.length > 1) {
        console.error("HTML does not have a single root node", html);
        throw new Error("HTML must have a single root node");
      }
      return fromDom(div.childNodes[0]);
    };
    var fromTag = function(tag, scope) {
      var doc2 = scope || document;
      var node = doc2.createElement(tag);
      return fromDom(node);
    };
    var fromText = function(text, scope) {
      var doc2 = scope || document;
      var node = doc2.createTextNode(text);
      return fromDom(node);
    };
    var fromDom = function(node) {
      if (node === null || node === void 0) {
        throw new Error("Node cannot be null or undefined");
      }
      return { dom: node };
    };
    var fromPoint = function(docElm, x, y) {
      return Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom);
    };
    var SugarElement = {
      fromHtml,
      fromTag,
      fromText,
      fromDom,
      fromPoint
    };
    var toArray$1 = function(target, f) {
      var r2 = [];
      var recurse = function(e) {
        r2.push(e);
        return f(e);
      };
      var cur = f(target);
      do {
        cur = cur.bind(recurse);
      } while (cur.isSome());
      return r2;
    };
    var compareDocumentPosition = function(a, b, match2) {
      return (a.compareDocumentPosition(b) & match2) !== 0;
    };
    var documentPositionContainedBy = function(a, b) {
      return compareDocumentPosition(a, b, Node.DOCUMENT_POSITION_CONTAINED_BY);
    };
    var COMMENT = 8;
    var DOCUMENT = 9;
    var DOCUMENT_FRAGMENT = 11;
    var ELEMENT = 1;
    var TEXT = 3;
    var is$1 = function(element, selector) {
      var dom2 = element.dom;
      if (dom2.nodeType !== ELEMENT) {
        return false;
      } else {
        var elem = dom2;
        if (elem.matches !== void 0) {
          return elem.matches(selector);
        } else if (elem.msMatchesSelector !== void 0) {
          return elem.msMatchesSelector(selector);
        } else if (elem.webkitMatchesSelector !== void 0) {
          return elem.webkitMatchesSelector(selector);
        } else if (elem.mozMatchesSelector !== void 0) {
          return elem.mozMatchesSelector(selector);
        } else {
          throw new Error("Browser lacks native selectors");
        }
      }
    };
    var bypassSelector = function(dom2) {
      return dom2.nodeType !== ELEMENT && dom2.nodeType !== DOCUMENT && dom2.nodeType !== DOCUMENT_FRAGMENT || dom2.childElementCount === 0;
    };
    var all = function(selector, scope) {
      var base = scope === void 0 ? document : scope.dom;
      return bypassSelector(base) ? [] : map(base.querySelectorAll(selector), SugarElement.fromDom);
    };
    var one = function(selector, scope) {
      var base = scope === void 0 ? document : scope.dom;
      return bypassSelector(base) ? Optional.none() : Optional.from(base.querySelector(selector)).map(SugarElement.fromDom);
    };
    var eq$2 = function(e1, e2) {
      return e1.dom === e2.dom;
    };
    var regularContains = function(e1, e2) {
      var d1 = e1.dom;
      var d2 = e2.dom;
      return d1 === d2 ? false : d1.contains(d2);
    };
    var ieContains = function(e1, e2) {
      return documentPositionContainedBy(e1.dom, e2.dom);
    };
    var contains$2 = function(e1, e2) {
      return detect$3().browser.isIE() ? ieContains(e1, e2) : regularContains(e1, e2);
    };
    typeof window !== "undefined" ? window : Function("return this;")();
    var name = function(element) {
      var r2 = element.dom.nodeName;
      return r2.toLowerCase();
    };
    var type = function(element) {
      return element.dom.nodeType;
    };
    var isType$1 = function(t) {
      return function(element) {
        return type(element) === t;
      };
    };
    var isComment = function(element) {
      return type(element) === COMMENT || name(element) === "#comment";
    };
    var isElement = isType$1(ELEMENT);
    var isText = isType$1(TEXT);
    var isDocument = isType$1(DOCUMENT);
    var isDocumentFragment = isType$1(DOCUMENT_FRAGMENT);
    var owner = function(element) {
      return SugarElement.fromDom(element.dom.ownerDocument);
    };
    var documentOrOwner = function(dos) {
      return isDocument(dos) ? dos : owner(dos);
    };
    var documentElement = function(element) {
      return SugarElement.fromDom(documentOrOwner(element).dom.documentElement);
    };
    var defaultView = function(element) {
      return SugarElement.fromDom(documentOrOwner(element).dom.defaultView);
    };
    var parent = function(element) {
      return Optional.from(element.dom.parentNode).map(SugarElement.fromDom);
    };
    var parents = function(element, isRoot) {
      var stop2 = isFunction(isRoot) ? isRoot : never;
      var dom2 = element.dom;
      var ret = [];
      while (dom2.parentNode !== null && dom2.parentNode !== void 0) {
        var rawParent = dom2.parentNode;
        var p = SugarElement.fromDom(rawParent);
        ret.push(p);
        if (stop2(p) === true) {
          break;
        } else {
          dom2 = rawParent;
        }
      }
      return ret;
    };
    var siblings = function(element) {
      var filterSelf = function(elements) {
        return filter(elements, function(x) {
          return !eq$2(element, x);
        });
      };
      return parent(element).map(children).map(filterSelf).getOr([]);
    };
    var prevSibling = function(element) {
      return Optional.from(element.dom.previousSibling).map(SugarElement.fromDom);
    };
    var nextSibling = function(element) {
      return Optional.from(element.dom.nextSibling).map(SugarElement.fromDom);
    };
    var prevSiblings = function(element) {
      return reverse(toArray$1(element, prevSibling));
    };
    var nextSiblings = function(element) {
      return toArray$1(element, nextSibling);
    };
    var children = function(element) {
      return map(element.dom.childNodes, SugarElement.fromDom);
    };
    var child = function(element, index) {
      var cs = element.dom.childNodes;
      return Optional.from(cs[index]).map(SugarElement.fromDom);
    };
    var firstChild = function(element) {
      return child(element, 0);
    };
    var lastChild = function(element) {
      return child(element, element.dom.childNodes.length - 1);
    };
    var childNodesCount = function(element) {
      return element.dom.childNodes.length;
    };
    var getHead = function(doc2) {
      var b = doc2.dom.head;
      if (b === null || b === void 0) {
        throw new Error("Head is not available yet");
      }
      return SugarElement.fromDom(b);
    };
    var isShadowRoot = function(dos) {
      return isDocumentFragment(dos) && isNonNullable(dos.dom.host);
    };
    var supported = isFunction(Element.prototype.attachShadow) && isFunction(Node.prototype.getRootNode);
    var isSupported = constant(supported);
    var getRootNode = supported ? function(e) {
      return SugarElement.fromDom(e.dom.getRootNode());
    } : documentOrOwner;
    var getStyleContainer = function(dos) {
      return isShadowRoot(dos) ? dos : getHead(documentOrOwner(dos));
    };
    var getShadowRoot = function(e) {
      var r2 = getRootNode(e);
      return isShadowRoot(r2) ? Optional.some(r2) : Optional.none();
    };
    var getShadowHost = function(e) {
      return SugarElement.fromDom(e.dom.host);
    };
    var getOriginalEventTarget = function(event) {
      if (isSupported() && isNonNullable(event.target)) {
        var el = SugarElement.fromDom(event.target);
        if (isElement(el) && isOpenShadowHost(el)) {
          if (event.composed && event.composedPath) {
            var composedPath = event.composedPath();
            if (composedPath) {
              return head(composedPath);
            }
          }
        }
      }
      return Optional.from(event.target);
    };
    var isOpenShadowHost = function(element) {
      return isNonNullable(element.dom.shadowRoot);
    };
    var before = function(marker, element) {
      var parent$1 = parent(marker);
      parent$1.each(function(v) {
        v.dom.insertBefore(element.dom, marker.dom);
      });
    };
    var after = function(marker, element) {
      var sibling2 = nextSibling(marker);
      sibling2.fold(function() {
        var parent$1 = parent(marker);
        parent$1.each(function(v) {
          append(v, element);
        });
      }, function(v) {
        before(v, element);
      });
    };
    var prepend = function(parent2, element) {
      var firstChild$1 = firstChild(parent2);
      firstChild$1.fold(function() {
        append(parent2, element);
      }, function(v) {
        parent2.dom.insertBefore(element.dom, v.dom);
      });
    };
    var append = function(parent2, element) {
      parent2.dom.appendChild(element.dom);
    };
    var wrap = function(element, wrapper) {
      before(element, wrapper);
      append(wrapper, element);
    };
    var before$1 = function(marker, elements) {
      each(elements, function(x) {
        before(marker, x);
      });
    };
    var append$1 = function(parent2, elements) {
      each(elements, function(x) {
        append(parent2, x);
      });
    };
    var empty = function(element) {
      element.dom.textContent = "";
      each(children(element), function(rogue) {
        remove(rogue);
      });
    };
    var remove = function(element) {
      var dom2 = element.dom;
      if (dom2.parentNode !== null) {
        dom2.parentNode.removeChild(dom2);
      }
    };
    var unwrap = function(wrapper) {
      var children$1 = children(wrapper);
      if (children$1.length > 0) {
        before$1(wrapper, children$1);
      }
      remove(wrapper);
    };
    var inBody = function(element) {
      var dom2 = isText(element) ? element.dom.parentNode : element.dom;
      if (dom2 === void 0 || dom2 === null || dom2.ownerDocument === null) {
        return false;
      }
      var doc2 = dom2.ownerDocument;
      return getShadowRoot(SugarElement.fromDom(dom2)).fold(function() {
        return doc2.body.contains(dom2);
      }, compose1(inBody, getShadowHost));
    };
    var r = function(left, top) {
      var translate2 = function(x, y) {
        return r(left + x, top + y);
      };
      return {
        left,
        top,
        translate: translate2
      };
    };
    var SugarPosition = r;
    var boxPosition = function(dom2) {
      var box = dom2.getBoundingClientRect();
      return SugarPosition(box.left, box.top);
    };
    var firstDefinedOrZero = function(a, b) {
      if (a !== void 0) {
        return a;
      } else {
        return b !== void 0 ? b : 0;
      }
    };
    var absolute = function(element) {
      var doc2 = element.dom.ownerDocument;
      var body = doc2.body;
      var win = doc2.defaultView;
      var html = doc2.documentElement;
      if (body === element.dom) {
        return SugarPosition(body.offsetLeft, body.offsetTop);
      }
      var scrollTop = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageYOffset, html.scrollTop);
      var scrollLeft = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageXOffset, html.scrollLeft);
      var clientTop = firstDefinedOrZero(html.clientTop, body.clientTop);
      var clientLeft = firstDefinedOrZero(html.clientLeft, body.clientLeft);
      return viewport(element).translate(scrollLeft - clientLeft, scrollTop - clientTop);
    };
    var viewport = function(element) {
      var dom2 = element.dom;
      var doc2 = dom2.ownerDocument;
      var body = doc2.body;
      if (body === dom2) {
        return SugarPosition(body.offsetLeft, body.offsetTop);
      }
      if (!inBody(element)) {
        return SugarPosition(0, 0);
      }
      return boxPosition(dom2);
    };
    var get$2 = function(_DOC) {
      var doc2 = _DOC !== void 0 ? _DOC.dom : document;
      var x = doc2.body.scrollLeft || doc2.documentElement.scrollLeft;
      var y = doc2.body.scrollTop || doc2.documentElement.scrollTop;
      return SugarPosition(x, y);
    };
    var to = function(x, y, _DOC) {
      var doc2 = _DOC !== void 0 ? _DOC.dom : document;
      var win = doc2.defaultView;
      if (win) {
        win.scrollTo(x, y);
      }
    };
    var intoView = function(element, alignToTop) {
      var isSafari = detect$3().browser.isSafari();
      if (isSafari && isFunction(element.dom.scrollIntoViewIfNeeded)) {
        element.dom.scrollIntoViewIfNeeded(false);
      } else {
        element.dom.scrollIntoView(alignToTop);
      }
    };
    var get$3 = function(_win) {
      var win = _win === void 0 ? window : _win;
      return Optional.from(win["visualViewport"]);
    };
    var bounds = function(x, y, width, height) {
      return {
        x,
        y,
        width,
        height,
        right: x + width,
        bottom: y + height
      };
    };
    var getBounds = function(_win) {
      var win = _win === void 0 ? window : _win;
      var doc2 = win.document;
      var scroll = get$2(SugarElement.fromDom(doc2));
      return get$3(win).fold(function() {
        var html = win.document.documentElement;
        var width = html.clientWidth;
        var height = html.clientHeight;
        return bounds(scroll.left, scroll.top, width, height);
      }, function(visualViewport) {
        return bounds(Math.max(visualViewport.pageLeft, scroll.left), Math.max(visualViewport.pageTop, scroll.top), visualViewport.width, visualViewport.height);
      });
    };
    var isNodeType = function(type2) {
      return function(node) {
        return !!node && node.nodeType === type2;
      };
    };
    var isRestrictedNode = function(node) {
      return !!node && !Object.getPrototypeOf(node);
    };
    var isElement$1 = isNodeType(1);
    var matchNodeNames = function(names) {
      var lowercasedNames = names.map(function(s) {
        return s.toLowerCase();
      });
      return function(node) {
        if (node && node.nodeName) {
          var nodeName = node.nodeName.toLowerCase();
          return contains(lowercasedNames, nodeName);
        }
        return false;
      };
    };
    var matchStyleValues = function(name2, values2) {
      var items = values2.toLowerCase().split(" ");
      return function(node) {
        var i, cssValue;
        if (isElement$1(node)) {
          for (i = 0; i < items.length; i++) {
            var computed = node.ownerDocument.defaultView.getComputedStyle(node, null);
            cssValue = computed ? computed.getPropertyValue(name2) : null;
            if (cssValue === items[i]) {
              return true;
            }
          }
        }
        return false;
      };
    };
    var hasAttribute = function(attrName) {
      return function(node) {
        return isElement$1(node) && node.hasAttribute(attrName);
      };
    };
    var hasAttributeValue = function(attrName, attrValue) {
      return function(node) {
        return isElement$1(node) && node.getAttribute(attrName) === attrValue;
      };
    };
    var isBogus = function(node) {
      return isElement$1(node) && node.hasAttribute("data-mce-bogus");
    };
    var isBogusAll = function(node) {
      return isElement$1(node) && node.getAttribute("data-mce-bogus") === "all";
    };
    var isTable = function(node) {
      return isElement$1(node) && node.tagName === "TABLE";
    };
    var hasContentEditableState = function(value2) {
      return function(node) {
        if (isElement$1(node)) {
          if (node.contentEditable === value2) {
            return true;
          }
          if (node.getAttribute("data-mce-contenteditable") === value2) {
            return true;
          }
        }
        return false;
      };
    };
    var isTextareaOrInput = matchNodeNames([
      "textarea",
      "input"
    ]);
    var isText$1 = isNodeType(3);
    var isComment$1 = isNodeType(8);
    var isDocument$1 = isNodeType(9);
    var isDocumentFragment$1 = isNodeType(11);
    var isBr = matchNodeNames(["br"]);
    var isImg = matchNodeNames(["img"]);
    var isContentEditableTrue = hasContentEditableState("true");
    var isContentEditableFalse = hasContentEditableState("false");
    var isTableCell = matchNodeNames([
      "td",
      "th"
    ]);
    var isMedia = matchNodeNames([
      "video",
      "audio",
      "object",
      "embed"
    ]);
    var isSupported$1 = function(dom2) {
      return dom2.style !== void 0 && isFunction(dom2.style.getPropertyValue);
    };
    var rawSet = function(dom2, key, value2) {
      if (isString(value2) || isBoolean(value2) || isNumber(value2)) {
        dom2.setAttribute(key, value2 + "");
      } else {
        console.error("Invalid call to Attribute.set. Key ", key, ":: Value ", value2, ":: Element ", dom2);
        throw new Error("Attribute value was not simple");
      }
    };
    var set = function(element, key, value2) {
      rawSet(element.dom, key, value2);
    };
    var setAll = function(element, attrs) {
      var dom2 = element.dom;
      each$1(attrs, function(v, k) {
        rawSet(dom2, k, v);
      });
    };
    var get$4 = function(element, key) {
      var v = element.dom.getAttribute(key);
      return v === null ? void 0 : v;
    };
    var getOpt = function(element, key) {
      return Optional.from(get$4(element, key));
    };
    var has$1 = function(element, key) {
      var dom2 = element.dom;
      return dom2 && dom2.hasAttribute ? dom2.hasAttribute(key) : false;
    };
    var remove$1 = function(element, key) {
      element.dom.removeAttribute(key);
    };
    var clone = function(element) {
      return foldl(element.dom.attributes, function(acc, attr) {
        acc[attr.name] = attr.value;
        return acc;
      }, {});
    };
    var internalSet = function(dom2, property, value2) {
      if (!isString(value2)) {
        console.error("Invalid call to CSS.set. Property ", property, ":: Value ", value2, ":: Element ", dom2);
        throw new Error("CSS value must be a string: " + value2);
      }
      if (isSupported$1(dom2)) {
        dom2.style.setProperty(property, value2);
      }
    };
    var setAll$1 = function(element, css) {
      var dom2 = element.dom;
      each$1(css, function(v, k) {
        internalSet(dom2, k, v);
      });
    };
    var get$5 = function(element, property) {
      var dom2 = element.dom;
      var styles = window.getComputedStyle(dom2);
      var r2 = styles.getPropertyValue(property);
      return r2 === "" && !inBody(element) ? getUnsafeProperty(dom2, property) : r2;
    };
    var getUnsafeProperty = function(dom2, property) {
      return isSupported$1(dom2) ? dom2.style.getPropertyValue(property) : "";
    };
    var getRaw = function(element, property) {
      var dom2 = element.dom;
      var raw = getUnsafeProperty(dom2, property);
      return Optional.from(raw).filter(function(r2) {
        return r2.length > 0;
      });
    };
    var getAllRaw = function(element) {
      var css = {};
      var dom2 = element.dom;
      if (isSupported$1(dom2)) {
        for (var i = 0; i < dom2.style.length; i++) {
          var ruleName = dom2.style.item(i);
          css[ruleName] = dom2.style[ruleName];
        }
      }
      return css;
    };
    var reflow = function(e) {
      return e.dom.offsetWidth;
    };
    var browser$1 = detect$3().browser;
    var firstElement = function(nodes) {
      return find(nodes, isElement);
    };
    var getTableCaptionDeltaY = function(elm) {
      if (browser$1.isFirefox() && name(elm) === "table") {
        return firstElement(children(elm)).filter(function(elm2) {
          return name(elm2) === "caption";
        }).bind(function(caption) {
          return firstElement(nextSiblings(caption)).map(function(body) {
            var bodyTop = body.dom.offsetTop;
            var captionTop = caption.dom.offsetTop;
            var captionHeight = caption.dom.offsetHeight;
            return bodyTop <= captionTop ? -captionHeight : 0;
          });
        }).getOr(0);
      } else {
        return 0;
      }
    };
    var hasChild = function(elm, child2) {
      return elm.children && contains(elm.children, child2);
    };
    var getPos = function(body, elm, rootElm) {
      var x = 0, y = 0, offsetParent;
      var doc2 = body.ownerDocument;
      var pos;
      rootElm = rootElm ? rootElm : body;
      if (elm) {
        if (rootElm === body && elm.getBoundingClientRect && get$5(SugarElement.fromDom(body), "position") === "static") {
          pos = elm.getBoundingClientRect();
          x = pos.left + (doc2.documentElement.scrollLeft || body.scrollLeft) - doc2.documentElement.clientLeft;
          y = pos.top + (doc2.documentElement.scrollTop || body.scrollTop) - doc2.documentElement.clientTop;
          return {
            x,
            y
          };
        }
        offsetParent = elm;
        while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType && !hasChild(offsetParent, rootElm)) {
          x += offsetParent.offsetLeft || 0;
          y += offsetParent.offsetTop || 0;
          offsetParent = offsetParent.offsetParent;
        }
        offsetParent = elm.parentNode;
        while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType && !hasChild(offsetParent, rootElm)) {
          x -= offsetParent.scrollLeft || 0;
          y -= offsetParent.scrollTop || 0;
          offsetParent = offsetParent.parentNode;
        }
        y += getTableCaptionDeltaY(SugarElement.fromDom(elm));
      }
      return {
        x,
        y
      };
    };
    var exports$1 = {}, module$1 = { exports: exports$1 };
    (function(define, exports, module2, require) {
      (function(f) {
        if (typeof exports === "object" && typeof module2 !== "undefined") {
          module2.exports = f();
        } else if (typeof define === "function" && define.amd) {
          define([], f);
        } else {
          var g;
          if (typeof window !== "undefined") {
            g = window;
          } else if (typeof commonjsGlobal !== "undefined") {
            g = commonjsGlobal;
          } else if (typeof self !== "undefined") {
            g = self;
          } else {
            g = this;
          }
          g.EphoxContactWrapper = f();
        }
      })(function() {
        return function() {
          function r2(e, n, t) {
            function o(i2, f) {
              if (!n[i2]) {
                if (!e[i2]) {
                  var c = typeof require == "function" && require;
                  if (!f && c)
                    return c(i2, true);
                  if (u)
                    return u(i2, true);
                  var a = new Error("Cannot find module '" + i2 + "'");
                  throw a.code = "MODULE_NOT_FOUND", a;
                }
                var p = n[i2] = { exports: {} };
                e[i2][0].call(p.exports, function(r3) {
                  var n2 = e[i2][1][r3];
                  return o(n2 || r3);
                }, p, p.exports, r2, e, n, t);
              }
              return n[i2].exports;
            }
            for (var u = typeof require == "function" && require, i = 0; i < t.length; i++)
              o(t[i]);
            return o;
          }
          return r2;
        }()({
          1: [
            function(require2, module3, exports2) {
              var process2 = module3.exports = {};
              var cachedSetTimeout;
              var cachedClearTimeout;
              function defaultSetTimout() {
                throw new Error("setTimeout has not been defined");
              }
              function defaultClearTimeout() {
                throw new Error("clearTimeout has not been defined");
              }
              (function() {
                try {
                  if (typeof setTimeout === "function") {
                    cachedSetTimeout = setTimeout;
                  } else {
                    cachedSetTimeout = defaultSetTimout;
                  }
                } catch (e) {
                  cachedSetTimeout = defaultSetTimout;
                }
                try {
                  if (typeof clearTimeout === "function") {
                    cachedClearTimeout = clearTimeout;
                  } else {
                    cachedClearTimeout = defaultClearTimeout;
                  }
                } catch (e) {
                  cachedClearTimeout = defaultClearTimeout;
                }
              })();
              function runTimeout(fun) {
                if (cachedSetTimeout === setTimeout) {
                  return setTimeout(fun, 0);
                }
                if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                  cachedSetTimeout = setTimeout;
                  return setTimeout(fun, 0);
                }
                try {
                  return cachedSetTimeout(fun, 0);
                } catch (e) {
                  try {
                    return cachedSetTimeout.call(null, fun, 0);
                  } catch (e2) {
                    return cachedSetTimeout.call(this, fun, 0);
                  }
                }
              }
              function runClearTimeout(marker) {
                if (cachedClearTimeout === clearTimeout) {
                  return clearTimeout(marker);
                }
                if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                  cachedClearTimeout = clearTimeout;
                  return clearTimeout(marker);
                }
                try {
                  return cachedClearTimeout(marker);
                } catch (e) {
                  try {
                    return cachedClearTimeout.call(null, marker);
                  } catch (e2) {
                    return cachedClearTimeout.call(this, marker);
                  }
                }
              }
              var queue = [];
              var draining = false;
              var currentQueue;
              var queueIndex = -1;
              function cleanUpNextTick() {
                if (!draining || !currentQueue) {
                  return;
                }
                draining = false;
                if (currentQueue.length) {
                  queue = currentQueue.concat(queue);
                } else {
                  queueIndex = -1;
                }
                if (queue.length) {
                  drainQueue();
                }
              }
              function drainQueue() {
                if (draining) {
                  return;
                }
                var timeout = runTimeout(cleanUpNextTick);
                draining = true;
                var len = queue.length;
                while (len) {
                  currentQueue = queue;
                  queue = [];
                  while (++queueIndex < len) {
                    if (currentQueue) {
                      currentQueue[queueIndex].run();
                    }
                  }
                  queueIndex = -1;
                  len = queue.length;
                }
                currentQueue = null;
                draining = false;
                runClearTimeout(timeout);
              }
              process2.nextTick = function(fun) {
                var args = new Array(arguments.length - 1);
                if (arguments.length > 1) {
                  for (var i = 1; i < arguments.length; i++) {
                    args[i - 1] = arguments[i];
                  }
                }
                queue.push(new Item(fun, args));
                if (queue.length === 1 && !draining) {
                  runTimeout(drainQueue);
                }
              };
              function Item(fun, array) {
                this.fun = fun;
                this.array = array;
              }
              Item.prototype.run = function() {
                this.fun.apply(null, this.array);
              };
              process2.title = "browser";
              process2.browser = true;
              process2.env = {};
              process2.argv = [];
              process2.version = "";
              process2.versions = {};
              function noop2() {
              }
              process2.on = noop2;
              process2.addListener = noop2;
              process2.once = noop2;
              process2.off = noop2;
              process2.removeListener = noop2;
              process2.removeAllListeners = noop2;
              process2.emit = noop2;
              process2.prependListener = noop2;
              process2.prependOnceListener = noop2;
              process2.listeners = function(name2) {
                return [];
              };
              process2.binding = function(name2) {
                throw new Error("process.binding is not supported");
              };
              process2.cwd = function() {
                return "/";
              };
              process2.chdir = function(dir2) {
                throw new Error("process.chdir is not supported");
              };
              process2.umask = function() {
                return 0;
              };
            },
            {}
          ],
          2: [
            function(require2, module3, exports2) {
              (function(setImmediate2) {
                (function(root) {
                  var setTimeoutFunc = setTimeout;
                  function noop2() {
                  }
                  function bind2(fn, thisArg) {
                    return function() {
                      fn.apply(thisArg, arguments);
                    };
                  }
                  function Promise2(fn) {
                    if (typeof this !== "object")
                      throw new TypeError("Promises must be constructed via new");
                    if (typeof fn !== "function")
                      throw new TypeError("not a function");
                    this._state = 0;
                    this._handled = false;
                    this._value = void 0;
                    this._deferreds = [];
                    doResolve(fn, this);
                  }
                  function handle2(self2, deferred) {
                    while (self2._state === 3) {
                      self2 = self2._value;
                    }
                    if (self2._state === 0) {
                      self2._deferreds.push(deferred);
                      return;
                    }
                    self2._handled = true;
                    Promise2._immediateFn(function() {
                      var cb = self2._state === 1 ? deferred.onFulfilled : deferred.onRejected;
                      if (cb === null) {
                        (self2._state === 1 ? resolve2 : reject)(deferred.promise, self2._value);
                        return;
                      }
                      var ret;
                      try {
                        ret = cb(self2._value);
                      } catch (e) {
                        reject(deferred.promise, e);
                        return;
                      }
                      resolve2(deferred.promise, ret);
                    });
                  }
                  function resolve2(self2, newValue) {
                    try {
                      if (newValue === self2)
                        throw new TypeError("A promise cannot be resolved with itself.");
                      if (newValue && (typeof newValue === "object" || typeof newValue === "function")) {
                        var then = newValue.then;
                        if (newValue instanceof Promise2) {
                          self2._state = 3;
                          self2._value = newValue;
                          finale(self2);
                          return;
                        } else if (typeof then === "function") {
                          doResolve(bind2(then, newValue), self2);
                          return;
                        }
                      }
                      self2._state = 1;
                      self2._value = newValue;
                      finale(self2);
                    } catch (e) {
                      reject(self2, e);
                    }
                  }
                  function reject(self2, newValue) {
                    self2._state = 2;
                    self2._value = newValue;
                    finale(self2);
                  }
                  function finale(self2) {
                    if (self2._state === 2 && self2._deferreds.length === 0) {
                      Promise2._immediateFn(function() {
                        if (!self2._handled) {
                          Promise2._unhandledRejectionFn(self2._value);
                        }
                      });
                    }
                    for (var i = 0, len = self2._deferreds.length; i < len; i++) {
                      handle2(self2, self2._deferreds[i]);
                    }
                    self2._deferreds = null;
                  }
                  function Handler(onFulfilled, onRejected, promise2) {
                    this.onFulfilled = typeof onFulfilled === "function" ? onFulfilled : null;
                    this.onRejected = typeof onRejected === "function" ? onRejected : null;
                    this.promise = promise2;
                  }
                  function doResolve(fn, self2) {
                    var done2 = false;
                    try {
                      fn(function(value2) {
                        if (done2)
                          return;
                        done2 = true;
                        resolve2(self2, value2);
                      }, function(reason) {
                        if (done2)
                          return;
                        done2 = true;
                        reject(self2, reason);
                      });
                    } catch (ex) {
                      if (done2)
                        return;
                      done2 = true;
                      reject(self2, ex);
                    }
                  }
                  Promise2.prototype["catch"] = function(onRejected) {
                    return this.then(null, onRejected);
                  };
                  Promise2.prototype.then = function(onFulfilled, onRejected) {
                    var prom = new this.constructor(noop2);
                    handle2(this, new Handler(onFulfilled, onRejected, prom));
                    return prom;
                  };
                  Promise2.all = function(arr2) {
                    var args = Array.prototype.slice.call(arr2);
                    return new Promise2(function(resolve3, reject2) {
                      if (args.length === 0)
                        return resolve3([]);
                      var remaining = args.length;
                      function res(i2, val) {
                        try {
                          if (val && (typeof val === "object" || typeof val === "function")) {
                            var then = val.then;
                            if (typeof then === "function") {
                              then.call(val, function(val2) {
                                res(i2, val2);
                              }, reject2);
                              return;
                            }
                          }
                          args[i2] = val;
                          if (--remaining === 0) {
                            resolve3(args);
                          }
                        } catch (ex) {
                          reject2(ex);
                        }
                      }
                      for (var i = 0; i < args.length; i++) {
                        res(i, args[i]);
                      }
                    });
                  };
                  Promise2.resolve = function(value2) {
                    if (value2 && typeof value2 === "object" && value2.constructor === Promise2) {
                      return value2;
                    }
                    return new Promise2(function(resolve3) {
                      resolve3(value2);
                    });
                  };
                  Promise2.reject = function(value2) {
                    return new Promise2(function(resolve3, reject2) {
                      reject2(value2);
                    });
                  };
                  Promise2.race = function(values2) {
                    return new Promise2(function(resolve3, reject2) {
                      for (var i = 0, len = values2.length; i < len; i++) {
                        values2[i].then(resolve3, reject2);
                      }
                    });
                  };
                  Promise2._immediateFn = typeof setImmediate2 === "function" ? function(fn) {
                    setImmediate2(fn);
                  } : function(fn) {
                    setTimeoutFunc(fn, 0);
                  };
                  Promise2._unhandledRejectionFn = function _unhandledRejectionFn(err) {
                    if (typeof console !== "undefined" && console) {
                      console.warn("Possible Unhandled Promise Rejection:", err);
                    }
                  };
                  Promise2._setImmediateFn = function _setImmediateFn(fn) {
                    Promise2._immediateFn = fn;
                  };
                  Promise2._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {
                    Promise2._unhandledRejectionFn = fn;
                  };
                  if (typeof module3 !== "undefined" && module3.exports) {
                    module3.exports = Promise2;
                  } else if (!root.Promise) {
                    root.Promise = Promise2;
                  }
                })(this);
              }).call(this, require2("timers").setImmediate);
            },
            { "timers": 3 }
          ],
          3: [
            function(require2, module3, exports2) {
              (function(setImmediate2, clearImmediate) {
                var nextTick2 = require2("process/browser.js").nextTick;
                var apply2 = Function.prototype.apply;
                var slice2 = Array.prototype.slice;
                var immediateIds = {};
                var nextImmediateId = 0;
                exports2.setTimeout = function() {
                  return new Timeout(apply2.call(setTimeout, window, arguments), clearTimeout);
                };
                exports2.setInterval = function() {
                  return new Timeout(apply2.call(setInterval, window, arguments), clearInterval);
                };
                exports2.clearTimeout = exports2.clearInterval = function(timeout) {
                  timeout.close();
                };
                function Timeout(id, clearFn) {
                  this._id = id;
                  this._clearFn = clearFn;
                }
                Timeout.prototype.unref = Timeout.prototype.ref = function() {
                };
                Timeout.prototype.close = function() {
                  this._clearFn.call(window, this._id);
                };
                exports2.enroll = function(item, msecs) {
                  clearTimeout(item._idleTimeoutId);
                  item._idleTimeout = msecs;
                };
                exports2.unenroll = function(item) {
                  clearTimeout(item._idleTimeoutId);
                  item._idleTimeout = -1;
                };
                exports2._unrefActive = exports2.active = function(item) {
                  clearTimeout(item._idleTimeoutId);
                  var msecs = item._idleTimeout;
                  if (msecs >= 0) {
                    item._idleTimeoutId = setTimeout(function onTimeout() {
                      if (item._onTimeout)
                        item._onTimeout();
                    }, msecs);
                  }
                };
                exports2.setImmediate = typeof setImmediate2 === "function" ? setImmediate2 : function(fn) {
                  var id = nextImmediateId++;
                  var args = arguments.length < 2 ? false : slice2.call(arguments, 1);
                  immediateIds[id] = true;
                  nextTick2(function onNextTick() {
                    if (immediateIds[id]) {
                      if (args) {
                        fn.apply(null, args);
                      } else {
                        fn.call(null);
                      }
                      exports2.clearImmediate(id);
                    }
                  });
                  return id;
                };
                exports2.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
                  delete immediateIds[id];
                };
              }).call(this, require2("timers").setImmediate, require2("timers").clearImmediate);
            },
            {
              "process/browser.js": 1,
              "timers": 3
            }
          ],
          4: [
            function(require2, module3, exports2) {
              var promisePolyfill = require2("promise-polyfill");
              var Global = function() {
                if (typeof window !== "undefined") {
                  return window;
                } else {
                  return Function("return this;")();
                }
              }();
              module3.exports = { boltExport: Global.Promise || promisePolyfill };
            },
            { "promise-polyfill": 2 }
          ]
        }, {}, [4])(4);
      });
    })(void 0, exports$1, module$1, void 0);
    var Promise = module$1.exports.boltExport;
    var nu$3 = function(baseFn) {
      var data2 = Optional.none();
      var callbacks = [];
      var map2 = function(f) {
        return nu$3(function(nCallback) {
          get2(function(data3) {
            nCallback(f(data3));
          });
        });
      };
      var get2 = function(nCallback) {
        if (isReady()) {
          call2(nCallback);
        } else {
          callbacks.push(nCallback);
        }
      };
      var set2 = function(x) {
        if (!isReady()) {
          data2 = Optional.some(x);
          run(callbacks);
          callbacks = [];
        }
      };
      var isReady = function() {
        return data2.isSome();
      };
      var run = function(cbs) {
        each(cbs, call2);
      };
      var call2 = function(cb) {
        data2.each(function(x) {
          setTimeout(function() {
            cb(x);
          }, 0);
        });
      };
      baseFn(set2);
      return {
        get: get2,
        map: map2,
        isReady
      };
    };
    var pure = function(a) {
      return nu$3(function(callback) {
        callback(a);
      });
    };
    var LazyValue = {
      nu: nu$3,
      pure
    };
    var errorReporter = function(err) {
      setTimeout(function() {
        throw err;
      }, 0);
    };
    var make = function(run) {
      var get2 = function(callback) {
        run().then(callback, errorReporter);
      };
      var map2 = function(fab) {
        return make(function() {
          return run().then(fab);
        });
      };
      var bind2 = function(aFutureB) {
        return make(function() {
          return run().then(function(v) {
            return aFutureB(v).toPromise();
          });
        });
      };
      var anonBind = function(futureB) {
        return make(function() {
          return run().then(function() {
            return futureB.toPromise();
          });
        });
      };
      var toLazy = function() {
        return LazyValue.nu(get2);
      };
      var toCached = function() {
        var cache = null;
        return make(function() {
          if (cache === null) {
            cache = run();
          }
          return cache;
        });
      };
      var toPromise = run;
      return {
        map: map2,
        bind: bind2,
        anonBind,
        toLazy,
        toCached,
        toPromise,
        get: get2
      };
    };
    var nu$4 = function(baseFn) {
      return make(function() {
        return new Promise(baseFn);
      });
    };
    var pure$1 = function(a) {
      return make(function() {
        return Promise.resolve(a);
      });
    };
    var Future = {
      nu: nu$4,
      pure: pure$1
    };
    var par = function(asyncValues, nu2) {
      return nu2(function(callback) {
        var r2 = [];
        var count2 = 0;
        var cb = function(i) {
          return function(value2) {
            r2[i] = value2;
            count2++;
            if (count2 >= asyncValues.length) {
              callback(r2);
            }
          };
        };
        if (asyncValues.length === 0) {
          callback([]);
        } else {
          each(asyncValues, function(asyncValue, i) {
            asyncValue.get(cb(i));
          });
        }
      });
    };
    var par$1 = function(futures) {
      return par(futures, Future.nu);
    };
    var value = function(o) {
      var is2 = function(v) {
        return o === v;
      };
      var or2 = function(_opt) {
        return value(o);
      };
      var orThunk = function(_f) {
        return value(o);
      };
      var map2 = function(f) {
        return value(f(o));
      };
      var mapError = function(_f) {
        return value(o);
      };
      var each2 = function(f) {
        f(o);
      };
      var bind2 = function(f) {
        return f(o);
      };
      var fold = function(_, onValue) {
        return onValue(o);
      };
      var exists2 = function(f) {
        return f(o);
      };
      var forall2 = function(f) {
        return f(o);
      };
      var toOptional = function() {
        return Optional.some(o);
      };
      return {
        is: is2,
        isValue: always,
        isError: never,
        getOr: constant(o),
        getOrThunk: constant(o),
        getOrDie: constant(o),
        or: or2,
        orThunk,
        fold,
        map: map2,
        mapError,
        each: each2,
        bind: bind2,
        exists: exists2,
        forall: forall2,
        toOptional
      };
    };
    var error = function(message) {
      var getOrThunk = function(f) {
        return f();
      };
      var getOrDie = function() {
        return die(String(message))();
      };
      var or2 = function(opt) {
        return opt;
      };
      var orThunk = function(f) {
        return f();
      };
      var map2 = function(_f) {
        return error(message);
      };
      var mapError = function(f) {
        return error(f(message));
      };
      var bind2 = function(_f) {
        return error(message);
      };
      var fold = function(onError, _) {
        return onError(message);
      };
      return {
        is: never,
        isValue: never,
        isError: always,
        getOr: identity,
        getOrThunk,
        getOrDie,
        or: or2,
        orThunk,
        fold,
        map: map2,
        mapError,
        each: noop,
        bind: bind2,
        exists: never,
        forall: always,
        toOptional: Optional.none
      };
    };
    var fromOption = function(opt, err) {
      return opt.fold(function() {
        return error(err);
      }, value);
    };
    var Result = {
      value,
      error,
      fromOption
    };
    var generate = function(cases) {
      if (!isArray(cases)) {
        throw new Error("cases must be an array");
      }
      if (cases.length === 0) {
        throw new Error("there must be at least one case");
      }
      var constructors = [];
      var adt2 = {};
      each(cases, function(acase, count2) {
        var keys$1 = keys(acase);
        if (keys$1.length !== 1) {
          throw new Error("one and only one name per case");
        }
        var key = keys$1[0];
        var value2 = acase[key];
        if (adt2[key] !== void 0) {
          throw new Error("duplicate key detected:" + key);
        } else if (key === "cata") {
          throw new Error("cannot have a case named cata (sorry)");
        } else if (!isArray(value2)) {
          throw new Error("case arguments must be an array");
        }
        constructors.push(key);
        adt2[key] = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var argLength = args.length;
          if (argLength !== value2.length) {
            throw new Error("Wrong number of arguments to case " + key + ". Expected " + value2.length + " (" + value2 + "), got " + argLength);
          }
          var match2 = function(branches) {
            var branchKeys = keys(branches);
            if (constructors.length !== branchKeys.length) {
              throw new Error("Wrong number of arguments to match. Expected: " + constructors.join(",") + "\nActual: " + branchKeys.join(","));
            }
            var allReqd = forall(constructors, function(reqKey) {
              return contains(branchKeys, reqKey);
            });
            if (!allReqd) {
              throw new Error("Not all branches were specified when using match. Specified: " + branchKeys.join(", ") + "\nRequired: " + constructors.join(", "));
            }
            return branches[key].apply(null, args);
          };
          return {
            fold: function() {
              var foldArgs = [];
              for (var _i2 = 0; _i2 < arguments.length; _i2++) {
                foldArgs[_i2] = arguments[_i2];
              }
              if (foldArgs.length !== cases.length) {
                throw new Error("Wrong number of arguments to fold. Expected " + cases.length + ", got " + foldArgs.length);
              }
              var target = foldArgs[count2];
              return target.apply(null, args);
            },
            match: match2,
            log: function(label) {
              console.log(label, {
                constructors,
                constructor: key,
                params: args
              });
            }
          };
        };
      });
      return adt2;
    };
    var Adt = { generate };
    Adt.generate([
      {
        bothErrors: [
          "error1",
          "error2"
        ]
      },
      {
        firstError: [
          "error1",
          "value2"
        ]
      },
      {
        secondError: [
          "value1",
          "error2"
        ]
      },
      {
        bothValues: [
          "value1",
          "value2"
        ]
      }
    ]);
    var unite = function(result) {
      return result.fold(identity, identity);
    };
    function ClosestOrAncestor(is2, ancestor2, scope, a, isRoot) {
      if (is2(scope, a)) {
        return Optional.some(scope);
      } else if (isFunction(isRoot) && isRoot(scope)) {
        return Optional.none();
      } else {
        return ancestor2(scope, a, isRoot);
      }
    }
    var ancestor = function(scope, predicate, isRoot) {
      var element = scope.dom;
      var stop2 = isFunction(isRoot) ? isRoot : never;
      while (element.parentNode) {
        element = element.parentNode;
        var el = SugarElement.fromDom(element);
        if (predicate(el)) {
          return Optional.some(el);
        } else if (stop2(el)) {
          break;
        }
      }
      return Optional.none();
    };
    var closest = function(scope, predicate, isRoot) {
      var is2 = function(s, test2) {
        return test2(s);
      };
      return ClosestOrAncestor(is2, ancestor, scope, predicate, isRoot);
    };
    var sibling = function(scope, predicate) {
      var element = scope.dom;
      if (!element.parentNode) {
        return Optional.none();
      }
      return child$1(SugarElement.fromDom(element.parentNode), function(x) {
        return !eq$2(scope, x) && predicate(x);
      });
    };
    var child$1 = function(scope, predicate) {
      var pred = function(node) {
        return predicate(SugarElement.fromDom(node));
      };
      var result = find(scope.dom.childNodes, pred);
      return result.map(SugarElement.fromDom);
    };
    var ancestor$1 = function(scope, selector, isRoot) {
      return ancestor(scope, function(e) {
        return is$1(e, selector);
      }, isRoot);
    };
    var descendant = function(scope, selector) {
      return one(selector, scope);
    };
    var closest$1 = function(scope, selector, isRoot) {
      var is2 = function(element, selector2) {
        return is$1(element, selector2);
      };
      return ClosestOrAncestor(is2, ancestor$1, scope, selector, isRoot);
    };
    var promise = function() {
      var bind2 = function(fn, thisArg) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          fn.apply(thisArg, args);
        };
      };
      var isArray2 = Array.isArray || function(value2) {
        return Object.prototype.toString.call(value2) === "[object Array]";
      };
      var Promise2 = function(fn) {
        if (typeof this !== "object") {
          throw new TypeError("Promises must be constructed via new");
        }
        if (typeof fn !== "function") {
          throw new TypeError("not a function");
        }
        this._state = null;
        this._value = null;
        this._deferreds = [];
        doResolve(fn, bind2(resolve2, this), bind2(reject, this));
      };
      var asap = Promise2.immediateFn || typeof setImmediate === "function" && setImmediate || function(fn) {
        return setTimeout(fn, 1);
      };
      function handle2(deferred) {
        var me = this;
        if (this._state === null) {
          this._deferreds.push(deferred);
          return;
        }
        asap(function() {
          var cb = me._state ? deferred.onFulfilled : deferred.onRejected;
          if (cb === null) {
            (me._state ? deferred.resolve : deferred.reject)(me._value);
            return;
          }
          var ret;
          try {
            ret = cb(me._value);
          } catch (e) {
            deferred.reject(e);
            return;
          }
          deferred.resolve(ret);
        });
      }
      function resolve2(newValue) {
        try {
          if (newValue === this) {
            throw new TypeError("A promise cannot be resolved with itself.");
          }
          if (newValue && (typeof newValue === "object" || typeof newValue === "function")) {
            var then = newValue.then;
            if (typeof then === "function") {
              doResolve(bind2(then, newValue), bind2(resolve2, this), bind2(reject, this));
              return;
            }
          }
          this._state = true;
          this._value = newValue;
          finale.call(this);
        } catch (e) {
          reject.call(this, e);
        }
      }
      function reject(newValue) {
        this._state = false;
        this._value = newValue;
        finale.call(this);
      }
      function finale() {
        for (var i = 0, len = this._deferreds.length; i < len; i++) {
          handle2.call(this, this._deferreds[i]);
        }
        this._deferreds = null;
      }
      function Handler(onFulfilled, onRejected, resolve3, reject2) {
        this.onFulfilled = typeof onFulfilled === "function" ? onFulfilled : null;
        this.onRejected = typeof onRejected === "function" ? onRejected : null;
        this.resolve = resolve3;
        this.reject = reject2;
      }
      var doResolve = function(fn, onFulfilled, onRejected) {
        var done2 = false;
        try {
          fn(function(value2) {
            if (done2) {
              return;
            }
            done2 = true;
            onFulfilled(value2);
          }, function(reason) {
            if (done2) {
              return;
            }
            done2 = true;
            onRejected(reason);
          });
        } catch (ex) {
          if (done2) {
            return;
          }
          done2 = true;
          onRejected(ex);
        }
      };
      Promise2.prototype.catch = function(onRejected) {
        return this.then(null, onRejected);
      };
      Promise2.prototype.then = function(onFulfilled, onRejected) {
        var me = this;
        return new Promise2(function(resolve3, reject2) {
          handle2.call(me, new Handler(onFulfilled, onRejected, resolve3, reject2));
        });
      };
      Promise2.all = function() {
        var values2 = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          values2[_i] = arguments[_i];
        }
        var args = Array.prototype.slice.call(values2.length === 1 && isArray2(values2[0]) ? values2[0] : values2);
        return new Promise2(function(resolve3, reject2) {
          if (args.length === 0) {
            return resolve3([]);
          }
          var remaining = args.length;
          var res = function(i2, val) {
            try {
              if (val && (typeof val === "object" || typeof val === "function")) {
                var then = val.then;
                if (typeof then === "function") {
                  then.call(val, function(val2) {
                    res(i2, val2);
                  }, reject2);
                  return;
                }
              }
              args[i2] = val;
              if (--remaining === 0) {
                resolve3(args);
              }
            } catch (ex) {
              reject2(ex);
            }
          };
          for (var i = 0; i < args.length; i++) {
            res(i, args[i]);
          }
        });
      };
      Promise2.resolve = function(value2) {
        if (value2 && typeof value2 === "object" && value2.constructor === Promise2) {
          return value2;
        }
        return new Promise2(function(resolve3) {
          resolve3(value2);
        });
      };
      Promise2.reject = function(value2) {
        return new Promise2(function(resolve3, reject2) {
          reject2(value2);
        });
      };
      Promise2.race = function(values2) {
        return new Promise2(function(resolve3, reject2) {
          for (var i = 0, len = values2.length; i < len; i++) {
            values2[i].then(resolve3, reject2);
          }
        });
      };
      return Promise2;
    };
    var promiseObj = window.Promise ? window.Promise : promise();
    var requestAnimationFramePromise;
    var requestAnimationFrame = function(callback, element) {
      var requestAnimationFrameFunc = window.requestAnimationFrame;
      var vendors = [
        "ms",
        "moz",
        "webkit"
      ];
      var featurefill = function(cb) {
        window.setTimeout(cb, 0);
      };
      for (var i = 0; i < vendors.length && !requestAnimationFrameFunc; i++) {
        requestAnimationFrameFunc = window[vendors[i] + "RequestAnimationFrame"];
      }
      if (!requestAnimationFrameFunc) {
        requestAnimationFrameFunc = featurefill;
      }
      requestAnimationFrameFunc(callback, element);
    };
    var wrappedSetTimeout = function(callback, time) {
      if (typeof time !== "number") {
        time = 0;
      }
      return setTimeout(callback, time);
    };
    var wrappedSetInterval = function(callback, time) {
      if (typeof time !== "number") {
        time = 1;
      }
      return setInterval(callback, time);
    };
    var wrappedClearTimeout = function(id) {
      return clearTimeout(id);
    };
    var wrappedClearInterval = function(id) {
      return clearInterval(id);
    };
    var debounce = function(callback, time) {
      var timer;
      var func = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        clearTimeout(timer);
        timer = wrappedSetTimeout(function() {
          callback.apply(this, args);
        }, time);
      };
      func.stop = function() {
        clearTimeout(timer);
      };
      return func;
    };
    var Delay = {
      requestAnimationFrame: function(callback, element) {
        if (requestAnimationFramePromise) {
          requestAnimationFramePromise.then(callback);
          return;
        }
        requestAnimationFramePromise = new promiseObj(function(resolve2) {
          if (!element) {
            element = document.body;
          }
          requestAnimationFrame(resolve2, element);
        }).then(callback);
      },
      setTimeout: wrappedSetTimeout,
      setInterval: wrappedSetInterval,
      setEditorTimeout: function(editor, callback, time) {
        return wrappedSetTimeout(function() {
          if (!editor.removed) {
            callback();
          }
        }, time);
      },
      setEditorInterval: function(editor, callback, time) {
        var timer = wrappedSetInterval(function() {
          if (!editor.removed) {
            callback();
          } else {
            clearInterval(timer);
          }
        }, time);
        return timer;
      },
      debounce,
      throttle: debounce,
      clearInterval: wrappedClearInterval,
      clearTimeout: wrappedClearTimeout
    };
    var StyleSheetLoader = function(documentOrShadowRoot, settings) {
      if (settings === void 0) {
        settings = {};
      }
      var idCount = 0;
      var loadedStates = {};
      var edos = SugarElement.fromDom(documentOrShadowRoot);
      var doc2 = documentOrOwner(edos);
      var maxLoadTime = settings.maxLoadTime || 5e3;
      var _setReferrerPolicy = function(referrerPolicy) {
        settings.referrerPolicy = referrerPolicy;
      };
      var addStyle = function(element) {
        append(getStyleContainer(edos), element);
      };
      var removeStyle = function(id) {
        var styleContainer = getStyleContainer(edos);
        descendant(styleContainer, "#" + id).each(remove);
      };
      var getOrCreateState = function(url) {
        return get$1(loadedStates, url).getOrThunk(function() {
          return {
            id: "mce-u" + idCount++,
            passed: [],
            failed: [],
            count: 0
          };
        });
      };
      var load = function(url, success, failure) {
        var link;
        var urlWithSuffix = Tools._addCacheSuffix(url);
        var state = getOrCreateState(urlWithSuffix);
        loadedStates[urlWithSuffix] = state;
        state.count++;
        var resolve2 = function(callbacks, status) {
          var i = callbacks.length;
          while (i--) {
            callbacks[i]();
          }
          state.status = status;
          state.passed = [];
          state.failed = [];
          if (link) {
            link.onload = null;
            link.onerror = null;
            link = null;
          }
        };
        var passed = function() {
          return resolve2(state.passed, 2);
        };
        var failed = function() {
          return resolve2(state.failed, 3);
        };
        var wait = function(testCallback, waitCallback) {
          if (!testCallback()) {
            if (Date.now() - startTime < maxLoadTime) {
              Delay.setTimeout(waitCallback);
            } else {
              failed();
            }
          }
        };
        var waitForWebKitLinkLoaded = function() {
          wait(function() {
            var styleSheets = documentOrShadowRoot.styleSheets;
            var i = styleSheets.length;
            while (i--) {
              var styleSheet = styleSheets[i];
              var owner2 = styleSheet.ownerNode;
              if (owner2 && owner2.id === link.id) {
                passed();
                return true;
              }
            }
            return false;
          }, waitForWebKitLinkLoaded);
        };
        if (success) {
          state.passed.push(success);
        }
        if (failure) {
          state.failed.push(failure);
        }
        if (state.status === 1) {
          return;
        }
        if (state.status === 2) {
          passed();
          return;
        }
        if (state.status === 3) {
          failed();
          return;
        }
        state.status = 1;
        var linkElem = SugarElement.fromTag("link", doc2.dom);
        setAll(linkElem, {
          rel: "stylesheet",
          type: "text/css",
          id: state.id
        });
        var startTime = Date.now();
        if (settings.contentCssCors) {
          set(linkElem, "crossOrigin", "anonymous");
        }
        if (settings.referrerPolicy) {
          set(linkElem, "referrerpolicy", settings.referrerPolicy);
        }
        link = linkElem.dom;
        link.onload = waitForWebKitLinkLoaded;
        link.onerror = failed;
        addStyle(linkElem);
        set(linkElem, "href", urlWithSuffix);
      };
      var loadF = function(url) {
        return Future.nu(function(resolve2) {
          load(url, compose(resolve2, constant(Result.value(url))), compose(resolve2, constant(Result.error(url))));
        });
      };
      var loadAll = function(urls, success, failure) {
        par$1(map(urls, loadF)).get(function(result) {
          var parts = partition(result, function(r2) {
            return r2.isValue();
          });
          if (parts.fail.length > 0) {
            failure(parts.fail.map(unite));
          } else {
            success(parts.pass.map(unite));
          }
        });
      };
      var unload = function(url) {
        var urlWithSuffix = Tools._addCacheSuffix(url);
        get$1(loadedStates, urlWithSuffix).each(function(state) {
          var count2 = --state.count;
          if (count2 === 0) {
            delete loadedStates[urlWithSuffix];
            removeStyle(state.id);
          }
        });
      };
      var unloadAll = function(urls) {
        each(urls, function(url) {
          unload(url);
        });
      };
      return {
        load,
        loadAll,
        unload,
        unloadAll,
        _setReferrerPolicy
      };
    };
    var create$1 = function() {
      var map2 = /* @__PURE__ */ new WeakMap();
      var forElement = function(referenceElement, settings) {
        var root = getRootNode(referenceElement);
        var rootDom = root.dom;
        return Optional.from(map2.get(rootDom)).getOrThunk(function() {
          var sl = StyleSheetLoader(rootDom, settings);
          map2.set(rootDom, sl);
          return sl;
        });
      };
      return { forElement };
    };
    var instance = create$1();
    var DomTreeWalker = function() {
      function DomTreeWalker2(startNode, rootNode) {
        this.node = startNode;
        this.rootNode = rootNode;
        this.current = this.current.bind(this);
        this.next = this.next.bind(this);
        this.prev = this.prev.bind(this);
        this.prev2 = this.prev2.bind(this);
      }
      DomTreeWalker2.prototype.current = function() {
        return this.node;
      };
      DomTreeWalker2.prototype.next = function(shallow2) {
        this.node = this.findSibling(this.node, "firstChild", "nextSibling", shallow2);
        return this.node;
      };
      DomTreeWalker2.prototype.prev = function(shallow2) {
        this.node = this.findSibling(this.node, "lastChild", "previousSibling", shallow2);
        return this.node;
      };
      DomTreeWalker2.prototype.prev2 = function(shallow2) {
        this.node = this.findPreviousNode(this.node, "lastChild", "previousSibling", shallow2);
        return this.node;
      };
      DomTreeWalker2.prototype.findSibling = function(node, startName, siblingName, shallow2) {
        var sibling2, parent2;
        if (node) {
          if (!shallow2 && node[startName]) {
            return node[startName];
          }
          if (node !== this.rootNode) {
            sibling2 = node[siblingName];
            if (sibling2) {
              return sibling2;
            }
            for (parent2 = node.parentNode; parent2 && parent2 !== this.rootNode; parent2 = parent2.parentNode) {
              sibling2 = parent2[siblingName];
              if (sibling2) {
                return sibling2;
              }
            }
          }
        }
      };
      DomTreeWalker2.prototype.findPreviousNode = function(node, startName, siblingName, shallow2) {
        var sibling2, parent2, child2;
        if (node) {
          sibling2 = node[siblingName];
          if (this.rootNode && sibling2 === this.rootNode) {
            return;
          }
          if (sibling2) {
            if (!shallow2) {
              for (child2 = sibling2[startName]; child2; child2 = child2[startName]) {
                if (!child2[startName]) {
                  return child2;
                }
              }
            }
            return sibling2;
          }
          parent2 = node.parentNode;
          if (parent2 && parent2 !== this.rootNode) {
            return parent2;
          }
        }
      };
      return DomTreeWalker2;
    }();
    var blocks = [
      "article",
      "aside",
      "details",
      "div",
      "dt",
      "figcaption",
      "footer",
      "form",
      "fieldset",
      "header",
      "hgroup",
      "html",
      "main",
      "nav",
      "section",
      "summary",
      "body",
      "p",
      "dl",
      "multicol",
      "dd",
      "figure",
      "address",
      "center",
      "blockquote",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "listing",
      "xmp",
      "pre",
      "plaintext",
      "menu",
      "dir",
      "ul",
      "ol",
      "li",
      "hr",
      "table",
      "tbody",
      "thead",
      "tfoot",
      "th",
      "tr",
      "td",
      "caption"
    ];
    var tableCells = [
      "td",
      "th"
    ];
    var tableSections = [
      "thead",
      "tbody",
      "tfoot"
    ];
    var textBlocks = [
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "p",
      "div",
      "address",
      "pre",
      "form",
      "blockquote",
      "center",
      "dir",
      "fieldset",
      "header",
      "footer",
      "article",
      "section",
      "hgroup",
      "aside",
      "nav",
      "figure"
    ];
    var headings = [
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6"
    ];
    var listItems = [
      "li",
      "dd",
      "dt"
    ];
    var lists = [
      "ul",
      "ol",
      "dl"
    ];
    var wsElements = [
      "pre",
      "script",
      "textarea",
      "style"
    ];
    var lazyLookup = function(items) {
      var lookup;
      return function(node) {
        lookup = lookup ? lookup : mapToObject(items, always);
        return lookup.hasOwnProperty(name(node));
      };
    };
    var isHeading = lazyLookup(headings);
    var isBlock = lazyLookup(blocks);
    var isTable$1 = function(node) {
      return name(node) === "table";
    };
    var isInline = function(node) {
      return isElement(node) && !isBlock(node);
    };
    var isBr$1 = function(node) {
      return isElement(node) && name(node) === "br";
    };
    var isTextBlock = lazyLookup(textBlocks);
    var isList = lazyLookup(lists);
    var isListItem = lazyLookup(listItems);
    var isTableSection = lazyLookup(tableSections);
    var isTableCell$1 = lazyLookup(tableCells);
    var isWsPreserveElement = lazyLookup(wsElements);
    var ancestor$2 = function(scope, selector, isRoot) {
      return ancestor$1(scope, selector, isRoot).isSome();
    };
    var zeroWidth = "\uFEFF";
    var nbsp = "\xA0";
    var isZwsp = function(char) {
      return char === zeroWidth;
    };
    var removeZwsp = function(s) {
      return s.replace(/\uFEFF/g, "");
    };
    var ZWSP = zeroWidth;
    var isZwsp$1 = isZwsp;
    var trim$2 = removeZwsp;
    var isElement$2 = isElement$1;
    var isText$2 = isText$1;
    var isCaretContainerBlock = function(node) {
      if (isText$2(node)) {
        node = node.parentNode;
      }
      return isElement$2(node) && node.hasAttribute("data-mce-caret");
    };
    var isCaretContainerInline = function(node) {
      return isText$2(node) && isZwsp$1(node.data);
    };
    var isCaretContainer = function(node) {
      return isCaretContainerBlock(node) || isCaretContainerInline(node);
    };
    var hasContent = function(node) {
      return node.firstChild !== node.lastChild || !isBr(node.firstChild);
    };
    var insertInline = function(node, before2) {
      var sibling2;
      var doc2 = node.ownerDocument;
      var textNode = doc2.createTextNode(ZWSP);
      var parentNode = node.parentNode;
      if (!before2) {
        sibling2 = node.nextSibling;
        if (isText$2(sibling2)) {
          if (isCaretContainer(sibling2)) {
            return sibling2;
          }
          if (startsWithCaretContainer(sibling2)) {
            sibling2.splitText(1);
            return sibling2;
          }
        }
        if (node.nextSibling) {
          parentNode.insertBefore(textNode, node.nextSibling);
        } else {
          parentNode.appendChild(textNode);
        }
      } else {
        sibling2 = node.previousSibling;
        if (isText$2(sibling2)) {
          if (isCaretContainer(sibling2)) {
            return sibling2;
          }
          if (endsWithCaretContainer(sibling2)) {
            return sibling2.splitText(sibling2.data.length - 1);
          }
        }
        parentNode.insertBefore(textNode, node);
      }
      return textNode;
    };
    var isBeforeInline = function(pos) {
      var container = pos.container();
      if (!isText$1(container)) {
        return false;
      }
      return container.data.charAt(pos.offset()) === ZWSP || pos.isAtStart() && isCaretContainerInline(container.previousSibling);
    };
    var isAfterInline = function(pos) {
      var container = pos.container();
      if (!isText$1(container)) {
        return false;
      }
      return container.data.charAt(pos.offset() - 1) === ZWSP || pos.isAtEnd() && isCaretContainerInline(container.nextSibling);
    };
    var createBogusBr = function() {
      var br = document.createElement("br");
      br.setAttribute("data-mce-bogus", "1");
      return br;
    };
    var insertBlock = function(blockName, node, before2) {
      var doc2 = node.ownerDocument;
      var blockNode = doc2.createElement(blockName);
      blockNode.setAttribute("data-mce-caret", before2 ? "before" : "after");
      blockNode.setAttribute("data-mce-bogus", "all");
      blockNode.appendChild(createBogusBr());
      var parentNode = node.parentNode;
      if (!before2) {
        if (node.nextSibling) {
          parentNode.insertBefore(blockNode, node.nextSibling);
        } else {
          parentNode.appendChild(blockNode);
        }
      } else {
        parentNode.insertBefore(blockNode, node);
      }
      return blockNode;
    };
    var startsWithCaretContainer = function(node) {
      return isText$2(node) && node.data[0] === ZWSP;
    };
    var endsWithCaretContainer = function(node) {
      return isText$2(node) && node.data[node.data.length - 1] === ZWSP;
    };
    var trimBogusBr = function(elm) {
      var brs = elm.getElementsByTagName("br");
      var lastBr = brs[brs.length - 1];
      if (isBogus(lastBr)) {
        lastBr.parentNode.removeChild(lastBr);
      }
    };
    var showCaretContainerBlock = function(caretContainer) {
      if (caretContainer && caretContainer.hasAttribute("data-mce-caret")) {
        trimBogusBr(caretContainer);
        caretContainer.removeAttribute("data-mce-caret");
        caretContainer.removeAttribute("data-mce-bogus");
        caretContainer.removeAttribute("style");
        caretContainer.removeAttribute("_moz_abspos");
        return caretContainer;
      }
      return null;
    };
    var isRangeInCaretContainerBlock = function(range2) {
      return isCaretContainerBlock(range2.startContainer);
    };
    var isContentEditableTrue$1 = isContentEditableTrue;
    var isContentEditableFalse$1 = isContentEditableFalse;
    var isBr$2 = isBr;
    var isText$3 = isText$1;
    var isInvalidTextElement = matchNodeNames([
      "script",
      "style",
      "textarea"
    ]);
    var isAtomicInline = matchNodeNames([
      "img",
      "input",
      "textarea",
      "hr",
      "iframe",
      "video",
      "audio",
      "object",
      "embed"
    ]);
    var isTable$2 = matchNodeNames(["table"]);
    var isCaretContainer$1 = isCaretContainer;
    var isCaretCandidate = function(node) {
      if (isCaretContainer$1(node)) {
        return false;
      }
      if (isText$3(node)) {
        return !isInvalidTextElement(node.parentNode);
      }
      return isAtomicInline(node) || isBr$2(node) || isTable$2(node) || isNonUiContentEditableFalse(node);
    };
    var isUnselectable = function(node) {
      return isElement$1(node) && node.getAttribute("unselectable") === "true";
    };
    var isNonUiContentEditableFalse = function(node) {
      return isUnselectable(node) === false && isContentEditableFalse$1(node);
    };
    var isInEditable = function(node, root) {
      for (node = node.parentNode; node && node !== root; node = node.parentNode) {
        if (isNonUiContentEditableFalse(node)) {
          return false;
        }
        if (isContentEditableTrue$1(node)) {
          return true;
        }
      }
      return true;
    };
    var isAtomicContentEditableFalse = function(node) {
      if (!isNonUiContentEditableFalse(node)) {
        return false;
      }
      return foldl(from$1(node.getElementsByTagName("*")), function(result, elm) {
        return result || isContentEditableTrue$1(elm);
      }, false) !== true;
    };
    var isAtomic = function(node) {
      return isAtomicInline(node) || isAtomicContentEditableFalse(node);
    };
    var isEditableCaretCandidate = function(node, root) {
      return isCaretCandidate(node) && isInEditable(node, root);
    };
    var whiteSpaceRegExp$1 = /^[ \t\r\n]*$/;
    var isWhitespaceText = function(text) {
      return whiteSpaceRegExp$1.test(text);
    };
    var hasWhitespacePreserveParent = function(node, rootNode) {
      var rootElement = SugarElement.fromDom(rootNode);
      var startNode = SugarElement.fromDom(node);
      return ancestor$2(startNode, "pre,code", curry(eq$2, rootElement));
    };
    var isWhitespace = function(node, rootNode) {
      return isText$1(node) && isWhitespaceText(node.data) && hasWhitespacePreserveParent(node, rootNode) === false;
    };
    var isNamedAnchor = function(node) {
      return isElement$1(node) && node.nodeName === "A" && !node.hasAttribute("href") && (node.hasAttribute("name") || node.hasAttribute("id"));
    };
    var isContent = function(node, rootNode) {
      return isCaretCandidate(node) && isWhitespace(node, rootNode) === false || isNamedAnchor(node) || isBookmark(node);
    };
    var isBookmark = hasAttribute("data-mce-bookmark");
    var isBogus$1 = hasAttribute("data-mce-bogus");
    var isBogusAll$1 = hasAttributeValue("data-mce-bogus", "all");
    var isEmptyNode = function(targetNode, skipBogus) {
      var node, brCount = 0;
      if (isContent(targetNode, targetNode)) {
        return false;
      } else {
        node = targetNode.firstChild;
        if (!node) {
          return true;
        }
        var walker = new DomTreeWalker(node, targetNode);
        do {
          if (skipBogus) {
            if (isBogusAll$1(node)) {
              node = walker.next(true);
              continue;
            }
            if (isBogus$1(node)) {
              node = walker.next();
              continue;
            }
          }
          if (isBr(node)) {
            brCount++;
            node = walker.next();
            continue;
          }
          if (isContent(node, targetNode)) {
            return false;
          }
          node = walker.next();
        } while (node);
        return brCount <= 1;
      }
    };
    var isEmpty = function(elm, skipBogus) {
      if (skipBogus === void 0) {
        skipBogus = true;
      }
      return isEmptyNode(elm.dom, skipBogus);
    };
    var isSpan = function(node) {
      return node.nodeName.toLowerCase() === "span";
    };
    var isInlineContent = function(node, root) {
      return isNonNullable(node) && (isContent(node, root) || isInline(SugarElement.fromDom(node)));
    };
    var surroundedByInlineContent = function(node, root) {
      var prev = new DomTreeWalker(node, root).prev(false);
      var next = new DomTreeWalker(node, root).next(false);
      var prevIsInline = isUndefined(prev) || isInlineContent(prev, root);
      var nextIsInline = isUndefined(next) || isInlineContent(next, root);
      return prevIsInline && nextIsInline;
    };
    var isBookmarkNode = function(node) {
      return isSpan(node) && node.getAttribute("data-mce-type") === "bookmark";
    };
    var isKeepTextNode = function(node, root) {
      return isText$1(node) && node.data.length > 0 && surroundedByInlineContent(node, root);
    };
    var isKeepElement = function(node) {
      return isElement$1(node) ? node.childNodes.length > 0 : false;
    };
    var isDocument$2 = function(node) {
      return isDocumentFragment$1(node) || isDocument$1(node);
    };
    var trimNode = function(dom2, node, root) {
      var rootNode = root || node;
      if (isElement$1(node) && isBookmarkNode(node)) {
        return node;
      }
      var children2 = node.childNodes;
      for (var i = children2.length - 1; i >= 0; i--) {
        trimNode(dom2, children2[i], rootNode);
      }
      if (isElement$1(node)) {
        var currentChildren = node.childNodes;
        if (currentChildren.length === 1 && isBookmarkNode(currentChildren[0])) {
          node.parentNode.insertBefore(currentChildren[0], node);
        }
      }
      if (!isDocument$2(node) && !isContent(node, rootNode) && !isKeepElement(node) && !isKeepTextNode(node, rootNode)) {
        dom2.remove(node);
      }
      return node;
    };
    var makeMap$1 = Tools.makeMap;
    var attrsCharsRegExp = /[&<>\"\u0060\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    var textCharsRegExp = /[<>&\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    var rawCharsRegExp = /[<>&\"\']/g;
    var entityRegExp = /&#([a-z0-9]+);?|&([a-z0-9]+);/gi;
    var asciiMap = {
      128: "\u20AC",
      130: "\u201A",
      131: "\u0192",
      132: "\u201E",
      133: "\u2026",
      134: "\u2020",
      135: "\u2021",
      136: "\u02C6",
      137: "\u2030",
      138: "\u0160",
      139: "\u2039",
      140: "\u0152",
      142: "\u017D",
      145: "\u2018",
      146: "\u2019",
      147: "\u201C",
      148: "\u201D",
      149: "\u2022",
      150: "\u2013",
      151: "\u2014",
      152: "\u02DC",
      153: "\u2122",
      154: "\u0161",
      155: "\u203A",
      156: "\u0153",
      158: "\u017E",
      159: "\u0178"
    };
    var baseEntities = {
      '"': "&quot;",
      "'": "&#39;",
      "<": "&lt;",
      ">": "&gt;",
      "&": "&amp;",
      "`": "&#96;"
    };
    var reverseEntities = {
      "&lt;": "<",
      "&gt;": ">",
      "&amp;": "&",
      "&quot;": '"',
      "&apos;": "'"
    };
    var nativeDecode = function(text) {
      var elm = SugarElement.fromTag("div").dom;
      elm.innerHTML = text;
      return elm.textContent || elm.innerText || text;
    };
    var buildEntitiesLookup = function(items, radix) {
      var i, chr, entity;
      var lookup = {};
      if (items) {
        items = items.split(",");
        radix = radix || 10;
        for (i = 0; i < items.length; i += 2) {
          chr = String.fromCharCode(parseInt(items[i], radix));
          if (!baseEntities[chr]) {
            entity = "&" + items[i + 1] + ";";
            lookup[chr] = entity;
            lookup[entity] = chr;
          }
        }
        return lookup;
      }
    };
    var namedEntities = buildEntitiesLookup("50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,t9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro", 32);
    var encodeRaw = function(text, attr) {
      return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function(chr) {
        return baseEntities[chr] || chr;
      });
    };
    var encodeAllRaw = function(text) {
      return ("" + text).replace(rawCharsRegExp, function(chr) {
        return baseEntities[chr] || chr;
      });
    };
    var encodeNumeric = function(text, attr) {
      return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function(chr) {
        if (chr.length > 1) {
          return "&#" + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + ";";
        }
        return baseEntities[chr] || "&#" + chr.charCodeAt(0) + ";";
      });
    };
    var encodeNamed = function(text, attr, entities) {
      entities = entities || namedEntities;
      return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function(chr) {
        return baseEntities[chr] || entities[chr] || chr;
      });
    };
    var getEncodeFunc = function(name2, entities) {
      var entitiesMap = buildEntitiesLookup(entities) || namedEntities;
      var encodeNamedAndNumeric = function(text, attr) {
        return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function(chr) {
          if (baseEntities[chr] !== void 0) {
            return baseEntities[chr];
          }
          if (entitiesMap[chr] !== void 0) {
            return entitiesMap[chr];
          }
          if (chr.length > 1) {
            return "&#" + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + ";";
          }
          return "&#" + chr.charCodeAt(0) + ";";
        });
      };
      var encodeCustomNamed = function(text, attr) {
        return encodeNamed(text, attr, entitiesMap);
      };
      var nameMap = makeMap$1(name2.replace(/\+/g, ","));
      if (nameMap.named && nameMap.numeric) {
        return encodeNamedAndNumeric;
      }
      if (nameMap.named) {
        if (entities) {
          return encodeCustomNamed;
        }
        return encodeNamed;
      }
      if (nameMap.numeric) {
        return encodeNumeric;
      }
      return encodeRaw;
    };
    var decode = function(text) {
      return text.replace(entityRegExp, function(all2, numeric) {
        if (numeric) {
          if (numeric.charAt(0).toLowerCase() === "x") {
            numeric = parseInt(numeric.substr(1), 16);
          } else {
            numeric = parseInt(numeric, 10);
          }
          if (numeric > 65535) {
            numeric -= 65536;
            return String.fromCharCode(55296 + (numeric >> 10), 56320 + (numeric & 1023));
          }
          return asciiMap[numeric] || String.fromCharCode(numeric);
        }
        return reverseEntities[all2] || namedEntities[all2] || nativeDecode(all2);
      });
    };
    var Entities = {
      encodeRaw,
      encodeAllRaw,
      encodeNumeric,
      encodeNamed,
      getEncodeFunc,
      decode
    };
    var mapCache = {}, dummyObj = {};
    var makeMap$2 = Tools.makeMap, each$3 = Tools.each, extend$1 = Tools.extend, explode$1 = Tools.explode, inArray = Tools.inArray;
    var split = function(items, delim) {
      items = Tools.trim(items);
      return items ? items.split(delim || " ") : [];
    };
    var compileSchema = function(type2) {
      var schema = {};
      var globalAttributes, blockContent;
      var phrasingContent, flowContent, html4BlockContent, html4PhrasingContent;
      var add2 = function(name2, attributes2, children2) {
        var ni, attributesOrder, element;
        var arrayToMap = function(array, obj) {
          var map2 = {};
          var i, l;
          for (i = 0, l = array.length; i < l; i++) {
            map2[array[i]] = obj || {};
          }
          return map2;
        };
        children2 = children2 || [];
        attributes2 = attributes2 || "";
        if (typeof children2 === "string") {
          children2 = split(children2);
        }
        var names = split(name2);
        ni = names.length;
        while (ni--) {
          attributesOrder = split([
            globalAttributes,
            attributes2
          ].join(" "));
          element = {
            attributes: arrayToMap(attributesOrder),
            attributesOrder,
            children: arrayToMap(children2, dummyObj)
          };
          schema[names[ni]] = element;
        }
      };
      var addAttrs = function(name2, attributes2) {
        var ni, schemaItem, i, l;
        var names = split(name2);
        ni = names.length;
        var attrs = split(attributes2);
        while (ni--) {
          schemaItem = schema[names[ni]];
          for (i = 0, l = attrs.length; i < l; i++) {
            schemaItem.attributes[attrs[i]] = {};
            schemaItem.attributesOrder.push(attrs[i]);
          }
        }
      };
      if (mapCache[type2]) {
        return mapCache[type2];
      }
      globalAttributes = "id accesskey class dir lang style tabindex title role";
      blockContent = "address blockquote div dl fieldset form h1 h2 h3 h4 h5 h6 hr menu ol p pre table ul";
      phrasingContent = "a abbr b bdo br button cite code del dfn em embed i iframe img input ins kbd label map noscript object q s samp script select small span strong sub sup textarea u var #text #comment";
      if (type2 !== "html4") {
        globalAttributes += " contenteditable contextmenu draggable dropzone hidden spellcheck translate";
        blockContent += " article aside details dialog figure main header footer hgroup section nav";
        phrasingContent += " audio canvas command datalist mark meter output picture progress time wbr video ruby bdi keygen";
      }
      if (type2 !== "html5-strict") {
        globalAttributes += " xml:lang";
        html4PhrasingContent = "acronym applet basefont big font strike tt";
        phrasingContent = [
          phrasingContent,
          html4PhrasingContent
        ].join(" ");
        each$3(split(html4PhrasingContent), function(name2) {
          add2(name2, "", phrasingContent);
        });
        html4BlockContent = "center dir isindex noframes";
        blockContent = [
          blockContent,
          html4BlockContent
        ].join(" ");
        flowContent = [
          blockContent,
          phrasingContent
        ].join(" ");
        each$3(split(html4BlockContent), function(name2) {
          add2(name2, "", flowContent);
        });
      }
      flowContent = flowContent || [
        blockContent,
        phrasingContent
      ].join(" ");
      add2("html", "manifest", "head body");
      add2("head", "", "base command link meta noscript script style title");
      add2("title hr noscript br");
      add2("base", "href target");
      add2("link", "href rel media hreflang type sizes hreflang");
      add2("meta", "name http-equiv content charset");
      add2("style", "media type scoped");
      add2("script", "src async defer type charset");
      add2("body", "onafterprint onbeforeprint onbeforeunload onblur onerror onfocus onhashchange onload onmessage onoffline ononline onpagehide onpageshow onpopstate onresize onscroll onstorage onunload", flowContent);
      add2("address dt dd div caption", "", flowContent);
      add2("h1 h2 h3 h4 h5 h6 pre p abbr code var samp kbd sub sup i b u bdo span legend em strong small s cite dfn", "", phrasingContent);
      add2("blockquote", "cite", flowContent);
      add2("ol", "reversed start type", "li");
      add2("ul", "", "li");
      add2("li", "value", flowContent);
      add2("dl", "", "dt dd");
      add2("a", "href target rel media hreflang type", phrasingContent);
      add2("q", "cite", phrasingContent);
      add2("ins del", "cite datetime", flowContent);
      add2("img", "src sizes srcset alt usemap ismap width height");
      add2("iframe", "src name width height", flowContent);
      add2("embed", "src type width height");
      add2("object", "data type typemustmatch name usemap form width height", [
        flowContent,
        "param"
      ].join(" "));
      add2("param", "name value");
      add2("map", "name", [
        flowContent,
        "area"
      ].join(" "));
      add2("area", "alt coords shape href target rel media hreflang type");
      add2("table", "border", "caption colgroup thead tfoot tbody tr" + (type2 === "html4" ? " col" : ""));
      add2("colgroup", "span", "col");
      add2("col", "span");
      add2("tbody thead tfoot", "", "tr");
      add2("tr", "", "td th");
      add2("td", "colspan rowspan headers", flowContent);
      add2("th", "colspan rowspan headers scope abbr", flowContent);
      add2("form", "accept-charset action autocomplete enctype method name novalidate target", flowContent);
      add2("fieldset", "disabled form name", [
        flowContent,
        "legend"
      ].join(" "));
      add2("label", "form for", phrasingContent);
      add2("input", "accept alt autocomplete checked dirname disabled form formaction formenctype formmethod formnovalidate formtarget height list max maxlength min multiple name pattern readonly required size src step type value width");
      add2("button", "disabled form formaction formenctype formmethod formnovalidate formtarget name type value", type2 === "html4" ? flowContent : phrasingContent);
      add2("select", "disabled form multiple name required size", "option optgroup");
      add2("optgroup", "disabled label", "option");
      add2("option", "disabled label selected value");
      add2("textarea", "cols dirname disabled form maxlength name readonly required rows wrap");
      add2("menu", "type label", [
        flowContent,
        "li"
      ].join(" "));
      add2("noscript", "", flowContent);
      if (type2 !== "html4") {
        add2("wbr");
        add2("ruby", "", [
          phrasingContent,
          "rt rp"
        ].join(" "));
        add2("figcaption", "", flowContent);
        add2("mark rt rp summary bdi", "", phrasingContent);
        add2("canvas", "width height", flowContent);
        add2("video", "src crossorigin poster preload autoplay mediagroup loop muted controls width height buffered", [
          flowContent,
          "track source"
        ].join(" "));
        add2("audio", "src crossorigin preload autoplay mediagroup loop muted controls buffered volume", [
          flowContent,
          "track source"
        ].join(" "));
        add2("picture", "", "img source");
        add2("source", "src srcset type media sizes");
        add2("track", "kind src srclang label default");
        add2("datalist", "", [
          phrasingContent,
          "option"
        ].join(" "));
        add2("article section nav aside main header footer", "", flowContent);
        add2("hgroup", "", "h1 h2 h3 h4 h5 h6");
        add2("figure", "", [
          flowContent,
          "figcaption"
        ].join(" "));
        add2("time", "datetime", phrasingContent);
        add2("dialog", "open", flowContent);
        add2("command", "type label icon disabled checked radiogroup command");
        add2("output", "for form name", phrasingContent);
        add2("progress", "value max", phrasingContent);
        add2("meter", "value min max low high optimum", phrasingContent);
        add2("details", "open", [
          flowContent,
          "summary"
        ].join(" "));
        add2("keygen", "autofocus challenge disabled form keytype name");
      }
      if (type2 !== "html5-strict") {
        addAttrs("script", "language xml:space");
        addAttrs("style", "xml:space");
        addAttrs("object", "declare classid code codebase codetype archive standby align border hspace vspace");
        addAttrs("embed", "align name hspace vspace");
        addAttrs("param", "valuetype type");
        addAttrs("a", "charset name rev shape coords");
        addAttrs("br", "clear");
        addAttrs("applet", "codebase archive code object alt name width height align hspace vspace");
        addAttrs("img", "name longdesc align border hspace vspace");
        addAttrs("iframe", "longdesc frameborder marginwidth marginheight scrolling align");
        addAttrs("font basefont", "size color face");
        addAttrs("input", "usemap align");
        addAttrs("select");
        addAttrs("textarea");
        addAttrs("h1 h2 h3 h4 h5 h6 div p legend caption", "align");
        addAttrs("ul", "type compact");
        addAttrs("li", "type");
        addAttrs("ol dl menu dir", "compact");
        addAttrs("pre", "width xml:space");
        addAttrs("hr", "align noshade size width");
        addAttrs("isindex", "prompt");
        addAttrs("table", "summary width frame rules cellspacing cellpadding align bgcolor");
        addAttrs("col", "width align char charoff valign");
        addAttrs("colgroup", "width align char charoff valign");
        addAttrs("thead", "align char charoff valign");
        addAttrs("tr", "align char charoff valign bgcolor");
        addAttrs("th", "axis align char charoff valign nowrap bgcolor width height");
        addAttrs("form", "accept");
        addAttrs("td", "abbr axis scope align char charoff valign nowrap bgcolor width height");
        addAttrs("tfoot", "align char charoff valign");
        addAttrs("tbody", "align char charoff valign");
        addAttrs("area", "nohref");
        addAttrs("body", "background bgcolor text link vlink alink");
      }
      if (type2 !== "html4") {
        addAttrs("input button select textarea", "autofocus");
        addAttrs("input textarea", "placeholder");
        addAttrs("a", "download");
        addAttrs("link script img", "crossorigin");
        addAttrs("img", "loading");
        addAttrs("iframe", "sandbox seamless allowfullscreen loading");
      }
      each$3(split("a form meter progress dfn"), function(name2) {
        if (schema[name2]) {
          delete schema[name2].children[name2];
        }
      });
      delete schema.caption.children.table;
      delete schema.script;
      mapCache[type2] = schema;
      return schema;
    };
    var compileElementMap = function(value2, mode) {
      var styles;
      if (value2) {
        styles = {};
        if (typeof value2 === "string") {
          value2 = { "*": value2 };
        }
        each$3(value2, function(value3, key) {
          styles[key] = styles[key.toUpperCase()] = mode === "map" ? makeMap$2(value3, /[, ]/) : explode$1(value3, /[, ]/);
        });
      }
      return styles;
    };
    var Schema = function(settings) {
      var elements = {};
      var children2 = {};
      var patternElements = [];
      var customElementsMap = {}, specialElements = {};
      var createLookupTable = function(option, defaultValue, extendWith) {
        var value2 = settings[option];
        if (!value2) {
          value2 = mapCache[option];
          if (!value2) {
            value2 = makeMap$2(defaultValue, " ", makeMap$2(defaultValue.toUpperCase(), " "));
            value2 = extend$1(value2, extendWith);
            mapCache[option] = value2;
          }
        } else {
          value2 = makeMap$2(value2, /[, ]/, makeMap$2(value2.toUpperCase(), /[, ]/));
        }
        return value2;
      };
      settings = settings || {};
      var schemaItems = compileSchema(settings.schema);
      if (settings.verify_html === false) {
        settings.valid_elements = "*[*]";
      }
      var validStyles = compileElementMap(settings.valid_styles);
      var invalidStyles = compileElementMap(settings.invalid_styles, "map");
      var validClasses = compileElementMap(settings.valid_classes, "map");
      var whiteSpaceElementsMap = createLookupTable("whitespace_elements", "pre script noscript style textarea video audio iframe object code");
      var selfClosingElementsMap = createLookupTable("self_closing_elements", "colgroup dd dt li option p td tfoot th thead tr");
      var shortEndedElementsMap = createLookupTable("short_ended_elements", "area base basefont br col frame hr img input isindex link meta param embed source wbr track");
      var boolAttrMap = createLookupTable("boolean_attributes", "checked compact declare defer disabled ismap multiple nohref noresize noshade nowrap readonly selected autoplay loop controls");
      var nonEmptyOrMoveCaretBeforeOnEnter = "td th iframe video audio object script code";
      var nonEmptyElementsMap = createLookupTable("non_empty_elements", nonEmptyOrMoveCaretBeforeOnEnter + " pre", shortEndedElementsMap);
      var moveCaretBeforeOnEnterElementsMap = createLookupTable("move_caret_before_on_enter_elements", nonEmptyOrMoveCaretBeforeOnEnter + " table", shortEndedElementsMap);
      var textBlockElementsMap = createLookupTable("text_block_elements", "h1 h2 h3 h4 h5 h6 p div address pre form blockquote center dir fieldset header footer article section hgroup aside main nav figure");
      var blockElementsMap = createLookupTable("block_elements", "hr table tbody thead tfoot th tr td li ol ul caption dl dt dd noscript menu isindex option datalist select optgroup figcaption details summary", textBlockElementsMap);
      var textInlineElementsMap = createLookupTable("text_inline_elements", "span strong b em i font strike u var cite dfn code mark q sup sub samp");
      each$3((settings.special || "script noscript iframe noframes noembed title style textarea xmp").split(" "), function(name2) {
        specialElements[name2] = new RegExp("</" + name2 + "[^>]*>", "gi");
      });
      var patternToRegExp = function(str) {
        return new RegExp("^" + str.replace(/([?+*])/g, ".$1") + "$");
      };
      var addValidElements = function(validElements) {
        var ei, el, ai, al, matches2, element, attr, attrData, elementName, attrName, attrType, attributes2, attributesOrder, prefix, outputName, globalAttributes, globalAttributesOrder, value2;
        var elementRuleRegExp = /^([#+\-])?([^\[!\/]+)(?:\/([^\[!]+))?(?:(!?)\[([^\]]+)])?$/, attrRuleRegExp = /^([!\-])?(\w+[\\:]:\w+|[^=:<]+)?(?:([=:<])(.*))?$/, hasPatternsRegExp = /[*?+]/;
        if (validElements) {
          var validElementsArr = split(validElements, ",");
          if (elements["@"]) {
            globalAttributes = elements["@"].attributes;
            globalAttributesOrder = elements["@"].attributesOrder;
          }
          for (ei = 0, el = validElementsArr.length; ei < el; ei++) {
            matches2 = elementRuleRegExp.exec(validElementsArr[ei]);
            if (matches2) {
              prefix = matches2[1];
              elementName = matches2[2];
              outputName = matches2[3];
              attrData = matches2[5];
              attributes2 = {};
              attributesOrder = [];
              element = {
                attributes: attributes2,
                attributesOrder
              };
              if (prefix === "#") {
                element.paddEmpty = true;
              }
              if (prefix === "-") {
                element.removeEmpty = true;
              }
              if (matches2[4] === "!") {
                element.removeEmptyAttrs = true;
              }
              if (globalAttributes) {
                each$1(globalAttributes, function(value3, key) {
                  attributes2[key] = value3;
                });
                attributesOrder.push.apply(attributesOrder, globalAttributesOrder);
              }
              if (attrData) {
                attrData = split(attrData, "|");
                for (ai = 0, al = attrData.length; ai < al; ai++) {
                  matches2 = attrRuleRegExp.exec(attrData[ai]);
                  if (matches2) {
                    attr = {};
                    attrType = matches2[1];
                    attrName = matches2[2].replace(/[\\:]:/g, ":");
                    prefix = matches2[3];
                    value2 = matches2[4];
                    if (attrType === "!") {
                      element.attributesRequired = element.attributesRequired || [];
                      element.attributesRequired.push(attrName);
                      attr.required = true;
                    }
                    if (attrType === "-") {
                      delete attributes2[attrName];
                      attributesOrder.splice(inArray(attributesOrder, attrName), 1);
                      continue;
                    }
                    if (prefix) {
                      if (prefix === "=") {
                        element.attributesDefault = element.attributesDefault || [];
                        element.attributesDefault.push({
                          name: attrName,
                          value: value2
                        });
                        attr.defaultValue = value2;
                      }
                      if (prefix === ":") {
                        element.attributesForced = element.attributesForced || [];
                        element.attributesForced.push({
                          name: attrName,
                          value: value2
                        });
                        attr.forcedValue = value2;
                      }
                      if (prefix === "<") {
                        attr.validValues = makeMap$2(value2, "?");
                      }
                    }
                    if (hasPatternsRegExp.test(attrName)) {
                      element.attributePatterns = element.attributePatterns || [];
                      attr.pattern = patternToRegExp(attrName);
                      element.attributePatterns.push(attr);
                    } else {
                      if (!attributes2[attrName]) {
                        attributesOrder.push(attrName);
                      }
                      attributes2[attrName] = attr;
                    }
                  }
                }
              }
              if (!globalAttributes && elementName === "@") {
                globalAttributes = attributes2;
                globalAttributesOrder = attributesOrder;
              }
              if (outputName) {
                element.outputName = elementName;
                elements[outputName] = element;
              }
              if (hasPatternsRegExp.test(elementName)) {
                element.pattern = patternToRegExp(elementName);
                patternElements.push(element);
              } else {
                elements[elementName] = element;
              }
            }
          }
        }
      };
      var setValidElements = function(validElements) {
        elements = {};
        patternElements = [];
        addValidElements(validElements);
        each$3(schemaItems, function(element, name2) {
          children2[name2] = element.children;
        });
      };
      var addCustomElements = function(customElements) {
        var customElementRegExp = /^(~)?(.+)$/;
        if (customElements) {
          mapCache.text_block_elements = mapCache.block_elements = null;
          each$3(split(customElements, ","), function(rule) {
            var matches2 = customElementRegExp.exec(rule), inline = matches2[1] === "~", cloneName = inline ? "span" : "div", name2 = matches2[2];
            children2[name2] = children2[cloneName];
            customElementsMap[name2] = cloneName;
            if (!inline) {
              blockElementsMap[name2.toUpperCase()] = {};
              blockElementsMap[name2] = {};
            }
            if (!elements[name2]) {
              var customRule = elements[cloneName];
              customRule = extend$1({}, customRule);
              delete customRule.removeEmptyAttrs;
              delete customRule.removeEmpty;
              elements[name2] = customRule;
            }
            each$3(children2, function(element, elmName) {
              if (element[cloneName]) {
                children2[elmName] = element = extend$1({}, children2[elmName]);
                element[name2] = element[cloneName];
              }
            });
          });
        }
      };
      var addValidChildren = function(validChildren) {
        var childRuleRegExp = /^([+\-]?)([A-Za-z0-9_\-.\u00b7\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u037d\u037f-\u1fff\u200c-\u200d\u203f-\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]+)\[([^\]]+)]$/;
        mapCache[settings.schema] = null;
        if (validChildren) {
          each$3(split(validChildren, ","), function(rule) {
            var matches2 = childRuleRegExp.exec(rule);
            var parent2, prefix;
            if (matches2) {
              prefix = matches2[1];
              if (prefix) {
                parent2 = children2[matches2[2]];
              } else {
                parent2 = children2[matches2[2]] = { "#comment": {} };
              }
              parent2 = children2[matches2[2]];
              each$3(split(matches2[3], "|"), function(child2) {
                if (prefix === "-") {
                  delete parent2[child2];
                } else {
                  parent2[child2] = {};
                }
              });
            }
          });
        }
      };
      var getElementRule = function(name2) {
        var element = elements[name2], i;
        if (element) {
          return element;
        }
        i = patternElements.length;
        while (i--) {
          element = patternElements[i];
          if (element.pattern.test(name2)) {
            return element;
          }
        }
      };
      if (!settings.valid_elements) {
        each$3(schemaItems, function(element, name2) {
          elements[name2] = {
            attributes: element.attributes,
            attributesOrder: element.attributesOrder
          };
          children2[name2] = element.children;
        });
        if (settings.schema !== "html5") {
          each$3(split("strong/b em/i"), function(item) {
            var items = split(item, "/");
            elements[items[1]].outputName = items[0];
          });
        }
        each$3(split("ol ul sub sup blockquote span font a table tbody strong em b i"), function(name2) {
          if (elements[name2]) {
            elements[name2].removeEmpty = true;
          }
        });
        each$3(split("p h1 h2 h3 h4 h5 h6 th td pre div address caption li"), function(name2) {
          elements[name2].paddEmpty = true;
        });
        each$3(split("span"), function(name2) {
          elements[name2].removeEmptyAttrs = true;
        });
      } else {
        setValidElements(settings.valid_elements);
      }
      addCustomElements(settings.custom_elements);
      addValidChildren(settings.valid_children);
      addValidElements(settings.extended_valid_elements);
      addValidChildren("+ol[ul|ol],+ul[ul|ol]");
      each$3({
        dd: "dl",
        dt: "dl",
        li: "ul ol",
        td: "tr",
        th: "tr",
        tr: "tbody thead tfoot",
        tbody: "table",
        thead: "table",
        tfoot: "table",
        legend: "fieldset",
        area: "map",
        param: "video audio object"
      }, function(parents2, item) {
        if (elements[item]) {
          elements[item].parentsRequired = split(parents2);
        }
      });
      if (settings.invalid_elements) {
        each$3(explode$1(settings.invalid_elements), function(item) {
          if (elements[item]) {
            delete elements[item];
          }
        });
      }
      if (!getElementRule("span")) {
        addValidElements("span[!data-mce-type|*]");
      }
      var getValidStyles = function() {
        return validStyles;
      };
      var getInvalidStyles = function() {
        return invalidStyles;
      };
      var getValidClasses = function() {
        return validClasses;
      };
      var getBoolAttrs = function() {
        return boolAttrMap;
      };
      var getBlockElements = function() {
        return blockElementsMap;
      };
      var getTextBlockElements = function() {
        return textBlockElementsMap;
      };
      var getTextInlineElements = function() {
        return textInlineElementsMap;
      };
      var getShortEndedElements = function() {
        return shortEndedElementsMap;
      };
      var getSelfClosingElements = function() {
        return selfClosingElementsMap;
      };
      var getNonEmptyElements = function() {
        return nonEmptyElementsMap;
      };
      var getMoveCaretBeforeOnEnterElements = function() {
        return moveCaretBeforeOnEnterElementsMap;
      };
      var getWhiteSpaceElements = function() {
        return whiteSpaceElementsMap;
      };
      var getSpecialElements = function() {
        return specialElements;
      };
      var isValidChild = function(name2, child2) {
        var parent2 = children2[name2.toLowerCase()];
        return !!(parent2 && parent2[child2.toLowerCase()]);
      };
      var isValid2 = function(name2, attr) {
        var attrPatterns, i;
        var rule = getElementRule(name2);
        if (rule) {
          if (attr) {
            if (rule.attributes[attr]) {
              return true;
            }
            attrPatterns = rule.attributePatterns;
            if (attrPatterns) {
              i = attrPatterns.length;
              while (i--) {
                if (attrPatterns[i].pattern.test(name2)) {
                  return true;
                }
              }
            }
          } else {
            return true;
          }
        }
        return false;
      };
      var getCustomElements = function() {
        return customElementsMap;
      };
      return {
        children: children2,
        elements,
        getValidStyles,
        getValidClasses,
        getBlockElements,
        getInvalidStyles,
        getShortEndedElements,
        getTextBlockElements,
        getTextInlineElements,
        getBoolAttrs,
        getElementRule,
        getSelfClosingElements,
        getNonEmptyElements,
        getMoveCaretBeforeOnEnterElements,
        getWhiteSpaceElements,
        getSpecialElements,
        isValidChild,
        isValid: isValid2,
        getCustomElements,
        addValidElements,
        setValidElements,
        addCustomElements,
        addValidChildren
      };
    };
    var toHex = function(match2, r2, g, b) {
      var hex = function(val) {
        val = parseInt(val, 10).toString(16);
        return val.length > 1 ? val : "0" + val;
      };
      return "#" + hex(r2) + hex(g) + hex(b);
    };
    var Styles = function(settings, schema) {
      var _this = this;
      var rgbRegExp = /rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)/gi;
      var urlOrStrRegExp = /(?:url(?:(?:\(\s*\"([^\"]+)\"\s*\))|(?:\(\s*\'([^\']+)\'\s*\))|(?:\(\s*([^)\s]+)\s*\))))|(?:\'([^\']+)\')|(?:\"([^\"]+)\")/gi;
      var styleRegExp = /\s*([^:]+):\s*([^;]+);?/g;
      var trimRightRegExp = /\s+$/;
      var i;
      var encodingLookup = {};
      var validStyles;
      var invalidStyles;
      var invisibleChar = zeroWidth;
      settings = settings || {};
      if (schema) {
        validStyles = schema.getValidStyles();
        invalidStyles = schema.getInvalidStyles();
      }
      var encodingItems = (`\\" \\' \\; \\: ; : ` + invisibleChar).split(" ");
      for (i = 0; i < encodingItems.length; i++) {
        encodingLookup[encodingItems[i]] = invisibleChar + i;
        encodingLookup[invisibleChar + i] = encodingItems[i];
      }
      return {
        toHex: function(color) {
          return color.replace(rgbRegExp, toHex);
        },
        parse: function(css) {
          var styles = {};
          var matches2, name2, value2, isEncoded;
          var urlConverter = settings.url_converter;
          var urlConverterScope = settings.url_converter_scope || _this;
          var compress = function(prefix, suffix, noJoin) {
            var top = styles[prefix + "-top" + suffix];
            if (!top) {
              return;
            }
            var right = styles[prefix + "-right" + suffix];
            if (!right) {
              return;
            }
            var bottom = styles[prefix + "-bottom" + suffix];
            if (!bottom) {
              return;
            }
            var left = styles[prefix + "-left" + suffix];
            if (!left) {
              return;
            }
            var box = [
              top,
              right,
              bottom,
              left
            ];
            i = box.length - 1;
            while (i--) {
              if (box[i] !== box[i + 1]) {
                break;
              }
            }
            if (i > -1 && noJoin) {
              return;
            }
            styles[prefix + suffix] = i === -1 ? box[0] : box.join(" ");
            delete styles[prefix + "-top" + suffix];
            delete styles[prefix + "-right" + suffix];
            delete styles[prefix + "-bottom" + suffix];
            delete styles[prefix + "-left" + suffix];
          };
          var canCompress = function(key) {
            var value3 = styles[key], i2;
            if (!value3) {
              return;
            }
            value3 = value3.split(" ");
            i2 = value3.length;
            while (i2--) {
              if (value3[i2] !== value3[0]) {
                return false;
              }
            }
            styles[key] = value3[0];
            return true;
          };
          var compress2 = function(target, a, b, c) {
            if (!canCompress(a)) {
              return;
            }
            if (!canCompress(b)) {
              return;
            }
            if (!canCompress(c)) {
              return;
            }
            styles[target] = styles[a] + " " + styles[b] + " " + styles[c];
            delete styles[a];
            delete styles[b];
            delete styles[c];
          };
          var encode = function(str) {
            isEncoded = true;
            return encodingLookup[str];
          };
          var decode2 = function(str, keepSlashes) {
            if (isEncoded) {
              str = str.replace(/\uFEFF[0-9]/g, function(str2) {
                return encodingLookup[str2];
              });
            }
            if (!keepSlashes) {
              str = str.replace(/\\([\'\";:])/g, "$1");
            }
            return str;
          };
          var decodeSingleHexSequence = function(escSeq) {
            return String.fromCharCode(parseInt(escSeq.slice(1), 16));
          };
          var decodeHexSequences = function(value3) {
            return value3.replace(/\\[0-9a-f]+/gi, decodeSingleHexSequence);
          };
          var processUrl = function(match2, url, url2, url3, str, str2) {
            str = str || str2;
            if (str) {
              str = decode2(str);
              return "'" + str.replace(/\'/g, "\\'") + "'";
            }
            url = decode2(url || url2 || url3);
            if (!settings.allow_script_urls) {
              var scriptUrl = url.replace(/[\s\r\n]+/g, "");
              if (/(java|vb)script:/i.test(scriptUrl)) {
                return "";
              }
              if (!settings.allow_svg_data_urls && /^data:image\/svg/i.test(scriptUrl)) {
                return "";
              }
            }
            if (urlConverter) {
              url = urlConverter.call(urlConverterScope, url, "style");
            }
            return "url('" + url.replace(/\'/g, "\\'") + "')";
          };
          if (css) {
            css = css.replace(/[\u0000-\u001F]/g, "");
            css = css.replace(/\\[\"\';:\uFEFF]/g, encode).replace(/\"[^\"]+\"|\'[^\']+\'/g, function(str) {
              return str.replace(/[;:]/g, encode);
            });
            while (matches2 = styleRegExp.exec(css)) {
              styleRegExp.lastIndex = matches2.index + matches2[0].length;
              name2 = matches2[1].replace(trimRightRegExp, "").toLowerCase();
              value2 = matches2[2].replace(trimRightRegExp, "");
              if (name2 && value2) {
                name2 = decodeHexSequences(name2);
                value2 = decodeHexSequences(value2);
                if (name2.indexOf(invisibleChar) !== -1 || name2.indexOf('"') !== -1) {
                  continue;
                }
                if (!settings.allow_script_urls && (name2 === "behavior" || /expression\s*\(|\/\*|\*\//.test(value2))) {
                  continue;
                }
                if (name2 === "font-weight" && value2 === "700") {
                  value2 = "bold";
                } else if (name2 === "color" || name2 === "background-color") {
                  value2 = value2.toLowerCase();
                }
                value2 = value2.replace(rgbRegExp, toHex);
                value2 = value2.replace(urlOrStrRegExp, processUrl);
                styles[name2] = isEncoded ? decode2(value2, true) : value2;
              }
            }
            compress("border", "", true);
            compress("border", "-width");
            compress("border", "-color");
            compress("border", "-style");
            compress("padding", "");
            compress("margin", "");
            compress2("border", "border-width", "border-style", "border-color");
            if (styles.border === "medium none") {
              delete styles.border;
            }
            if (styles["border-image"] === "none") {
              delete styles["border-image"];
            }
          }
          return styles;
        },
        serialize: function(styles, elementName) {
          var css = "";
          var serializeStyles = function(name2) {
            var value2;
            var styleList = validStyles[name2];
            if (styleList) {
              for (var i_1 = 0, l = styleList.length; i_1 < l; i_1++) {
                name2 = styleList[i_1];
                value2 = styles[name2];
                if (value2) {
                  css += (css.length > 0 ? " " : "") + name2 + ": " + value2 + ";";
                }
              }
            }
          };
          var isValid2 = function(name2, elementName2) {
            var styleMap = invalidStyles["*"];
            if (styleMap && styleMap[name2]) {
              return false;
            }
            styleMap = invalidStyles[elementName2];
            return !(styleMap && styleMap[name2]);
          };
          if (elementName && validStyles) {
            serializeStyles("*");
            serializeStyles(elementName);
          } else {
            each$1(styles, function(value2, name2) {
              if (value2 && (!invalidStyles || isValid2(name2, elementName))) {
                css += (css.length > 0 ? " " : "") + name2 + ": " + value2 + ";";
              }
            });
          }
          return css;
        }
      };
    };
    var eventExpandoPrefix = "mce-data-";
    var mouseEventRe = /^(?:mouse|contextmenu)|click/;
    var deprecated = {
      keyLocation: 1,
      layerX: 1,
      layerY: 1,
      returnValue: 1,
      webkitMovementX: 1,
      webkitMovementY: 1,
      keyIdentifier: 1,
      mozPressure: 1
    };
    var hasIsDefaultPrevented = function(event) {
      return event.isDefaultPrevented === returnTrue || event.isDefaultPrevented === returnFalse;
    };
    var returnFalse = never;
    var returnTrue = always;
    var addEvent = function(target, name2, callback, capture) {
      if (target.addEventListener) {
        target.addEventListener(name2, callback, capture || false);
      } else if (target.attachEvent) {
        target.attachEvent("on" + name2, callback);
      }
    };
    var removeEvent = function(target, name2, callback, capture) {
      if (target.removeEventListener) {
        target.removeEventListener(name2, callback, capture || false);
      } else if (target.detachEvent) {
        target.detachEvent("on" + name2, callback);
      }
    };
    var isMouseEvent = function(event) {
      return mouseEventRe.test(event.type);
    };
    var fix = function(originalEvent, data2) {
      var name2;
      var event = data2 || {};
      for (name2 in originalEvent) {
        if (!deprecated[name2]) {
          event[name2] = originalEvent[name2];
        }
      }
      if (!event.target) {
        event.target = event.srcElement || document;
      }
      if (event.composedPath) {
        event.composedPath = function() {
          return originalEvent.composedPath();
        };
      }
      if (originalEvent && isMouseEvent(originalEvent) && originalEvent.pageX === void 0 && originalEvent.clientX !== void 0) {
        var eventDoc = event.target.ownerDocument || document;
        var doc2 = eventDoc.documentElement;
        var body = eventDoc.body;
        event.pageX = originalEvent.clientX + (doc2 && doc2.scrollLeft || body && body.scrollLeft || 0) - (doc2 && doc2.clientLeft || body && body.clientLeft || 0);
        event.pageY = originalEvent.clientY + (doc2 && doc2.scrollTop || body && body.scrollTop || 0) - (doc2 && doc2.clientTop || body && body.clientTop || 0);
      }
      event.preventDefault = function() {
        event.defaultPrevented = true;
        event.isDefaultPrevented = returnTrue;
        if (originalEvent) {
          if (originalEvent.preventDefault) {
            originalEvent.preventDefault();
          } else {
            originalEvent.returnValue = false;
          }
        }
      };
      event.stopPropagation = function() {
        event.cancelBubble = true;
        event.isPropagationStopped = returnTrue;
        if (originalEvent) {
          if (originalEvent.stopPropagation) {
            originalEvent.stopPropagation();
          } else {
            originalEvent.cancelBubble = true;
          }
        }
      };
      event.stopImmediatePropagation = function() {
        event.isImmediatePropagationStopped = returnTrue;
        event.stopPropagation();
      };
      if (hasIsDefaultPrevented(event) === false) {
        event.isDefaultPrevented = event.defaultPrevented === true ? returnTrue : returnFalse;
        event.isPropagationStopped = event.cancelBubble === true ? returnTrue : returnFalse;
        event.isImmediatePropagationStopped = returnFalse;
      }
      if (typeof event.metaKey === "undefined") {
        event.metaKey = false;
      }
      return event;
    };
    var bindOnReady = function(win, callback, eventUtils) {
      var doc2 = win.document, event = { type: "ready" };
      if (eventUtils.domLoaded) {
        callback(event);
        return;
      }
      var isDocReady = function() {
        return doc2.readyState === "complete" || doc2.readyState === "interactive" && doc2.body;
      };
      var readyHandler = function() {
        removeEvent(win, "DOMContentLoaded", readyHandler);
        removeEvent(win, "load", readyHandler);
        if (!eventUtils.domLoaded) {
          eventUtils.domLoaded = true;
          callback(event);
        }
        win = null;
      };
      if (isDocReady()) {
        readyHandler();
      } else {
        addEvent(win, "DOMContentLoaded", readyHandler);
      }
      if (!eventUtils.domLoaded) {
        addEvent(win, "load", readyHandler);
      }
    };
    var EventUtils = function() {
      function EventUtils2() {
        this.domLoaded = false;
        this.events = {};
        this.count = 1;
        this.expando = eventExpandoPrefix + (+new Date()).toString(32);
        this.hasMouseEnterLeave = "onmouseenter" in document.documentElement;
        this.hasFocusIn = "onfocusin" in document.documentElement;
        this.count = 1;
      }
      EventUtils2.prototype.bind = function(target, names, callback, scope) {
        var self2 = this;
        var id, callbackList, i, name2, fakeName, nativeHandler, capture;
        var win = window;
        var defaultNativeHandler = function(evt) {
          self2.executeHandlers(fix(evt || win.event), id);
        };
        if (!target || target.nodeType === 3 || target.nodeType === 8) {
          return;
        }
        if (!target[self2.expando]) {
          id = self2.count++;
          target[self2.expando] = id;
          self2.events[id] = {};
        } else {
          id = target[self2.expando];
        }
        scope = scope || target;
        var namesList = names.split(" ");
        i = namesList.length;
        while (i--) {
          name2 = namesList[i];
          nativeHandler = defaultNativeHandler;
          fakeName = capture = false;
          if (name2 === "DOMContentLoaded") {
            name2 = "ready";
          }
          if (self2.domLoaded && name2 === "ready" && target.readyState === "complete") {
            callback.call(scope, fix({ type: name2 }));
            continue;
          }
          if (!self2.hasMouseEnterLeave) {
            fakeName = self2.mouseEnterLeave[name2];
            if (fakeName) {
              nativeHandler = function(evt) {
                var current = evt.currentTarget;
                var related = evt.relatedTarget;
                if (related && current.contains) {
                  related = current.contains(related);
                } else {
                  while (related && related !== current) {
                    related = related.parentNode;
                  }
                }
                if (!related) {
                  evt = fix(evt || win.event);
                  evt.type = evt.type === "mouseout" ? "mouseleave" : "mouseenter";
                  evt.target = current;
                  self2.executeHandlers(evt, id);
                }
              };
            }
          }
          if (!self2.hasFocusIn && (name2 === "focusin" || name2 === "focusout")) {
            capture = true;
            fakeName = name2 === "focusin" ? "focus" : "blur";
            nativeHandler = function(evt) {
              evt = fix(evt || win.event);
              evt.type = evt.type === "focus" ? "focusin" : "focusout";
              self2.executeHandlers(evt, id);
            };
          }
          callbackList = self2.events[id][name2];
          if (!callbackList) {
            self2.events[id][name2] = callbackList = [{
              func: callback,
              scope
            }];
            callbackList.fakeName = fakeName;
            callbackList.capture = capture;
            callbackList.nativeHandler = nativeHandler;
            if (name2 === "ready") {
              bindOnReady(target, nativeHandler, self2);
            } else {
              addEvent(target, fakeName || name2, nativeHandler, capture);
            }
          } else {
            if (name2 === "ready" && self2.domLoaded) {
              callback(fix({ type: name2 }));
            } else {
              callbackList.push({
                func: callback,
                scope
              });
            }
          }
        }
        target = callbackList = null;
        return callback;
      };
      EventUtils2.prototype.unbind = function(target, names, callback) {
        var callbackList, i, ci, name2, eventMap;
        if (!target || target.nodeType === 3 || target.nodeType === 8) {
          return this;
        }
        var id = target[this.expando];
        if (id) {
          eventMap = this.events[id];
          if (names) {
            var namesList = names.split(" ");
            i = namesList.length;
            while (i--) {
              name2 = namesList[i];
              callbackList = eventMap[name2];
              if (callbackList) {
                if (callback) {
                  ci = callbackList.length;
                  while (ci--) {
                    if (callbackList[ci].func === callback) {
                      var nativeHandler = callbackList.nativeHandler;
                      var fakeName = callbackList.fakeName, capture = callbackList.capture;
                      callbackList = callbackList.slice(0, ci).concat(callbackList.slice(ci + 1));
                      callbackList.nativeHandler = nativeHandler;
                      callbackList.fakeName = fakeName;
                      callbackList.capture = capture;
                      eventMap[name2] = callbackList;
                    }
                  }
                }
                if (!callback || callbackList.length === 0) {
                  delete eventMap[name2];
                  removeEvent(target, callbackList.fakeName || name2, callbackList.nativeHandler, callbackList.capture);
                }
              }
            }
          } else {
            each$1(eventMap, function(callbackList2, name3) {
              removeEvent(target, callbackList2.fakeName || name3, callbackList2.nativeHandler, callbackList2.capture);
            });
            eventMap = {};
          }
          for (name2 in eventMap) {
            if (has(eventMap, name2)) {
              return this;
            }
          }
          delete this.events[id];
          try {
            delete target[this.expando];
          } catch (ex) {
            target[this.expando] = null;
          }
        }
        return this;
      };
      EventUtils2.prototype.fire = function(target, name2, args) {
        var id;
        if (!target || target.nodeType === 3 || target.nodeType === 8) {
          return this;
        }
        var event = fix(null, args);
        event.type = name2;
        event.target = target;
        do {
          id = target[this.expando];
          if (id) {
            this.executeHandlers(event, id);
          }
          target = target.parentNode || target.ownerDocument || target.defaultView || target.parentWindow;
        } while (target && !event.isPropagationStopped());
        return this;
      };
      EventUtils2.prototype.clean = function(target) {
        var i, children2;
        if (!target || target.nodeType === 3 || target.nodeType === 8) {
          return this;
        }
        if (target[this.expando]) {
          this.unbind(target);
        }
        if (!target.getElementsByTagName) {
          target = target.document;
        }
        if (target && target.getElementsByTagName) {
          this.unbind(target);
          children2 = target.getElementsByTagName("*");
          i = children2.length;
          while (i--) {
            target = children2[i];
            if (target[this.expando]) {
              this.unbind(target);
            }
          }
        }
        return this;
      };
      EventUtils2.prototype.destroy = function() {
        this.events = {};
      };
      EventUtils2.prototype.cancel = function(e) {
        if (e) {
          e.preventDefault();
          e.stopImmediatePropagation();
        }
        return false;
      };
      EventUtils2.prototype.executeHandlers = function(evt, id) {
        var container = this.events[id];
        var callbackList = container && container[evt.type];
        if (callbackList) {
          for (var i = 0, l = callbackList.length; i < l; i++) {
            var callback = callbackList[i];
            if (callback && callback.func.call(callback.scope, evt) === false) {
              evt.preventDefault();
            }
            if (evt.isImmediatePropagationStopped()) {
              return;
            }
          }
        }
      };
      EventUtils2.Event = new EventUtils2();
      return EventUtils2;
    }();
    var support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document$1, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains$3, expando = "sizzle" + -new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function(a, b) {
      if (a === b) {
        hasDuplicate = true;
      }
      return 0;
    }, strundefined = "undefined", MAX_NEGATIVE = 1 << 31, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, indexOf$2 = arr.indexOf || function(elem) {
      var i = 0, len = this.length;
      for (; i < len; i++) {
        if (this[i] === elem) {
          return i;
        }
      }
      return -1;
    }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", whitespace = "[\\x20\\t\\r\\n\\f]", identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+", attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + `*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(` + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + identifier + `)(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|` + attributes + ")*)|.*)\\)|)", rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rattributeQuotes = new RegExp("=" + whitespace + `*([^\\]'"]*?)` + whitespace + "*\\]", "g"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
      ID: new RegExp("^#(" + identifier + ")"),
      CLASS: new RegExp("^\\.(" + identifier + ")"),
      TAG: new RegExp("^(" + identifier + "|[*])"),
      ATTR: new RegExp("^" + attributes),
      PSEUDO: new RegExp("^" + pseudos),
      CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
      bool: new RegExp("^(?:" + booleans + ")$", "i"),
      needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
    }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, rescape = /'|\\/g, runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"), funescape = function(_, escaped, escapedWhitespace) {
      var high = "0x" + escaped - 65536;
      return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
    };
    try {
      push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
      arr[preferredDoc.childNodes.length].nodeType;
    } catch (e) {
      push = {
        apply: arr.length ? function(target, els) {
          push_native.apply(target, slice.call(els));
        } : function(target, els) {
          var j = target.length, i = 0;
          while (target[j++] = els[i++]) {
          }
          target.length = j - 1;
        }
      };
    }
    var Sizzle = function(selector, context2, results, seed2) {
      var match2, elem, m, nodeType, i, groups, old, nid, newContext, newSelector;
      if ((context2 ? context2.ownerDocument || context2 : preferredDoc) !== document$1) {
        setDocument(context2);
      }
      context2 = context2 || document$1;
      results = results || [];
      if (!selector || typeof selector !== "string") {
        return results;
      }
      if ((nodeType = context2.nodeType) !== 1 && nodeType !== 9) {
        return [];
      }
      if (documentIsHTML && !seed2) {
        if (match2 = rquickExpr.exec(selector)) {
          if (m = match2[1]) {
            if (nodeType === 9) {
              elem = context2.getElementById(m);
              if (elem && elem.parentNode) {
                if (elem.id === m) {
                  results.push(elem);
                  return results;
                }
              } else {
                return results;
              }
            } else {
              if (context2.ownerDocument && (elem = context2.ownerDocument.getElementById(m)) && contains$3(context2, elem) && elem.id === m) {
                results.push(elem);
                return results;
              }
            }
          } else if (match2[2]) {
            push.apply(results, context2.getElementsByTagName(selector));
            return results;
          } else if ((m = match2[3]) && support.getElementsByClassName) {
            push.apply(results, context2.getElementsByClassName(m));
            return results;
          }
        }
        if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
          nid = old = expando;
          newContext = context2;
          newSelector = nodeType === 9 && selector;
          if (nodeType === 1 && context2.nodeName.toLowerCase() !== "object") {
            groups = tokenize(selector);
            if (old = context2.getAttribute("id")) {
              nid = old.replace(rescape, "\\$&");
            } else {
              context2.setAttribute("id", nid);
            }
            nid = "[id='" + nid + "'] ";
            i = groups.length;
            while (i--) {
              groups[i] = nid + toSelector(groups[i]);
            }
            newContext = rsibling.test(selector) && testContext(context2.parentNode) || context2;
            newSelector = groups.join(",");
          }
          if (newSelector) {
            try {
              push.apply(results, newContext.querySelectorAll(newSelector));
              return results;
            } catch (qsaError) {
            } finally {
              if (!old) {
                context2.removeAttribute("id");
              }
            }
          }
        }
      }
      return select(selector.replace(rtrim, "$1"), context2, results, seed2);
    };
    function createCache() {
      var keys2 = [];
      function cache(key, value2) {
        if (keys2.push(key + " ") > Expr.cacheLength) {
          delete cache[keys2.shift()];
        }
        return cache[key + " "] = value2;
      }
      return cache;
    }
    function markFunction(fn) {
      fn[expando] = true;
      return fn;
    }
    function siblingCheck(a, b) {
      var cur = b && a, diff2 = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
      if (diff2) {
        return diff2;
      }
      if (cur) {
        while (cur = cur.nextSibling) {
          if (cur === b) {
            return -1;
          }
        }
      }
      return a ? 1 : -1;
    }
    function createInputPseudo(type2) {
      return function(elem) {
        var name2 = elem.nodeName.toLowerCase();
        return name2 === "input" && elem.type === type2;
      };
    }
    function createButtonPseudo(type2) {
      return function(elem) {
        var name2 = elem.nodeName.toLowerCase();
        return (name2 === "input" || name2 === "button") && elem.type === type2;
      };
    }
    function createPositionalPseudo(fn) {
      return markFunction(function(argument) {
        argument = +argument;
        return markFunction(function(seed2, matches2) {
          var j, matchIndexes = fn([], seed2.length, argument), i = matchIndexes.length;
          while (i--) {
            if (seed2[j = matchIndexes[i]]) {
              seed2[j] = !(matches2[j] = seed2[j]);
            }
          }
        });
      });
    }
    function testContext(context2) {
      return context2 && typeof context2.getElementsByTagName !== strundefined && context2;
    }
    support = Sizzle.support = {};
    isXML = Sizzle.isXML = function(elem) {
      var documentElement2 = elem && (elem.ownerDocument || elem).documentElement;
      return documentElement2 ? documentElement2.nodeName !== "HTML" : false;
    };
    setDocument = Sizzle.setDocument = function(node) {
      var hasCompare, doc2 = node ? node.ownerDocument || node : preferredDoc, parent2 = doc2.defaultView;
      function getTop(win) {
        try {
          return win.top;
        } catch (ex) {
        }
        return null;
      }
      if (doc2 === document$1 || doc2.nodeType !== 9 || !doc2.documentElement) {
        return document$1;
      }
      document$1 = doc2;
      docElem = doc2.documentElement;
      documentIsHTML = !isXML(doc2);
      if (parent2 && parent2 !== getTop(parent2)) {
        if (parent2.addEventListener) {
          parent2.addEventListener("unload", function() {
            setDocument();
          }, false);
        } else if (parent2.attachEvent) {
          parent2.attachEvent("onunload", function() {
            setDocument();
          });
        }
      }
      support.attributes = true;
      support.getElementsByTagName = true;
      support.getElementsByClassName = rnative.test(doc2.getElementsByClassName);
      support.getById = true;
      Expr.find.ID = function(id, context2) {
        if (typeof context2.getElementById !== strundefined && documentIsHTML) {
          var m = context2.getElementById(id);
          return m && m.parentNode ? [m] : [];
        }
      };
      Expr.filter.ID = function(id) {
        var attrId = id.replace(runescape, funescape);
        return function(elem) {
          return elem.getAttribute("id") === attrId;
        };
      };
      Expr.find.TAG = support.getElementsByTagName ? function(tag, context2) {
        if (typeof context2.getElementsByTagName !== strundefined) {
          return context2.getElementsByTagName(tag);
        }
      } : function(tag, context2) {
        var elem, tmp = [], i = 0, results = context2.getElementsByTagName(tag);
        if (tag === "*") {
          while (elem = results[i++]) {
            if (elem.nodeType === 1) {
              tmp.push(elem);
            }
          }
          return tmp;
        }
        return results;
      };
      Expr.find.CLASS = support.getElementsByClassName && function(className, context2) {
        if (documentIsHTML) {
          return context2.getElementsByClassName(className);
        }
      };
      rbuggyMatches = [];
      rbuggyQSA = [];
      support.disconnectedMatch = true;
      rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
      rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
      hasCompare = rnative.test(docElem.compareDocumentPosition);
      contains$3 = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
        var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
      } : function(a, b) {
        if (b) {
          while (b = b.parentNode) {
            if (b === a) {
              return true;
            }
          }
        }
        return false;
      };
      sortOrder = hasCompare ? function(a, b) {
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
        if (compare) {
          return compare;
        }
        compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
        if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
          if (a === doc2 || a.ownerDocument === preferredDoc && contains$3(preferredDoc, a)) {
            return -1;
          }
          if (b === doc2 || b.ownerDocument === preferredDoc && contains$3(preferredDoc, b)) {
            return 1;
          }
          return sortInput ? indexOf$2.call(sortInput, a) - indexOf$2.call(sortInput, b) : 0;
        }
        return compare & 4 ? -1 : 1;
      } : function(a, b) {
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];
        if (!aup || !bup) {
          return a === doc2 ? -1 : b === doc2 ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf$2.call(sortInput, a) - indexOf$2.call(sortInput, b) : 0;
        } else if (aup === bup) {
          return siblingCheck(a, b);
        }
        cur = a;
        while (cur = cur.parentNode) {
          ap.unshift(cur);
        }
        cur = b;
        while (cur = cur.parentNode) {
          bp.unshift(cur);
        }
        while (ap[i] === bp[i]) {
          i++;
        }
        return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
      };
      return doc2;
    };
    Sizzle.matches = function(expr, elements) {
      return Sizzle(expr, null, null, elements);
    };
    Sizzle.matchesSelector = function(elem, expr) {
      if ((elem.ownerDocument || elem) !== document$1) {
        setDocument(elem);
      }
      expr = expr.replace(rattributeQuotes, "='$1']");
      if (support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
        try {
          var ret = matches.call(elem, expr);
          if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
            return ret;
          }
        } catch (e) {
        }
      }
      return Sizzle(expr, document$1, null, [elem]).length > 0;
    };
    Sizzle.contains = function(context2, elem) {
      if ((context2.ownerDocument || context2) !== document$1) {
        setDocument(context2);
      }
      return contains$3(context2, elem);
    };
    Sizzle.attr = function(elem, name2) {
      if ((elem.ownerDocument || elem) !== document$1) {
        setDocument(elem);
      }
      var fn = Expr.attrHandle[name2.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name2.toLowerCase()) ? fn(elem, name2, !documentIsHTML) : void 0;
      return val !== void 0 ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name2) : (val = elem.getAttributeNode(name2)) && val.specified ? val.value : null;
    };
    Sizzle.error = function(msg) {
      throw new Error("Syntax error, unrecognized expression: " + msg);
    };
    Sizzle.uniqueSort = function(results) {
      var elem, duplicates = [], j = 0, i = 0;
      hasDuplicate = !support.detectDuplicates;
      sortInput = !support.sortStable && results.slice(0);
      results.sort(sortOrder);
      if (hasDuplicate) {
        while (elem = results[i++]) {
          if (elem === results[i]) {
            j = duplicates.push(i);
          }
        }
        while (j--) {
          results.splice(duplicates[j], 1);
        }
      }
      sortInput = null;
      return results;
    };
    getText = Sizzle.getText = function(elem) {
      var node, ret = "", i = 0, nodeType = elem.nodeType;
      if (!nodeType) {
        while (node = elem[i++]) {
          ret += getText(node);
        }
      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
        if (typeof elem.textContent === "string") {
          return elem.textContent;
        } else {
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            ret += getText(elem);
          }
        }
      } else if (nodeType === 3 || nodeType === 4) {
        return elem.nodeValue;
      }
      return ret;
    };
    Expr = Sizzle.selectors = {
      cacheLength: 50,
      createPseudo: markFunction,
      match: matchExpr,
      attrHandle: {},
      find: {},
      relative: {
        ">": {
          dir: "parentNode",
          first: true
        },
        " ": { dir: "parentNode" },
        "+": {
          dir: "previousSibling",
          first: true
        },
        "~": { dir: "previousSibling" }
      },
      preFilter: {
        ATTR: function(match2) {
          match2[1] = match2[1].replace(runescape, funescape);
          match2[3] = (match2[3] || match2[4] || match2[5] || "").replace(runescape, funescape);
          if (match2[2] === "~=") {
            match2[3] = " " + match2[3] + " ";
          }
          return match2.slice(0, 4);
        },
        CHILD: function(match2) {
          match2[1] = match2[1].toLowerCase();
          if (match2[1].slice(0, 3) === "nth") {
            if (!match2[3]) {
              Sizzle.error(match2[0]);
            }
            match2[4] = +(match2[4] ? match2[5] + (match2[6] || 1) : 2 * (match2[3] === "even" || match2[3] === "odd"));
            match2[5] = +(match2[7] + match2[8] || match2[3] === "odd");
          } else if (match2[3]) {
            Sizzle.error(match2[0]);
          }
          return match2;
        },
        PSEUDO: function(match2) {
          var excess, unquoted = !match2[6] && match2[2];
          if (matchExpr.CHILD.test(match2[0])) {
            return null;
          }
          if (match2[3]) {
            match2[2] = match2[4] || match2[5] || "";
          } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
            match2[0] = match2[0].slice(0, excess);
            match2[2] = unquoted.slice(0, excess);
          }
          return match2.slice(0, 3);
        }
      },
      filter: {
        TAG: function(nodeNameSelector) {
          var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
          return nodeNameSelector === "*" ? function() {
            return true;
          } : function(elem) {
            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
          };
        },
        CLASS: function(className) {
          var pattern = classCache[className + " "];
          return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
            return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute("class") || "");
          });
        },
        ATTR: function(name2, operator, check) {
          return function(elem) {
            var result = Sizzle.attr(elem, name2);
            if (result == null) {
              return operator === "!=";
            }
            if (!operator) {
              return true;
            }
            result += "";
            return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
          };
        },
        CHILD: function(type2, what, argument, first2, last2) {
          var simple = type2.slice(0, 3) !== "nth", forward = type2.slice(-4) !== "last", ofType = what === "of-type";
          return first2 === 1 && last2 === 0 ? function(elem) {
            return !!elem.parentNode;
          } : function(elem, context2, xml) {
            var cache, outerCache, node, diff2, nodeIndex2, start2, dir2 = simple !== forward ? "nextSibling" : "previousSibling", parent2 = elem.parentNode, name2 = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType;
            if (parent2) {
              if (simple) {
                while (dir2) {
                  node = elem;
                  while (node = node[dir2]) {
                    if (ofType ? node.nodeName.toLowerCase() === name2 : node.nodeType === 1) {
                      return false;
                    }
                  }
                  start2 = dir2 = type2 === "only" && !start2 && "nextSibling";
                }
                return true;
              }
              start2 = [forward ? parent2.firstChild : parent2.lastChild];
              if (forward && useCache) {
                outerCache = parent2[expando] || (parent2[expando] = {});
                cache = outerCache[type2] || [];
                nodeIndex2 = cache[0] === dirruns && cache[1];
                diff2 = cache[0] === dirruns && cache[2];
                node = nodeIndex2 && parent2.childNodes[nodeIndex2];
                while (node = ++nodeIndex2 && node && node[dir2] || (diff2 = nodeIndex2 = 0) || start2.pop()) {
                  if (node.nodeType === 1 && ++diff2 && node === elem) {
                    outerCache[type2] = [
                      dirruns,
                      nodeIndex2,
                      diff2
                    ];
                    break;
                  }
                }
              } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type2]) && cache[0] === dirruns) {
                diff2 = cache[1];
              } else {
                while (node = ++nodeIndex2 && node && node[dir2] || (diff2 = nodeIndex2 = 0) || start2.pop()) {
                  if ((ofType ? node.nodeName.toLowerCase() === name2 : node.nodeType === 1) && ++diff2) {
                    if (useCache) {
                      (node[expando] || (node[expando] = {}))[type2] = [
                        dirruns,
                        diff2
                      ];
                    }
                    if (node === elem) {
                      break;
                    }
                  }
                }
              }
              diff2 -= last2;
              return diff2 === first2 || diff2 % first2 === 0 && diff2 / first2 >= 0;
            }
          };
        },
        PSEUDO: function(pseudo, argument) {
          var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
          if (fn[expando]) {
            return fn(argument);
          }
          if (fn.length > 1) {
            args = [
              pseudo,
              pseudo,
              "",
              argument
            ];
            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed2, matches2) {
              var idx, matched = fn(seed2, argument), i = matched.length;
              while (i--) {
                idx = indexOf$2.call(seed2, matched[i]);
                seed2[idx] = !(matches2[idx] = matched[i]);
              }
            }) : function(elem) {
              return fn(elem, 0, args);
            };
          }
          return fn;
        }
      },
      pseudos: {
        not: markFunction(function(selector) {
          var input = [], results = [], matcher = compile(selector.replace(rtrim, "$1"));
          return matcher[expando] ? markFunction(function(seed2, matches2, context2, xml) {
            var elem, unmatched = matcher(seed2, null, xml, []), i = seed2.length;
            while (i--) {
              if (elem = unmatched[i]) {
                seed2[i] = !(matches2[i] = elem);
              }
            }
          }) : function(elem, context2, xml) {
            input[0] = elem;
            matcher(input, null, xml, results);
            input[0] = null;
            return !results.pop();
          };
        }),
        has: markFunction(function(selector) {
          return function(elem) {
            return Sizzle(selector, elem).length > 0;
          };
        }),
        contains: markFunction(function(text) {
          text = text.replace(runescape, funescape);
          return function(elem) {
            return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
          };
        }),
        lang: markFunction(function(lang) {
          if (!ridentifier.test(lang || "")) {
            Sizzle.error("unsupported lang: " + lang);
          }
          lang = lang.replace(runescape, funescape).toLowerCase();
          return function(elem) {
            var elemLang;
            do {
              if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                elemLang = elemLang.toLowerCase();
                return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
              }
            } while ((elem = elem.parentNode) && elem.nodeType === 1);
            return false;
          };
        }),
        target: function(elem) {
          var hash = window.location && window.location.hash;
          return hash && hash.slice(1) === elem.id;
        },
        root: function(elem) {
          return elem === docElem;
        },
        focus: function(elem) {
          return elem === document$1.activeElement && (!document$1.hasFocus || document$1.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
        },
        enabled: function(elem) {
          return elem.disabled === false;
        },
        disabled: function(elem) {
          return elem.disabled === true;
        },
        checked: function(elem) {
          var nodeName = elem.nodeName.toLowerCase();
          return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
        },
        selected: function(elem) {
          if (elem.parentNode) {
            elem.parentNode.selectedIndex;
          }
          return elem.selected === true;
        },
        empty: function(elem) {
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            if (elem.nodeType < 6) {
              return false;
            }
          }
          return true;
        },
        parent: function(elem) {
          return !Expr.pseudos.empty(elem);
        },
        header: function(elem) {
          return rheader.test(elem.nodeName);
        },
        input: function(elem) {
          return rinputs.test(elem.nodeName);
        },
        button: function(elem) {
          var name2 = elem.nodeName.toLowerCase();
          return name2 === "input" && elem.type === "button" || name2 === "button";
        },
        text: function(elem) {
          var attr;
          return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
        },
        first: createPositionalPseudo(function() {
          return [0];
        }),
        last: createPositionalPseudo(function(matchIndexes, length) {
          return [length - 1];
        }),
        eq: createPositionalPseudo(function(matchIndexes, length, argument) {
          return [argument < 0 ? argument + length : argument];
        }),
        even: createPositionalPseudo(function(matchIndexes, length) {
          var i = 0;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        odd: createPositionalPseudo(function(matchIndexes, length) {
          var i = 1;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        lt: createPositionalPseudo(function(matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;
          for (; --i >= 0; ) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        gt: createPositionalPseudo(function(matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;
          for (; ++i < length; ) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        })
      }
    };
    Expr.pseudos.nth = Expr.pseudos.eq;
    each([
      "radio",
      "checkbox",
      "file",
      "password",
      "image"
    ], function(i) {
      Expr.pseudos[i] = createInputPseudo(i);
    });
    each([
      "submit",
      "reset"
    ], function(i) {
      Expr.pseudos[i] = createButtonPseudo(i);
    });
    function setFilters() {
    }
    setFilters.prototype = Expr.filters = Expr.pseudos;
    Expr.setFilters = new setFilters();
    tokenize = Sizzle.tokenize = function(selector, parseOnly) {
      var matched, match2, tokens, type2, soFar, groups, preFilters, cached2 = tokenCache[selector + " "];
      if (cached2) {
        return parseOnly ? 0 : cached2.slice(0);
      }
      soFar = selector;
      groups = [];
      preFilters = Expr.preFilter;
      while (soFar) {
        if (!matched || (match2 = rcomma.exec(soFar))) {
          if (match2) {
            soFar = soFar.slice(match2[0].length) || soFar;
          }
          groups.push(tokens = []);
        }
        matched = false;
        if (match2 = rcombinators.exec(soFar)) {
          matched = match2.shift();
          tokens.push({
            value: matched,
            type: match2[0].replace(rtrim, " ")
          });
          soFar = soFar.slice(matched.length);
        }
        for (type2 in Expr.filter) {
          if (!Expr.filter.hasOwnProperty(type2)) {
            continue;
          }
          if ((match2 = matchExpr[type2].exec(soFar)) && (!preFilters[type2] || (match2 = preFilters[type2](match2)))) {
            matched = match2.shift();
            tokens.push({
              value: matched,
              type: type2,
              matches: match2
            });
            soFar = soFar.slice(matched.length);
          }
        }
        if (!matched) {
          break;
        }
      }
      return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
    };
    function toSelector(tokens) {
      var i = 0, len = tokens.length, selector = "";
      for (; i < len; i++) {
        selector += tokens[i].value;
      }
      return selector;
    }
    function addCombinator(matcher, combinator, base) {
      var dir2 = combinator.dir, checkNonElements = base && dir2 === "parentNode", doneName = done++;
      return combinator.first ? function(elem, context2, xml) {
        while (elem = elem[dir2]) {
          if (elem.nodeType === 1 || checkNonElements) {
            return matcher(elem, context2, xml);
          }
        }
      } : function(elem, context2, xml) {
        var oldCache, outerCache, newCache = [
          dirruns,
          doneName
        ];
        if (xml) {
          while (elem = elem[dir2]) {
            if (elem.nodeType === 1 || checkNonElements) {
              if (matcher(elem, context2, xml)) {
                return true;
              }
            }
          }
        } else {
          while (elem = elem[dir2]) {
            if (elem.nodeType === 1 || checkNonElements) {
              outerCache = elem[expando] || (elem[expando] = {});
              if ((oldCache = outerCache[dir2]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                return newCache[2] = oldCache[2];
              } else {
                outerCache[dir2] = newCache;
                if (newCache[2] = matcher(elem, context2, xml)) {
                  return true;
                }
              }
            }
          }
        }
      };
    }
    function elementMatcher(matchers) {
      return matchers.length > 1 ? function(elem, context2, xml) {
        var i = matchers.length;
        while (i--) {
          if (!matchers[i](elem, context2, xml)) {
            return false;
          }
        }
        return true;
      } : matchers[0];
    }
    function multipleContexts(selector, contexts, results) {
      var i = 0, len = contexts.length;
      for (; i < len; i++) {
        Sizzle(selector, contexts[i], results);
      }
      return results;
    }
    function condense(unmatched, map2, filter2, context2, xml) {
      var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map2 != null;
      for (; i < len; i++) {
        if (elem = unmatched[i]) {
          if (!filter2 || filter2(elem, context2, xml)) {
            newUnmatched.push(elem);
            if (mapped) {
              map2.push(i);
            }
          }
        }
      }
      return newUnmatched;
    }
    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
      if (postFilter && !postFilter[expando]) {
        postFilter = setMatcher(postFilter);
      }
      if (postFinder && !postFinder[expando]) {
        postFinder = setMatcher(postFinder, postSelector);
      }
      return markFunction(function(seed2, results, context2, xml) {
        var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed2 || multipleContexts(selector || "*", context2.nodeType ? [context2] : context2, []), matcherIn = preFilter && (seed2 || !selector) ? condense(elems, preMap, preFilter, context2, xml) : elems, matcherOut = matcher ? postFinder || (seed2 ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
        if (matcher) {
          matcher(matcherIn, matcherOut, context2, xml);
        }
        if (postFilter) {
          temp = condense(matcherOut, postMap);
          postFilter(temp, [], context2, xml);
          i = temp.length;
          while (i--) {
            if (elem = temp[i]) {
              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
            }
          }
        }
        if (seed2) {
          if (postFinder || preFilter) {
            if (postFinder) {
              temp = [];
              i = matcherOut.length;
              while (i--) {
                if (elem = matcherOut[i]) {
                  temp.push(matcherIn[i] = elem);
                }
              }
              postFinder(null, matcherOut = [], temp, xml);
            }
            i = matcherOut.length;
            while (i--) {
              if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf$2.call(seed2, elem) : preMap[i]) > -1) {
                seed2[temp] = !(results[temp] = elem);
              }
            }
          }
        } else {
          matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
          if (postFinder) {
            postFinder(null, results, matcherOut, xml);
          } else {
            push.apply(results, matcherOut);
          }
        }
      });
    }
    function matcherFromTokens(tokens) {
      var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
        return elem === checkContext;
      }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
        return indexOf$2.call(checkContext, elem) > -1;
      }, implicitRelative, true), matchers = [function(elem, context2, xml) {
        var ret = !leadingRelative && (xml || context2 !== outermostContext) || ((checkContext = context2).nodeType ? matchContext(elem, context2, xml) : matchAnyContext(elem, context2, xml));
        checkContext = null;
        return ret;
      }];
      for (; i < len; i++) {
        if (matcher = Expr.relative[tokens[i].type]) {
          matchers = [addCombinator(elementMatcher(matchers), matcher)];
        } else {
          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
          if (matcher[expando]) {
            j = ++i;
            for (; j < len; j++) {
              if (Expr.relative[tokens[j].type]) {
                break;
              }
            }
            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === " " ? "*" : "" })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
          }
          matchers.push(matcher);
        }
      }
      return elementMatcher(matchers);
    }
    function matcherFromGroupMatchers(elementMatchers, setMatchers) {
      var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed2, context2, xml, results, outermost) {
        var elem, j, matcher, matchedCount = 0, i = "0", unmatched = seed2 && [], setMatched = [], contextBackup = outermostContext, elems = seed2 || byElement && Expr.find.TAG("*", outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
        if (outermost) {
          outermostContext = context2 !== document$1 && context2;
        }
        for (; i !== len && (elem = elems[i]) != null; i++) {
          if (byElement && elem) {
            j = 0;
            while (matcher = elementMatchers[j++]) {
              if (matcher(elem, context2, xml)) {
                results.push(elem);
                break;
              }
            }
            if (outermost) {
              dirruns = dirrunsUnique;
            }
          }
          if (bySet) {
            if (elem = !matcher && elem) {
              matchedCount--;
            }
            if (seed2) {
              unmatched.push(elem);
            }
          }
        }
        matchedCount += i;
        if (bySet && i !== matchedCount) {
          j = 0;
          while (matcher = setMatchers[j++]) {
            matcher(unmatched, setMatched, context2, xml);
          }
          if (seed2) {
            if (matchedCount > 0) {
              while (i--) {
                if (!(unmatched[i] || setMatched[i])) {
                  setMatched[i] = pop.call(results);
                }
              }
            }
            setMatched = condense(setMatched);
          }
          push.apply(results, setMatched);
          if (outermost && !seed2 && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
            Sizzle.uniqueSort(results);
          }
        }
        if (outermost) {
          dirruns = dirrunsUnique;
          outermostContext = contextBackup;
        }
        return unmatched;
      };
      return bySet ? markFunction(superMatcher) : superMatcher;
    }
    compile = Sizzle.compile = function(selector, match2) {
      var i, setMatchers = [], elementMatchers = [], cached2 = compilerCache[selector + " "];
      if (!cached2) {
        if (!match2) {
          match2 = tokenize(selector);
        }
        i = match2.length;
        while (i--) {
          cached2 = matcherFromTokens(match2[i]);
          if (cached2[expando]) {
            setMatchers.push(cached2);
          } else {
            elementMatchers.push(cached2);
          }
        }
        cached2 = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
        cached2.selector = selector;
      }
      return cached2;
    };
    select = Sizzle.select = function(selector, context2, results, seed2) {
      var i, tokens, token, type2, find2, compiled = typeof selector === "function" && selector, match2 = !seed2 && tokenize(selector = compiled.selector || selector);
      results = results || [];
      if (match2.length === 1) {
        tokens = match2[0] = match2[0].slice(0);
        if (tokens.length > 2 && (token = tokens[0]).type === "ID" && support.getById && context2.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
          context2 = (Expr.find.ID(token.matches[0].replace(runescape, funescape), context2) || [])[0];
          if (!context2) {
            return results;
          } else if (compiled) {
            context2 = context2.parentNode;
          }
          selector = selector.slice(tokens.shift().value.length);
        }
        i = matchExpr.needsContext.test(selector) ? 0 : tokens.length;
        while (i--) {
          token = tokens[i];
          if (Expr.relative[type2 = token.type]) {
            break;
          }
          if (find2 = Expr.find[type2]) {
            if (seed2 = find2(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context2.parentNode) || context2)) {
              tokens.splice(i, 1);
              selector = seed2.length && toSelector(tokens);
              if (!selector) {
                push.apply(results, seed2);
                return results;
              }
              break;
            }
          }
        }
      }
      (compiled || compile(selector, match2))(seed2, context2, !documentIsHTML, results, rsibling.test(selector) && testContext(context2.parentNode) || context2);
      return results;
    };
    support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
    support.detectDuplicates = !!hasDuplicate;
    setDocument();
    support.sortDetached = true;
    var doc = document;
    var push$1 = Array.prototype.push;
    var slice$1 = Array.prototype.slice;
    var rquickExpr$1 = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/;
    var Event = EventUtils.Event;
    var skipUniques = Tools.makeMap("children,contents,next,prev");
    var isDefined = function(obj) {
      return typeof obj !== "undefined";
    };
    var isString$1 = function(obj) {
      return typeof obj === "string";
    };
    var isWindow = function(obj) {
      return obj && obj === obj.window;
    };
    var createFragment = function(html, fragDoc) {
      fragDoc = fragDoc || doc;
      var container = fragDoc.createElement("div");
      var frag = fragDoc.createDocumentFragment();
      container.innerHTML = html;
      var node;
      while (node = container.firstChild) {
        frag.appendChild(node);
      }
      return frag;
    };
    var domManipulate = function(targetNodes, sourceItem, callback, reverse2) {
      var i;
      if (isString$1(sourceItem)) {
        sourceItem = createFragment(sourceItem, getElementDocument(targetNodes[0]));
      } else if (sourceItem.length && !sourceItem.nodeType) {
        sourceItem = DomQuery.makeArray(sourceItem);
        if (reverse2) {
          for (i = sourceItem.length - 1; i >= 0; i--) {
            domManipulate(targetNodes, sourceItem[i], callback, reverse2);
          }
        } else {
          for (i = 0; i < sourceItem.length; i++) {
            domManipulate(targetNodes, sourceItem[i], callback, reverse2);
          }
        }
        return targetNodes;
      }
      if (sourceItem.nodeType) {
        i = targetNodes.length;
        while (i--) {
          callback.call(targetNodes[i], sourceItem);
        }
      }
      return targetNodes;
    };
    var hasClass = function(node, className) {
      return node && className && (" " + node.className + " ").indexOf(" " + className + " ") !== -1;
    };
    var wrap$1 = function(elements, wrapper, all2) {
      var lastParent, newWrapper;
      wrapper = DomQuery(wrapper)[0];
      elements.each(function() {
        var self2 = this;
        if (!all2 || lastParent !== self2.parentNode) {
          lastParent = self2.parentNode;
          newWrapper = wrapper.cloneNode(false);
          self2.parentNode.insertBefore(newWrapper, self2);
          newWrapper.appendChild(self2);
        } else {
          newWrapper.appendChild(self2);
        }
      });
      return elements;
    };
    var numericCssMap = Tools.makeMap("fillOpacity fontWeight lineHeight opacity orphans widows zIndex zoom", " ");
    var booleanMap = Tools.makeMap("checked compact declare defer disabled ismap multiple nohref noshade nowrap readonly selected", " ");
    var propFix = {
      for: "htmlFor",
      class: "className",
      readonly: "readOnly"
    };
    var cssFix = { float: "cssFloat" };
    var attrHooks = {}, cssHooks = {};
    var DomQueryConstructor = function(selector, context2) {
      return new DomQuery.fn.init(selector, context2);
    };
    var inArray$1 = function(item, array) {
      var i;
      if (array.indexOf) {
        return array.indexOf(item);
      }
      i = array.length;
      while (i--) {
        if (array[i] === item) {
          return i;
        }
      }
      return -1;
    };
    var whiteSpaceRegExp$2 = /^\s*|\s*$/g;
    var trim$3 = function(str) {
      return str === null || str === void 0 ? "" : ("" + str).replace(whiteSpaceRegExp$2, "");
    };
    var each$4 = function(obj, callback) {
      var length, key, i, value2;
      if (obj) {
        length = obj.length;
        if (length === void 0) {
          for (key in obj) {
            if (obj.hasOwnProperty(key)) {
              value2 = obj[key];
              if (callback.call(value2, key, value2) === false) {
                break;
              }
            }
          }
        } else {
          for (i = 0; i < length; i++) {
            value2 = obj[i];
            if (callback.call(value2, i, value2) === false) {
              break;
            }
          }
        }
      }
      return obj;
    };
    var grep = function(array, callback) {
      var out = [];
      each$4(array, function(i, item) {
        if (callback(item, i)) {
          out.push(item);
        }
      });
      return out;
    };
    var getElementDocument = function(element) {
      if (!element) {
        return doc;
      }
      if (element.nodeType === 9) {
        return element;
      }
      return element.ownerDocument;
    };
    DomQueryConstructor.fn = DomQueryConstructor.prototype = {
      constructor: DomQueryConstructor,
      selector: "",
      context: null,
      length: 0,
      init: function(selector, context2) {
        var self2 = this;
        var match2, node;
        if (!selector) {
          return self2;
        }
        if (selector.nodeType) {
          self2.context = self2[0] = selector;
          self2.length = 1;
          return self2;
        }
        if (context2 && context2.nodeType) {
          self2.context = context2;
        } else {
          if (context2) {
            return DomQuery(selector).attr(context2);
          }
          self2.context = context2 = document;
        }
        if (isString$1(selector)) {
          self2.selector = selector;
          if (selector.charAt(0) === "<" && selector.charAt(selector.length - 1) === ">" && selector.length >= 3) {
            match2 = [
              null,
              selector,
              null
            ];
          } else {
            match2 = rquickExpr$1.exec(selector);
          }
          if (match2) {
            if (match2[1]) {
              node = createFragment(selector, getElementDocument(context2)).firstChild;
              while (node) {
                push$1.call(self2, node);
                node = node.nextSibling;
              }
            } else {
              node = getElementDocument(context2).getElementById(match2[2]);
              if (!node) {
                return self2;
              }
              if (node.id !== match2[2]) {
                return self2.find(selector);
              }
              self2.length = 1;
              self2[0] = node;
            }
          } else {
            return DomQuery(context2).find(selector);
          }
        } else {
          this.add(selector, false);
        }
        return self2;
      },
      toArray: function() {
        return Tools.toArray(this);
      },
      add: function(items, sort2) {
        var self2 = this;
        var nodes, i;
        if (isString$1(items)) {
          return self2.add(DomQuery(items));
        }
        if (sort2 !== false) {
          nodes = DomQuery.unique(self2.toArray().concat(DomQuery.makeArray(items)));
          self2.length = nodes.length;
          for (i = 0; i < nodes.length; i++) {
            self2[i] = nodes[i];
          }
        } else {
          push$1.apply(self2, DomQuery.makeArray(items));
        }
        return self2;
      },
      attr: function(name2, value2) {
        var self2 = this;
        var hook;
        if (typeof name2 === "object") {
          each$4(name2, function(name3, value3) {
            self2.attr(name3, value3);
          });
        } else if (isDefined(value2)) {
          this.each(function() {
            var hook2;
            if (this.nodeType === 1) {
              hook2 = attrHooks[name2];
              if (hook2 && hook2.set) {
                hook2.set(this, value2);
                return;
              }
              if (value2 === null) {
                this.removeAttribute(name2, 2);
              } else {
                this.setAttribute(name2, value2, 2);
              }
            }
          });
        } else {
          if (self2[0] && self2[0].nodeType === 1) {
            hook = attrHooks[name2];
            if (hook && hook.get) {
              return hook.get(self2[0], name2);
            }
            if (booleanMap[name2]) {
              return self2.prop(name2) ? name2 : void 0;
            }
            value2 = self2[0].getAttribute(name2, 2);
            if (value2 === null) {
              value2 = void 0;
            }
          }
          return value2;
        }
        return self2;
      },
      removeAttr: function(name2) {
        return this.attr(name2, null);
      },
      prop: function(name2, value2) {
        var self2 = this;
        name2 = propFix[name2] || name2;
        if (typeof name2 === "object") {
          each$4(name2, function(name3, value3) {
            self2.prop(name3, value3);
          });
        } else if (isDefined(value2)) {
          this.each(function() {
            if (this.nodeType === 1) {
              this[name2] = value2;
            }
          });
        } else {
          if (self2[0] && self2[0].nodeType && name2 in self2[0]) {
            return self2[0][name2];
          }
          return value2;
        }
        return self2;
      },
      css: function(name2, value2) {
        var self2 = this;
        var elm, hook;
        var camel = function(name3) {
          return name3.replace(/-(\D)/g, function(a, b) {
            return b.toUpperCase();
          });
        };
        var dashed = function(name3) {
          return name3.replace(/[A-Z]/g, function(a) {
            return "-" + a;
          });
        };
        if (typeof name2 === "object") {
          each$4(name2, function(name3, value3) {
            self2.css(name3, value3);
          });
        } else {
          if (isDefined(value2)) {
            name2 = camel(name2);
            if (typeof value2 === "number" && !numericCssMap[name2]) {
              value2 = value2.toString() + "px";
            }
            self2.each(function() {
              var style = this.style;
              hook = cssHooks[name2];
              if (hook && hook.set) {
                hook.set(this, value2);
                return;
              }
              try {
                this.style[cssFix[name2] || name2] = value2;
              } catch (ex) {
              }
              if (value2 === null || value2 === "") {
                if (style.removeProperty) {
                  style.removeProperty(dashed(name2));
                } else {
                  style.removeAttribute(name2);
                }
              }
            });
          } else {
            elm = self2[0];
            hook = cssHooks[name2];
            if (hook && hook.get) {
              return hook.get(elm);
            }
            if (elm.ownerDocument.defaultView) {
              try {
                return elm.ownerDocument.defaultView.getComputedStyle(elm, null).getPropertyValue(dashed(name2));
              } catch (ex) {
                return void 0;
              }
            } else if (elm.currentStyle) {
              return elm.currentStyle[camel(name2)];
            } else {
              return "";
            }
          }
        }
        return self2;
      },
      remove: function() {
        var self2 = this;
        var node, i = this.length;
        while (i--) {
          node = self2[i];
          Event.clean(node);
          if (node.parentNode) {
            node.parentNode.removeChild(node);
          }
        }
        return this;
      },
      empty: function() {
        var self2 = this;
        var node, i = this.length;
        while (i--) {
          node = self2[i];
          while (node.firstChild) {
            node.removeChild(node.firstChild);
          }
        }
        return this;
      },
      html: function(value2) {
        var self2 = this;
        var i;
        if (isDefined(value2)) {
          i = self2.length;
          try {
            while (i--) {
              self2[i].innerHTML = value2;
            }
          } catch (ex) {
            DomQuery(self2[i]).empty().append(value2);
          }
          return self2;
        }
        return self2[0] ? self2[0].innerHTML : "";
      },
      text: function(value2) {
        var self2 = this;
        var i;
        if (isDefined(value2)) {
          i = self2.length;
          while (i--) {
            if ("innerText" in self2[i]) {
              self2[i].innerText = value2;
            } else {
              self2[0].textContent = value2;
            }
          }
          return self2;
        }
        return self2[0] ? self2[0].innerText || self2[0].textContent : "";
      },
      append: function() {
        return domManipulate(this, arguments, function(node) {
          if (this.nodeType === 1 || this.host && this.host.nodeType === 1) {
            this.appendChild(node);
          }
        });
      },
      prepend: function() {
        return domManipulate(this, arguments, function(node) {
          if (this.nodeType === 1 || this.host && this.host.nodeType === 1) {
            this.insertBefore(node, this.firstChild);
          }
        }, true);
      },
      before: function() {
        var self2 = this;
        if (self2[0] && self2[0].parentNode) {
          return domManipulate(self2, arguments, function(node) {
            this.parentNode.insertBefore(node, this);
          });
        }
        return self2;
      },
      after: function() {
        var self2 = this;
        if (self2[0] && self2[0].parentNode) {
          return domManipulate(self2, arguments, function(node) {
            this.parentNode.insertBefore(node, this.nextSibling);
          }, true);
        }
        return self2;
      },
      appendTo: function(val) {
        DomQuery(val).append(this);
        return this;
      },
      prependTo: function(val) {
        DomQuery(val).prepend(this);
        return this;
      },
      replaceWith: function(content) {
        return this.before(content).remove();
      },
      wrap: function(content) {
        return wrap$1(this, content);
      },
      wrapAll: function(content) {
        return wrap$1(this, content, true);
      },
      wrapInner: function(content) {
        this.each(function() {
          DomQuery(this).contents().wrapAll(content);
        });
        return this;
      },
      unwrap: function() {
        return this.parent().each(function() {
          DomQuery(this).replaceWith(this.childNodes);
        });
      },
      clone: function() {
        var result = [];
        this.each(function() {
          result.push(this.cloneNode(true));
        });
        return DomQuery(result);
      },
      addClass: function(className) {
        return this.toggleClass(className, true);
      },
      removeClass: function(className) {
        return this.toggleClass(className, false);
      },
      toggleClass: function(className, state) {
        var self2 = this;
        if (typeof className !== "string") {
          return self2;
        }
        if (className.indexOf(" ") !== -1) {
          each$4(className.split(" "), function() {
            self2.toggleClass(this, state);
          });
        } else {
          self2.each(function(index, node) {
            var classState = hasClass(node, className);
            if (classState !== state) {
              var existingClassName = node.className;
              if (classState) {
                node.className = trim$3((" " + existingClassName + " ").replace(" " + className + " ", " "));
              } else {
                node.className += existingClassName ? " " + className : className;
              }
            }
          });
        }
        return self2;
      },
      hasClass: function(className) {
        return hasClass(this[0], className);
      },
      each: function(callback) {
        return each$4(this, callback);
      },
      on: function(name2, callback) {
        return this.each(function() {
          Event.bind(this, name2, callback);
        });
      },
      off: function(name2, callback) {
        return this.each(function() {
          Event.unbind(this, name2, callback);
        });
      },
      trigger: function(name2) {
        return this.each(function() {
          if (typeof name2 === "object") {
            Event.fire(this, name2.type, name2);
          } else {
            Event.fire(this, name2);
          }
        });
      },
      show: function() {
        return this.css("display", "");
      },
      hide: function() {
        return this.css("display", "none");
      },
      slice: function() {
        return DomQuery(slice$1.apply(this, arguments));
      },
      eq: function(index) {
        return index === -1 ? this.slice(index) : this.slice(index, +index + 1);
      },
      first: function() {
        return this.eq(0);
      },
      last: function() {
        return this.eq(-1);
      },
      find: function(selector) {
        var i, l;
        var ret = [];
        for (i = 0, l = this.length; i < l; i++) {
          DomQuery.find(selector, this[i], ret);
        }
        return DomQuery(ret);
      },
      filter: function(selector) {
        if (typeof selector === "function") {
          return DomQuery(grep(this.toArray(), function(item, i) {
            return selector(i, item);
          }));
        }
        return DomQuery(DomQuery.filter(selector, this.toArray()));
      },
      closest: function(selector) {
        var result = [];
        if (selector instanceof DomQuery) {
          selector = selector[0];
        }
        this.each(function(i, node) {
          while (node) {
            if (typeof selector === "string" && DomQuery(node).is(selector)) {
              result.push(node);
              break;
            } else if (node === selector) {
              result.push(node);
              break;
            }
            node = node.parentNode;
          }
        });
        return DomQuery(result);
      },
      offset: function(offset) {
        var elm, doc2, docElm;
        var x = 0, y = 0, pos;
        if (!offset) {
          elm = this[0];
          if (elm) {
            doc2 = elm.ownerDocument;
            docElm = doc2.documentElement;
            if (elm.getBoundingClientRect) {
              pos = elm.getBoundingClientRect();
              x = pos.left + (docElm.scrollLeft || doc2.body.scrollLeft) - docElm.clientLeft;
              y = pos.top + (docElm.scrollTop || doc2.body.scrollTop) - docElm.clientTop;
            }
          }
          return {
            left: x,
            top: y
          };
        }
        return this.css(offset);
      },
      push: push$1,
      sort: Array.prototype.sort,
      splice: Array.prototype.splice
    };
    Tools.extend(DomQueryConstructor, {
      extend: Tools.extend,
      makeArray: function(object) {
        if (isWindow(object) || object.nodeType) {
          return [object];
        }
        return Tools.toArray(object);
      },
      inArray: inArray$1,
      isArray: Tools.isArray,
      each: each$4,
      trim: trim$3,
      grep,
      find: Sizzle,
      expr: Sizzle.selectors,
      unique: Sizzle.uniqueSort,
      text: Sizzle.getText,
      contains: Sizzle.contains,
      filter: function(expr, elems, not2) {
        var i = elems.length;
        if (not2) {
          expr = ":not(" + expr + ")";
        }
        while (i--) {
          if (elems[i].nodeType !== 1) {
            elems.splice(i, 1);
          }
        }
        if (elems.length === 1) {
          elems = DomQuery.find.matchesSelector(elems[0], expr) ? [elems[0]] : [];
        } else {
          elems = DomQuery.find.matches(expr, elems);
        }
        return elems;
      }
    });
    var dir = function(el, prop, until) {
      var matched = [];
      var cur = el[prop];
      if (typeof until !== "string" && until instanceof DomQuery) {
        until = until[0];
      }
      while (cur && cur.nodeType !== 9) {
        if (until !== void 0) {
          if (cur === until) {
            break;
          }
          if (typeof until === "string" && DomQuery(cur).is(until)) {
            break;
          }
        }
        if (cur.nodeType === 1) {
          matched.push(cur);
        }
        cur = cur[prop];
      }
      return matched;
    };
    var sibling$1 = function(node, siblingName, nodeType, until) {
      var result = [];
      if (until instanceof DomQuery) {
        until = until[0];
      }
      for (; node; node = node[siblingName]) {
        if (nodeType && node.nodeType !== nodeType) {
          continue;
        }
        if (until !== void 0) {
          if (node === until) {
            break;
          }
          if (typeof until === "string" && DomQuery(node).is(until)) {
            break;
          }
        }
        result.push(node);
      }
      return result;
    };
    var firstSibling = function(node, siblingName, nodeType) {
      for (node = node[siblingName]; node; node = node[siblingName]) {
        if (node.nodeType === nodeType) {
          return node;
        }
      }
      return null;
    };
    each$4({
      parent: function(node) {
        var parent2 = node.parentNode;
        return parent2 && parent2.nodeType !== 11 ? parent2 : null;
      },
      parents: function(node) {
        return dir(node, "parentNode");
      },
      next: function(node) {
        return firstSibling(node, "nextSibling", 1);
      },
      prev: function(node) {
        return firstSibling(node, "previousSibling", 1);
      },
      children: function(node) {
        return sibling$1(node.firstChild, "nextSibling", 1);
      },
      contents: function(node) {
        return Tools.toArray((node.nodeName === "iframe" ? node.contentDocument || node.contentWindow.document : node).childNodes);
      }
    }, function(name2, fn) {
      DomQueryConstructor.fn[name2] = function(selector) {
        var self2 = this;
        var result = [];
        self2.each(function() {
          var nodes = fn.call(result, this, selector, result);
          if (nodes) {
            if (DomQuery.isArray(nodes)) {
              result.push.apply(result, nodes);
            } else {
              result.push(nodes);
            }
          }
        });
        if (this.length > 1) {
          if (!skipUniques[name2]) {
            result = DomQuery.unique(result);
          }
          if (name2.indexOf("parents") === 0) {
            result = result.reverse();
          }
        }
        var wrappedResult = DomQuery(result);
        if (selector) {
          return wrappedResult.filter(selector);
        }
        return wrappedResult;
      };
    });
    each$4({
      parentsUntil: function(node, until) {
        return dir(node, "parentNode", until);
      },
      nextUntil: function(node, until) {
        return sibling$1(node, "nextSibling", 1, until).slice(1);
      },
      prevUntil: function(node, until) {
        return sibling$1(node, "previousSibling", 1, until).slice(1);
      }
    }, function(name2, fn) {
      DomQueryConstructor.fn[name2] = function(selector, filter2) {
        var self2 = this;
        var result = [];
        self2.each(function() {
          var nodes = fn.call(result, this, selector, result);
          if (nodes) {
            if (DomQuery.isArray(nodes)) {
              result.push.apply(result, nodes);
            } else {
              result.push(nodes);
            }
          }
        });
        if (this.length > 1) {
          result = DomQuery.unique(result);
          if (name2.indexOf("parents") === 0 || name2 === "prevUntil") {
            result = result.reverse();
          }
        }
        var wrappedResult = DomQuery(result);
        if (filter2) {
          return wrappedResult.filter(filter2);
        }
        return wrappedResult;
      };
    });
    DomQueryConstructor.fn.is = function(selector) {
      return !!selector && this.filter(selector).length > 0;
    };
    DomQueryConstructor.fn.init.prototype = DomQueryConstructor.fn;
    DomQueryConstructor.overrideDefaults = function(callback) {
      var defaults;
      var sub = function(selector, context2) {
        defaults = defaults || callback();
        if (arguments.length === 0) {
          selector = defaults.element;
        }
        if (!context2) {
          context2 = defaults.context;
        }
        return new sub.fn.init(selector, context2);
      };
      DomQuery.extend(sub, this);
      return sub;
    };
    DomQueryConstructor.attrHooks = attrHooks;
    DomQueryConstructor.cssHooks = cssHooks;
    var DomQuery = DomQueryConstructor;
    var each$5 = Tools.each;
    var grep$1 = Tools.grep;
    var isIE = Env.ie;
    var simpleSelectorRe = /^([a-z0-9],?)+$/i;
    var setupAttrHooks = function(styles, settings, getContext) {
      var keepValues = settings.keep_values;
      var keepUrlHook = {
        set: function($elm, value2, name2) {
          if (settings.url_converter) {
            value2 = settings.url_converter.call(settings.url_converter_scope || getContext(), value2, name2, $elm[0]);
          }
          $elm.attr("data-mce-" + name2, value2).attr(name2, value2);
        },
        get: function($elm, name2) {
          return $elm.attr("data-mce-" + name2) || $elm.attr(name2);
        }
      };
      var attrHooks2 = {
        style: {
          set: function($elm, value2) {
            if (value2 !== null && typeof value2 === "object") {
              $elm.css(value2);
              return;
            }
            if (keepValues) {
              $elm.attr("data-mce-style", value2);
            }
            if (value2 !== null && typeof value2 === "string") {
              $elm.removeAttr("style");
              $elm.css(styles.parse(value2));
            } else {
              $elm.attr("style", value2);
            }
          },
          get: function($elm) {
            var value2 = $elm.attr("data-mce-style") || $elm.attr("style");
            value2 = styles.serialize(styles.parse(value2), $elm[0].nodeName);
            return value2;
          }
        }
      };
      if (keepValues) {
        attrHooks2.href = attrHooks2.src = keepUrlHook;
      }
      return attrHooks2;
    };
    var updateInternalStyleAttr = function(styles, $elm) {
      var rawValue = $elm.attr("style");
      var value2 = styles.serialize(styles.parse(rawValue), $elm[0].nodeName);
      if (!value2) {
        value2 = null;
      }
      $elm.attr("data-mce-style", value2);
    };
    var findNodeIndex = function(node, normalized) {
      var idx = 0, lastNodeType, nodeType;
      if (node) {
        for (lastNodeType = node.nodeType, node = node.previousSibling; node; node = node.previousSibling) {
          nodeType = node.nodeType;
          if (normalized && nodeType === 3) {
            if (nodeType === lastNodeType || !node.nodeValue.length) {
              continue;
            }
          }
          idx++;
          lastNodeType = nodeType;
        }
      }
      return idx;
    };
    var DOMUtils = function(doc2, settings) {
      if (settings === void 0) {
        settings = {};
      }
      var addedStyles = {};
      var win = window;
      var files = {};
      var counter = 0;
      var stdMode = true;
      var boxModel = true;
      var styleSheetLoader = instance.forElement(SugarElement.fromDom(doc2), {
        contentCssCors: settings.contentCssCors,
        referrerPolicy: settings.referrerPolicy
      });
      var boundEvents = [];
      var schema = settings.schema ? settings.schema : Schema({});
      var styles = Styles({
        url_converter: settings.url_converter,
        url_converter_scope: settings.url_converter_scope
      }, settings.schema);
      var events = settings.ownEvents ? new EventUtils() : EventUtils.Event;
      var blockElementsMap = schema.getBlockElements();
      var $ = DomQuery.overrideDefaults(function() {
        return {
          context: doc2,
          element: self2.getRoot()
        };
      });
      var isBlock2 = function(node) {
        if (typeof node === "string") {
          return !!blockElementsMap[node];
        } else if (node) {
          var type2 = node.nodeType;
          if (type2) {
            return !!(type2 === 1 && blockElementsMap[node.nodeName]);
          }
        }
        return false;
      };
      var get2 = function(elm) {
        return elm && doc2 && isString(elm) ? doc2.getElementById(elm) : elm;
      };
      var $$ = function(elm) {
        return $(typeof elm === "string" ? get2(elm) : elm);
      };
      var getAttrib = function(elm, name2, defaultVal) {
        var hook, value2;
        var $elm = $$(elm);
        if ($elm.length) {
          hook = attrHooks2[name2];
          if (hook && hook.get) {
            value2 = hook.get($elm, name2);
          } else {
            value2 = $elm.attr(name2);
          }
        }
        if (typeof value2 === "undefined") {
          value2 = defaultVal || "";
        }
        return value2;
      };
      var getAttribs = function(elm) {
        var node = get2(elm);
        if (!node) {
          return [];
        }
        return node.attributes;
      };
      var setAttrib = function(elm, name2, value2) {
        if (value2 === "") {
          value2 = null;
        }
        var $elm = $$(elm);
        var originalValue = $elm.attr(name2);
        if (!$elm.length) {
          return;
        }
        var hook = attrHooks2[name2];
        if (hook && hook.set) {
          hook.set($elm, value2, name2);
        } else {
          $elm.attr(name2, value2);
        }
        if (originalValue !== value2 && settings.onSetAttrib) {
          settings.onSetAttrib({
            attrElm: $elm,
            attrName: name2,
            attrValue: value2
          });
        }
      };
      var clone2 = function(node, deep2) {
        if (!isIE || node.nodeType !== 1 || deep2) {
          return node.cloneNode(deep2);
        } else {
          var clone_1 = doc2.createElement(node.nodeName);
          each$5(getAttribs(node), function(attr) {
            setAttrib(clone_1, attr.nodeName, getAttrib(node, attr.nodeName));
          });
          return clone_1;
        }
      };
      var getRoot = function() {
        return settings.root_element || doc2.body;
      };
      var getViewPort = function(argWin) {
        var vp = getBounds(argWin);
        return {
          x: vp.x,
          y: vp.y,
          w: vp.width,
          h: vp.height
        };
      };
      var getPos$1 = function(elm, rootElm) {
        return getPos(doc2.body, get2(elm), rootElm);
      };
      var setStyle = function(elm, name2, value2) {
        var $elm = isString(name2) ? $$(elm).css(name2, value2) : $$(elm).css(name2);
        if (settings.update_styles) {
          updateInternalStyleAttr(styles, $elm);
        }
      };
      var setStyles = function(elm, stylesArg) {
        var $elm = $$(elm).css(stylesArg);
        if (settings.update_styles) {
          updateInternalStyleAttr(styles, $elm);
        }
      };
      var getStyle2 = function(elm, name2, computed) {
        var $elm = $$(elm);
        if (computed) {
          return $elm.css(name2);
        }
        name2 = name2.replace(/-(\D)/g, function(a, b) {
          return b.toUpperCase();
        });
        if (name2 === "float") {
          name2 = Env.browser.isIE() ? "styleFloat" : "cssFloat";
        }
        return $elm[0] && $elm[0].style ? $elm[0].style[name2] : void 0;
      };
      var getSize = function(elm) {
        var w, h2;
        elm = get2(elm);
        w = getStyle2(elm, "width");
        h2 = getStyle2(elm, "height");
        if (w.indexOf("px") === -1) {
          w = 0;
        }
        if (h2.indexOf("px") === -1) {
          h2 = 0;
        }
        return {
          w: parseInt(w, 10) || elm.offsetWidth || elm.clientWidth,
          h: parseInt(h2, 10) || elm.offsetHeight || elm.clientHeight
        };
      };
      var getRect = function(elm) {
        elm = get2(elm);
        var pos = getPos$1(elm);
        var size = getSize(elm);
        return {
          x: pos.x,
          y: pos.y,
          w: size.w,
          h: size.h
        };
      };
      var is2 = function(elm, selector) {
        var i;
        if (!elm) {
          return false;
        }
        if (!Array.isArray(elm)) {
          if (selector === "*") {
            return elm.nodeType === 1;
          }
          if (simpleSelectorRe.test(selector)) {
            var selectors = selector.toLowerCase().split(/,/);
            var elmName = elm.nodeName.toLowerCase();
            for (i = selectors.length - 1; i >= 0; i--) {
              if (selectors[i] === elmName) {
                return true;
              }
            }
            return false;
          }
          if (elm.nodeType && elm.nodeType !== 1) {
            return false;
          }
        }
        var elms = !Array.isArray(elm) ? [elm] : elm;
        return Sizzle(selector, elms[0].ownerDocument || elms[0], null, elms).length > 0;
      };
      var getParents2 = function(elm, selector, root, collect) {
        var result = [];
        var selectorVal;
        var node = get2(elm);
        collect = collect === void 0;
        root = root || (getRoot().nodeName !== "BODY" ? getRoot().parentNode : null);
        if (Tools.is(selector, "string")) {
          selectorVal = selector;
          if (selector === "*") {
            selector = function(node2) {
              return node2.nodeType === 1;
            };
          } else {
            selector = function(node2) {
              return is2(node2, selectorVal);
            };
          }
        }
        while (node) {
          if (node === root || isNullable(node.nodeType) || isDocument$1(node) || isDocumentFragment$1(node)) {
            break;
          }
          if (!selector || typeof selector === "function" && selector(node)) {
            if (collect) {
              result.push(node);
            } else {
              return [node];
            }
          }
          node = node.parentNode;
        }
        return collect ? result : null;
      };
      var getParent = function(node, selector, root) {
        var parents2 = getParents2(node, selector, root, false);
        return parents2 && parents2.length > 0 ? parents2[0] : null;
      };
      var _findSib = function(node, selector, name2) {
        var func = selector;
        if (node) {
          if (typeof selector === "string") {
            func = function(node2) {
              return is2(node2, selector);
            };
          }
          for (node = node[name2]; node; node = node[name2]) {
            if (typeof func === "function" && func(node)) {
              return node;
            }
          }
        }
        return null;
      };
      var getNext = function(node, selector) {
        return _findSib(node, selector, "nextSibling");
      };
      var getPrev = function(node, selector) {
        return _findSib(node, selector, "previousSibling");
      };
      var select2 = function(selector, scope) {
        return Sizzle(selector, get2(scope) || settings.root_element || doc2, []);
      };
      var run = function(elm, func, scope) {
        var result;
        var node = typeof elm === "string" ? get2(elm) : elm;
        if (!node) {
          return false;
        }
        if (Tools.isArray(node) && (node.length || node.length === 0)) {
          result = [];
          each$5(node, function(elm2, i) {
            if (elm2) {
              result.push(func.call(scope, typeof elm2 === "string" ? get2(elm2) : elm2, i));
            }
          });
          return result;
        }
        var context2 = scope ? scope : this;
        return func.call(context2, node);
      };
      var setAttribs = function(elm, attrs) {
        $$(elm).each(function(i, node) {
          each$5(attrs, function(value2, name2) {
            setAttrib(node, name2, value2);
          });
        });
      };
      var setHTML = function(elm, html) {
        var $elm = $$(elm);
        if (isIE) {
          $elm.each(function(i, target) {
            if (target.canHaveHTML === false) {
              return;
            }
            while (target.firstChild) {
              target.removeChild(target.firstChild);
            }
            try {
              target.innerHTML = "<br>" + html;
              target.removeChild(target.firstChild);
            } catch (ex) {
              DomQuery("<div></div>").html("<br>" + html).contents().slice(1).appendTo(target);
            }
            return html;
          });
        } else {
          $elm.html(html);
        }
      };
      var add2 = function(parentElm, name2, attrs, html, create3) {
        return run(parentElm, function(parentElm2) {
          var newElm = typeof name2 === "string" ? doc2.createElement(name2) : name2;
          setAttribs(newElm, attrs);
          if (html) {
            if (typeof html !== "string" && html.nodeType) {
              newElm.appendChild(html);
            } else if (typeof html === "string") {
              setHTML(newElm, html);
            }
          }
          return !create3 ? parentElm2.appendChild(newElm) : newElm;
        });
      };
      var create2 = function(name2, attrs, html) {
        return add2(doc2.createElement(name2), name2, attrs, html, true);
      };
      var decode2 = Entities.decode;
      var encode = Entities.encodeAllRaw;
      var createHTML = function(name2, attrs, html) {
        var outHtml = "", key;
        outHtml += "<" + name2;
        for (key in attrs) {
          if (attrs.hasOwnProperty(key) && attrs[key] !== null && typeof attrs[key] !== "undefined") {
            outHtml += " " + key + '="' + encode(attrs[key]) + '"';
          }
        }
        if (typeof html !== "undefined") {
          return outHtml + ">" + html + "</" + name2 + ">";
        }
        return outHtml + " />";
      };
      var createFragment2 = function(html) {
        var node;
        var container = doc2.createElement("div");
        var frag = doc2.createDocumentFragment();
        frag.appendChild(container);
        if (html) {
          container.innerHTML = html;
        }
        while (node = container.firstChild) {
          frag.appendChild(node);
        }
        frag.removeChild(container);
        return frag;
      };
      var remove2 = function(node, keepChildren) {
        var $node = $$(node);
        if (keepChildren) {
          $node.each(function() {
            var child2;
            while (child2 = this.firstChild) {
              if (child2.nodeType === 3 && child2.data.length === 0) {
                this.removeChild(child2);
              } else {
                this.parentNode.insertBefore(child2, this);
              }
            }
          }).remove();
        } else {
          $node.remove();
        }
        return $node.length > 1 ? $node.toArray() : $node[0];
      };
      var removeAllAttribs = function(e) {
        return run(e, function(e2) {
          var i;
          var attrs = e2.attributes;
          for (i = attrs.length - 1; i >= 0; i--) {
            e2.removeAttributeNode(attrs.item(i));
          }
        });
      };
      var parseStyle = function(cssText) {
        return styles.parse(cssText);
      };
      var serializeStyle = function(stylesArg, name2) {
        return styles.serialize(stylesArg, name2);
      };
      var addStyle = function(cssText) {
        var head2, styleElm;
        if (self2 !== DOMUtils.DOM && doc2 === document) {
          if (addedStyles[cssText]) {
            return;
          }
          addedStyles[cssText] = true;
        }
        styleElm = doc2.getElementById("mceDefaultStyles");
        if (!styleElm) {
          styleElm = doc2.createElement("style");
          styleElm.id = "mceDefaultStyles";
          styleElm.type = "text/css";
          head2 = doc2.getElementsByTagName("head")[0];
          if (head2.firstChild) {
            head2.insertBefore(styleElm, head2.firstChild);
          } else {
            head2.appendChild(styleElm);
          }
        }
        if (styleElm.styleSheet) {
          styleElm.styleSheet.cssText += cssText;
        } else {
          styleElm.appendChild(doc2.createTextNode(cssText));
        }
      };
      var loadCSS = function(urls) {
        if (!urls) {
          urls = "";
        }
        each(urls.split(","), function(url) {
          files[url] = true;
          styleSheetLoader.load(url, noop);
        });
      };
      var toggleClass2 = function(elm, cls, state) {
        $$(elm).toggleClass(cls, state).each(function() {
          if (this.className === "") {
            DomQuery(this).attr("class", null);
          }
        });
      };
      var addClass = function(elm, cls) {
        $$(elm).addClass(cls);
      };
      var removeClass = function(elm, cls) {
        toggleClass2(elm, cls, false);
      };
      var hasClass2 = function(elm, cls) {
        return $$(elm).hasClass(cls);
      };
      var show = function(elm) {
        $$(elm).show();
      };
      var hide = function(elm) {
        $$(elm).hide();
      };
      var isHidden = function(elm) {
        return $$(elm).css("display") === "none";
      };
      var uniqueId2 = function(prefix) {
        return (!prefix ? "mce_" : prefix) + counter++;
      };
      var getOuterHTML = function(elm) {
        var node = typeof elm === "string" ? get2(elm) : elm;
        return isElement$1(node) ? node.outerHTML : DomQuery("<div></div>").append(DomQuery(node).clone()).html();
      };
      var setOuterHTML = function(elm, html) {
        $$(elm).each(function() {
          try {
            if ("outerHTML" in this) {
              this.outerHTML = html;
              return;
            }
          } catch (ex) {
          }
          remove2(DomQuery(this).html(html), true);
        });
      };
      var insertAfter2 = function(node, reference) {
        var referenceNode = get2(reference);
        return run(node, function(node2) {
          var parent2 = referenceNode.parentNode;
          var nextSibling2 = referenceNode.nextSibling;
          if (nextSibling2) {
            parent2.insertBefore(node2, nextSibling2);
          } else {
            parent2.appendChild(node2);
          }
          return node2;
        });
      };
      var replace = function(newElm, oldElm, keepChildren) {
        return run(oldElm, function(oldElm2) {
          if (Tools.is(oldElm2, "array")) {
            newElm = newElm.cloneNode(true);
          }
          if (keepChildren) {
            each$5(grep$1(oldElm2.childNodes), function(node) {
              newElm.appendChild(node);
            });
          }
          return oldElm2.parentNode.replaceChild(newElm, oldElm2);
        });
      };
      var rename = function(elm, name2) {
        var newElm;
        if (elm.nodeName !== name2.toUpperCase()) {
          newElm = create2(name2);
          each$5(getAttribs(elm), function(attrNode) {
            setAttrib(newElm, attrNode.nodeName, getAttrib(elm, attrNode.nodeName));
          });
          replace(newElm, elm, true);
        }
        return newElm || elm;
      };
      var findCommonAncestor = function(a, b) {
        var ps = a, pe;
        while (ps) {
          pe = b;
          while (pe && ps !== pe) {
            pe = pe.parentNode;
          }
          if (ps === pe) {
            break;
          }
          ps = ps.parentNode;
        }
        if (!ps && a.ownerDocument) {
          return a.ownerDocument.documentElement;
        }
        return ps;
      };
      var toHex2 = function(rgbVal) {
        return styles.toHex(Tools.trim(rgbVal));
      };
      var isNonEmptyElement2 = function(node) {
        if (isElement$1(node)) {
          var isNamedAnchor2 = node.nodeName.toLowerCase() === "a" && !getAttrib(node, "href") && getAttrib(node, "id");
          if (getAttrib(node, "name") || getAttrib(node, "data-mce-bookmark") || isNamedAnchor2) {
            return true;
          }
        }
        return false;
      };
      var isEmpty2 = function(node, elements) {
        var type2, name2, brCount = 0;
        if (isNonEmptyElement2(node)) {
          return false;
        }
        node = node.firstChild;
        if (node) {
          var walker = new DomTreeWalker(node, node.parentNode);
          var whitespace2 = schema ? schema.getWhiteSpaceElements() : {};
          elements = elements || (schema ? schema.getNonEmptyElements() : null);
          do {
            type2 = node.nodeType;
            if (isElement$1(node)) {
              var bogusVal = node.getAttribute("data-mce-bogus");
              if (bogusVal) {
                node = walker.next(bogusVal === "all");
                continue;
              }
              name2 = node.nodeName.toLowerCase();
              if (elements && elements[name2]) {
                if (name2 === "br") {
                  brCount++;
                  node = walker.next();
                  continue;
                }
                return false;
              }
              if (isNonEmptyElement2(node)) {
                return false;
              }
            }
            if (type2 === 8) {
              return false;
            }
            if (type2 === 3 && !isWhitespaceText(node.nodeValue)) {
              return false;
            }
            if (type2 === 3 && node.parentNode && whitespace2[node.parentNode.nodeName] && isWhitespaceText(node.nodeValue)) {
              return false;
            }
            node = walker.next();
          } while (node);
        }
        return brCount <= 1;
      };
      var createRng = function() {
        return doc2.createRange();
      };
      var split2 = function(parentElm, splitElm, replacementElm) {
        var range2 = createRng();
        var beforeFragment;
        var afterFragment;
        var parentNode;
        if (parentElm && splitElm) {
          range2.setStart(parentElm.parentNode, findNodeIndex(parentElm));
          range2.setEnd(splitElm.parentNode, findNodeIndex(splitElm));
          beforeFragment = range2.extractContents();
          range2 = createRng();
          range2.setStart(splitElm.parentNode, findNodeIndex(splitElm) + 1);
          range2.setEnd(parentElm.parentNode, findNodeIndex(parentElm) + 1);
          afterFragment = range2.extractContents();
          parentNode = parentElm.parentNode;
          parentNode.insertBefore(trimNode(self2, beforeFragment), parentElm);
          if (replacementElm) {
            parentNode.insertBefore(replacementElm, parentElm);
          } else {
            parentNode.insertBefore(splitElm, parentElm);
          }
          parentNode.insertBefore(trimNode(self2, afterFragment), parentElm);
          remove2(parentElm);
          return replacementElm || splitElm;
        }
      };
      var bind2 = function(target, name2, func, scope) {
        if (Tools.isArray(target)) {
          var i = target.length;
          var rv = [];
          while (i--) {
            rv[i] = bind2(target[i], name2, func, scope);
          }
          return rv;
        }
        if (settings.collect && (target === doc2 || target === win)) {
          boundEvents.push([
            target,
            name2,
            func,
            scope
          ]);
        }
        var output = events.bind(target, name2, func, scope || self2);
        return output;
      };
      var unbind = function(target, name2, func) {
        if (Tools.isArray(target)) {
          var i = target.length;
          var rv = [];
          while (i--) {
            rv[i] = unbind(target[i], name2, func);
          }
          return rv;
        } else {
          if (boundEvents.length > 0 && (target === doc2 || target === win)) {
            var i = boundEvents.length;
            while (i--) {
              var item = boundEvents[i];
              if (target === item[0] && (!name2 || name2 === item[1]) && (!func || func === item[2])) {
                events.unbind(item[0], item[1], item[2]);
              }
            }
          }
          return events.unbind(target, name2, func);
        }
      };
      var fire = function(target, name2, evt) {
        return events.fire(target, name2, evt);
      };
      var getContentEditable = function(node) {
        if (node && isElement$1(node)) {
          var contentEditable = node.getAttribute("data-mce-contenteditable");
          if (contentEditable && contentEditable !== "inherit") {
            return contentEditable;
          }
          return node.contentEditable !== "inherit" ? node.contentEditable : null;
        } else {
          return null;
        }
      };
      var getContentEditableParent = function(node) {
        var root = getRoot();
        var state = null;
        for (; node && node !== root; node = node.parentNode) {
          state = getContentEditable(node);
          if (state !== null) {
            break;
          }
        }
        return state;
      };
      var destroy2 = function() {
        if (boundEvents.length > 0) {
          var i = boundEvents.length;
          while (i--) {
            var item = boundEvents[i];
            events.unbind(item[0], item[1], item[2]);
          }
        }
        each$1(files, function(_, url) {
          styleSheetLoader.unload(url);
          delete files[url];
        });
        if (Sizzle.setDocument) {
          Sizzle.setDocument();
        }
      };
      var isChildOf = function(node, parent2) {
        while (node) {
          if (parent2 === node) {
            return true;
          }
          node = node.parentNode;
        }
        return false;
      };
      var dumpRng = function(r2) {
        return "startContainer: " + r2.startContainer.nodeName + ", startOffset: " + r2.startOffset + ", endContainer: " + r2.endContainer.nodeName + ", endOffset: " + r2.endOffset;
      };
      var self2 = {
        doc: doc2,
        settings,
        win,
        files,
        stdMode,
        boxModel,
        styleSheetLoader,
        boundEvents,
        styles,
        schema,
        events,
        isBlock: isBlock2,
        $,
        $$,
        root: null,
        clone: clone2,
        getRoot,
        getViewPort,
        getRect,
        getSize,
        getParent,
        getParents: getParents2,
        get: get2,
        getNext,
        getPrev,
        select: select2,
        is: is2,
        add: add2,
        create: create2,
        createHTML,
        createFragment: createFragment2,
        remove: remove2,
        setStyle,
        getStyle: getStyle2,
        setStyles,
        removeAllAttribs,
        setAttrib,
        setAttribs,
        getAttrib,
        getPos: getPos$1,
        parseStyle,
        serializeStyle,
        addStyle,
        loadCSS,
        addClass,
        removeClass,
        hasClass: hasClass2,
        toggleClass: toggleClass2,
        show,
        hide,
        isHidden,
        uniqueId: uniqueId2,
        setHTML,
        getOuterHTML,
        setOuterHTML,
        decode: decode2,
        encode,
        insertAfter: insertAfter2,
        replace,
        rename,
        findCommonAncestor,
        toHex: toHex2,
        run,
        getAttribs,
        isEmpty: isEmpty2,
        createRng,
        nodeIndex: findNodeIndex,
        split: split2,
        bind: bind2,
        unbind,
        fire,
        getContentEditable,
        getContentEditableParent,
        destroy: destroy2,
        isChildOf,
        dumpRng
      };
      var attrHooks2 = setupAttrHooks(styles, settings, function() {
        return self2;
      });
      return self2;
    };
    DOMUtils.DOM = DOMUtils(document);
    DOMUtils.nodeIndex = findNodeIndex;
    var DOM = DOMUtils.DOM;
    var each$6 = Tools.each, grep$2 = Tools.grep;
    var QUEUED = 0;
    var LOADING = 1;
    var LOADED = 2;
    var FAILED = 3;
    var ScriptLoader2 = function() {
      function ScriptLoader3(settings) {
        if (settings === void 0) {
          settings = {};
        }
        this.states = {};
        this.queue = [];
        this.scriptLoadedCallbacks = {};
        this.queueLoadedCallbacks = [];
        this.loading = 0;
        this.settings = settings;
      }
      ScriptLoader3.prototype._setReferrerPolicy = function(referrerPolicy) {
        this.settings.referrerPolicy = referrerPolicy;
      };
      ScriptLoader3.prototype.loadScript = function(url, success, failure) {
        var dom2 = DOM;
        var elm;
        var cleanup = function() {
          dom2.remove(id);
          if (elm) {
            elm.onerror = elm.onload = elm = null;
          }
        };
        var done2 = function() {
          cleanup();
          success();
        };
        var error2 = function() {
          cleanup();
          if (isFunction(failure)) {
            failure();
          } else {
            if (typeof console !== "undefined" && console.log) {
              console.log("Failed to load script: " + url);
            }
          }
        };
        var id = dom2.uniqueId();
        elm = document.createElement("script");
        elm.id = id;
        elm.type = "text/javascript";
        elm.src = Tools._addCacheSuffix(url);
        if (this.settings.referrerPolicy) {
          dom2.setAttrib(elm, "referrerpolicy", this.settings.referrerPolicy);
        }
        elm.onload = done2;
        elm.onerror = error2;
        (document.getElementsByTagName("head")[0] || document.body).appendChild(elm);
      };
      ScriptLoader3.prototype.isDone = function(url) {
        return this.states[url] === LOADED;
      };
      ScriptLoader3.prototype.markDone = function(url) {
        this.states[url] = LOADED;
      };
      ScriptLoader3.prototype.add = function(url, success, scope, failure) {
        var state = this.states[url];
        this.queue.push(url);
        if (state === void 0) {
          this.states[url] = QUEUED;
        }
        if (success) {
          if (!this.scriptLoadedCallbacks[url]) {
            this.scriptLoadedCallbacks[url] = [];
          }
          this.scriptLoadedCallbacks[url].push({
            success,
            failure,
            scope: scope || this
          });
        }
      };
      ScriptLoader3.prototype.load = function(url, success, scope, failure) {
        return this.add(url, success, scope, failure);
      };
      ScriptLoader3.prototype.remove = function(url) {
        delete this.states[url];
        delete this.scriptLoadedCallbacks[url];
      };
      ScriptLoader3.prototype.loadQueue = function(success, scope, failure) {
        this.loadScripts(this.queue, success, scope, failure);
      };
      ScriptLoader3.prototype.loadScripts = function(scripts, success, scope, failure) {
        var self2 = this;
        var failures = [];
        var execCallbacks = function(name2, url) {
          each$6(self2.scriptLoadedCallbacks[url], function(callback) {
            if (isFunction(callback[name2])) {
              callback[name2].call(callback.scope);
            }
          });
          self2.scriptLoadedCallbacks[url] = void 0;
        };
        self2.queueLoadedCallbacks.push({
          success,
          failure,
          scope: scope || this
        });
        var loadScripts2 = function() {
          var loadingScripts = grep$2(scripts);
          scripts.length = 0;
          each$6(loadingScripts, function(url) {
            if (self2.states[url] === LOADED) {
              execCallbacks("success", url);
              return;
            }
            if (self2.states[url] === FAILED) {
              execCallbacks("failure", url);
              return;
            }
            if (self2.states[url] !== LOADING) {
              self2.states[url] = LOADING;
              self2.loading++;
              self2.loadScript(url, function() {
                self2.states[url] = LOADED;
                self2.loading--;
                execCallbacks("success", url);
                loadScripts2();
              }, function() {
                self2.states[url] = FAILED;
                self2.loading--;
                failures.push(url);
                execCallbacks("failure", url);
                loadScripts2();
              });
            }
          });
          if (!self2.loading) {
            var notifyCallbacks = self2.queueLoadedCallbacks.slice(0);
            self2.queueLoadedCallbacks.length = 0;
            each$6(notifyCallbacks, function(callback) {
              if (failures.length === 0) {
                if (isFunction(callback.success)) {
                  callback.success.call(callback.scope);
                }
              } else {
                if (isFunction(callback.failure)) {
                  callback.failure.call(callback.scope, failures);
                }
              }
            });
          }
        };
        loadScripts2();
      };
      ScriptLoader3.ScriptLoader = new ScriptLoader3();
      return ScriptLoader3;
    }();
    var Cell = function(initial) {
      var value2 = initial;
      var get2 = function() {
        return value2;
      };
      var set2 = function(v) {
        value2 = v;
      };
      return {
        get: get2,
        set: set2
      };
    };
    var isRaw = function(str) {
      return isObject(str) && has(str, "raw");
    };
    var isTokenised = function(str) {
      return isArray(str) && str.length > 1;
    };
    var data = {};
    var currentCode = Cell("en");
    var getLanguageData = function() {
      return get$1(data, currentCode.get());
    };
    var getData = function() {
      return map$1(data, function(value2) {
        return __assign2({}, value2);
      });
    };
    var setCode = function(newCode) {
      if (newCode) {
        currentCode.set(newCode);
      }
    };
    var getCode = function() {
      return currentCode.get();
    };
    var add = function(code, items) {
      var langData = data[code];
      if (!langData) {
        data[code] = langData = {};
      }
      each$1(items, function(translation, name2) {
        langData[name2.toLowerCase()] = translation;
      });
    };
    var translate = function(text) {
      var langData = getLanguageData().getOr({});
      var toString = function(obj) {
        if (isFunction(obj)) {
          return Object.prototype.toString.call(obj);
        }
        return !isEmpty2(obj) ? "" + obj : "";
      };
      var isEmpty2 = function(text2) {
        return text2 === "" || text2 === null || text2 === void 0;
      };
      var getLangData = function(text2) {
        var textstr = toString(text2);
        return get$1(langData, textstr.toLowerCase()).map(toString).getOr(textstr);
      };
      var removeContext = function(str) {
        return str.replace(/{context:\w+}$/, "");
      };
      if (isEmpty2(text)) {
        return "";
      }
      if (isRaw(text)) {
        return toString(text.raw);
      }
      if (isTokenised(text)) {
        var values_1 = text.slice(1);
        var substitued = getLangData(text[0]).replace(/\{([0-9]+)\}/g, function($1, $2) {
          return has(values_1, $2) ? toString(values_1[$2]) : $1;
        });
        return removeContext(substitued);
      }
      return removeContext(getLangData(text));
    };
    var isRtl = function() {
      return getLanguageData().bind(function(items) {
        return get$1(items, "_dir");
      }).exists(function(dir2) {
        return dir2 === "rtl";
      });
    };
    var hasCode = function(code) {
      return has(data, code);
    };
    var I18n = {
      getData,
      setCode,
      getCode,
      add,
      translate,
      isRtl,
      hasCode
    };
    var AddOnManager = function() {
      var items = [];
      var urls = {};
      var lookup = {};
      var _listeners = [];
      var runListeners = function(name2, state) {
        var matchedListeners = filter(_listeners, function(listener) {
          return listener.name === name2 && listener.state === state;
        });
        each(matchedListeners, function(listener) {
          return listener.callback();
        });
      };
      var get2 = function(name2) {
        if (lookup[name2]) {
          return lookup[name2].instance;
        }
        return void 0;
      };
      var dependencies = function(name2) {
        var result;
        if (lookup[name2]) {
          result = lookup[name2].dependencies;
        }
        return result || [];
      };
      var requireLangPack = function(name2, languages) {
        if (AddOnManager.languageLoad !== false) {
          waitFor(name2, function() {
            var language = I18n.getCode();
            var wrappedLanguages = "," + (languages || "") + ",";
            if (!language || languages && wrappedLanguages.indexOf("," + language + ",") === -1) {
              return;
            }
            ScriptLoader2.ScriptLoader.add(urls[name2] + "/langs/" + language + ".js");
          }, "loaded");
        }
      };
      var add2 = function(id, addOn, dependencies2) {
        var addOnConstructor = addOn;
        items.push(addOnConstructor);
        lookup[id] = {
          instance: addOnConstructor,
          dependencies: dependencies2
        };
        runListeners(id, "added");
        return addOnConstructor;
      };
      var remove2 = function(name2) {
        delete urls[name2];
        delete lookup[name2];
      };
      var createUrl = function(baseUrl, dep) {
        if (typeof dep === "object") {
          return dep;
        }
        return typeof baseUrl === "string" ? {
          prefix: "",
          resource: dep,
          suffix: ""
        } : {
          prefix: baseUrl.prefix,
          resource: dep,
          suffix: baseUrl.suffix
        };
      };
      var addComponents = function(pluginName, scripts) {
        var pluginUrl = urls[pluginName];
        each(scripts, function(script) {
          ScriptLoader2.ScriptLoader.add(pluginUrl + "/" + script);
        });
      };
      var loadDependencies = function(name2, addOnUrl, success, scope) {
        var deps = dependencies(name2);
        each(deps, function(dep) {
          var newUrl = createUrl(addOnUrl, dep);
          load(newUrl.resource, newUrl, void 0, void 0);
        });
        if (success) {
          if (scope) {
            success.call(scope);
          } else {
            success.call(ScriptLoader2);
          }
        }
      };
      var load = function(name2, addOnUrl, success, scope, failure) {
        if (urls[name2]) {
          return;
        }
        var urlString = typeof addOnUrl === "string" ? addOnUrl : addOnUrl.prefix + addOnUrl.resource + addOnUrl.suffix;
        if (urlString.indexOf("/") !== 0 && urlString.indexOf("://") === -1) {
          urlString = AddOnManager.baseURL + "/" + urlString;
        }
        urls[name2] = urlString.substring(0, urlString.lastIndexOf("/"));
        var done2 = function() {
          runListeners(name2, "loaded");
          loadDependencies(name2, addOnUrl, success, scope);
        };
        if (lookup[name2]) {
          done2();
        } else {
          ScriptLoader2.ScriptLoader.add(urlString, done2, scope, failure);
        }
      };
      var waitFor = function(name2, callback, state) {
        if (state === void 0) {
          state = "added";
        }
        if (has(lookup, name2) && state === "added") {
          callback();
        } else if (has(urls, name2) && state === "loaded") {
          callback();
        } else {
          _listeners.push({
            name: name2,
            state,
            callback
          });
        }
      };
      return {
        items,
        urls,
        lookup,
        _listeners,
        get: get2,
        dependencies,
        requireLangPack,
        add: add2,
        remove: remove2,
        createUrl,
        addComponents,
        load,
        waitFor
      };
    };
    AddOnManager.languageLoad = true;
    AddOnManager.baseURL = "";
    AddOnManager.PluginManager = AddOnManager();
    AddOnManager.ThemeManager = AddOnManager();
    var first = function(fn, rate) {
      var timer = null;
      var cancel = function() {
        if (timer !== null) {
          clearTimeout(timer);
          timer = null;
        }
      };
      var throttle = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (timer === null) {
          timer = setTimeout(function() {
            fn.apply(null, args);
            timer = null;
          }, rate);
        }
      };
      return {
        cancel,
        throttle
      };
    };
    var last$2 = function(fn, rate) {
      var timer = null;
      var cancel = function() {
        if (timer !== null) {
          clearTimeout(timer);
          timer = null;
        }
      };
      var throttle = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (timer !== null) {
          clearTimeout(timer);
        }
        timer = setTimeout(function() {
          fn.apply(null, args);
          timer = null;
        }, rate);
      };
      return {
        cancel,
        throttle
      };
    };
    var read = function(element, attr) {
      var value2 = get$4(element, attr);
      return value2 === void 0 || value2 === "" ? [] : value2.split(" ");
    };
    var add$1 = function(element, attr, id) {
      var old = read(element, attr);
      var nu2 = old.concat([id]);
      set(element, attr, nu2.join(" "));
      return true;
    };
    var remove$2 = function(element, attr, id) {
      var nu2 = filter(read(element, attr), function(v) {
        return v !== id;
      });
      if (nu2.length > 0) {
        set(element, attr, nu2.join(" "));
      } else {
        remove$1(element, attr);
      }
      return false;
    };
    var supports = function(element) {
      return element.dom.classList !== void 0;
    };
    var get$6 = function(element) {
      return read(element, "class");
    };
    var add$2 = function(element, clazz) {
      return add$1(element, "class", clazz);
    };
    var remove$3 = function(element, clazz) {
      return remove$2(element, "class", clazz);
    };
    var add$3 = function(element, clazz) {
      if (supports(element)) {
        element.dom.classList.add(clazz);
      } else {
        add$2(element, clazz);
      }
    };
    var cleanClass = function(element) {
      var classList = supports(element) ? element.dom.classList : get$6(element);
      if (classList.length === 0) {
        remove$1(element, "class");
      }
    };
    var remove$4 = function(element, clazz) {
      if (supports(element)) {
        var classList = element.dom.classList;
        classList.remove(clazz);
      } else {
        remove$3(element, clazz);
      }
      cleanClass(element);
    };
    var has$2 = function(element, clazz) {
      return supports(element) && element.dom.classList.contains(clazz);
    };
    var descendants = function(scope, predicate) {
      var result = [];
      each(children(scope), function(x) {
        if (predicate(x)) {
          result = result.concat([x]);
        }
        result = result.concat(descendants(x, predicate));
      });
      return result;
    };
    var descendants$1 = function(scope, selector) {
      return all(selector, scope);
    };
    var annotation = constant("mce-annotation");
    var dataAnnotation = constant("data-mce-annotation");
    var dataAnnotationId = constant("data-mce-annotation-uid");
    var identify = function(editor, annotationName) {
      var rng = editor.selection.getRng();
      var start2 = SugarElement.fromDom(rng.startContainer);
      var root = SugarElement.fromDom(editor.getBody());
      var selector = annotationName.fold(function() {
        return "." + annotation();
      }, function(an) {
        return "[" + dataAnnotation() + '="' + an + '"]';
      });
      var newStart = child(start2, rng.startOffset).getOr(start2);
      var closest2 = closest$1(newStart, selector, function(n) {
        return eq$2(n, root);
      });
      var getAttr = function(c, property) {
        if (has$1(c, property)) {
          return Optional.some(get$4(c, property));
        } else {
          return Optional.none();
        }
      };
      return closest2.bind(function(c) {
        return getAttr(c, "" + dataAnnotationId()).bind(function(uid) {
          return getAttr(c, "" + dataAnnotation()).map(function(name2) {
            var elements = findMarkers(editor, uid);
            return {
              uid,
              name: name2,
              elements
            };
          });
        });
      });
    };
    var isAnnotation = function(elem) {
      return isElement(elem) && has$2(elem, annotation());
    };
    var findMarkers = function(editor, uid) {
      var body = SugarElement.fromDom(editor.getBody());
      return descendants$1(body, "[" + dataAnnotationId() + '="' + uid + '"]');
    };
    var findAll = function(editor, name2) {
      var body = SugarElement.fromDom(editor.getBody());
      var markers = descendants$1(body, "[" + dataAnnotation() + '="' + name2 + '"]');
      var directory = {};
      each(markers, function(m) {
        var uid = get$4(m, dataAnnotationId());
        var nodesAlready = directory.hasOwnProperty(uid) ? directory[uid] : [];
        directory[uid] = nodesAlready.concat([m]);
      });
      return directory;
    };
    var setup = function(editor, _registry) {
      var changeCallbacks = Cell({});
      var initData = function() {
        return {
          listeners: [],
          previous: Cell(Optional.none())
        };
      };
      var withCallbacks = function(name2, f) {
        updateCallbacks(name2, function(data2) {
          f(data2);
          return data2;
        });
      };
      var updateCallbacks = function(name2, f) {
        var callbackMap = changeCallbacks.get();
        var data2 = callbackMap.hasOwnProperty(name2) ? callbackMap[name2] : initData();
        var outputData = f(data2);
        callbackMap[name2] = outputData;
        changeCallbacks.set(callbackMap);
      };
      var fireCallbacks = function(name2, uid, elements) {
        withCallbacks(name2, function(data2) {
          each(data2.listeners, function(f) {
            return f(true, name2, {
              uid,
              nodes: map(elements, function(elem) {
                return elem.dom;
              })
            });
          });
        });
      };
      var fireNoAnnotation = function(name2) {
        withCallbacks(name2, function(data2) {
          each(data2.listeners, function(f) {
            return f(false, name2);
          });
        });
      };
      var onNodeChange = last$2(function() {
        var callbackMap = changeCallbacks.get();
        var annotations = sort$1(keys(callbackMap));
        each(annotations, function(name2) {
          updateCallbacks(name2, function(data2) {
            var prev = data2.previous.get();
            identify(editor, Optional.some(name2)).fold(function() {
              if (prev.isSome()) {
                fireNoAnnotation(name2);
                data2.previous.set(Optional.none());
              }
            }, function(_a) {
              var uid = _a.uid, name3 = _a.name, elements = _a.elements;
              if (!prev.is(uid)) {
                fireCallbacks(name3, uid, elements);
                data2.previous.set(Optional.some(uid));
              }
            });
            return {
              previous: data2.previous,
              listeners: data2.listeners
            };
          });
        });
      }, 30);
      editor.on("remove", function() {
        onNodeChange.cancel();
      });
      editor.on("NodeChange", function() {
        onNodeChange.throttle();
      });
      var addListener = function(name2, f) {
        updateCallbacks(name2, function(data2) {
          return {
            previous: data2.previous,
            listeners: data2.listeners.concat([f])
          };
        });
      };
      return { addListener };
    };
    var setup$1 = function(editor, registry2) {
      var identifyParserNode = function(span) {
        return Optional.from(span.attr(dataAnnotation())).bind(registry2.lookup);
      };
      editor.on("init", function() {
        editor.serializer.addNodeFilter("span", function(spans) {
          each(spans, function(span) {
            identifyParserNode(span).each(function(settings) {
              if (settings.persistent === false) {
                span.unwrap();
              }
            });
          });
        });
      });
    };
    var create$2 = function() {
      var annotations = {};
      var register2 = function(name2, settings) {
        annotations[name2] = {
          name: name2,
          settings
        };
      };
      var lookup = function(name2) {
        return annotations.hasOwnProperty(name2) ? Optional.from(annotations[name2]).map(function(a) {
          return a.settings;
        }) : Optional.none();
      };
      return {
        register: register2,
        lookup
      };
    };
    var unique2 = 0;
    var generate$1 = function(prefix) {
      var date = new Date();
      var time = date.getTime();
      var random = Math.floor(Math.random() * 1e9);
      unique2++;
      return prefix + "_" + random + unique2 + String(time);
    };
    var add$4 = function(element, classes) {
      each(classes, function(x) {
        add$3(element, x);
      });
    };
    var fromHtml$1 = function(html, scope) {
      var doc2 = scope || document;
      var div = doc2.createElement("div");
      div.innerHTML = html;
      return children(SugarElement.fromDom(div));
    };
    var get$7 = function(element) {
      return element.dom.innerHTML;
    };
    var set$1 = function(element, content) {
      var owner$12 = owner(element);
      var docDom = owner$12.dom;
      var fragment = SugarElement.fromDom(docDom.createDocumentFragment());
      var contentElements = fromHtml$1(content, docDom);
      append$1(fragment, contentElements);
      empty(element);
      append(element, fragment);
    };
    var clone$1 = function(original, isDeep) {
      return SugarElement.fromDom(original.dom.cloneNode(isDeep));
    };
    var shallow = function(original) {
      return clone$1(original, false);
    };
    var deep = function(original) {
      return clone$1(original, true);
    };
    var TextWalker = function(startNode, rootNode, isBoundary) {
      if (isBoundary === void 0) {
        isBoundary = never;
      }
      var walker = new DomTreeWalker(startNode, rootNode);
      var walk2 = function(direction) {
        var next;
        do {
          next = walker[direction]();
        } while (next && !isText$1(next) && !isBoundary(next));
        return Optional.from(next).filter(isText$1);
      };
      return {
        current: function() {
          return Optional.from(walker.current()).filter(isText$1);
        },
        next: function() {
          return walk2("next");
        },
        prev: function() {
          return walk2("prev");
        },
        prev2: function() {
          return walk2("prev2");
        }
      };
    };
    var TextSeeker = function(dom2, isBoundary) {
      var isBlockBoundary = isBoundary ? isBoundary : function(node) {
        return dom2.isBlock(node) || isBr(node) || isContentEditableFalse(node);
      };
      var walk2 = function(node, offset, walker, process2) {
        if (isText$1(node)) {
          var newOffset = process2(node, offset, node.data);
          if (newOffset !== -1) {
            return Optional.some({
              container: node,
              offset: newOffset
            });
          }
        }
        return walker().bind(function(next) {
          return walk2(next.container, next.offset, walker, process2);
        });
      };
      var backwards = function(node, offset, process2, root) {
        var walker = TextWalker(node, root, isBlockBoundary);
        return walk2(node, offset, function() {
          return walker.prev().map(function(prev) {
            return {
              container: prev,
              offset: prev.length
            };
          });
        }, process2).getOrNull();
      };
      var forwards = function(node, offset, process2, root) {
        var walker = TextWalker(node, root, isBlockBoundary);
        return walk2(node, offset, function() {
          return walker.next().map(function(next) {
            return {
              container: next,
              offset: 0
            };
          });
        }, process2).getOrNull();
      };
      return {
        backwards,
        forwards
      };
    };
    var cat = function(arr2) {
      var r2 = [];
      var push2 = function(x) {
        r2.push(x);
      };
      for (var i = 0; i < arr2.length; i++) {
        arr2[i].each(push2);
      }
      return r2;
    };
    var lift2 = function(oa, ob, f) {
      return oa.isSome() && ob.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie())) : Optional.none();
    };
    var lift3 = function(oa, ob, oc, f) {
      return oa.isSome() && ob.isSome() && oc.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie(), oc.getOrDie())) : Optional.none();
    };
    var someIf = function(b, a) {
      return b ? Optional.some(a) : Optional.none();
    };
    var round = Math.round;
    var clone$2 = function(rect) {
      if (!rect) {
        return {
          left: 0,
          top: 0,
          bottom: 0,
          right: 0,
          width: 0,
          height: 0
        };
      }
      return {
        left: round(rect.left),
        top: round(rect.top),
        bottom: round(rect.bottom),
        right: round(rect.right),
        width: round(rect.width),
        height: round(rect.height)
      };
    };
    var collapse = function(rect, toStart) {
      rect = clone$2(rect);
      if (toStart) {
        rect.right = rect.left;
      } else {
        rect.left = rect.left + rect.width;
        rect.right = rect.left;
      }
      rect.width = 0;
      return rect;
    };
    var isEqual = function(rect1, rect2) {
      return rect1.left === rect2.left && rect1.top === rect2.top && rect1.bottom === rect2.bottom && rect1.right === rect2.right;
    };
    var isValidOverflow = function(overflowY, rect1, rect2) {
      return overflowY >= 0 && overflowY <= Math.min(rect1.height, rect2.height) / 2;
    };
    var isAbove = function(rect1, rect2) {
      var halfHeight = Math.min(rect2.height / 2, rect1.height / 2);
      if (rect1.bottom - halfHeight < rect2.top) {
        return true;
      }
      if (rect1.top > rect2.bottom) {
        return false;
      }
      return isValidOverflow(rect2.top - rect1.bottom, rect1, rect2);
    };
    var isBelow = function(rect1, rect2) {
      if (rect1.top > rect2.bottom) {
        return true;
      }
      if (rect1.bottom < rect2.top) {
        return false;
      }
      return isValidOverflow(rect2.bottom - rect1.top, rect1, rect2);
    };
    var containsXY = function(rect, clientX, clientY) {
      return clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;
    };
    var getSelectedNode = function(range2) {
      var startContainer = range2.startContainer, startOffset = range2.startOffset;
      if (startContainer.hasChildNodes() && range2.endOffset === startOffset + 1) {
        return startContainer.childNodes[startOffset];
      }
      return null;
    };
    var getNode = function(container, offset) {
      if (container.nodeType === 1 && container.hasChildNodes()) {
        if (offset >= container.childNodes.length) {
          offset = container.childNodes.length - 1;
        }
        container = container.childNodes[offset];
      }
      return container;
    };
    var extendingChars = new RegExp("[\u0300-\u036F\u0483-\u0487\u0488-\u0489\u0591-\u05BD\u05BF\u05C1-\u05C2\u05C4-\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7-\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962-\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2-\u09E3\u0A01-\u0A02\u0A3C\u0A41-\u0A42\u0A47-\u0A48\u0A4B-\u0A4D\u0A51\u0A70-\u0A71\u0A75\u0A81-\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7-\u0AC8\u0ACD\u0AE2-\u0AE3\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B57\u0B62-\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55-\u0C56\u0C62-\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC-\u0CCD\u0CD5-\u0CD6\u0CE2-\u0CE3\u0D01\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62-\u0D63\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB-\u0EBC\u0EC8-\u0ECD\u0F18-\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86-\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039-\u103A\u103D-\u103E\u1058-\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085-\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752-\u1753\u1772-\u1773\u17B4-\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u1922\u1927-\u1928\u1932\u1939-\u193B\u1A17-\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ABD\u1ABE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80-\u1B81\u1BA2-\u1BA5\u1BA8-\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8-\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8-\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u200C-\u200D\u20D0-\u20DC\u20DD-\u20E0\u20E1\u20E2-\u20E4\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u302E-\u302F\u3099-\u309A\uA66F\uA670-\uA672\uA674-\uA67D\uA69E-\uA69F\uA6F0-\uA6F1\uA802\uA806\uA80B\uA825-\uA826\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9E5\uAA29-\uAA2E\uAA31-\uAA32\uAA35-\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7-\uAAB8\uAABE-\uAABF\uAAC1\uAAEC-\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E-\uFF9F]");
    var isExtendingChar = function(ch) {
      return typeof ch === "string" && ch.charCodeAt(0) >= 768 && extendingChars.test(ch);
    };
    var or = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return function(x) {
        for (var i = 0; i < args.length; i++) {
          if (args[i](x)) {
            return true;
          }
        }
        return false;
      };
    };
    var and = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return function(x) {
        for (var i = 0; i < args.length; i++) {
          if (!args[i](x)) {
            return false;
          }
        }
        return true;
      };
    };
    var isElement$3 = isElement$1;
    var isCaretCandidate$1 = isCaretCandidate;
    var isBlock$1 = matchStyleValues("display", "block table");
    var isFloated = matchStyleValues("float", "left right");
    var isValidElementCaretCandidate = and(isElement$3, isCaretCandidate$1, not(isFloated));
    var isNotPre = not(matchStyleValues("white-space", "pre pre-line pre-wrap"));
    var isText$4 = isText$1;
    var isBr$3 = isBr;
    var nodeIndex = DOMUtils.nodeIndex;
    var resolveIndex = getNode;
    var createRange = function(doc2) {
      return "createRange" in doc2 ? doc2.createRange() : DOMUtils.DOM.createRng();
    };
    var isWhiteSpace = function(chr) {
      return chr && /[\r\n\t ]/.test(chr);
    };
    var isRange = function(rng) {
      return !!rng.setStart && !!rng.setEnd;
    };
    var isHiddenWhiteSpaceRange = function(range2) {
      var container = range2.startContainer;
      var offset = range2.startOffset;
      var text;
      if (isWhiteSpace(range2.toString()) && isNotPre(container.parentNode) && isText$1(container)) {
        text = container.data;
        if (isWhiteSpace(text[offset - 1]) || isWhiteSpace(text[offset + 1])) {
          return true;
        }
      }
      return false;
    };
    var getBrClientRect = function(brNode) {
      var doc2 = brNode.ownerDocument;
      var rng = createRange(doc2);
      var nbsp$1 = doc2.createTextNode(nbsp);
      var parentNode = brNode.parentNode;
      parentNode.insertBefore(nbsp$1, brNode);
      rng.setStart(nbsp$1, 0);
      rng.setEnd(nbsp$1, 1);
      var clientRect = clone$2(rng.getBoundingClientRect());
      parentNode.removeChild(nbsp$1);
      return clientRect;
    };
    var getBoundingClientRectWebKitText = function(rng) {
      var sc = rng.startContainer;
      var ec = rng.endContainer;
      var so = rng.startOffset;
      var eo = rng.endOffset;
      if (sc === ec && isText$1(ec) && so === 0 && eo === 1) {
        var newRng = rng.cloneRange();
        newRng.setEndAfter(ec);
        return getBoundingClientRect(newRng);
      } else {
        return null;
      }
    };
    var isZeroRect = function(r2) {
      return r2.left === 0 && r2.right === 0 && r2.top === 0 && r2.bottom === 0;
    };
    var getBoundingClientRect = function(item) {
      var clientRect;
      var clientRects = item.getClientRects();
      if (clientRects.length > 0) {
        clientRect = clone$2(clientRects[0]);
      } else {
        clientRect = clone$2(item.getBoundingClientRect());
      }
      if (!isRange(item) && isBr$3(item) && isZeroRect(clientRect)) {
        return getBrClientRect(item);
      }
      if (isZeroRect(clientRect) && isRange(item)) {
        return getBoundingClientRectWebKitText(item);
      }
      return clientRect;
    };
    var collapseAndInflateWidth = function(clientRect, toStart) {
      var newClientRect = collapse(clientRect, toStart);
      newClientRect.width = 1;
      newClientRect.right = newClientRect.left + 1;
      return newClientRect;
    };
    var getCaretPositionClientRects = function(caretPosition) {
      var clientRects = [];
      var beforeNode, node;
      var addUniqueAndValidRect = function(clientRect) {
        if (clientRect.height === 0) {
          return;
        }
        if (clientRects.length > 0) {
          if (isEqual(clientRect, clientRects[clientRects.length - 1])) {
            return;
          }
        }
        clientRects.push(clientRect);
      };
      var addCharacterOffset = function(container, offset) {
        var range2 = createRange(container.ownerDocument);
        if (offset < container.data.length) {
          if (isExtendingChar(container.data[offset])) {
            return clientRects;
          }
          if (isExtendingChar(container.data[offset - 1])) {
            range2.setStart(container, offset);
            range2.setEnd(container, offset + 1);
            if (!isHiddenWhiteSpaceRange(range2)) {
              addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(range2), false));
              return clientRects;
            }
          }
        }
        if (offset > 0) {
          range2.setStart(container, offset - 1);
          range2.setEnd(container, offset);
          if (!isHiddenWhiteSpaceRange(range2)) {
            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(range2), false));
          }
        }
        if (offset < container.data.length) {
          range2.setStart(container, offset);
          range2.setEnd(container, offset + 1);
          if (!isHiddenWhiteSpaceRange(range2)) {
            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(range2), true));
          }
        }
      };
      if (isText$4(caretPosition.container())) {
        addCharacterOffset(caretPosition.container(), caretPosition.offset());
        return clientRects;
      }
      if (isElement$3(caretPosition.container())) {
        if (caretPosition.isAtEnd()) {
          node = resolveIndex(caretPosition.container(), caretPosition.offset());
          if (isText$4(node)) {
            addCharacterOffset(node, node.data.length);
          }
          if (isValidElementCaretCandidate(node) && !isBr$3(node)) {
            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(node), false));
          }
        } else {
          node = resolveIndex(caretPosition.container(), caretPosition.offset());
          if (isText$4(node)) {
            addCharacterOffset(node, 0);
          }
          if (isValidElementCaretCandidate(node) && caretPosition.isAtEnd()) {
            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(node), false));
            return clientRects;
          }
          beforeNode = resolveIndex(caretPosition.container(), caretPosition.offset() - 1);
          if (isValidElementCaretCandidate(beforeNode) && !isBr$3(beforeNode)) {
            if (isBlock$1(beforeNode) || isBlock$1(node) || !isValidElementCaretCandidate(node)) {
              addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(beforeNode), false));
            }
          }
          if (isValidElementCaretCandidate(node)) {
            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(node), true));
          }
        }
      }
      return clientRects;
    };
    var CaretPosition = function(container, offset, clientRects) {
      var isAtStart = function() {
        if (isText$4(container)) {
          return offset === 0;
        }
        return offset === 0;
      };
      var isAtEnd = function() {
        if (isText$4(container)) {
          return offset >= container.data.length;
        }
        return offset >= container.childNodes.length;
      };
      var toRange = function() {
        var range2 = createRange(container.ownerDocument);
        range2.setStart(container, offset);
        range2.setEnd(container, offset);
        return range2;
      };
      var getClientRects2 = function() {
        if (!clientRects) {
          clientRects = getCaretPositionClientRects(CaretPosition(container, offset));
        }
        return clientRects;
      };
      var isVisible = function() {
        return getClientRects2().length > 0;
      };
      var isEqual2 = function(caretPosition) {
        return caretPosition && container === caretPosition.container() && offset === caretPosition.offset();
      };
      var getNode2 = function(before2) {
        return resolveIndex(container, before2 ? offset - 1 : offset);
      };
      return {
        container: constant(container),
        offset: constant(offset),
        toRange,
        getClientRects: getClientRects2,
        isVisible,
        isAtStart,
        isAtEnd,
        isEqual: isEqual2,
        getNode: getNode2
      };
    };
    CaretPosition.fromRangeStart = function(range2) {
      return CaretPosition(range2.startContainer, range2.startOffset);
    };
    CaretPosition.fromRangeEnd = function(range2) {
      return CaretPosition(range2.endContainer, range2.endOffset);
    };
    CaretPosition.after = function(node) {
      return CaretPosition(node.parentNode, nodeIndex(node) + 1);
    };
    CaretPosition.before = function(node) {
      return CaretPosition(node.parentNode, nodeIndex(node));
    };
    CaretPosition.isAbove = function(pos1, pos2) {
      return lift2(head(pos2.getClientRects()), last(pos1.getClientRects()), isAbove).getOr(false);
    };
    CaretPosition.isBelow = function(pos1, pos2) {
      return lift2(last(pos2.getClientRects()), head(pos1.getClientRects()), isBelow).getOr(false);
    };
    CaretPosition.isAtStart = function(pos) {
      return pos ? pos.isAtStart() : false;
    };
    CaretPosition.isAtEnd = function(pos) {
      return pos ? pos.isAtEnd() : false;
    };
    CaretPosition.isTextPosition = function(pos) {
      return pos ? isText$1(pos.container()) : false;
    };
    CaretPosition.isElementPosition = function(pos) {
      return CaretPosition.isTextPosition(pos) === false;
    };
    var trimEmptyTextNode = function(dom2, node) {
      if (isText$1(node) && node.data.length === 0) {
        dom2.remove(node);
      }
    };
    var insertNode = function(dom2, rng, node) {
      rng.insertNode(node);
      trimEmptyTextNode(dom2, node.previousSibling);
      trimEmptyTextNode(dom2, node.nextSibling);
    };
    var insertFragment = function(dom2, rng, frag) {
      var firstChild2 = Optional.from(frag.firstChild);
      var lastChild2 = Optional.from(frag.lastChild);
      rng.insertNode(frag);
      firstChild2.each(function(child2) {
        return trimEmptyTextNode(dom2, child2.previousSibling);
      });
      lastChild2.each(function(child2) {
        return trimEmptyTextNode(dom2, child2.nextSibling);
      });
    };
    var rangeInsertNode = function(dom2, rng, node) {
      if (isDocumentFragment$1(node)) {
        insertFragment(dom2, rng, node);
      } else {
        insertNode(dom2, rng, node);
      }
    };
    var isText$5 = isText$1;
    var isBogus$2 = isBogus;
    var nodeIndex$1 = DOMUtils.nodeIndex;
    var normalizedParent = function(node) {
      var parentNode = node.parentNode;
      if (isBogus$2(parentNode)) {
        return normalizedParent(parentNode);
      }
      return parentNode;
    };
    var getChildNodes = function(node) {
      if (!node) {
        return [];
      }
      return reduce(node.childNodes, function(result, node2) {
        if (isBogus$2(node2) && node2.nodeName !== "BR") {
          result = result.concat(getChildNodes(node2));
        } else {
          result.push(node2);
        }
        return result;
      }, []);
    };
    var normalizedTextOffset = function(node, offset) {
      while (node = node.previousSibling) {
        if (!isText$5(node)) {
          break;
        }
        offset += node.data.length;
      }
      return offset;
    };
    var equal$1 = function(a) {
      return function(b) {
        return a === b;
      };
    };
    var normalizedNodeIndex = function(node) {
      var nodes, index;
      nodes = getChildNodes(normalizedParent(node));
      index = findIndex$1(nodes, equal$1(node), node);
      nodes = nodes.slice(0, index + 1);
      var numTextFragments = reduce(nodes, function(result, node2, i) {
        if (isText$5(node2) && isText$5(nodes[i - 1])) {
          result++;
        }
        return result;
      }, 0);
      nodes = filter$2(nodes, matchNodeNames([node.nodeName]));
      index = findIndex$1(nodes, equal$1(node), node);
      return index - numTextFragments;
    };
    var createPathItem = function(node) {
      var name2;
      if (isText$5(node)) {
        name2 = "text()";
      } else {
        name2 = node.nodeName.toLowerCase();
      }
      return name2 + "[" + normalizedNodeIndex(node) + "]";
    };
    var parentsUntil = function(root, node, predicate) {
      var parents2 = [];
      for (node = node.parentNode; node !== root; node = node.parentNode) {
        if (predicate && predicate(node)) {
          break;
        }
        parents2.push(node);
      }
      return parents2;
    };
    var create$3 = function(root, caretPosition) {
      var container, offset, path = [], outputOffset, childNodes, parents2;
      container = caretPosition.container();
      offset = caretPosition.offset();
      if (isText$5(container)) {
        outputOffset = normalizedTextOffset(container, offset);
      } else {
        childNodes = container.childNodes;
        if (offset >= childNodes.length) {
          outputOffset = "after";
          offset = childNodes.length - 1;
        } else {
          outputOffset = "before";
        }
        container = childNodes[offset];
      }
      path.push(createPathItem(container));
      parents2 = parentsUntil(root, container);
      parents2 = filter$2(parents2, not(isBogus));
      path = path.concat(map$2(parents2, function(node) {
        return createPathItem(node);
      }));
      return path.reverse().join("/") + "," + outputOffset;
    };
    var resolvePathItem = function(node, name2, index) {
      var nodes = getChildNodes(node);
      nodes = filter$2(nodes, function(node2, index2) {
        return !isText$5(node2) || !isText$5(nodes[index2 - 1]);
      });
      nodes = filter$2(nodes, matchNodeNames([name2]));
      return nodes[index];
    };
    var findTextPosition = function(container, offset) {
      var node = container, targetOffset = 0, dataLen;
      while (isText$5(node)) {
        dataLen = node.data.length;
        if (offset >= targetOffset && offset <= targetOffset + dataLen) {
          container = node;
          offset = offset - targetOffset;
          break;
        }
        if (!isText$5(node.nextSibling)) {
          container = node;
          offset = dataLen;
          break;
        }
        targetOffset += dataLen;
        node = node.nextSibling;
      }
      if (isText$5(container) && offset > container.data.length) {
        offset = container.data.length;
      }
      return CaretPosition(container, offset);
    };
    var resolve$1 = function(root, path) {
      var offset;
      if (!path) {
        return null;
      }
      var parts = path.split(",");
      var paths = parts[0].split("/");
      offset = parts.length > 1 ? parts[1] : "before";
      var container = reduce(paths, function(result, value2) {
        var match2 = /([\w\-\(\)]+)\[([0-9]+)\]/.exec(value2);
        if (!match2) {
          return null;
        }
        if (match2[1] === "text()") {
          match2[1] = "#text";
        }
        return resolvePathItem(result, match2[1], parseInt(match2[2], 10));
      }, root);
      if (!container) {
        return null;
      }
      if (!isText$5(container)) {
        if (offset === "after") {
          offset = nodeIndex$1(container) + 1;
        } else {
          offset = nodeIndex$1(container);
        }
        return CaretPosition(container.parentNode, offset);
      }
      return findTextPosition(container, parseInt(offset, 10));
    };
    var isContentEditableFalse$2 = isContentEditableFalse;
    var getNormalizedTextOffset = function(trim2, container, offset) {
      var node, trimmedOffset;
      trimmedOffset = trim2(container.data.slice(0, offset)).length;
      for (node = container.previousSibling; node && isText$1(node); node = node.previousSibling) {
        trimmedOffset += trim2(node.data).length;
      }
      return trimmedOffset;
    };
    var getPoint = function(dom2, trim2, normalized, rng, start2) {
      var container = rng[start2 ? "startContainer" : "endContainer"];
      var offset = rng[start2 ? "startOffset" : "endOffset"];
      var point = [];
      var childNodes, after2 = 0;
      var root = dom2.getRoot();
      if (isText$1(container)) {
        point.push(normalized ? getNormalizedTextOffset(trim2, container, offset) : offset);
      } else {
        childNodes = container.childNodes;
        if (offset >= childNodes.length && childNodes.length) {
          after2 = 1;
          offset = Math.max(0, childNodes.length - 1);
        }
        point.push(dom2.nodeIndex(childNodes[offset], normalized) + after2);
      }
      for (; container && container !== root; container = container.parentNode) {
        point.push(dom2.nodeIndex(container, normalized));
      }
      return point;
    };
    var getLocation = function(trim2, selection, normalized, rng) {
      var dom2 = selection.dom, bookmark = {};
      bookmark.start = getPoint(dom2, trim2, normalized, rng, true);
      if (!selection.isCollapsed()) {
        bookmark.end = getPoint(dom2, trim2, normalized, rng, false);
      }
      return bookmark;
    };
    var findIndex$2 = function(dom2, name2, element) {
      var count2 = 0;
      Tools.each(dom2.select(name2), function(node) {
        if (node.getAttribute("data-mce-bogus") === "all") {
          return;
        }
        if (node === element) {
          return false;
        }
        count2++;
      });
      return count2;
    };
    var moveEndPoint = function(rng, start2) {
      var container, offset, childNodes;
      var prefix = start2 ? "start" : "end";
      container = rng[prefix + "Container"];
      offset = rng[prefix + "Offset"];
      if (isElement$1(container) && container.nodeName === "TR") {
        childNodes = container.childNodes;
        container = childNodes[Math.min(start2 ? offset : offset - 1, childNodes.length - 1)];
        if (container) {
          offset = start2 ? 0 : container.childNodes.length;
          rng["set" + (start2 ? "Start" : "End")](container, offset);
        }
      }
    };
    var normalizeTableCellSelection = function(rng) {
      moveEndPoint(rng, true);
      moveEndPoint(rng, false);
      return rng;
    };
    var findSibling = function(node, offset) {
      var sibling2;
      if (isElement$1(node)) {
        node = getNode(node, offset);
        if (isContentEditableFalse$2(node)) {
          return node;
        }
      }
      if (isCaretContainer(node)) {
        if (isText$1(node) && isCaretContainerBlock(node)) {
          node = node.parentNode;
        }
        sibling2 = node.previousSibling;
        if (isContentEditableFalse$2(sibling2)) {
          return sibling2;
        }
        sibling2 = node.nextSibling;
        if (isContentEditableFalse$2(sibling2)) {
          return sibling2;
        }
      }
    };
    var findAdjacentContentEditableFalseElm = function(rng) {
      return findSibling(rng.startContainer, rng.startOffset) || findSibling(rng.endContainer, rng.endOffset);
    };
    var getOffsetBookmark = function(trim2, normalized, selection) {
      var element = selection.getNode();
      var name2 = element ? element.nodeName : null;
      var rng = selection.getRng();
      if (isContentEditableFalse$2(element) || name2 === "IMG") {
        return {
          name: name2,
          index: findIndex$2(selection.dom, name2, element)
        };
      }
      var sibling2 = findAdjacentContentEditableFalseElm(rng);
      if (sibling2) {
        name2 = sibling2.tagName;
        return {
          name: name2,
          index: findIndex$2(selection.dom, name2, sibling2)
        };
      }
      return getLocation(trim2, selection, normalized, rng);
    };
    var getCaretBookmark = function(selection) {
      var rng = selection.getRng();
      return {
        start: create$3(selection.dom.getRoot(), CaretPosition.fromRangeStart(rng)),
        end: create$3(selection.dom.getRoot(), CaretPosition.fromRangeEnd(rng))
      };
    };
    var getRangeBookmark = function(selection) {
      return { rng: selection.getRng() };
    };
    var createBookmarkSpan = function(dom2, id, filled) {
      var args = {
        "data-mce-type": "bookmark",
        id,
        "style": "overflow:hidden;line-height:0px"
      };
      return filled ? dom2.create("span", args, "&#xFEFF;") : dom2.create("span", args);
    };
    var getPersistentBookmark = function(selection, filled) {
      var dom2 = selection.dom;
      var rng = selection.getRng();
      var id = dom2.uniqueId();
      var collapsed = selection.isCollapsed();
      var element = selection.getNode();
      var name2 = element.nodeName;
      if (name2 === "IMG") {
        return {
          name: name2,
          index: findIndex$2(dom2, name2, element)
        };
      }
      var rng2 = normalizeTableCellSelection(rng.cloneRange());
      if (!collapsed) {
        rng2.collapse(false);
        var endBookmarkNode = createBookmarkSpan(dom2, id + "_end", filled);
        rangeInsertNode(dom2, rng2, endBookmarkNode);
      }
      rng = normalizeTableCellSelection(rng);
      rng.collapse(true);
      var startBookmarkNode = createBookmarkSpan(dom2, id + "_start", filled);
      rangeInsertNode(dom2, rng, startBookmarkNode);
      selection.moveToBookmark({
        id,
        keep: true
      });
      return { id };
    };
    var getBookmark = function(selection, type2, normalized) {
      if (type2 === 2) {
        return getOffsetBookmark(trim$2, normalized, selection);
      } else if (type2 === 3) {
        return getCaretBookmark(selection);
      } else if (type2) {
        return getRangeBookmark(selection);
      } else {
        return getPersistentBookmark(selection, false);
      }
    };
    var getUndoBookmark = curry(getOffsetBookmark, identity, true);
    var DOM$1 = DOMUtils.DOM;
    var defaultPreviewStyles = "font-family font-size font-weight font-style text-decoration text-transform color background-color border border-radius outline text-shadow";
    var getBodySetting = function(editor, name2, defaultValue) {
      var value2 = editor.getParam(name2, defaultValue);
      if (value2.indexOf("=") !== -1) {
        var bodyObj = editor.getParam(name2, "", "hash");
        return bodyObj.hasOwnProperty(editor.id) ? bodyObj[editor.id] : defaultValue;
      } else {
        return value2;
      }
    };
    var getIframeAttrs = function(editor) {
      return editor.getParam("iframe_attrs", {});
    };
    var getDocType = function(editor) {
      return editor.getParam("doctype", "<!DOCTYPE html>");
    };
    var getDocumentBaseUrl = function(editor) {
      return editor.getParam("document_base_url", "");
    };
    var getBodyId = function(editor) {
      return getBodySetting(editor, "body_id", "tinymce");
    };
    var getBodyClass = function(editor) {
      return getBodySetting(editor, "body_class", "");
    };
    var getContentSecurityPolicy = function(editor) {
      return editor.getParam("content_security_policy", "");
    };
    var shouldPutBrInPre = function(editor) {
      return editor.getParam("br_in_pre", true);
    };
    var getForcedRootBlock = function(editor) {
      if (editor.getParam("force_p_newlines", false)) {
        return "p";
      }
      var block = editor.getParam("forced_root_block", "p");
      if (block === false) {
        return "";
      } else if (block === true) {
        return "p";
      } else {
        return block;
      }
    };
    var getForcedRootBlockAttrs = function(editor) {
      return editor.getParam("forced_root_block_attrs", {});
    };
    var getBrNewLineSelector = function(editor) {
      return editor.getParam("br_newline_selector", ".mce-toc h2,figcaption,caption");
    };
    var getNoNewLineSelector = function(editor) {
      return editor.getParam("no_newline_selector", "");
    };
    var shouldKeepStyles = function(editor) {
      return editor.getParam("keep_styles", true);
    };
    var shouldEndContainerOnEmptyBlock = function(editor) {
      return editor.getParam("end_container_on_empty_block", false);
    };
    var getFontStyleValues = function(editor) {
      return Tools.explode(editor.getParam("font_size_style_values", "xx-small,x-small,small,medium,large,x-large,xx-large"));
    };
    var getFontSizeClasses = function(editor) {
      return Tools.explode(editor.getParam("font_size_classes", ""));
    };
    var getImagesDataImgFilter = function(editor) {
      return editor.getParam("images_dataimg_filter", always, "function");
    };
    var isAutomaticUploadsEnabled = function(editor) {
      return editor.getParam("automatic_uploads", true, "boolean");
    };
    var shouldReuseFileName = function(editor) {
      return editor.getParam("images_reuse_filename", false, "boolean");
    };
    var shouldReplaceBlobUris = function(editor) {
      return editor.getParam("images_replace_blob_uris", true, "boolean");
    };
    var getIconPackName = function(editor) {
      return editor.getParam("icons", "", "string");
    };
    var getIconsUrl = function(editor) {
      return editor.getParam("icons_url", "", "string");
    };
    var getImageUploadUrl = function(editor) {
      return editor.getParam("images_upload_url", "", "string");
    };
    var getImageUploadBasePath = function(editor) {
      return editor.getParam("images_upload_base_path", "", "string");
    };
    var getImagesUploadCredentials = function(editor) {
      return editor.getParam("images_upload_credentials", false, "boolean");
    };
    var getImagesUploadHandler = function(editor) {
      return editor.getParam("images_upload_handler", null, "function");
    };
    var shouldUseContentCssCors = function(editor) {
      return editor.getParam("content_css_cors", false, "boolean");
    };
    var getReferrerPolicy = function(editor) {
      return editor.getParam("referrer_policy", "", "string");
    };
    var getLanguageCode = function(editor) {
      return editor.getParam("language", "en", "string");
    };
    var getLanguageUrl = function(editor) {
      return editor.getParam("language_url", "", "string");
    };
    var shouldIndentUseMargin = function(editor) {
      return editor.getParam("indent_use_margin", false);
    };
    var getIndentation = function(editor) {
      return editor.getParam("indentation", "40px", "string");
    };
    var getContentCss = function(editor) {
      var contentCss = editor.getParam("content_css");
      if (isString(contentCss)) {
        return map(contentCss.split(","), trim);
      } else if (isArray(contentCss)) {
        return contentCss;
      } else if (contentCss === false || editor.inline) {
        return [];
      } else {
        return ["default"];
      }
    };
    var getFontCss = function(editor) {
      var fontCss = editor.getParam("font_css", []);
      return isArray(fontCss) ? fontCss : map(fontCss.split(","), trim);
    };
    var getDirectionality = function(editor) {
      return editor.getParam("directionality", I18n.isRtl() ? "rtl" : void 0);
    };
    var getInlineBoundarySelector = function(editor) {
      return editor.getParam("inline_boundaries_selector", "a[href],code,.mce-annotation", "string");
    };
    var getObjectResizing = function(editor) {
      var selector = editor.getParam("object_resizing");
      if (selector === false || Env.iOS) {
        return false;
      } else {
        return isString(selector) ? selector : "table,img,figure.image,div,video,iframe";
      }
    };
    var getResizeImgProportional = function(editor) {
      return editor.getParam("resize_img_proportional", true, "boolean");
    };
    var getPlaceholder = function(editor) {
      return editor.getParam("placeholder", DOM$1.getAttrib(editor.getElement(), "placeholder"), "string");
    };
    var getEventRoot = function(editor) {
      return editor.getParam("event_root");
    };
    var getServiceMessage = function(editor) {
      return editor.getParam("service_message");
    };
    var getTheme = function(editor) {
      return editor.getParam("theme");
    };
    var shouldValidate = function(editor) {
      return editor.getParam("validate");
    };
    var isInlineBoundariesEnabled = function(editor) {
      return editor.getParam("inline_boundaries") !== false;
    };
    var getFormats = function(editor) {
      return editor.getParam("formats");
    };
    var getPreviewStyles = function(editor) {
      var style = editor.getParam("preview_styles", defaultPreviewStyles);
      if (isString(style)) {
        return style;
      } else {
        return "";
      }
    };
    var canFormatEmptyLines = function(editor) {
      return editor.getParam("format_empty_lines", false, "boolean");
    };
    var getCustomUiSelector = function(editor) {
      return editor.getParam("custom_ui_selector", "", "string");
    };
    var getThemeUrl = function(editor) {
      return editor.getParam("theme_url");
    };
    var isInline$1 = function(editor) {
      return editor.getParam("inline");
    };
    var hasHiddenInput = function(editor) {
      return editor.getParam("hidden_input");
    };
    var shouldPatchSubmit = function(editor) {
      return editor.getParam("submit_patch");
    };
    var isEncodingXml = function(editor) {
      return editor.getParam("encoding") === "xml";
    };
    var shouldAddFormSubmitTrigger = function(editor) {
      return editor.getParam("add_form_submit_trigger");
    };
    var shouldAddUnloadTrigger = function(editor) {
      return editor.getParam("add_unload_trigger");
    };
    var hasForcedRootBlock = function(editor) {
      return getForcedRootBlock(editor) !== "";
    };
    var getCustomUndoRedoLevels = function(editor) {
      return editor.getParam("custom_undo_redo_levels", 0, "number");
    };
    var shouldDisableNodeChange = function(editor) {
      return editor.getParam("disable_nodechange");
    };
    var isReadOnly = function(editor) {
      return editor.getParam("readonly");
    };
    var hasContentCssCors = function(editor) {
      return editor.getParam("content_css_cors");
    };
    var getPlugins = function(editor) {
      return editor.getParam("plugins", "", "string");
    };
    var getExternalPlugins = function(editor) {
      return editor.getParam("external_plugins");
    };
    var shouldBlockUnsupportedDrop = function(editor) {
      return editor.getParam("block_unsupported_drop", true, "boolean");
    };
    var isVisualAidsEnabled = function(editor) {
      return editor.getParam("visual", true, "boolean");
    };
    var getVisualAidsTableClass = function(editor) {
      return editor.getParam("visual_table_class", "mce-item-table", "string");
    };
    var getVisualAidsAnchorClass = function(editor) {
      return editor.getParam("visual_anchor_class", "mce-item-anchor", "string");
    };
    var isElement$4 = isElement$1;
    var isText$6 = isText$1;
    var removeNode = function(node) {
      var parentNode = node.parentNode;
      if (parentNode) {
        parentNode.removeChild(node);
      }
    };
    var trimCount = function(text) {
      var trimmedText = trim$2(text);
      return {
        count: text.length - trimmedText.length,
        text: trimmedText
      };
    };
    var deleteZwspChars = function(caretContainer) {
      var idx;
      while ((idx = caretContainer.data.lastIndexOf(ZWSP)) !== -1) {
        caretContainer.deleteData(idx, 1);
      }
    };
    var removeUnchanged = function(caretContainer, pos) {
      remove$5(caretContainer);
      return pos;
    };
    var removeTextAndReposition = function(caretContainer, pos) {
      var before2 = trimCount(caretContainer.data.substr(0, pos.offset()));
      var after2 = trimCount(caretContainer.data.substr(pos.offset()));
      var text = before2.text + after2.text;
      if (text.length > 0) {
        deleteZwspChars(caretContainer);
        return CaretPosition(caretContainer, pos.offset() - before2.count);
      } else {
        return pos;
      }
    };
    var removeElementAndReposition = function(caretContainer, pos) {
      var parentNode = pos.container();
      var newPosition = indexOf(from$1(parentNode.childNodes), caretContainer).map(function(index) {
        return index < pos.offset() ? CaretPosition(parentNode, pos.offset() - 1) : pos;
      }).getOr(pos);
      remove$5(caretContainer);
      return newPosition;
    };
    var removeTextCaretContainer = function(caretContainer, pos) {
      return isText$6(caretContainer) && pos.container() === caretContainer ? removeTextAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);
    };
    var removeElementCaretContainer = function(caretContainer, pos) {
      return pos.container() === caretContainer.parentNode ? removeElementAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);
    };
    var removeAndReposition = function(container, pos) {
      return CaretPosition.isTextPosition(pos) ? removeTextCaretContainer(container, pos) : removeElementCaretContainer(container, pos);
    };
    var remove$5 = function(caretContainerNode) {
      if (isElement$4(caretContainerNode) && isCaretContainer(caretContainerNode)) {
        if (hasContent(caretContainerNode)) {
          caretContainerNode.removeAttribute("data-mce-caret");
        } else {
          removeNode(caretContainerNode);
        }
      }
      if (isText$6(caretContainerNode)) {
        deleteZwspChars(caretContainerNode);
        if (caretContainerNode.data.length === 0) {
          removeNode(caretContainerNode);
        }
      }
    };
    var browser$2 = detect$3().browser;
    var isContentEditableFalse$3 = isContentEditableFalse;
    var isMedia$1 = isMedia;
    var isTableCell$2 = isTableCell;
    var inlineFakeCaretSelector = "*[contentEditable=false],video,audio,embed,object";
    var getAbsoluteClientRect = function(root, element, before2) {
      var clientRect = collapse(element.getBoundingClientRect(), before2);
      var docElm, scrollX, scrollY, margin, rootRect;
      if (root.tagName === "BODY") {
        docElm = root.ownerDocument.documentElement;
        scrollX = root.scrollLeft || docElm.scrollLeft;
        scrollY = root.scrollTop || docElm.scrollTop;
      } else {
        rootRect = root.getBoundingClientRect();
        scrollX = root.scrollLeft - rootRect.left;
        scrollY = root.scrollTop - rootRect.top;
      }
      clientRect.left += scrollX;
      clientRect.right += scrollX;
      clientRect.top += scrollY;
      clientRect.bottom += scrollY;
      clientRect.width = 1;
      margin = element.offsetWidth - element.clientWidth;
      if (margin > 0) {
        if (before2) {
          margin *= -1;
        }
        clientRect.left += margin;
        clientRect.right += margin;
      }
      return clientRect;
    };
    var trimInlineCaretContainers = function(root) {
      var fakeCaretTargetNodes = descendants$1(SugarElement.fromDom(root), inlineFakeCaretSelector);
      for (var i = 0; i < fakeCaretTargetNodes.length; i++) {
        var node = fakeCaretTargetNodes[i].dom;
        var sibling2 = node.previousSibling;
        if (endsWithCaretContainer(sibling2)) {
          var data2 = sibling2.data;
          if (data2.length === 1) {
            sibling2.parentNode.removeChild(sibling2);
          } else {
            sibling2.deleteData(data2.length - 1, 1);
          }
        }
        sibling2 = node.nextSibling;
        if (startsWithCaretContainer(sibling2)) {
          var data2 = sibling2.data;
          if (data2.length === 1) {
            sibling2.parentNode.removeChild(sibling2);
          } else {
            sibling2.deleteData(0, 1);
          }
        }
      }
    };
    var FakeCaret = function(editor, root, isBlock2, hasFocus2) {
      var lastVisualCaret = Cell(Optional.none());
      var cursorInterval, caretContainerNode;
      var rootBlock = getForcedRootBlock(editor);
      var caretBlock = rootBlock.length > 0 ? rootBlock : "p";
      var show = function(before2, element) {
        var clientRect, rng;
        hide();
        if (isTableCell$2(element)) {
          return null;
        }
        if (isBlock2(element)) {
          caretContainerNode = insertBlock(caretBlock, element, before2);
          clientRect = getAbsoluteClientRect(root, element, before2);
          DomQuery(caretContainerNode).css("top", clientRect.top);
          var caret = DomQuery('<div class="mce-visual-caret" data-mce-bogus="all"></div>').css(clientRect).appendTo(root)[0];
          lastVisualCaret.set(Optional.some({
            caret,
            element,
            before: before2
          }));
          lastVisualCaret.get().each(function(caretState) {
            if (before2) {
              DomQuery(caretState.caret).addClass("mce-visual-caret-before");
            }
          });
          startBlink();
          rng = element.ownerDocument.createRange();
          rng.setStart(caretContainerNode, 0);
          rng.setEnd(caretContainerNode, 0);
        } else {
          caretContainerNode = insertInline(element, before2);
          rng = element.ownerDocument.createRange();
          if (isInlineFakeCaretTarget(caretContainerNode.nextSibling)) {
            rng.setStart(caretContainerNode, 0);
            rng.setEnd(caretContainerNode, 0);
          } else {
            rng.setStart(caretContainerNode, 1);
            rng.setEnd(caretContainerNode, 1);
          }
          return rng;
        }
        return rng;
      };
      var hide = function() {
        trimInlineCaretContainers(root);
        if (caretContainerNode) {
          remove$5(caretContainerNode);
          caretContainerNode = null;
        }
        lastVisualCaret.get().each(function(caretState) {
          DomQuery(caretState.caret).remove();
          lastVisualCaret.set(Optional.none());
        });
        if (cursorInterval) {
          Delay.clearInterval(cursorInterval);
          cursorInterval = null;
        }
      };
      var startBlink = function() {
        cursorInterval = Delay.setInterval(function() {
          if (hasFocus2()) {
            DomQuery("div.mce-visual-caret", root).toggleClass("mce-visual-caret-hidden");
          } else {
            DomQuery("div.mce-visual-caret", root).addClass("mce-visual-caret-hidden");
          }
        }, 500);
      };
      var reposition2 = function() {
        lastVisualCaret.get().each(function(caretState) {
          var clientRect = getAbsoluteClientRect(root, caretState.element, caretState.before);
          DomQuery(caretState.caret).css(__assign2({}, clientRect));
        });
      };
      var destroy2 = function() {
        return Delay.clearInterval(cursorInterval);
      };
      var getCss = function() {
        return ".mce-visual-caret {position: absolute;background-color: black;background-color: currentcolor;}.mce-visual-caret-hidden {display: none;}*[data-mce-caret] {position: absolute;left: -1000px;right: auto;top: 0;margin: 0;padding: 0;}";
      };
      return {
        show,
        hide,
        getCss,
        reposition: reposition2,
        destroy: destroy2
      };
    };
    var isFakeCaretTableBrowser = function() {
      return browser$2.isIE() || browser$2.isEdge() || browser$2.isFirefox();
    };
    var isInlineFakeCaretTarget = function(node) {
      return isContentEditableFalse$3(node) || isMedia$1(node);
    };
    var isFakeCaretTarget = function(node) {
      return isInlineFakeCaretTarget(node) || isTable(node) && isFakeCaretTableBrowser();
    };
    var isContentEditableFalse$4 = isContentEditableFalse;
    var isMedia$2 = isMedia;
    var isBlockLike = matchStyleValues("display", "block table table-cell table-caption list-item");
    var isCaretContainer$2 = isCaretContainer;
    var isCaretContainerBlock$1 = isCaretContainerBlock;
    var isElement$5 = isElement$1;
    var isCaretCandidate$2 = isCaretCandidate;
    var isForwards = function(direction) {
      return direction > 0;
    };
    var isBackwards = function(direction) {
      return direction < 0;
    };
    var skipCaretContainers = function(walk2, shallow2) {
      var node;
      while (node = walk2(shallow2)) {
        if (!isCaretContainerBlock$1(node)) {
          return node;
        }
      }
      return null;
    };
    var findNode = function(node, direction, predicateFn, rootNode, shallow2) {
      var walker = new DomTreeWalker(node, rootNode);
      var isCefOrCaretContainer = isContentEditableFalse$4(node) || isCaretContainerBlock$1(node);
      if (isBackwards(direction)) {
        if (isCefOrCaretContainer) {
          node = skipCaretContainers(walker.prev.bind(walker), true);
          if (predicateFn(node)) {
            return node;
          }
        }
        while (node = skipCaretContainers(walker.prev.bind(walker), shallow2)) {
          if (predicateFn(node)) {
            return node;
          }
        }
      }
      if (isForwards(direction)) {
        if (isCefOrCaretContainer) {
          node = skipCaretContainers(walker.next.bind(walker), true);
          if (predicateFn(node)) {
            return node;
          }
        }
        while (node = skipCaretContainers(walker.next.bind(walker), shallow2)) {
          if (predicateFn(node)) {
            return node;
          }
        }
      }
      return null;
    };
    var getParentBlock = function(node, rootNode) {
      while (node && node !== rootNode) {
        if (isBlockLike(node)) {
          return node;
        }
        node = node.parentNode;
      }
      return null;
    };
    var isInSameBlock = function(caretPosition1, caretPosition2, rootNode) {
      return getParentBlock(caretPosition1.container(), rootNode) === getParentBlock(caretPosition2.container(), rootNode);
    };
    var getChildNodeAtRelativeOffset = function(relativeOffset, caretPosition) {
      if (!caretPosition) {
        return null;
      }
      var container = caretPosition.container();
      var offset = caretPosition.offset();
      if (!isElement$5(container)) {
        return null;
      }
      return container.childNodes[offset + relativeOffset];
    };
    var beforeAfter = function(before2, node) {
      var range2 = node.ownerDocument.createRange();
      if (before2) {
        range2.setStartBefore(node);
        range2.setEndBefore(node);
      } else {
        range2.setStartAfter(node);
        range2.setEndAfter(node);
      }
      return range2;
    };
    var isNodesInSameBlock = function(root, node1, node2) {
      return getParentBlock(node1, root) === getParentBlock(node2, root);
    };
    var lean = function(left, root, node) {
      var sibling2, siblingName;
      if (left) {
        siblingName = "previousSibling";
      } else {
        siblingName = "nextSibling";
      }
      while (node && node !== root) {
        sibling2 = node[siblingName];
        if (isCaretContainer$2(sibling2)) {
          sibling2 = sibling2[siblingName];
        }
        if (isContentEditableFalse$4(sibling2) || isMedia$2(sibling2)) {
          if (isNodesInSameBlock(root, sibling2, node)) {
            return sibling2;
          }
          break;
        }
        if (isCaretCandidate$2(sibling2)) {
          break;
        }
        node = node.parentNode;
      }
      return null;
    };
    var before$2 = curry(beforeAfter, true);
    var after$1 = curry(beforeAfter, false);
    var normalizeRange = function(direction, root, range2) {
      var node, container, location;
      var leanLeft = curry(lean, true, root);
      var leanRight2 = curry(lean, false, root);
      container = range2.startContainer;
      var offset = range2.startOffset;
      if (isCaretContainerBlock(container)) {
        if (!isElement$5(container)) {
          container = container.parentNode;
        }
        location = container.getAttribute("data-mce-caret");
        if (location === "before") {
          node = container.nextSibling;
          if (isFakeCaretTarget(node)) {
            return before$2(node);
          }
        }
        if (location === "after") {
          node = container.previousSibling;
          if (isFakeCaretTarget(node)) {
            return after$1(node);
          }
        }
      }
      if (!range2.collapsed) {
        return range2;
      }
      if (isText$1(container)) {
        if (isCaretContainer$2(container)) {
          if (direction === 1) {
            node = leanRight2(container);
            if (node) {
              return before$2(node);
            }
            node = leanLeft(container);
            if (node) {
              return after$1(node);
            }
          }
          if (direction === -1) {
            node = leanLeft(container);
            if (node) {
              return after$1(node);
            }
            node = leanRight2(container);
            if (node) {
              return before$2(node);
            }
          }
          return range2;
        }
        if (endsWithCaretContainer(container) && offset >= container.data.length - 1) {
          if (direction === 1) {
            node = leanRight2(container);
            if (node) {
              return before$2(node);
            }
          }
          return range2;
        }
        if (startsWithCaretContainer(container) && offset <= 1) {
          if (direction === -1) {
            node = leanLeft(container);
            if (node) {
              return after$1(node);
            }
          }
          return range2;
        }
        if (offset === container.data.length) {
          node = leanRight2(container);
          if (node) {
            return before$2(node);
          }
          return range2;
        }
        if (offset === 0) {
          node = leanLeft(container);
          if (node) {
            return after$1(node);
          }
          return range2;
        }
      }
      return range2;
    };
    var getRelativeCefElm = function(forward, caretPosition) {
      return Optional.from(getChildNodeAtRelativeOffset(forward ? 0 : -1, caretPosition)).filter(isContentEditableFalse$4);
    };
    var getNormalizedRangeEndPoint = function(direction, root, range2) {
      var normalizedRange = normalizeRange(direction, root, range2);
      if (direction === -1) {
        return CaretPosition.fromRangeStart(normalizedRange);
      }
      return CaretPosition.fromRangeEnd(normalizedRange);
    };
    var getElementFromPosition = function(pos) {
      return Optional.from(pos.getNode()).map(SugarElement.fromDom);
    };
    var getElementFromPrevPosition = function(pos) {
      return Optional.from(pos.getNode(true)).map(SugarElement.fromDom);
    };
    var getVisualCaretPosition = function(walkFn, caretPosition) {
      while (caretPosition = walkFn(caretPosition)) {
        if (caretPosition.isVisible()) {
          return caretPosition;
        }
      }
      return caretPosition;
    };
    var isMoveInsideSameBlock = function(from2, to2) {
      var inSameBlock = isInSameBlock(from2, to2);
      if (!inSameBlock && isBr(from2.getNode())) {
        return true;
      }
      return inSameBlock;
    };
    var HDirection;
    (function(HDirection2) {
      HDirection2[HDirection2["Backwards"] = -1] = "Backwards";
      HDirection2[HDirection2["Forwards"] = 1] = "Forwards";
    })(HDirection || (HDirection = {}));
    var isContentEditableFalse$5 = isContentEditableFalse;
    var isText$7 = isText$1;
    var isElement$6 = isElement$1;
    var isBr$4 = isBr;
    var isCaretCandidate$3 = isCaretCandidate;
    var isAtomic$1 = isAtomic;
    var isEditableCaretCandidate$1 = isEditableCaretCandidate;
    var getParents = function(node, root) {
      var parents2 = [];
      while (node && node !== root) {
        parents2.push(node);
        node = node.parentNode;
      }
      return parents2;
    };
    var nodeAtIndex = function(container, offset) {
      if (container.hasChildNodes() && offset < container.childNodes.length) {
        return container.childNodes[offset];
      }
      return null;
    };
    var getCaretCandidatePosition = function(direction, node) {
      if (isForwards(direction)) {
        if (isCaretCandidate$3(node.previousSibling) && !isText$7(node.previousSibling)) {
          return CaretPosition.before(node);
        }
        if (isText$7(node)) {
          return CaretPosition(node, 0);
        }
      }
      if (isBackwards(direction)) {
        if (isCaretCandidate$3(node.nextSibling) && !isText$7(node.nextSibling)) {
          return CaretPosition.after(node);
        }
        if (isText$7(node)) {
          return CaretPosition(node, node.data.length);
        }
      }
      if (isBackwards(direction)) {
        if (isBr$4(node)) {
          return CaretPosition.before(node);
        }
        return CaretPosition.after(node);
      }
      return CaretPosition.before(node);
    };
    var moveForwardFromBr = function(root, nextNode) {
      var nextSibling2 = nextNode.nextSibling;
      if (nextSibling2 && isCaretCandidate$3(nextSibling2)) {
        if (isText$7(nextSibling2)) {
          return CaretPosition(nextSibling2, 0);
        } else {
          return CaretPosition.before(nextSibling2);
        }
      } else {
        return findCaretPosition(HDirection.Forwards, CaretPosition.after(nextNode), root);
      }
    };
    var findCaretPosition = function(direction, startPos, root) {
      var node, nextNode, innerNode;
      var caretPosition;
      if (!isElement$6(root) || !startPos) {
        return null;
      }
      if (startPos.isEqual(CaretPosition.after(root)) && root.lastChild) {
        caretPosition = CaretPosition.after(root.lastChild);
        if (isBackwards(direction) && isCaretCandidate$3(root.lastChild) && isElement$6(root.lastChild)) {
          return isBr$4(root.lastChild) ? CaretPosition.before(root.lastChild) : caretPosition;
        }
      } else {
        caretPosition = startPos;
      }
      var container = caretPosition.container();
      var offset = caretPosition.offset();
      if (isText$7(container)) {
        if (isBackwards(direction) && offset > 0) {
          return CaretPosition(container, --offset);
        }
        if (isForwards(direction) && offset < container.length) {
          return CaretPosition(container, ++offset);
        }
        node = container;
      } else {
        if (isBackwards(direction) && offset > 0) {
          nextNode = nodeAtIndex(container, offset - 1);
          if (isCaretCandidate$3(nextNode)) {
            if (!isAtomic$1(nextNode)) {
              innerNode = findNode(nextNode, direction, isEditableCaretCandidate$1, nextNode);
              if (innerNode) {
                if (isText$7(innerNode)) {
                  return CaretPosition(innerNode, innerNode.data.length);
                }
                return CaretPosition.after(innerNode);
              }
            }
            if (isText$7(nextNode)) {
              return CaretPosition(nextNode, nextNode.data.length);
            }
            return CaretPosition.before(nextNode);
          }
        }
        if (isForwards(direction) && offset < container.childNodes.length) {
          nextNode = nodeAtIndex(container, offset);
          if (isCaretCandidate$3(nextNode)) {
            if (isBr$4(nextNode)) {
              return moveForwardFromBr(root, nextNode);
            }
            if (!isAtomic$1(nextNode)) {
              innerNode = findNode(nextNode, direction, isEditableCaretCandidate$1, nextNode);
              if (innerNode) {
                if (isText$7(innerNode)) {
                  return CaretPosition(innerNode, 0);
                }
                return CaretPosition.before(innerNode);
              }
            }
            if (isText$7(nextNode)) {
              return CaretPosition(nextNode, 0);
            }
            return CaretPosition.after(nextNode);
          }
        }
        node = nextNode ? nextNode : caretPosition.getNode();
      }
      if (isForwards(direction) && caretPosition.isAtEnd() || isBackwards(direction) && caretPosition.isAtStart()) {
        node = findNode(node, direction, always, root, true);
        if (isEditableCaretCandidate$1(node, root)) {
          return getCaretCandidatePosition(direction, node);
        }
      }
      nextNode = findNode(node, direction, isEditableCaretCandidate$1, root);
      var rootContentEditableFalseElm = last$1(filter(getParents(container, root), isContentEditableFalse$5));
      if (rootContentEditableFalseElm && (!nextNode || !rootContentEditableFalseElm.contains(nextNode))) {
        if (isForwards(direction)) {
          caretPosition = CaretPosition.after(rootContentEditableFalseElm);
        } else {
          caretPosition = CaretPosition.before(rootContentEditableFalseElm);
        }
        return caretPosition;
      }
      if (nextNode) {
        return getCaretCandidatePosition(direction, nextNode);
      }
      return null;
    };
    var CaretWalker = function(root) {
      return {
        next: function(caretPosition) {
          return findCaretPosition(HDirection.Forwards, caretPosition, root);
        },
        prev: function(caretPosition) {
          return findCaretPosition(HDirection.Backwards, caretPosition, root);
        }
      };
    };
    var walkToPositionIn = function(forward, root, start2) {
      var position = forward ? CaretPosition.before(start2) : CaretPosition.after(start2);
      return fromPosition(forward, root, position);
    };
    var afterElement = function(node) {
      return isBr(node) ? CaretPosition.before(node) : CaretPosition.after(node);
    };
    var isBeforeOrStart = function(position) {
      if (CaretPosition.isTextPosition(position)) {
        return position.offset() === 0;
      } else {
        return isCaretCandidate(position.getNode());
      }
    };
    var isAfterOrEnd = function(position) {
      if (CaretPosition.isTextPosition(position)) {
        var container = position.container();
        return position.offset() === container.data.length;
      } else {
        return isCaretCandidate(position.getNode(true));
      }
    };
    var isBeforeAfterSameElement = function(from2, to2) {
      return !CaretPosition.isTextPosition(from2) && !CaretPosition.isTextPosition(to2) && from2.getNode() === to2.getNode(true);
    };
    var isAtBr = function(position) {
      return !CaretPosition.isTextPosition(position) && isBr(position.getNode());
    };
    var shouldSkipPosition = function(forward, from2, to2) {
      if (forward) {
        return !isBeforeAfterSameElement(from2, to2) && !isAtBr(from2) && isAfterOrEnd(from2) && isBeforeOrStart(to2);
      } else {
        return !isBeforeAfterSameElement(to2, from2) && isBeforeOrStart(from2) && isAfterOrEnd(to2);
      }
    };
    var fromPosition = function(forward, root, pos) {
      var walker = CaretWalker(root);
      return Optional.from(forward ? walker.next(pos) : walker.prev(pos));
    };
    var navigate = function(forward, root, from2) {
      return fromPosition(forward, root, from2).bind(function(to2) {
        if (isInSameBlock(from2, to2, root) && shouldSkipPosition(forward, from2, to2)) {
          return fromPosition(forward, root, to2);
        } else {
          return Optional.some(to2);
        }
      });
    };
    var navigateIgnore = function(forward, root, from2, ignoreFilter) {
      return navigate(forward, root, from2).bind(function(pos) {
        return ignoreFilter(pos) ? navigateIgnore(forward, root, pos, ignoreFilter) : Optional.some(pos);
      });
    };
    var positionIn = function(forward, element) {
      var startNode = forward ? element.firstChild : element.lastChild;
      if (isText$1(startNode)) {
        return Optional.some(CaretPosition(startNode, forward ? 0 : startNode.data.length));
      } else if (startNode) {
        if (isCaretCandidate(startNode)) {
          return Optional.some(forward ? CaretPosition.before(startNode) : afterElement(startNode));
        } else {
          return walkToPositionIn(forward, element, startNode);
        }
      } else {
        return Optional.none();
      }
    };
    var nextPosition = curry(fromPosition, true);
    var prevPosition = curry(fromPosition, false);
    var firstPositionIn = curry(positionIn, true);
    var lastPositionIn = curry(positionIn, false);
    var CARET_ID = "_mce_caret";
    var isCaretNode = function(node) {
      return isElement$1(node) && node.id === CARET_ID;
    };
    var getParentCaretContainer = function(body, node) {
      while (node && node !== body) {
        if (node.id === CARET_ID) {
          return node;
        }
        node = node.parentNode;
      }
      return null;
    };
    var isStringPathBookmark = function(bookmark) {
      return isString(bookmark.start);
    };
    var isRangeBookmark = function(bookmark) {
      return bookmark.hasOwnProperty("rng");
    };
    var isIdBookmark = function(bookmark) {
      return bookmark.hasOwnProperty("id");
    };
    var isIndexBookmark = function(bookmark) {
      return bookmark.hasOwnProperty("name");
    };
    var isPathBookmark = function(bookmark) {
      return Tools.isArray(bookmark.start);
    };
    var addBogus = function(dom2, node) {
      if (isElement$1(node) && dom2.isBlock(node) && !node.innerHTML && !Env.ie) {
        node.innerHTML = '<br data-mce-bogus="1" />';
      }
      return node;
    };
    var resolveCaretPositionBookmark = function(dom2, bookmark) {
      var pos;
      var rng = dom2.createRng();
      pos = resolve$1(dom2.getRoot(), bookmark.start);
      rng.setStart(pos.container(), pos.offset());
      pos = resolve$1(dom2.getRoot(), bookmark.end);
      rng.setEnd(pos.container(), pos.offset());
      return rng;
    };
    var insertZwsp = function(node, rng) {
      var textNode = node.ownerDocument.createTextNode(ZWSP);
      node.appendChild(textNode);
      rng.setStart(textNode, 0);
      rng.setEnd(textNode, 0);
    };
    var isEmpty$1 = function(node) {
      return node.hasChildNodes() === false;
    };
    var tryFindRangePosition = function(node, rng) {
      return lastPositionIn(node).fold(never, function(pos) {
        rng.setStart(pos.container(), pos.offset());
        rng.setEnd(pos.container(), pos.offset());
        return true;
      });
    };
    var padEmptyCaretContainer = function(root, node, rng) {
      if (isEmpty$1(node) && getParentCaretContainer(root, node)) {
        insertZwsp(node, rng);
        return true;
      } else {
        return false;
      }
    };
    var setEndPoint = function(dom2, start2, bookmark, rng) {
      var point = bookmark[start2 ? "start" : "end"];
      var i, node, offset, children2;
      var root = dom2.getRoot();
      if (point) {
        offset = point[0];
        for (node = root, i = point.length - 1; i >= 1; i--) {
          children2 = node.childNodes;
          if (padEmptyCaretContainer(root, node, rng)) {
            return true;
          }
          if (point[i] > children2.length - 1) {
            if (padEmptyCaretContainer(root, node, rng)) {
              return true;
            }
            return tryFindRangePosition(node, rng);
          }
          node = children2[point[i]];
        }
        if (node.nodeType === 3) {
          offset = Math.min(point[0], node.nodeValue.length);
        }
        if (node.nodeType === 1) {
          offset = Math.min(point[0], node.childNodes.length);
        }
        if (start2) {
          rng.setStart(node, offset);
        } else {
          rng.setEnd(node, offset);
        }
      }
      return true;
    };
    var isValidTextNode = function(node) {
      return isText$1(node) && node.data.length > 0;
    };
    var restoreEndPoint = function(dom2, suffix, bookmark) {
      var marker = dom2.get(bookmark.id + "_" + suffix), node, idx, next, prev;
      var keep = bookmark.keep;
      var container, offset;
      if (marker) {
        node = marker.parentNode;
        if (suffix === "start") {
          if (!keep) {
            idx = dom2.nodeIndex(marker);
          } else {
            if (marker.hasChildNodes()) {
              node = marker.firstChild;
              idx = 1;
            } else if (isValidTextNode(marker.nextSibling)) {
              node = marker.nextSibling;
              idx = 0;
            } else if (isValidTextNode(marker.previousSibling)) {
              node = marker.previousSibling;
              idx = marker.previousSibling.data.length;
            } else {
              node = marker.parentNode;
              idx = dom2.nodeIndex(marker) + 1;
            }
          }
          container = node;
          offset = idx;
        } else {
          if (!keep) {
            idx = dom2.nodeIndex(marker);
          } else {
            if (marker.hasChildNodes()) {
              node = marker.firstChild;
              idx = 1;
            } else if (isValidTextNode(marker.previousSibling)) {
              node = marker.previousSibling;
              idx = marker.previousSibling.data.length;
            } else {
              node = marker.parentNode;
              idx = dom2.nodeIndex(marker);
            }
          }
          container = node;
          offset = idx;
        }
        if (!keep) {
          prev = marker.previousSibling;
          next = marker.nextSibling;
          Tools.each(Tools.grep(marker.childNodes), function(node2) {
            if (isText$1(node2)) {
              node2.nodeValue = node2.nodeValue.replace(/\uFEFF/g, "");
            }
          });
          while (marker = dom2.get(bookmark.id + "_" + suffix)) {
            dom2.remove(marker, true);
          }
          if (prev && next && prev.nodeType === next.nodeType && isText$1(prev) && !Env.opera) {
            idx = prev.nodeValue.length;
            prev.appendData(next.nodeValue);
            dom2.remove(next);
            container = prev;
            offset = idx;
          }
        }
        return Optional.some(CaretPosition(container, offset));
      } else {
        return Optional.none();
      }
    };
    var resolvePaths = function(dom2, bookmark) {
      var rng = dom2.createRng();
      if (setEndPoint(dom2, true, bookmark, rng) && setEndPoint(dom2, false, bookmark, rng)) {
        return Optional.some(rng);
      } else {
        return Optional.none();
      }
    };
    var resolveId = function(dom2, bookmark) {
      var startPos = restoreEndPoint(dom2, "start", bookmark);
      var endPos = restoreEndPoint(dom2, "end", bookmark);
      return lift2(startPos, endPos.or(startPos), function(spos, epos) {
        var rng = dom2.createRng();
        rng.setStart(addBogus(dom2, spos.container()), spos.offset());
        rng.setEnd(addBogus(dom2, epos.container()), epos.offset());
        return rng;
      });
    };
    var resolveIndex$1 = function(dom2, bookmark) {
      return Optional.from(dom2.select(bookmark.name)[bookmark.index]).map(function(elm) {
        var rng = dom2.createRng();
        rng.selectNode(elm);
        return rng;
      });
    };
    var resolve$2 = function(selection, bookmark) {
      var dom2 = selection.dom;
      if (bookmark) {
        if (isPathBookmark(bookmark)) {
          return resolvePaths(dom2, bookmark);
        } else if (isStringPathBookmark(bookmark)) {
          return Optional.some(resolveCaretPositionBookmark(dom2, bookmark));
        } else if (isIdBookmark(bookmark)) {
          return resolveId(dom2, bookmark);
        } else if (isIndexBookmark(bookmark)) {
          return resolveIndex$1(dom2, bookmark);
        } else if (isRangeBookmark(bookmark)) {
          return Optional.some(bookmark.rng);
        }
      }
      return Optional.none();
    };
    var getBookmark$1 = function(selection, type2, normalized) {
      return getBookmark(selection, type2, normalized);
    };
    var moveToBookmark = function(selection, bookmark) {
      resolve$2(selection, bookmark).each(function(rng) {
        selection.setRng(rng);
      });
    };
    var isBookmarkNode$1 = function(node) {
      return isElement$1(node) && node.tagName === "SPAN" && node.getAttribute("data-mce-type") === "bookmark";
    };
    var is$2 = function(expected) {
      return function(actual) {
        return expected === actual;
      };
    };
    var isNbsp = is$2(nbsp);
    var isWhiteSpace$1 = function(chr) {
      return chr !== "" && " \f\n\r	\v".indexOf(chr) !== -1;
    };
    var isContent$1 = function(chr) {
      return !isWhiteSpace$1(chr) && !isNbsp(chr);
    };
    var isNode = function(node) {
      return !!node.nodeType;
    };
    var isInlineBlock = function(node) {
      return node && /^(IMG)$/.test(node.nodeName);
    };
    var moveStart = function(dom2, selection, rng) {
      var offset = rng.startOffset;
      var container = rng.startContainer, walker, node, nodes;
      if (rng.startContainer === rng.endContainer) {
        if (isInlineBlock(rng.startContainer.childNodes[rng.startOffset])) {
          return;
        }
      }
      if (container.nodeType === 1) {
        nodes = container.childNodes;
        if (offset < nodes.length) {
          container = nodes[offset];
          walker = new DomTreeWalker(container, dom2.getParent(container, dom2.isBlock));
        } else {
          container = nodes[nodes.length - 1];
          walker = new DomTreeWalker(container, dom2.getParent(container, dom2.isBlock));
          walker.next(true);
        }
        for (node = walker.current(); node; node = walker.next()) {
          if (node.nodeType === 3 && !isWhiteSpaceNode(node)) {
            rng.setStart(node, 0);
            selection.setRng(rng);
            return;
          }
        }
      }
    };
    var getNonWhiteSpaceSibling = function(node, next, inc) {
      if (node) {
        var nextName = next ? "nextSibling" : "previousSibling";
        for (node = inc ? node : node[nextName]; node; node = node[nextName]) {
          if (node.nodeType === 1 || !isWhiteSpaceNode(node)) {
            return node;
          }
        }
      }
    };
    var isTextBlock$1 = function(editor, name2) {
      if (isNode(name2)) {
        name2 = name2.nodeName;
      }
      return !!editor.schema.getTextBlockElements()[name2.toLowerCase()];
    };
    var isValid = function(ed, parent2, child2) {
      return ed.schema.isValidChild(parent2, child2);
    };
    var isWhiteSpaceNode = function(node, allowSpaces) {
      if (allowSpaces === void 0) {
        allowSpaces = false;
      }
      if (isNonNullable(node) && isText$1(node)) {
        var data2 = allowSpaces ? node.data.replace(/ /g, "\xA0") : node.data;
        return isWhitespaceText(data2);
      } else {
        return false;
      }
    };
    var isEmptyTextNode = function(node) {
      return isNonNullable(node) && isText$1(node) && node.length === 0;
    };
    var replaceVars = function(value2, vars) {
      if (typeof value2 !== "string") {
        value2 = value2(vars);
      } else if (vars) {
        value2 = value2.replace(/%(\w+)/g, function(str, name2) {
          return vars[name2] || str;
        });
      }
      return value2;
    };
    var isEq = function(str1, str2) {
      str1 = str1 || "";
      str2 = str2 || "";
      str1 = "" + (str1.nodeName || str1);
      str2 = "" + (str2.nodeName || str2);
      return str1.toLowerCase() === str2.toLowerCase();
    };
    var normalizeStyleValue = function(dom2, value2, name2) {
      if (name2 === "color" || name2 === "backgroundColor") {
        value2 = dom2.toHex(value2);
      }
      if (name2 === "fontWeight" && value2 === 700) {
        value2 = "bold";
      }
      if (name2 === "fontFamily") {
        value2 = value2.replace(/[\'\"]/g, "").replace(/,\s+/g, ",");
      }
      return "" + value2;
    };
    var getStyle = function(dom2, node, name2) {
      return normalizeStyleValue(dom2, dom2.getStyle(node, name2), name2);
    };
    var getTextDecoration = function(dom2, node) {
      var decoration;
      dom2.getParent(node, function(n) {
        decoration = dom2.getStyle(n, "text-decoration");
        return decoration && decoration !== "none";
      });
      return decoration;
    };
    var getParents$1 = function(dom2, node, selector) {
      return dom2.getParents(node, selector, dom2.getRoot());
    };
    var isVariableFormatName = function(editor, formatName) {
      var hasVariableValues = function(format) {
        var isVariableValue = function(val) {
          return val.length > 1 && val.charAt(0) === "%";
        };
        return exists([
          "styles",
          "attributes"
        ], function(key) {
          return get$1(format, key).exists(function(field) {
            var fieldValues = isArray(field) ? field : values(field);
            return exists(fieldValues, isVariableValue);
          });
        });
      };
      return exists(editor.formatter.get(formatName), hasVariableValues);
    };
    var areSimilarFormats = function(editor, formatName, otherFormatName) {
      var validKeys = [
        "inline",
        "block",
        "selector",
        "attributes",
        "styles",
        "classes"
      ];
      var filterObj = function(format) {
        return filter$1(format, function(_, key) {
          return exists(validKeys, function(validKey) {
            return validKey === key;
          });
        });
      };
      return exists(editor.formatter.get(formatName), function(fmt1) {
        var filteredFmt1 = filterObj(fmt1);
        return exists(editor.formatter.get(otherFormatName), function(fmt2) {
          var filteredFmt2 = filterObj(fmt2);
          return equal(filteredFmt1, filteredFmt2);
        });
      });
    };
    var isBlockFormat = function(format) {
      return hasNonNullableKey(format, "block");
    };
    var isSelectorFormat = function(format) {
      return hasNonNullableKey(format, "selector");
    };
    var isInlineFormat = function(format) {
      return hasNonNullableKey(format, "inline");
    };
    var hasBlockChildren = function(dom2, elm) {
      return exists(elm.childNodes, dom2.isBlock);
    };
    var isBookmarkNode$2 = isBookmarkNode$1;
    var getParents$2 = getParents$1;
    var isWhiteSpaceNode$1 = isWhiteSpaceNode;
    var isTextBlock$2 = isTextBlock$1;
    var isBogusBr = function(node) {
      return isBr(node) && node.getAttribute("data-mce-bogus") && !node.nextSibling;
    };
    var findParentContentEditable = function(dom2, node) {
      var parent2 = node;
      while (parent2) {
        if (isElement$1(parent2) && dom2.getContentEditable(parent2)) {
          return dom2.getContentEditable(parent2) === "false" ? parent2 : node;
        }
        parent2 = parent2.parentNode;
      }
      return node;
    };
    var walkText = function(start2, node, offset, predicate) {
      var str = node.data;
      for (var i = offset; start2 ? i >= 0 : i < str.length; start2 ? i-- : i++) {
        if (predicate(str.charAt(i))) {
          return start2 ? i + 1 : i;
        }
      }
      return -1;
    };
    var findSpace = function(start2, node, offset) {
      return walkText(start2, node, offset, function(c) {
        return isNbsp(c) || isWhiteSpace$1(c);
      });
    };
    var findContent = function(start2, node, offset) {
      return walkText(start2, node, offset, isContent$1);
    };
    var findWordEndPoint = function(dom2, body, container, offset, start2, includeTrailingSpaces) {
      var lastTextNode;
      var rootNode = dom2.getParent(container, dom2.isBlock) || body;
      var walk2 = function(container2, offset2, pred) {
        var textSeeker = TextSeeker(dom2);
        var walker = start2 ? textSeeker.backwards : textSeeker.forwards;
        return Optional.from(walker(container2, offset2, function(text, textOffset) {
          if (isBookmarkNode$2(text.parentNode)) {
            return -1;
          } else {
            lastTextNode = text;
            return pred(start2, text, textOffset);
          }
        }, rootNode));
      };
      var spaceResult = walk2(container, offset, findSpace);
      return spaceResult.bind(function(result) {
        return includeTrailingSpaces ? walk2(result.container, result.offset + (start2 ? -1 : 0), findContent) : Optional.some(result);
      }).orThunk(function() {
        return lastTextNode ? Optional.some({
          container: lastTextNode,
          offset: start2 ? 0 : lastTextNode.length
        }) : Optional.none();
      });
    };
    var findSelectorEndPoint = function(dom2, format, rng, container, siblingName) {
      if (isText$1(container) && container.nodeValue.length === 0 && container[siblingName]) {
        container = container[siblingName];
      }
      var parents2 = getParents$2(dom2, container);
      for (var i = 0; i < parents2.length; i++) {
        for (var y = 0; y < format.length; y++) {
          var curFormat = format[y];
          if ("collapsed" in curFormat && curFormat.collapsed !== rng.collapsed) {
            continue;
          }
          if (dom2.is(parents2[i], curFormat.selector)) {
            return parents2[i];
          }
        }
      }
      return container;
    };
    var findBlockEndPoint = function(editor, format, container, siblingName) {
      var node;
      var dom2 = editor.dom;
      var root = dom2.getRoot();
      if (!format[0].wrapper) {
        node = dom2.getParent(container, format[0].block, root);
      }
      if (!node) {
        var scopeRoot = dom2.getParent(container, "LI,TD,TH");
        node = dom2.getParent(isText$1(container) ? container.parentNode : container, function(node2) {
          return node2 !== root && isTextBlock$2(editor, node2);
        }, scopeRoot);
      }
      if (node && format[0].wrapper) {
        node = getParents$2(dom2, node, "ul,ol").reverse()[0] || node;
      }
      if (!node) {
        node = container;
        while (node[siblingName] && !dom2.isBlock(node[siblingName])) {
          node = node[siblingName];
          if (isEq(node, "br")) {
            break;
          }
        }
      }
      return node || container;
    };
    var isAtBlockBoundary = function(dom2, root, container, siblingName) {
      var parent2 = container.parentNode;
      if (isNonNullable(container[siblingName])) {
        return false;
      } else if (parent2 === root || isNullable(parent2) || dom2.isBlock(parent2)) {
        return true;
      } else {
        return isAtBlockBoundary(dom2, root, parent2, siblingName);
      }
    };
    var findParentContainer = function(dom2, format, container, offset, start2) {
      var parent2 = container;
      var sibling2;
      var siblingName = start2 ? "previousSibling" : "nextSibling";
      var root = dom2.getRoot();
      if (isText$1(container) && !isWhiteSpaceNode$1(container)) {
        if (start2 ? offset > 0 : offset < container.data.length) {
          return container;
        }
      }
      while (true) {
        if (!format[0].block_expand && dom2.isBlock(parent2)) {
          return parent2;
        }
        for (sibling2 = parent2[siblingName]; sibling2; sibling2 = sibling2[siblingName]) {
          var allowSpaces = isText$1(sibling2) && !isAtBlockBoundary(dom2, root, sibling2, siblingName);
          if (!isBookmarkNode$2(sibling2) && !isBogusBr(sibling2) && !isWhiteSpaceNode$1(sibling2, allowSpaces)) {
            return parent2;
          }
        }
        if (parent2 === root || parent2.parentNode === root) {
          container = parent2;
          break;
        }
        parent2 = parent2.parentNode;
      }
      return container;
    };
    var isSelfOrParentBookmark = function(container) {
      return isBookmarkNode$2(container.parentNode) || isBookmarkNode$2(container);
    };
    var expandRng = function(editor, rng, format, includeTrailingSpace) {
      if (includeTrailingSpace === void 0) {
        includeTrailingSpace = false;
      }
      var startContainer = rng.startContainer, startOffset = rng.startOffset, endContainer = rng.endContainer, endOffset = rng.endOffset;
      var dom2 = editor.dom;
      if (isElement$1(startContainer) && startContainer.hasChildNodes()) {
        startContainer = getNode(startContainer, startOffset);
        if (isText$1(startContainer)) {
          startOffset = 0;
        }
      }
      if (isElement$1(endContainer) && endContainer.hasChildNodes()) {
        endContainer = getNode(endContainer, rng.collapsed ? endOffset : endOffset - 1);
        if (isText$1(endContainer)) {
          endOffset = endContainer.nodeValue.length;
        }
      }
      startContainer = findParentContentEditable(dom2, startContainer);
      endContainer = findParentContentEditable(dom2, endContainer);
      if (isSelfOrParentBookmark(startContainer)) {
        startContainer = isBookmarkNode$2(startContainer) ? startContainer : startContainer.parentNode;
        if (rng.collapsed) {
          startContainer = startContainer.previousSibling || startContainer;
        } else {
          startContainer = startContainer.nextSibling || startContainer;
        }
        if (isText$1(startContainer)) {
          startOffset = rng.collapsed ? startContainer.length : 0;
        }
      }
      if (isSelfOrParentBookmark(endContainer)) {
        endContainer = isBookmarkNode$2(endContainer) ? endContainer : endContainer.parentNode;
        if (rng.collapsed) {
          endContainer = endContainer.nextSibling || endContainer;
        } else {
          endContainer = endContainer.previousSibling || endContainer;
        }
        if (isText$1(endContainer)) {
          endOffset = rng.collapsed ? 0 : endContainer.length;
        }
      }
      if (rng.collapsed) {
        var startPoint = findWordEndPoint(dom2, editor.getBody(), startContainer, startOffset, true, includeTrailingSpace);
        startPoint.each(function(_a) {
          var container = _a.container, offset = _a.offset;
          startContainer = container;
          startOffset = offset;
        });
        var endPoint = findWordEndPoint(dom2, editor.getBody(), endContainer, endOffset, false, includeTrailingSpace);
        endPoint.each(function(_a) {
          var container = _a.container, offset = _a.offset;
          endContainer = container;
          endOffset = offset;
        });
      }
      if (format[0].inline || format[0].block_expand) {
        if (!format[0].inline || (!isText$1(startContainer) || startOffset === 0)) {
          startContainer = findParentContainer(dom2, format, startContainer, startOffset, true);
        }
        if (!format[0].inline || (!isText$1(endContainer) || endOffset === endContainer.nodeValue.length)) {
          endContainer = findParentContainer(dom2, format, endContainer, endOffset, false);
        }
      }
      if (format[0].selector && format[0].expand !== false && !format[0].inline) {
        startContainer = findSelectorEndPoint(dom2, format, rng, startContainer, "previousSibling");
        endContainer = findSelectorEndPoint(dom2, format, rng, endContainer, "nextSibling");
      }
      if (format[0].block || format[0].selector) {
        startContainer = findBlockEndPoint(editor, format, startContainer, "previousSibling");
        endContainer = findBlockEndPoint(editor, format, endContainer, "nextSibling");
        if (format[0].block) {
          if (!dom2.isBlock(startContainer)) {
            startContainer = findParentContainer(dom2, format, startContainer, startOffset, true);
          }
          if (!dom2.isBlock(endContainer)) {
            endContainer = findParentContainer(dom2, format, endContainer, endOffset, false);
          }
        }
      }
      if (isElement$1(startContainer)) {
        startOffset = dom2.nodeIndex(startContainer);
        startContainer = startContainer.parentNode;
      }
      if (isElement$1(endContainer)) {
        endOffset = dom2.nodeIndex(endContainer) + 1;
        endContainer = endContainer.parentNode;
      }
      return {
        startContainer,
        startOffset,
        endContainer,
        endOffset
      };
    };
    var clampToExistingChildren = function(container, index) {
      var childNodes = container.childNodes;
      if (index >= childNodes.length) {
        index = childNodes.length - 1;
      } else if (index < 0) {
        index = 0;
      }
      return childNodes[index] || container;
    };
    var getEndChild = function(container, index) {
      return clampToExistingChildren(container, index - 1);
    };
    var walk$1 = function(dom2, rng, callback) {
      var startContainer = rng.startContainer;
      var startOffset = rng.startOffset;
      var endContainer = rng.endContainer;
      var endOffset = rng.endOffset;
      var exclude = function(nodes) {
        var node2;
        node2 = nodes[0];
        if (node2.nodeType === 3 && node2 === startContainer && startOffset >= node2.nodeValue.length) {
          nodes.splice(0, 1);
        }
        node2 = nodes[nodes.length - 1];
        if (endOffset === 0 && nodes.length > 0 && node2 === endContainer && node2.nodeType === 3) {
          nodes.splice(nodes.length - 1, 1);
        }
        return nodes;
      };
      var collectSiblings = function(node2, name2, endNode) {
        var siblings3 = [];
        for (; node2 && node2 !== endNode; node2 = node2[name2]) {
          siblings3.push(node2);
        }
        return siblings3;
      };
      var findEndPoint = function(node2, root) {
        do {
          if (node2.parentNode === root) {
            return node2;
          }
          node2 = node2.parentNode;
        } while (node2);
      };
      var walkBoundary = function(startNode, endNode, next) {
        var siblingName = next ? "nextSibling" : "previousSibling";
        for (var node2 = startNode, parent_1 = node2.parentNode; node2 && node2 !== endNode; node2 = parent_1) {
          parent_1 = node2.parentNode;
          var siblings_1 = collectSiblings(node2 === startNode ? node2 : node2[siblingName], siblingName);
          if (siblings_1.length) {
            if (!next) {
              siblings_1.reverse();
            }
            callback(exclude(siblings_1));
          }
        }
      };
      if (startContainer.nodeType === 1 && startContainer.hasChildNodes()) {
        startContainer = clampToExistingChildren(startContainer, startOffset);
      }
      if (endContainer.nodeType === 1 && endContainer.hasChildNodes()) {
        endContainer = getEndChild(endContainer, endOffset);
      }
      if (startContainer === endContainer) {
        return callback(exclude([startContainer]));
      }
      var ancestor2 = dom2.findCommonAncestor(startContainer, endContainer);
      for (var node = startContainer; node; node = node.parentNode) {
        if (node === endContainer) {
          return walkBoundary(startContainer, ancestor2, true);
        }
        if (node === ancestor2) {
          break;
        }
      }
      for (var node = endContainer; node; node = node.parentNode) {
        if (node === startContainer) {
          return walkBoundary(endContainer, ancestor2);
        }
        if (node === ancestor2) {
          break;
        }
      }
      var startPoint = findEndPoint(startContainer, ancestor2) || startContainer;
      var endPoint = findEndPoint(endContainer, ancestor2) || endContainer;
      walkBoundary(startContainer, startPoint, true);
      var siblings2 = collectSiblings(startPoint === startContainer ? startPoint : startPoint.nextSibling, "nextSibling", endPoint === endContainer ? endPoint.nextSibling : endPoint);
      if (siblings2.length) {
        callback(exclude(siblings2));
      }
      walkBoundary(endContainer, endPoint);
    };
    var getRanges = function(selection) {
      var ranges = [];
      if (selection) {
        for (var i = 0; i < selection.rangeCount; i++) {
          ranges.push(selection.getRangeAt(i));
        }
      }
      return ranges;
    };
    var getSelectedNodes = function(ranges) {
      return bind(ranges, function(range2) {
        var node = getSelectedNode(range2);
        return node ? [SugarElement.fromDom(node)] : [];
      });
    };
    var hasMultipleRanges = function(selection) {
      return getRanges(selection).length > 1;
    };
    var getCellsFromRanges = function(ranges) {
      return filter(getSelectedNodes(ranges), isTableCell$1);
    };
    var getCellsFromElement = function(elm) {
      return descendants$1(elm, "td[data-mce-selected],th[data-mce-selected]");
    };
    var getCellsFromElementOrRanges = function(ranges, element) {
      var selectedCells = getCellsFromElement(element);
      return selectedCells.length > 0 ? selectedCells : getCellsFromRanges(ranges);
    };
    var getCellsFromEditor = function(editor) {
      return getCellsFromElementOrRanges(getRanges(editor.selection.getSel()), SugarElement.fromDom(editor.getBody()));
    };
    var getStartNode = function(rng) {
      var sc = rng.startContainer, so = rng.startOffset;
      if (isText$1(sc)) {
        return so === 0 ? Optional.some(SugarElement.fromDom(sc)) : Optional.none();
      } else {
        return Optional.from(sc.childNodes[so]).map(SugarElement.fromDom);
      }
    };
    var getEndNode = function(rng) {
      var ec = rng.endContainer, eo = rng.endOffset;
      if (isText$1(ec)) {
        return eo === ec.data.length ? Optional.some(SugarElement.fromDom(ec)) : Optional.none();
      } else {
        return Optional.from(ec.childNodes[eo - 1]).map(SugarElement.fromDom);
      }
    };
    var getFirstChildren = function(node) {
      return firstChild(node).fold(constant([node]), function(child2) {
        return [node].concat(getFirstChildren(child2));
      });
    };
    var getLastChildren = function(node) {
      return lastChild(node).fold(constant([node]), function(child2) {
        if (name(child2) === "br") {
          return prevSibling(child2).map(function(sibling2) {
            return [node].concat(getLastChildren(sibling2));
          }).getOr([]);
        } else {
          return [node].concat(getLastChildren(child2));
        }
      });
    };
    var hasAllContentsSelected = function(elm, rng) {
      return lift2(getStartNode(rng), getEndNode(rng), function(startNode, endNode) {
        var start2 = find(getFirstChildren(elm), curry(eq$2, startNode));
        var end2 = find(getLastChildren(elm), curry(eq$2, endNode));
        return start2.isSome() && end2.isSome();
      }).getOr(false);
    };
    var moveEndPoint$1 = function(dom2, rng, node, start2) {
      var root = node, walker = new DomTreeWalker(node, root);
      var moveCaretBeforeOnEnterElementsMap = filter$1(dom2.schema.getMoveCaretBeforeOnEnterElements(), function(_, name2) {
        return !contains([
          "td",
          "th",
          "table"
        ], name2.toLowerCase());
      });
      do {
        if (isText$1(node) && Tools.trim(node.nodeValue).length !== 0) {
          if (start2) {
            rng.setStart(node, 0);
          } else {
            rng.setEnd(node, node.nodeValue.length);
          }
          return;
        }
        if (moveCaretBeforeOnEnterElementsMap[node.nodeName]) {
          if (start2) {
            rng.setStartBefore(node);
          } else {
            if (node.nodeName === "BR") {
              rng.setEndBefore(node);
            } else {
              rng.setEndAfter(node);
            }
          }
          return;
        }
      } while (node = start2 ? walker.next() : walker.prev());
      if (root.nodeName === "BODY") {
        if (start2) {
          rng.setStart(root, 0);
        } else {
          rng.setEnd(root, root.childNodes.length);
        }
      }
    };
    var hasAnyRanges = function(editor) {
      var sel = editor.selection.getSel();
      return sel && sel.rangeCount > 0;
    };
    var runOnRanges = function(editor, executor) {
      var fakeSelectionNodes = getCellsFromEditor(editor);
      if (fakeSelectionNodes.length > 0) {
        each(fakeSelectionNodes, function(elem) {
          var node = elem.dom;
          var fakeNodeRng = editor.dom.createRng();
          fakeNodeRng.setStartBefore(node);
          fakeNodeRng.setEndAfter(node);
          executor(fakeNodeRng, true);
        });
      } else {
        executor(editor.selection.getRng(), false);
      }
    };
    var preserve = function(selection, fillBookmark, executor) {
      var bookmark = getPersistentBookmark(selection, fillBookmark);
      executor(bookmark);
      selection.moveToBookmark(bookmark);
    };
    var NodeValue = function(is2, name2) {
      var get2 = function(element) {
        if (!is2(element)) {
          throw new Error("Can only get " + name2 + " value of a " + name2 + " node");
        }
        return getOption(element).getOr("");
      };
      var getOption = function(element) {
        return is2(element) ? Optional.from(element.dom.nodeValue) : Optional.none();
      };
      var set2 = function(element, value2) {
        if (!is2(element)) {
          throw new Error("Can only set raw " + name2 + " value of a " + name2 + " node");
        }
        element.dom.nodeValue = value2;
      };
      return {
        get: get2,
        getOption,
        set: set2
      };
    };
    var api = NodeValue(isText, "text");
    var get$8 = function(element) {
      return api.get(element);
    };
    var isZeroWidth = function(elem) {
      return isText(elem) && get$8(elem) === ZWSP;
    };
    var context = function(editor, elem, wrapName, nodeName) {
      return parent(elem).fold(function() {
        return "skipping";
      }, function(parent2) {
        if (nodeName === "br" || isZeroWidth(elem)) {
          return "valid";
        } else if (isAnnotation(elem)) {
          return "existing";
        } else if (isCaretNode(elem.dom)) {
          return "caret";
        } else if (!isValid(editor, wrapName, nodeName) || !isValid(editor, name(parent2), wrapName)) {
          return "invalid-child";
        } else {
          return "valid";
        }
      });
    };
    var applyWordGrab = function(editor, rng) {
      var r2 = expandRng(editor, rng, [{ inline: true }]);
      rng.setStart(r2.startContainer, r2.startOffset);
      rng.setEnd(r2.endContainer, r2.endOffset);
      editor.selection.setRng(rng);
    };
    var makeAnnotation = function(eDoc, _a, annotationName, decorate) {
      var _b = _a.uid, uid = _b === void 0 ? generate$1("mce-annotation") : _b, data2 = __rest(_a, ["uid"]);
      var master = SugarElement.fromTag("span", eDoc);
      add$3(master, annotation());
      set(master, "" + dataAnnotationId(), uid);
      set(master, "" + dataAnnotation(), annotationName);
      var _c = decorate(uid, data2), _d = _c.attributes, attributes2 = _d === void 0 ? {} : _d, _e = _c.classes, classes = _e === void 0 ? [] : _e;
      setAll(master, attributes2);
      add$4(master, classes);
      return master;
    };
    var annotate = function(editor, rng, annotationName, decorate, data2) {
      var newWrappers = [];
      var master = makeAnnotation(editor.getDoc(), data2, annotationName, decorate);
      var wrapper = Cell(Optional.none());
      var finishWrapper = function() {
        wrapper.set(Optional.none());
      };
      var getOrOpenWrapper = function() {
        return wrapper.get().getOrThunk(function() {
          var nu2 = shallow(master);
          newWrappers.push(nu2);
          wrapper.set(Optional.some(nu2));
          return nu2;
        });
      };
      var processElements = function(elems) {
        each(elems, processElement);
      };
      var processElement = function(elem) {
        var ctx = context(editor, elem, "span", name(elem));
        switch (ctx) {
          case "invalid-child": {
            finishWrapper();
            var children$1 = children(elem);
            processElements(children$1);
            finishWrapper();
            break;
          }
          case "valid": {
            var w = getOrOpenWrapper();
            wrap(elem, w);
            break;
          }
        }
      };
      var processNodes = function(nodes) {
        var elems = map(nodes, SugarElement.fromDom);
        processElements(elems);
      };
      walk$1(editor.dom, rng, function(nodes) {
        finishWrapper();
        processNodes(nodes);
      });
      return newWrappers;
    };
    var annotateWithBookmark = function(editor, name2, settings, data2) {
      editor.undoManager.transact(function() {
        var selection = editor.selection;
        var initialRng = selection.getRng();
        var hasFakeSelection = getCellsFromEditor(editor).length > 0;
        if (initialRng.collapsed && !hasFakeSelection) {
          applyWordGrab(editor, initialRng);
        }
        if (selection.getRng().collapsed && !hasFakeSelection) {
          var wrapper = makeAnnotation(editor.getDoc(), data2, name2, settings.decorate);
          set$1(wrapper, nbsp);
          selection.getRng().insertNode(wrapper.dom);
          selection.select(wrapper.dom);
        } else {
          preserve(selection, false, function() {
            runOnRanges(editor, function(selectionRng) {
              annotate(editor, selectionRng, name2, settings.decorate, data2);
            });
          });
        }
      });
    };
    var Annotator = function(editor) {
      var registry2 = create$2();
      setup$1(editor, registry2);
      var changes = setup(editor);
      return {
        register: function(name2, settings) {
          registry2.register(name2, settings);
        },
        annotate: function(name2, data2) {
          registry2.lookup(name2).each(function(settings) {
            annotateWithBookmark(editor, name2, settings, data2);
          });
        },
        annotationChanged: function(name2, callback) {
          changes.addListener(name2, callback);
        },
        remove: function(name2) {
          identify(editor, Optional.some(name2)).each(function(_a) {
            var elements = _a.elements;
            each(elements, unwrap);
          });
        },
        getAll: function(name2) {
          var directory = findAll(editor, name2);
          return map$1(directory, function(elems) {
            return map(elems, function(elem) {
              return elem.dom;
            });
          });
        }
      };
    };
    var BookmarkManager = function(selection) {
      return {
        getBookmark: curry(getBookmark$1, selection),
        moveToBookmark: curry(moveToBookmark, selection)
      };
    };
    BookmarkManager.isBookmarkNode = isBookmarkNode$1;
    var getContentEditableRoot = function(root, node) {
      while (node && node !== root) {
        if (isContentEditableTrue(node) || isContentEditableFalse(node)) {
          return node;
        }
        node = node.parentNode;
      }
      return null;
    };
    var isXYWithinRange = function(clientX, clientY, range2) {
      if (range2.collapsed) {
        return false;
      }
      if (Env.browser.isIE() && range2.startOffset === range2.endOffset - 1 && range2.startContainer === range2.endContainer) {
        var elm = range2.startContainer.childNodes[range2.startOffset];
        if (isElement$1(elm)) {
          return exists(elm.getClientRects(), function(rect) {
            return containsXY(rect, clientX, clientY);
          });
        }
      }
      return exists(range2.getClientRects(), function(rect) {
        return containsXY(rect, clientX, clientY);
      });
    };
    var firePreProcess = function(editor, args) {
      return editor.fire("PreProcess", args);
    };
    var firePostProcess = function(editor, args) {
      return editor.fire("PostProcess", args);
    };
    var fireRemove = function(editor) {
      return editor.fire("remove");
    };
    var fireDetach = function(editor) {
      return editor.fire("detach");
    };
    var fireSwitchMode = function(editor, mode) {
      return editor.fire("SwitchMode", { mode });
    };
    var fireObjectResizeStart = function(editor, target, width, height, origin) {
      editor.fire("ObjectResizeStart", {
        target,
        width,
        height,
        origin
      });
    };
    var fireObjectResized = function(editor, target, width, height, origin) {
      editor.fire("ObjectResized", {
        target,
        width,
        height,
        origin
      });
    };
    var firePreInit = function(editor) {
      return editor.fire("PreInit");
    };
    var firePostRender = function(editor) {
      return editor.fire("PostRender");
    };
    var fireInit = function(editor) {
      return editor.fire("Init");
    };
    var firePlaceholderToggle = function(editor, state) {
      return editor.fire("PlaceholderToggle", { state });
    };
    var fireError = function(editor, errorType, error2) {
      return editor.fire(errorType, error2);
    };
    var VK = {
      BACKSPACE: 8,
      DELETE: 46,
      DOWN: 40,
      ENTER: 13,
      LEFT: 37,
      RIGHT: 39,
      SPACEBAR: 32,
      TAB: 9,
      UP: 38,
      PAGE_UP: 33,
      PAGE_DOWN: 34,
      END: 35,
      HOME: 36,
      modifierPressed: function(e) {
        return e.shiftKey || e.ctrlKey || e.altKey || VK.metaKeyPressed(e);
      },
      metaKeyPressed: function(e) {
        return Env.mac ? e.metaKey : e.ctrlKey && !e.altKey;
      }
    };
    var isContentEditableFalse$6 = isContentEditableFalse;
    var ControlSelection = function(selection, editor) {
      var elementSelectionAttr = "data-mce-selected";
      var dom2 = editor.dom, each$22 = Tools.each;
      var selectedElm, selectedElmGhost, resizeHelper, selectedHandle, resizeBackdrop;
      var startX, startY, selectedElmX, selectedElmY, startW, startH, ratio, resizeStarted;
      var width, height;
      var editableDoc = editor.getDoc(), rootDocument = document;
      var abs = Math.abs, round2 = Math.round, rootElement = editor.getBody();
      var startScrollWidth, startScrollHeight;
      var resizeHandles = {
        nw: [
          0,
          0,
          -1,
          -1
        ],
        ne: [
          1,
          0,
          1,
          -1
        ],
        se: [
          1,
          1,
          1,
          1
        ],
        sw: [
          0,
          1,
          -1,
          1
        ]
      };
      var isImage = function(elm) {
        return elm && (elm.nodeName === "IMG" || editor.dom.is(elm, "figure.image"));
      };
      var isMedia$12 = function(elm) {
        return isMedia(elm) || dom2.hasClass(elm, "mce-preview-object");
      };
      var isEventOnImageOutsideRange = function(evt, range2) {
        if (evt.type === "longpress" || evt.type.indexOf("touch") === 0) {
          var touch = evt.touches[0];
          return isImage(evt.target) && !isXYWithinRange(touch.clientX, touch.clientY, range2);
        } else {
          return isImage(evt.target) && !isXYWithinRange(evt.clientX, evt.clientY, range2);
        }
      };
      var contextMenuSelectImage = function(evt) {
        var target = evt.target;
        if (isEventOnImageOutsideRange(evt, editor.selection.getRng()) && !evt.isDefaultPrevented()) {
          editor.selection.select(target);
        }
      };
      var getResizeTargets = function(elm) {
        if (dom2.is(elm, "figure.image")) {
          return [elm.querySelector("img")];
        } else if (dom2.hasClass(elm, "mce-preview-object") && isNonNullable(elm.firstElementChild)) {
          return [
            elm,
            elm.firstElementChild
          ];
        } else {
          return [elm];
        }
      };
      var isResizable = function(elm) {
        var selector = getObjectResizing(editor);
        if (!selector) {
          return false;
        }
        if (elm.getAttribute("data-mce-resize") === "false") {
          return false;
        }
        if (elm === editor.getBody()) {
          return false;
        }
        if (dom2.hasClass(elm, "mce-preview-object")) {
          return is$1(SugarElement.fromDom(elm.firstElementChild), selector);
        } else {
          return is$1(SugarElement.fromDom(elm), selector);
        }
      };
      var createGhostElement = function(elm) {
        if (isMedia$12(elm)) {
          return dom2.create("img", { src: Env.transparentSrc });
        } else {
          return elm.cloneNode(true);
        }
      };
      var setSizeProp = function(element, name2, value2) {
        if (isNonNullable(value2)) {
          var targets = getResizeTargets(element);
          each(targets, function(target) {
            if (target.style[name2] || !editor.schema.isValid(target.nodeName.toLowerCase(), name2)) {
              dom2.setStyle(target, name2, value2);
            } else {
              dom2.setAttrib(target, name2, "" + value2);
            }
          });
        }
      };
      var setGhostElmSize = function(ghostElm, width2, height2) {
        setSizeProp(ghostElm, "width", width2);
        setSizeProp(ghostElm, "height", height2);
      };
      var resizeGhostElement = function(e) {
        var deltaX, deltaY, proportional;
        var resizeHelperX, resizeHelperY;
        deltaX = e.screenX - startX;
        deltaY = e.screenY - startY;
        width = deltaX * selectedHandle[2] + startW;
        height = deltaY * selectedHandle[3] + startH;
        width = width < 5 ? 5 : width;
        height = height < 5 ? 5 : height;
        if ((isImage(selectedElm) || isMedia$12(selectedElm)) && getResizeImgProportional(editor) !== false) {
          proportional = !VK.modifierPressed(e);
        } else {
          proportional = VK.modifierPressed(e);
        }
        if (proportional) {
          if (abs(deltaX) > abs(deltaY)) {
            height = round2(width * ratio);
            width = round2(height / ratio);
          } else {
            width = round2(height / ratio);
            height = round2(width * ratio);
          }
        }
        setGhostElmSize(selectedElmGhost, width, height);
        resizeHelperX = selectedHandle.startPos.x + deltaX;
        resizeHelperY = selectedHandle.startPos.y + deltaY;
        resizeHelperX = resizeHelperX > 0 ? resizeHelperX : 0;
        resizeHelperY = resizeHelperY > 0 ? resizeHelperY : 0;
        dom2.setStyles(resizeHelper, {
          left: resizeHelperX,
          top: resizeHelperY,
          display: "block"
        });
        resizeHelper.innerHTML = width + " &times; " + height;
        if (selectedHandle[2] < 0 && selectedElmGhost.clientWidth <= width) {
          dom2.setStyle(selectedElmGhost, "left", selectedElmX + (startW - width));
        }
        if (selectedHandle[3] < 0 && selectedElmGhost.clientHeight <= height) {
          dom2.setStyle(selectedElmGhost, "top", selectedElmY + (startH - height));
        }
        deltaX = rootElement.scrollWidth - startScrollWidth;
        deltaY = rootElement.scrollHeight - startScrollHeight;
        if (deltaX + deltaY !== 0) {
          dom2.setStyles(resizeHelper, {
            left: resizeHelperX - deltaX,
            top: resizeHelperY - deltaY
          });
        }
        if (!resizeStarted) {
          fireObjectResizeStart(editor, selectedElm, startW, startH, "corner-" + selectedHandle.name);
          resizeStarted = true;
        }
      };
      var endGhostResize = function() {
        var wasResizeStarted = resizeStarted;
        resizeStarted = false;
        if (wasResizeStarted) {
          setSizeProp(selectedElm, "width", width);
          setSizeProp(selectedElm, "height", height);
        }
        dom2.unbind(editableDoc, "mousemove", resizeGhostElement);
        dom2.unbind(editableDoc, "mouseup", endGhostResize);
        if (rootDocument !== editableDoc) {
          dom2.unbind(rootDocument, "mousemove", resizeGhostElement);
          dom2.unbind(rootDocument, "mouseup", endGhostResize);
        }
        dom2.remove(selectedElmGhost);
        dom2.remove(resizeHelper);
        dom2.remove(resizeBackdrop);
        showResizeRect(selectedElm);
        if (wasResizeStarted) {
          fireObjectResized(editor, selectedElm, width, height, "corner-" + selectedHandle.name);
          dom2.setAttrib(selectedElm, "style", dom2.getAttrib(selectedElm, "style"));
        }
        editor.nodeChanged();
      };
      var showResizeRect = function(targetElm) {
        unbindResizeHandleEvents();
        var position = dom2.getPos(targetElm, rootElement);
        var selectedElmX2 = position.x;
        var selectedElmY2 = position.y;
        var rect = targetElm.getBoundingClientRect();
        var targetWidth = rect.width || rect.right - rect.left;
        var targetHeight = rect.height || rect.bottom - rect.top;
        if (selectedElm !== targetElm) {
          hideResizeRect();
          selectedElm = targetElm;
          width = height = 0;
        }
        var e = editor.fire("ObjectSelected", { target: targetElm });
        var selectedValue = dom2.getAttrib(selectedElm, elementSelectionAttr, "1");
        if (isResizable(targetElm) && !e.isDefaultPrevented()) {
          each$22(resizeHandles, function(handle2, name2) {
            var handleElm;
            var startDrag = function(e2) {
              var target = getResizeTargets(selectedElm)[0];
              startX = e2.screenX;
              startY = e2.screenY;
              startW = target.clientWidth;
              startH = target.clientHeight;
              ratio = startH / startW;
              selectedHandle = handle2;
              selectedHandle.name = name2;
              selectedHandle.startPos = {
                x: targetWidth * handle2[0] + selectedElmX2,
                y: targetHeight * handle2[1] + selectedElmY2
              };
              startScrollWidth = rootElement.scrollWidth;
              startScrollHeight = rootElement.scrollHeight;
              resizeBackdrop = dom2.add(rootElement, "div", { class: "mce-resize-backdrop" });
              dom2.setStyles(resizeBackdrop, {
                position: "fixed",
                left: "0",
                top: "0",
                width: "100%",
                height: "100%"
              });
              selectedElmGhost = createGhostElement(selectedElm);
              dom2.addClass(selectedElmGhost, "mce-clonedresizable");
              dom2.setAttrib(selectedElmGhost, "data-mce-bogus", "all");
              selectedElmGhost.contentEditable = "false";
              dom2.setStyles(selectedElmGhost, {
                left: selectedElmX2,
                top: selectedElmY2,
                margin: 0
              });
              setGhostElmSize(selectedElmGhost, targetWidth, targetHeight);
              selectedElmGhost.removeAttribute(elementSelectionAttr);
              rootElement.appendChild(selectedElmGhost);
              dom2.bind(editableDoc, "mousemove", resizeGhostElement);
              dom2.bind(editableDoc, "mouseup", endGhostResize);
              if (rootDocument !== editableDoc) {
                dom2.bind(rootDocument, "mousemove", resizeGhostElement);
                dom2.bind(rootDocument, "mouseup", endGhostResize);
              }
              resizeHelper = dom2.add(rootElement, "div", {
                "class": "mce-resize-helper",
                "data-mce-bogus": "all"
              }, startW + " &times; " + startH);
            };
            handleElm = dom2.get("mceResizeHandle" + name2);
            if (handleElm) {
              dom2.remove(handleElm);
            }
            handleElm = dom2.add(rootElement, "div", {
              "id": "mceResizeHandle" + name2,
              "data-mce-bogus": "all",
              "class": "mce-resizehandle",
              "unselectable": true,
              "style": "cursor:" + name2 + "-resize; margin:0; padding:0"
            });
            if (Env.ie === 11) {
              handleElm.contentEditable = false;
            }
            dom2.bind(handleElm, "mousedown", function(e2) {
              e2.stopImmediatePropagation();
              e2.preventDefault();
              startDrag(e2);
            });
            handle2.elm = handleElm;
            dom2.setStyles(handleElm, {
              left: targetWidth * handle2[0] + selectedElmX2 - handleElm.offsetWidth / 2,
              top: targetHeight * handle2[1] + selectedElmY2 - handleElm.offsetHeight / 2
            });
          });
        } else {
          hideResizeRect();
        }
        if (!dom2.getAttrib(selectedElm, elementSelectionAttr)) {
          selectedElm.setAttribute(elementSelectionAttr, selectedValue);
        }
      };
      var hideResizeRect = function() {
        unbindResizeHandleEvents();
        if (selectedElm) {
          selectedElm.removeAttribute(elementSelectionAttr);
        }
        each$1(resizeHandles, function(value2, name2) {
          var handleElm = dom2.get("mceResizeHandle" + name2);
          if (handleElm) {
            dom2.unbind(handleElm);
            dom2.remove(handleElm);
          }
        });
      };
      var updateResizeRect = function(e) {
        var startElm, controlElm;
        var isChildOrEqual = function(node, parent2) {
          if (node) {
            do {
              if (node === parent2) {
                return true;
              }
            } while (node = node.parentNode);
          }
        };
        if (resizeStarted || editor.removed) {
          return;
        }
        each$22(dom2.select("img[data-mce-selected],hr[data-mce-selected]"), function(img) {
          img.removeAttribute(elementSelectionAttr);
        });
        controlElm = e.type === "mousedown" ? e.target : selection.getNode();
        controlElm = dom2.$(controlElm).closest("table,img,figure.image,hr,video,span.mce-preview-object")[0];
        if (isChildOrEqual(controlElm, rootElement)) {
          disableGeckoResize();
          startElm = selection.getStart(true);
          if (isChildOrEqual(startElm, controlElm) && isChildOrEqual(selection.getEnd(true), controlElm)) {
            showResizeRect(controlElm);
            return;
          }
        }
        hideResizeRect();
      };
      var isWithinContentEditableFalse = function(elm) {
        return isContentEditableFalse$6(getContentEditableRoot(editor.getBody(), elm));
      };
      var unbindResizeHandleEvents = function() {
        each$1(resizeHandles, function(handle2) {
          if (handle2.elm) {
            dom2.unbind(handle2.elm);
            delete handle2.elm;
          }
        });
      };
      var disableGeckoResize = function() {
        try {
          editor.getDoc().execCommand("enableObjectResizing", false, "false");
        } catch (ex) {
        }
      };
      editor.on("init", function() {
        disableGeckoResize();
        if (Env.browser.isIE() || Env.browser.isEdge()) {
          editor.on("mousedown click", function(e) {
            var target = e.target, nodeName = target.nodeName;
            if (!resizeStarted && /^(TABLE|IMG|HR)$/.test(nodeName) && !isWithinContentEditableFalse(target)) {
              if (e.button !== 2) {
                editor.selection.select(target, nodeName === "TABLE");
              }
              if (e.type === "mousedown") {
                editor.nodeChanged();
              }
            }
          });
          var handleMSControlSelect_1 = function(e) {
            var delayedSelect = function(node) {
              Delay.setEditorTimeout(editor, function() {
                return editor.selection.select(node);
              });
            };
            if (isWithinContentEditableFalse(e.target) || isMedia(e.target)) {
              e.preventDefault();
              delayedSelect(e.target);
              return;
            }
            if (/^(TABLE|IMG|HR)$/.test(e.target.nodeName)) {
              e.preventDefault();
              if (e.target.tagName === "IMG") {
                delayedSelect(e.target);
              }
            }
          };
          dom2.bind(rootElement, "mscontrolselect", handleMSControlSelect_1);
          editor.on("remove", function() {
            return dom2.unbind(rootElement, "mscontrolselect", handleMSControlSelect_1);
          });
        }
        var throttledUpdateResizeRect = Delay.throttle(function(e) {
          if (!editor.composing) {
            updateResizeRect(e);
          }
        });
        editor.on("nodechange ResizeEditor ResizeWindow ResizeContent drop FullscreenStateChanged", throttledUpdateResizeRect);
        editor.on("keyup compositionend", function(e) {
          if (selectedElm && selectedElm.nodeName === "TABLE") {
            throttledUpdateResizeRect(e);
          }
        });
        editor.on("hide blur", hideResizeRect);
        editor.on("contextmenu longpress", contextMenuSelectImage, true);
      });
      editor.on("remove", unbindResizeHandleEvents);
      var destroy2 = function() {
        selectedElm = selectedElmGhost = resizeBackdrop = null;
      };
      return {
        isResizable,
        showResizeRect,
        hideResizeRect,
        updateResizeRect,
        destroy: destroy2
      };
    };
    var hasCeProperty = function(node) {
      return isContentEditableTrue(node) || isContentEditableFalse(node);
    };
    var findParent = function(node, rootNode, predicate) {
      while (node && node !== rootNode) {
        if (predicate(node)) {
          return node;
        }
        node = node.parentNode;
      }
      return null;
    };
    var findClosestIeRange = function(clientX, clientY, doc2) {
      var rects;
      var element = doc2.elementFromPoint(clientX, clientY);
      var rng = doc2.body.createTextRange();
      if (!element || element.tagName === "HTML") {
        element = doc2.body;
      }
      rng.moveToElementText(element);
      rects = Tools.toArray(rng.getClientRects());
      rects = rects.sort(function(a, b) {
        a = Math.abs(Math.max(a.top - clientY, a.bottom - clientY));
        b = Math.abs(Math.max(b.top - clientY, b.bottom - clientY));
        return a - b;
      });
      if (rects.length > 0) {
        clientY = (rects[0].bottom + rects[0].top) / 2;
        try {
          rng.moveToPoint(clientX, clientY);
          rng.collapse(true);
          return rng;
        } catch (ex) {
        }
      }
      return null;
    };
    var moveOutOfContentEditableFalse = function(rng, rootNode) {
      var parentElement = rng && rng.parentElement ? rng.parentElement() : null;
      return isContentEditableFalse(findParent(parentElement, rootNode, hasCeProperty)) ? null : rng;
    };
    var fromPoint$1 = function(clientX, clientY, doc2) {
      var rng, point;
      var pointDoc = doc2;
      if (pointDoc.caretPositionFromPoint) {
        point = pointDoc.caretPositionFromPoint(clientX, clientY);
        if (point) {
          rng = doc2.createRange();
          rng.setStart(point.offsetNode, point.offset);
          rng.collapse(true);
        }
      } else if (doc2.caretRangeFromPoint) {
        rng = doc2.caretRangeFromPoint(clientX, clientY);
      } else if (pointDoc.body.createTextRange) {
        rng = pointDoc.body.createTextRange();
        try {
          rng.moveToPoint(clientX, clientY);
          rng.collapse(true);
        } catch (ex) {
          rng = findClosestIeRange(clientX, clientY, doc2);
        }
        return moveOutOfContentEditableFalse(rng, doc2.body);
      }
      return rng;
    };
    var isEq$1 = function(rng1, rng2) {
      return rng1 && rng2 && (rng1.startContainer === rng2.startContainer && rng1.startOffset === rng2.startOffset) && (rng1.endContainer === rng2.endContainer && rng1.endOffset === rng2.endOffset);
    };
    var findParent$1 = function(node, rootNode, predicate) {
      while (node && node !== rootNode) {
        if (predicate(node)) {
          return node;
        }
        node = node.parentNode;
      }
      return null;
    };
    var hasParent = function(node, rootNode, predicate) {
      return findParent$1(node, rootNode, predicate) !== null;
    };
    var hasParentWithName = function(node, rootNode, name2) {
      return hasParent(node, rootNode, function(node2) {
        return node2.nodeName === name2;
      });
    };
    var isTable$3 = function(node) {
      return node && node.nodeName === "TABLE";
    };
    var isTableCell$3 = function(node) {
      return node && /^(TD|TH|CAPTION)$/.test(node.nodeName);
    };
    var isCeFalseCaretContainer = function(node, rootNode) {
      return isCaretContainer(node) && hasParent(node, rootNode, isCaretNode) === false;
    };
    var hasBrBeforeAfter = function(dom2, node, left) {
      var walker = new DomTreeWalker(node, dom2.getParent(node.parentNode, dom2.isBlock) || dom2.getRoot());
      while (node = walker[left ? "prev" : "next"]()) {
        if (isBr(node)) {
          return true;
        }
      }
    };
    var isPrevNode = function(node, name2) {
      return node.previousSibling && node.previousSibling.nodeName === name2;
    };
    var hasContentEditableFalseParent = function(body, node) {
      while (node && node !== body) {
        if (isContentEditableFalse(node)) {
          return true;
        }
        node = node.parentNode;
      }
      return false;
    };
    var findTextNodeRelative = function(dom2, isAfterNode, collapsed, left, startNode) {
      var lastInlineElement;
      var body = dom2.getRoot();
      var node;
      var nonEmptyElementsMap = dom2.schema.getNonEmptyElements();
      var parentBlockContainer = dom2.getParent(startNode.parentNode, dom2.isBlock) || body;
      if (left && isBr(startNode) && isAfterNode && dom2.isEmpty(parentBlockContainer)) {
        return Optional.some(CaretPosition(startNode.parentNode, dom2.nodeIndex(startNode)));
      }
      var walker = new DomTreeWalker(startNode, parentBlockContainer);
      while (node = walker[left ? "prev" : "next"]()) {
        if (dom2.getContentEditableParent(node) === "false" || isCeFalseCaretContainer(node, body)) {
          return Optional.none();
        }
        if (isText$1(node) && node.nodeValue.length > 0) {
          if (hasParentWithName(node, body, "A") === false) {
            return Optional.some(CaretPosition(node, left ? node.nodeValue.length : 0));
          }
          return Optional.none();
        }
        if (dom2.isBlock(node) || nonEmptyElementsMap[node.nodeName.toLowerCase()]) {
          return Optional.none();
        }
        lastInlineElement = node;
      }
      if (collapsed && lastInlineElement) {
        return Optional.some(CaretPosition(lastInlineElement, 0));
      }
      return Optional.none();
    };
    var normalizeEndPoint = function(dom2, collapsed, start2, rng) {
      var container, offset;
      var body = dom2.getRoot();
      var node;
      var directionLeft, normalized = false;
      container = rng[(start2 ? "start" : "end") + "Container"];
      offset = rng[(start2 ? "start" : "end") + "Offset"];
      var isAfterNode = isElement$1(container) && offset === container.childNodes.length;
      var nonEmptyElementsMap = dom2.schema.getNonEmptyElements();
      directionLeft = start2;
      if (isCaretContainer(container)) {
        return Optional.none();
      }
      if (isElement$1(container) && offset > container.childNodes.length - 1) {
        directionLeft = false;
      }
      if (isDocument$1(container)) {
        container = body;
        offset = 0;
      }
      if (container === body) {
        if (directionLeft) {
          node = container.childNodes[offset > 0 ? offset - 1 : 0];
          if (node) {
            if (isCaretContainer(node)) {
              return Optional.none();
            }
            if (nonEmptyElementsMap[node.nodeName] || isTable$3(node)) {
              return Optional.none();
            }
          }
        }
        if (container.hasChildNodes()) {
          offset = Math.min(!directionLeft && offset > 0 ? offset - 1 : offset, container.childNodes.length - 1);
          container = container.childNodes[offset];
          offset = isText$1(container) && isAfterNode ? container.data.length : 0;
          if (!collapsed && container === body.lastChild && isTable$3(container)) {
            return Optional.none();
          }
          if (hasContentEditableFalseParent(body, container) || isCaretContainer(container)) {
            return Optional.none();
          }
          if (container.hasChildNodes() && isTable$3(container) === false) {
            node = container;
            var walker = new DomTreeWalker(container, body);
            do {
              if (isContentEditableFalse(node) || isCaretContainer(node)) {
                normalized = false;
                break;
              }
              if (isText$1(node) && node.nodeValue.length > 0) {
                offset = directionLeft ? 0 : node.nodeValue.length;
                container = node;
                normalized = true;
                break;
              }
              if (nonEmptyElementsMap[node.nodeName.toLowerCase()] && !isTableCell$3(node)) {
                offset = dom2.nodeIndex(node);
                container = node.parentNode;
                if (!directionLeft) {
                  offset++;
                }
                normalized = true;
                break;
              }
            } while (node = directionLeft ? walker.next() : walker.prev());
          }
        }
      }
      if (collapsed) {
        if (isText$1(container) && offset === 0) {
          findTextNodeRelative(dom2, isAfterNode, collapsed, true, container).each(function(pos) {
            container = pos.container();
            offset = pos.offset();
            normalized = true;
          });
        }
        if (isElement$1(container)) {
          node = container.childNodes[offset];
          if (!node) {
            node = container.childNodes[offset - 1];
          }
          if (node && isBr(node) && !isPrevNode(node, "A") && !hasBrBeforeAfter(dom2, node, false) && !hasBrBeforeAfter(dom2, node, true)) {
            findTextNodeRelative(dom2, isAfterNode, collapsed, true, node).each(function(pos) {
              container = pos.container();
              offset = pos.offset();
              normalized = true;
            });
          }
        }
      }
      if (directionLeft && !collapsed && isText$1(container) && offset === container.nodeValue.length) {
        findTextNodeRelative(dom2, isAfterNode, collapsed, false, container).each(function(pos) {
          container = pos.container();
          offset = pos.offset();
          normalized = true;
        });
      }
      return normalized ? Optional.some(CaretPosition(container, offset)) : Optional.none();
    };
    var normalize = function(dom2, rng) {
      var collapsed = rng.collapsed, normRng = rng.cloneRange();
      var startPos = CaretPosition.fromRangeStart(rng);
      normalizeEndPoint(dom2, collapsed, true, normRng).each(function(pos) {
        if (!collapsed || !CaretPosition.isAbove(startPos, pos)) {
          normRng.setStart(pos.container(), pos.offset());
        }
      });
      if (!collapsed) {
        normalizeEndPoint(dom2, collapsed, false, normRng).each(function(pos) {
          normRng.setEnd(pos.container(), pos.offset());
        });
      }
      if (collapsed) {
        normRng.collapse(true);
      }
      return isEq$1(rng, normRng) ? Optional.none() : Optional.some(normRng);
    };
    var splitText = function(node, offset) {
      return node.splitText(offset);
    };
    var split$1 = function(rng) {
      var startContainer = rng.startContainer, startOffset = rng.startOffset, endContainer = rng.endContainer, endOffset = rng.endOffset;
      if (startContainer === endContainer && isText$1(startContainer)) {
        if (startOffset > 0 && startOffset < startContainer.nodeValue.length) {
          endContainer = splitText(startContainer, startOffset);
          startContainer = endContainer.previousSibling;
          if (endOffset > startOffset) {
            endOffset = endOffset - startOffset;
            startContainer = endContainer = splitText(endContainer, endOffset).previousSibling;
            endOffset = endContainer.nodeValue.length;
            startOffset = 0;
          } else {
            endOffset = 0;
          }
        }
      } else {
        if (isText$1(startContainer) && startOffset > 0 && startOffset < startContainer.nodeValue.length) {
          startContainer = splitText(startContainer, startOffset);
          startOffset = 0;
        }
        if (isText$1(endContainer) && endOffset > 0 && endOffset < endContainer.nodeValue.length) {
          endContainer = splitText(endContainer, endOffset).previousSibling;
          endOffset = endContainer.nodeValue.length;
        }
      }
      return {
        startContainer,
        startOffset,
        endContainer,
        endOffset
      };
    };
    var RangeUtils = function(dom2) {
      var walk2 = function(rng, callback) {
        return walk$1(dom2, rng, callback);
      };
      var split2 = split$1;
      var normalize$12 = function(rng) {
        return normalize(dom2, rng).fold(never, function(normalizedRng) {
          rng.setStart(normalizedRng.startContainer, normalizedRng.startOffset);
          rng.setEnd(normalizedRng.endContainer, normalizedRng.endOffset);
          return true;
        });
      };
      return {
        walk: walk2,
        split: split2,
        normalize: normalize$12
      };
    };
    RangeUtils.compareRanges = isEq$1;
    RangeUtils.getCaretRangeFromPoint = fromPoint$1;
    RangeUtils.getSelectedNode = getSelectedNode;
    RangeUtils.getNode = getNode;
    var Dimension = function(name2, getOffset) {
      var set2 = function(element, h2) {
        if (!isNumber(h2) && !h2.match(/^[0-9]+$/)) {
          throw new Error(name2 + ".set accepts only positive integer values. Value was " + h2);
        }
        var dom2 = element.dom;
        if (isSupported$1(dom2)) {
          dom2.style[name2] = h2 + "px";
        }
      };
      var get2 = function(element) {
        var r2 = getOffset(element);
        if (r2 <= 0 || r2 === null) {
          var css = get$5(element, name2);
          return parseFloat(css) || 0;
        }
        return r2;
      };
      var getOuter = get2;
      var aggregate = function(element, properties) {
        return foldl(properties, function(acc, property) {
          var val = get$5(element, property);
          var value2 = val === void 0 ? 0 : parseInt(val, 10);
          return isNaN(value2) ? acc : acc + value2;
        }, 0);
      };
      var max2 = function(element, value2, properties) {
        var cumulativeInclusions = aggregate(element, properties);
        var absoluteMax = value2 > cumulativeInclusions ? value2 - cumulativeInclusions : 0;
        return absoluteMax;
      };
      return {
        set: set2,
        get: get2,
        getOuter,
        aggregate,
        max: max2
      };
    };
    var api$1 = Dimension("height", function(element) {
      var dom2 = element.dom;
      return inBody(element) ? dom2.getBoundingClientRect().height : dom2.offsetHeight;
    });
    var get$9 = function(element) {
      return api$1.get(element);
    };
    var walkUp = function(navigation, doc2) {
      var frame = navigation.view(doc2);
      return frame.fold(constant([]), function(f) {
        var parent2 = navigation.owner(f);
        var rest = walkUp(navigation, parent2);
        return [f].concat(rest);
      });
    };
    var pathTo = function(element, navigation) {
      var d = navigation.owner(element);
      return walkUp(navigation, d);
    };
    var view = function(doc2) {
      var _a;
      var element = doc2.dom === document ? Optional.none() : Optional.from((_a = doc2.dom.defaultView) === null || _a === void 0 ? void 0 : _a.frameElement);
      return element.map(SugarElement.fromDom);
    };
    var owner$1 = function(element) {
      return documentOrOwner(element);
    };
    var Navigation = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      view,
      owner: owner$1
    });
    var find$2 = function(element) {
      var doc2 = SugarElement.fromDom(document);
      var scroll = get$2(doc2);
      var frames = pathTo(element, Navigation);
      var offset = viewport(element);
      var r2 = foldr(frames, function(b, a) {
        var loc = viewport(a);
        return {
          left: b.left + loc.left,
          top: b.top + loc.top
        };
      }, {
        left: 0,
        top: 0
      });
      return SugarPosition(r2.left + offset.left + scroll.left, r2.top + offset.top + scroll.top);
    };
    var excludeFromDescend = function(element) {
      return name(element) === "textarea";
    };
    var fireScrollIntoViewEvent = function(editor, data2) {
      var scrollEvent = editor.fire("ScrollIntoView", data2);
      return scrollEvent.isDefaultPrevented();
    };
    var fireAfterScrollIntoViewEvent = function(editor, data2) {
      editor.fire("AfterScrollIntoView", data2);
    };
    var descend = function(element, offset) {
      var children$1 = children(element);
      if (children$1.length === 0 || excludeFromDescend(element)) {
        return {
          element,
          offset
        };
      } else if (offset < children$1.length && !excludeFromDescend(children$1[offset])) {
        return {
          element: children$1[offset],
          offset: 0
        };
      } else {
        var last2 = children$1[children$1.length - 1];
        if (excludeFromDescend(last2)) {
          return {
            element,
            offset
          };
        } else {
          if (name(last2) === "img") {
            return {
              element: last2,
              offset: 1
            };
          } else if (isText(last2)) {
            return {
              element: last2,
              offset: get$8(last2).length
            };
          } else {
            return {
              element: last2,
              offset: children(last2).length
            };
          }
        }
      }
    };
    var markerInfo = function(element, cleanupFun) {
      var pos = absolute(element);
      var height = get$9(element);
      return {
        element,
        bottom: pos.top + height,
        height,
        pos,
        cleanup: cleanupFun
      };
    };
    var createMarker = function(element, offset) {
      var startPoint = descend(element, offset);
      var span = SugarElement.fromHtml('<span data-mce-bogus="all">' + ZWSP + "</span>");
      before(startPoint.element, span);
      return markerInfo(span, function() {
        return remove(span);
      });
    };
    var elementMarker = function(element) {
      return markerInfo(SugarElement.fromDom(element), noop);
    };
    var withMarker = function(editor, f, rng, alignToTop) {
      preserveWith(editor, function(_s, _e) {
        return applyWithMarker(editor, f, rng, alignToTop);
      }, rng);
    };
    var withScrollEvents = function(editor, doc2, f, marker, alignToTop) {
      var data2 = {
        elm: marker.element.dom,
        alignToTop
      };
      if (fireScrollIntoViewEvent(editor, data2)) {
        return;
      }
      var scrollTop = get$2(doc2).top;
      f(doc2, scrollTop, marker, alignToTop);
      fireAfterScrollIntoViewEvent(editor, data2);
    };
    var applyWithMarker = function(editor, f, rng, alignToTop) {
      var body = SugarElement.fromDom(editor.getBody());
      var doc2 = SugarElement.fromDom(editor.getDoc());
      reflow(body);
      var marker = createMarker(SugarElement.fromDom(rng.startContainer), rng.startOffset);
      withScrollEvents(editor, doc2, f, marker, alignToTop);
      marker.cleanup();
    };
    var withElement = function(editor, element, f, alignToTop) {
      var doc2 = SugarElement.fromDom(editor.getDoc());
      withScrollEvents(editor, doc2, f, elementMarker(element), alignToTop);
    };
    var preserveWith = function(editor, f, rng) {
      var startElement = rng.startContainer;
      var startOffset = rng.startOffset;
      var endElement = rng.endContainer;
      var endOffset = rng.endOffset;
      f(SugarElement.fromDom(startElement), SugarElement.fromDom(endElement));
      var newRng = editor.dom.createRng();
      newRng.setStart(startElement, startOffset);
      newRng.setEnd(endElement, endOffset);
      editor.selection.setRng(rng);
    };
    var scrollToMarker = function(marker, viewHeight, alignToTop, doc2) {
      var pos = marker.pos;
      if (alignToTop) {
        to(pos.left, pos.top, doc2);
      } else {
        var y = pos.top - viewHeight + marker.height;
        to(pos.left, y, doc2);
      }
    };
    var intoWindowIfNeeded = function(doc2, scrollTop, viewHeight, marker, alignToTop) {
      var viewportBottom = viewHeight + scrollTop;
      var markerTop = marker.pos.top;
      var markerBottom = marker.bottom;
      var largerThanViewport = markerBottom - markerTop >= viewHeight;
      if (markerTop < scrollTop) {
        scrollToMarker(marker, viewHeight, alignToTop !== false, doc2);
      } else if (markerTop > viewportBottom) {
        var align = largerThanViewport ? alignToTop !== false : alignToTop === true;
        scrollToMarker(marker, viewHeight, align, doc2);
      } else if (markerBottom > viewportBottom && !largerThanViewport) {
        scrollToMarker(marker, viewHeight, alignToTop === true, doc2);
      }
    };
    var intoWindow = function(doc2, scrollTop, marker, alignToTop) {
      var viewHeight = doc2.dom.defaultView.innerHeight;
      intoWindowIfNeeded(doc2, scrollTop, viewHeight, marker, alignToTop);
    };
    var intoFrame = function(doc2, scrollTop, marker, alignToTop) {
      var frameViewHeight = doc2.dom.defaultView.innerHeight;
      intoWindowIfNeeded(doc2, scrollTop, frameViewHeight, marker, alignToTop);
      var op = find$2(marker.element);
      var viewportBounds = getBounds(window);
      if (op.top < viewportBounds.y) {
        intoView(marker.element, alignToTop !== false);
      } else if (op.top > viewportBounds.bottom) {
        intoView(marker.element, alignToTop === true);
      }
    };
    var rangeIntoWindow = function(editor, rng, alignToTop) {
      return withMarker(editor, intoWindow, rng, alignToTop);
    };
    var elementIntoWindow = function(editor, element, alignToTop) {
      return withElement(editor, element, intoWindow, alignToTop);
    };
    var rangeIntoFrame = function(editor, rng, alignToTop) {
      return withMarker(editor, intoFrame, rng, alignToTop);
    };
    var elementIntoFrame = function(editor, element, alignToTop) {
      return withElement(editor, element, intoFrame, alignToTop);
    };
    var scrollElementIntoView = function(editor, element, alignToTop) {
      var scroller = editor.inline ? elementIntoWindow : elementIntoFrame;
      scroller(editor, element, alignToTop);
    };
    var scrollRangeIntoView = function(editor, rng, alignToTop) {
      var scroller = editor.inline ? rangeIntoWindow : rangeIntoFrame;
      scroller(editor, rng, alignToTop);
    };
    var getDocument = function() {
      return SugarElement.fromDom(document);
    };
    var focus = function(element) {
      return element.dom.focus();
    };
    var hasFocus = function(element) {
      var root = getRootNode(element).dom;
      return element.dom === root.activeElement;
    };
    var active = function(root) {
      if (root === void 0) {
        root = getDocument();
      }
      return Optional.from(root.dom.activeElement).map(SugarElement.fromDom);
    };
    var search = function(element) {
      return active(getRootNode(element)).filter(function(e) {
        return element.dom.contains(e.dom);
      });
    };
    var create$4 = function(start2, soffset, finish, foffset) {
      return {
        start: start2,
        soffset,
        finish,
        foffset
      };
    };
    var SimRange = { create: create$4 };
    var adt = Adt.generate([
      { before: ["element"] },
      {
        on: [
          "element",
          "offset"
        ]
      },
      { after: ["element"] }
    ]);
    var cata = function(subject, onBefore, onOn, onAfter) {
      return subject.fold(onBefore, onOn, onAfter);
    };
    var getStart = function(situ) {
      return situ.fold(identity, identity, identity);
    };
    var before$3 = adt.before;
    var on = adt.on;
    var after$2 = adt.after;
    var Situ = {
      before: before$3,
      on,
      after: after$2,
      cata,
      getStart
    };
    var adt$1 = Adt.generate([
      { domRange: ["rng"] },
      {
        relative: [
          "startSitu",
          "finishSitu"
        ]
      },
      {
        exact: [
          "start",
          "soffset",
          "finish",
          "foffset"
        ]
      }
    ]);
    var exactFromRange = function(simRange) {
      return adt$1.exact(simRange.start, simRange.soffset, simRange.finish, simRange.foffset);
    };
    var getStart$1 = function(selection) {
      return selection.match({
        domRange: function(rng) {
          return SugarElement.fromDom(rng.startContainer);
        },
        relative: function(startSitu, _finishSitu) {
          return Situ.getStart(startSitu);
        },
        exact: function(start2, _soffset, _finish, _foffset) {
          return start2;
        }
      });
    };
    var domRange = adt$1.domRange;
    var relative = adt$1.relative;
    var exact = adt$1.exact;
    var getWin = function(selection) {
      var start2 = getStart$1(selection);
      return defaultView(start2);
    };
    var range = SimRange.create;
    var SimSelection = {
      domRange,
      relative,
      exact,
      exactFromRange,
      getWin,
      range
    };
    var browser$3 = detect$3().browser;
    var clamp = function(offset, element) {
      var max2 = isText(element) ? get$8(element).length : children(element).length + 1;
      if (offset > max2) {
        return max2;
      } else if (offset < 0) {
        return 0;
      }
      return offset;
    };
    var normalizeRng = function(rng) {
      return SimSelection.range(rng.start, clamp(rng.soffset, rng.start), rng.finish, clamp(rng.foffset, rng.finish));
    };
    var isOrContains = function(root, elm) {
      return !isRestrictedNode(elm.dom) && (contains$2(root, elm) || eq$2(root, elm));
    };
    var isRngInRoot = function(root) {
      return function(rng) {
        return isOrContains(root, rng.start) && isOrContains(root, rng.finish);
      };
    };
    var shouldStore = function(editor) {
      return editor.inline === true || browser$3.isIE();
    };
    var nativeRangeToSelectionRange = function(r2) {
      return SimSelection.range(SugarElement.fromDom(r2.startContainer), r2.startOffset, SugarElement.fromDom(r2.endContainer), r2.endOffset);
    };
    var readRange = function(win) {
      var selection = win.getSelection();
      var rng = !selection || selection.rangeCount === 0 ? Optional.none() : Optional.from(selection.getRangeAt(0));
      return rng.map(nativeRangeToSelectionRange);
    };
    var getBookmark$2 = function(root) {
      var win = defaultView(root);
      return readRange(win.dom).filter(isRngInRoot(root));
    };
    var validate = function(root, bookmark) {
      return Optional.from(bookmark).filter(isRngInRoot(root)).map(normalizeRng);
    };
    var bookmarkToNativeRng = function(bookmark) {
      var rng = document.createRange();
      try {
        rng.setStart(bookmark.start.dom, bookmark.soffset);
        rng.setEnd(bookmark.finish.dom, bookmark.foffset);
        return Optional.some(rng);
      } catch (_) {
        return Optional.none();
      }
    };
    var store = function(editor) {
      var newBookmark = shouldStore(editor) ? getBookmark$2(SugarElement.fromDom(editor.getBody())) : Optional.none();
      editor.bookmark = newBookmark.isSome() ? newBookmark : editor.bookmark;
    };
    var storeNative = function(editor, rng) {
      var root = SugarElement.fromDom(editor.getBody());
      var range2 = shouldStore(editor) ? Optional.from(rng) : Optional.none();
      var newBookmark = range2.map(nativeRangeToSelectionRange).filter(isRngInRoot(root));
      editor.bookmark = newBookmark.isSome() ? newBookmark : editor.bookmark;
    };
    var getRng = function(editor) {
      var bookmark = editor.bookmark ? editor.bookmark : Optional.none();
      return bookmark.bind(function(x) {
        return validate(SugarElement.fromDom(editor.getBody()), x);
      }).bind(bookmarkToNativeRng);
    };
    var restore = function(editor) {
      getRng(editor).each(function(rng) {
        return editor.selection.setRng(rng);
      });
    };
    var isEditorUIElement = function(elm) {
      var className = elm.className.toString();
      return className.indexOf("tox-") !== -1 || className.indexOf("mce-") !== -1;
    };
    var FocusManager = { isEditorUIElement };
    var isManualNodeChange = function(e) {
      return e.type === "nodechange" && e.selectionChange;
    };
    var registerPageMouseUp = function(editor, throttledStore) {
      var mouseUpPage = function() {
        throttledStore.throttle();
      };
      DOMUtils.DOM.bind(document, "mouseup", mouseUpPage);
      editor.on("remove", function() {
        DOMUtils.DOM.unbind(document, "mouseup", mouseUpPage);
      });
    };
    var registerFocusOut = function(editor) {
      editor.on("focusout", function() {
        store(editor);
      });
    };
    var registerMouseUp = function(editor, throttledStore) {
      editor.on("mouseup touchend", function(_e) {
        throttledStore.throttle();
      });
    };
    var registerEditorEvents = function(editor, throttledStore) {
      var browser2 = detect$3().browser;
      if (browser2.isIE()) {
        registerFocusOut(editor);
      } else {
        registerMouseUp(editor, throttledStore);
      }
      editor.on("keyup NodeChange", function(e) {
        if (!isManualNodeChange(e)) {
          store(editor);
        }
      });
    };
    var register = function(editor) {
      var throttledStore = first(function() {
        store(editor);
      }, 0);
      editor.on("init", function() {
        if (editor.inline) {
          registerPageMouseUp(editor, throttledStore);
        }
        registerEditorEvents(editor, throttledStore);
      });
      editor.on("remove", function() {
        throttledStore.cancel();
      });
    };
    var documentFocusInHandler;
    var DOM$2 = DOMUtils.DOM;
    var isEditorUIElement$1 = function(elm) {
      return FocusManager.isEditorUIElement(elm);
    };
    var isEditorContentAreaElement = function(elm) {
      var classList = elm.classList;
      if (classList !== void 0) {
        return classList.contains("tox-edit-area") || classList.contains("tox-edit-area__iframe") || classList.contains("mce-content-body");
      } else {
        return false;
      }
    };
    var isUIElement = function(editor, elm) {
      var customSelector = getCustomUiSelector(editor);
      var parent2 = DOM$2.getParent(elm, function(elm2) {
        return isEditorUIElement$1(elm2) || (customSelector ? editor.dom.is(elm2, customSelector) : false);
      });
      return parent2 !== null;
    };
    var getActiveElement = function(editor) {
      try {
        var root = getRootNode(SugarElement.fromDom(editor.getElement()));
        return active(root).fold(function() {
          return document.body;
        }, function(x) {
          return x.dom;
        });
      } catch (ex) {
        return document.body;
      }
    };
    var registerEvents = function(editorManager, e) {
      var editor = e.editor;
      register(editor);
      editor.on("focusin", function() {
        var focusedEditor = editorManager.focusedEditor;
        if (focusedEditor !== editor) {
          if (focusedEditor) {
            focusedEditor.fire("blur", { focusedEditor: editor });
          }
          editorManager.setActive(editor);
          editorManager.focusedEditor = editor;
          editor.fire("focus", { blurredEditor: focusedEditor });
          editor.focus(true);
        }
      });
      editor.on("focusout", function() {
        Delay.setEditorTimeout(editor, function() {
          var focusedEditor = editorManager.focusedEditor;
          if (!isUIElement(editor, getActiveElement(editor)) && focusedEditor === editor) {
            editor.fire("blur", { focusedEditor: null });
            editorManager.focusedEditor = null;
          }
        });
      });
      if (!documentFocusInHandler) {
        documentFocusInHandler = function(e2) {
          var activeEditor = editorManager.activeEditor;
          if (activeEditor) {
            getOriginalEventTarget(e2).each(function(target) {
              if (target.ownerDocument === document) {
                if (target !== document.body && !isUIElement(activeEditor, target) && editorManager.focusedEditor === activeEditor) {
                  activeEditor.fire("blur", { focusedEditor: null });
                  editorManager.focusedEditor = null;
                }
              }
            });
          }
        };
        DOM$2.bind(document, "focusin", documentFocusInHandler);
      }
    };
    var unregisterDocumentEvents = function(editorManager, e) {
      if (editorManager.focusedEditor === e.editor) {
        editorManager.focusedEditor = null;
      }
      if (!editorManager.activeEditor) {
        DOM$2.unbind(document, "focusin", documentFocusInHandler);
        documentFocusInHandler = null;
      }
    };
    var setup$2 = function(editorManager) {
      editorManager.on("AddEditor", curry(registerEvents, editorManager));
      editorManager.on("RemoveEditor", curry(unregisterDocumentEvents, editorManager));
    };
    var getContentEditableHost = function(editor, node) {
      return editor.dom.getParent(node, function(node2) {
        return editor.dom.getContentEditable(node2) === "true";
      });
    };
    var getCollapsedNode = function(rng) {
      return rng.collapsed ? Optional.from(getNode(rng.startContainer, rng.startOffset)).map(SugarElement.fromDom) : Optional.none();
    };
    var getFocusInElement = function(root, rng) {
      return getCollapsedNode(rng).bind(function(node) {
        if (isTableSection(node)) {
          return Optional.some(node);
        } else if (contains$2(root, node) === false) {
          return Optional.some(root);
        } else {
          return Optional.none();
        }
      });
    };
    var normalizeSelection = function(editor, rng) {
      getFocusInElement(SugarElement.fromDom(editor.getBody()), rng).bind(function(elm) {
        return firstPositionIn(elm.dom);
      }).fold(function() {
        editor.selection.normalize();
        return;
      }, function(caretPos) {
        return editor.selection.setRng(caretPos.toRange());
      });
    };
    var focusBody = function(body) {
      if (body.setActive) {
        try {
          body.setActive();
        } catch (ex) {
          body.focus();
        }
      } else {
        body.focus();
      }
    };
    var hasElementFocus = function(elm) {
      return hasFocus(elm) || search(elm).isSome();
    };
    var hasIframeFocus = function(editor) {
      return editor.iframeElement && hasFocus(SugarElement.fromDom(editor.iframeElement));
    };
    var hasInlineFocus = function(editor) {
      var rawBody = editor.getBody();
      return rawBody && hasElementFocus(SugarElement.fromDom(rawBody));
    };
    var hasUiFocus = function(editor) {
      var dos = getRootNode(SugarElement.fromDom(editor.getElement()));
      return active(dos).filter(function(elem) {
        return !isEditorContentAreaElement(elem.dom) && isUIElement(editor, elem.dom);
      }).isSome();
    };
    var hasFocus$1 = function(editor) {
      return editor.inline ? hasInlineFocus(editor) : hasIframeFocus(editor);
    };
    var hasEditorOrUiFocus = function(editor) {
      return hasFocus$1(editor) || hasUiFocus(editor);
    };
    var focusEditor = function(editor) {
      var selection = editor.selection;
      var body = editor.getBody();
      var rng = selection.getRng();
      editor.quirks.refreshContentEditable();
      if (editor.bookmark !== void 0 && hasFocus$1(editor) === false) {
        getRng(editor).each(function(bookmarkRng) {
          editor.selection.setRng(bookmarkRng);
          rng = bookmarkRng;
        });
      }
      var contentEditableHost = getContentEditableHost(editor, selection.getNode());
      if (editor.$.contains(body, contentEditableHost)) {
        focusBody(contentEditableHost);
        normalizeSelection(editor, rng);
        activateEditor(editor);
        return;
      }
      if (!editor.inline) {
        if (!Env.opera) {
          focusBody(body);
        }
        editor.getWin().focus();
      }
      if (Env.gecko || editor.inline) {
        focusBody(body);
        normalizeSelection(editor, rng);
      }
      activateEditor(editor);
    };
    var activateEditor = function(editor) {
      return editor.editorManager.setActive(editor);
    };
    var focus$1 = function(editor, skipFocus) {
      if (editor.removed) {
        return;
      }
      skipFocus ? activateEditor(editor) : focusEditor(editor);
    };
    var getEndpointElement = function(root, rng, start2, real, resolve2) {
      var container = start2 ? rng.startContainer : rng.endContainer;
      var offset = start2 ? rng.startOffset : rng.endOffset;
      return Optional.from(container).map(SugarElement.fromDom).map(function(elm) {
        return !real || !rng.collapsed ? child(elm, resolve2(elm, offset)).getOr(elm) : elm;
      }).bind(function(elm) {
        return isElement(elm) ? Optional.some(elm) : parent(elm).filter(isElement);
      }).map(function(elm) {
        return elm.dom;
      }).getOr(root);
    };
    var getStart$2 = function(root, rng, real) {
      return getEndpointElement(root, rng, true, real, function(elm, offset) {
        return Math.min(childNodesCount(elm), offset);
      });
    };
    var getEnd = function(root, rng, real) {
      return getEndpointElement(root, rng, false, real, function(elm, offset) {
        return offset > 0 ? offset - 1 : offset;
      });
    };
    var skipEmptyTextNodes = function(node, forwards) {
      var orig = node;
      while (node && isText$1(node) && node.length === 0) {
        node = forwards ? node.nextSibling : node.previousSibling;
      }
      return node || orig;
    };
    var getNode$1 = function(root, rng) {
      var elm, startContainer, endContainer;
      if (!rng) {
        return root;
      }
      startContainer = rng.startContainer;
      endContainer = rng.endContainer;
      var startOffset = rng.startOffset;
      var endOffset = rng.endOffset;
      elm = rng.commonAncestorContainer;
      if (!rng.collapsed) {
        if (startContainer === endContainer) {
          if (endOffset - startOffset < 2) {
            if (startContainer.hasChildNodes()) {
              elm = startContainer.childNodes[startOffset];
            }
          }
        }
        if (startContainer.nodeType === 3 && endContainer.nodeType === 3) {
          if (startContainer.length === startOffset) {
            startContainer = skipEmptyTextNodes(startContainer.nextSibling, true);
          } else {
            startContainer = startContainer.parentNode;
          }
          if (endOffset === 0) {
            endContainer = skipEmptyTextNodes(endContainer.previousSibling, false);
          } else {
            endContainer = endContainer.parentNode;
          }
          if (startContainer && startContainer === endContainer) {
            return startContainer;
          }
        }
      }
      if (elm && elm.nodeType === 3) {
        return elm.parentNode;
      }
      return elm;
    };
    var getSelectedBlocks = function(dom2, rng, startElm, endElm) {
      var node;
      var selectedBlocks = [];
      var root = dom2.getRoot();
      startElm = dom2.getParent(startElm || getStart$2(root, rng, rng.collapsed), dom2.isBlock);
      endElm = dom2.getParent(endElm || getEnd(root, rng, rng.collapsed), dom2.isBlock);
      if (startElm && startElm !== root) {
        selectedBlocks.push(startElm);
      }
      if (startElm && endElm && startElm !== endElm) {
        node = startElm;
        var walker = new DomTreeWalker(startElm, root);
        while ((node = walker.next()) && node !== endElm) {
          if (dom2.isBlock(node)) {
            selectedBlocks.push(node);
          }
        }
      }
      if (endElm && startElm !== endElm && endElm !== root) {
        selectedBlocks.push(endElm);
      }
      return selectedBlocks;
    };
    var select$1 = function(dom2, node, content) {
      return Optional.from(node).map(function(node2) {
        var idx = dom2.nodeIndex(node2);
        var rng = dom2.createRng();
        rng.setStart(node2.parentNode, idx);
        rng.setEnd(node2.parentNode, idx + 1);
        if (content) {
          moveEndPoint$1(dom2, rng, node2, true);
          moveEndPoint$1(dom2, rng, node2, false);
        }
        return rng;
      });
    };
    var processRanges = function(editor, ranges) {
      return map(ranges, function(range2) {
        var evt = editor.fire("GetSelectionRange", { range: range2 });
        return evt.range !== range2 ? evt.range : range2;
      });
    };
    var typeLookup = {
      "#text": 3,
      "#comment": 8,
      "#cdata": 4,
      "#pi": 7,
      "#doctype": 10,
      "#document-fragment": 11
    };
    var walk$2 = function(node, root, prev) {
      var startName = prev ? "lastChild" : "firstChild";
      var siblingName = prev ? "prev" : "next";
      if (node[startName]) {
        return node[startName];
      }
      if (node !== root) {
        var sibling2 = node[siblingName];
        if (sibling2) {
          return sibling2;
        }
        for (var parent_1 = node.parent; parent_1 && parent_1 !== root; parent_1 = parent_1.parent) {
          sibling2 = parent_1[siblingName];
          if (sibling2) {
            return sibling2;
          }
        }
      }
    };
    var isEmptyTextNode$1 = function(node) {
      if (!isWhitespaceText(node.value)) {
        return false;
      }
      var parentNode = node.parent;
      if (parentNode && (parentNode.name !== "span" || parentNode.attr("style")) && /^[ ]+$/.test(node.value)) {
        return false;
      }
      return true;
    };
    var isNonEmptyElement = function(node) {
      var isNamedAnchor2 = node.name === "a" && !node.attr("href") && node.attr("id");
      return node.attr("name") || node.attr("id") && !node.firstChild || node.attr("data-mce-bookmark") || isNamedAnchor2;
    };
    var AstNode = function() {
      function AstNode2(name2, type2) {
        this.name = name2;
        this.type = type2;
        if (type2 === 1) {
          this.attributes = [];
          this.attributes.map = {};
        }
      }
      AstNode2.create = function(name2, attrs) {
        var node = new AstNode2(name2, typeLookup[name2] || 1);
        if (attrs) {
          each$1(attrs, function(value2, attrName) {
            node.attr(attrName, value2);
          });
        }
        return node;
      };
      AstNode2.prototype.replace = function(node) {
        var self2 = this;
        if (node.parent) {
          node.remove();
        }
        self2.insert(node, self2);
        self2.remove();
        return self2;
      };
      AstNode2.prototype.attr = function(name2, value2) {
        var self2 = this;
        var attrs;
        if (typeof name2 !== "string") {
          if (name2 !== void 0 && name2 !== null) {
            each$1(name2, function(value3, key) {
              self2.attr(key, value3);
            });
          }
          return self2;
        }
        if (attrs = self2.attributes) {
          if (value2 !== void 0) {
            if (value2 === null) {
              if (name2 in attrs.map) {
                delete attrs.map[name2];
                var i = attrs.length;
                while (i--) {
                  if (attrs[i].name === name2) {
                    attrs.splice(i, 1);
                    return self2;
                  }
                }
              }
              return self2;
            }
            if (name2 in attrs.map) {
              var i = attrs.length;
              while (i--) {
                if (attrs[i].name === name2) {
                  attrs[i].value = value2;
                  break;
                }
              }
            } else {
              attrs.push({
                name: name2,
                value: value2
              });
            }
            attrs.map[name2] = value2;
            return self2;
          }
          return attrs.map[name2];
        }
      };
      AstNode2.prototype.clone = function() {
        var self2 = this;
        var clone2 = new AstNode2(self2.name, self2.type);
        var selfAttrs;
        if (selfAttrs = self2.attributes) {
          var cloneAttrs = [];
          cloneAttrs.map = {};
          for (var i = 0, l = selfAttrs.length; i < l; i++) {
            var selfAttr = selfAttrs[i];
            if (selfAttr.name !== "id") {
              cloneAttrs[cloneAttrs.length] = {
                name: selfAttr.name,
                value: selfAttr.value
              };
              cloneAttrs.map[selfAttr.name] = selfAttr.value;
            }
          }
          clone2.attributes = cloneAttrs;
        }
        clone2.value = self2.value;
        clone2.shortEnded = self2.shortEnded;
        return clone2;
      };
      AstNode2.prototype.wrap = function(wrapper) {
        var self2 = this;
        self2.parent.insert(wrapper, self2);
        wrapper.append(self2);
        return self2;
      };
      AstNode2.prototype.unwrap = function() {
        var self2 = this;
        for (var node = self2.firstChild; node; ) {
          var next = node.next;
          self2.insert(node, self2, true);
          node = next;
        }
        self2.remove();
      };
      AstNode2.prototype.remove = function() {
        var self2 = this, parent2 = self2.parent, next = self2.next, prev = self2.prev;
        if (parent2) {
          if (parent2.firstChild === self2) {
            parent2.firstChild = next;
            if (next) {
              next.prev = null;
            }
          } else {
            prev.next = next;
          }
          if (parent2.lastChild === self2) {
            parent2.lastChild = prev;
            if (prev) {
              prev.next = null;
            }
          } else {
            next.prev = prev;
          }
          self2.parent = self2.next = self2.prev = null;
        }
        return self2;
      };
      AstNode2.prototype.append = function(node) {
        var self2 = this;
        if (node.parent) {
          node.remove();
        }
        var last2 = self2.lastChild;
        if (last2) {
          last2.next = node;
          node.prev = last2;
          self2.lastChild = node;
        } else {
          self2.lastChild = self2.firstChild = node;
        }
        node.parent = self2;
        return node;
      };
      AstNode2.prototype.insert = function(node, refNode, before2) {
        if (node.parent) {
          node.remove();
        }
        var parent2 = refNode.parent || this;
        if (before2) {
          if (refNode === parent2.firstChild) {
            parent2.firstChild = node;
          } else {
            refNode.prev.next = node;
          }
          node.prev = refNode.prev;
          node.next = refNode;
          refNode.prev = node;
        } else {
          if (refNode === parent2.lastChild) {
            parent2.lastChild = node;
          } else {
            refNode.next.prev = node;
          }
          node.next = refNode.next;
          node.prev = refNode;
          refNode.next = node;
        }
        node.parent = parent2;
        return node;
      };
      AstNode2.prototype.getAll = function(name2) {
        var self2 = this;
        var collection = [];
        for (var node = self2.firstChild; node; node = walk$2(node, self2)) {
          if (node.name === name2) {
            collection.push(node);
          }
        }
        return collection;
      };
      AstNode2.prototype.empty = function() {
        var self2 = this;
        if (self2.firstChild) {
          var nodes = [];
          for (var node = self2.firstChild; node; node = walk$2(node, self2)) {
            nodes.push(node);
          }
          var i = nodes.length;
          while (i--) {
            var node = nodes[i];
            node.parent = node.firstChild = node.lastChild = node.next = node.prev = null;
          }
        }
        self2.firstChild = self2.lastChild = null;
        return self2;
      };
      AstNode2.prototype.isEmpty = function(elements, whitespace2, predicate) {
        if (whitespace2 === void 0) {
          whitespace2 = {};
        }
        var self2 = this;
        var node = self2.firstChild;
        if (isNonEmptyElement(self2)) {
          return false;
        }
        if (node) {
          do {
            if (node.type === 1) {
              if (node.attr("data-mce-bogus")) {
                continue;
              }
              if (elements[node.name]) {
                return false;
              }
              if (isNonEmptyElement(node)) {
                return false;
              }
            }
            if (node.type === 8) {
              return false;
            }
            if (node.type === 3 && !isEmptyTextNode$1(node)) {
              return false;
            }
            if (node.type === 3 && node.parent && whitespace2[node.parent.name] && isWhitespaceText(node.value)) {
              return false;
            }
            if (predicate && predicate(node)) {
              return false;
            }
          } while (node = walk$2(node, self2));
        }
        return true;
      };
      AstNode2.prototype.walk = function(prev) {
        return walk$2(this, null, prev);
      };
      return AstNode2;
    }();
    var extractBase64DataUris = function(html) {
      var dataImageUri = /data:[^;]+;base64,([a-z0-9\+\/=]+)/gi;
      var chunks = [];
      var uris = {};
      var prefix = generate$1("img");
      var matches2;
      var index = 0;
      var count2 = 0;
      while (matches2 = dataImageUri.exec(html)) {
        var uri = matches2[0];
        var imageId = prefix + "_" + count2++;
        uris[imageId] = uri;
        if (index < matches2.index) {
          chunks.push(html.substr(index, matches2.index - index));
        }
        chunks.push(imageId);
        index = matches2.index + uri.length;
      }
      var re = new RegExp(prefix + "_[0-9]+", "g");
      if (index === 0) {
        return {
          prefix,
          uris,
          html,
          re
        };
      } else {
        if (index < html.length) {
          chunks.push(html.substr(index));
        }
        return {
          prefix,
          uris,
          html: chunks.join(""),
          re
        };
      }
    };
    var restoreDataUris = function(html, result) {
      return html.replace(result.re, function(imageId) {
        return get$1(result.uris, imageId).getOr(imageId);
      });
    };
    var parseDataUri = function(uri) {
      var matches2 = /data:([^;]+);base64,([a-z0-9\+\/=]+)/i.exec(uri);
      if (matches2) {
        return Optional.some({
          type: matches2[1],
          data: decodeURIComponent(matches2[2])
        });
      } else {
        return Optional.none();
      }
    };
    var safeSvgDataUrlElements = [
      "img",
      "video"
    ];
    var isValidPrefixAttrName = function(name2) {
      return name2.indexOf("data-") === 0 || name2.indexOf("aria-") === 0;
    };
    var blockSvgDataUris = function(allowSvgDataUrls, tagName) {
      var allowed = isNullable(allowSvgDataUrls) ? contains(safeSvgDataUrlElements, tagName) : allowSvgDataUrls;
      return !allowed;
    };
    var isInvalidUri = function(settings, uri, tagName) {
      if (settings.allow_html_data_urls) {
        return false;
      } else if (/^data:image\//i.test(uri)) {
        return blockSvgDataUris(settings.allow_svg_data_urls, tagName) && /^data:image\/svg\+xml/i.test(uri);
      } else {
        return /^data:/i.test(uri);
      }
    };
    var findEndTagIndex = function(schema, html, startIndex) {
      var count2 = 1, index, matches2;
      var shortEndedElements = schema.getShortEndedElements();
      var tokenRegExp = /<([!?\/])?([A-Za-z0-9\-_:.]+)(\s(?:[^'">]+(?:"[^"]*"|'[^']*'))*[^"'>]*(?:"[^">]*|'[^'>]*)?|\s*|\/)>/g;
      tokenRegExp.lastIndex = index = startIndex;
      while (matches2 = tokenRegExp.exec(html)) {
        index = tokenRegExp.lastIndex;
        if (matches2[1] === "/") {
          count2--;
        } else if (!matches2[1]) {
          if (matches2[2] in shortEndedElements) {
            continue;
          }
          count2++;
        }
        if (count2 === 0) {
          break;
        }
      }
      return index;
    };
    var isConditionalComment = function(html, startIndex) {
      return /^\s*\[if [\w\W]+\]>.*<!\[endif\](--!?)?>/.test(html.substr(startIndex));
    };
    var findCommentEndIndex = function(html, isBogus2, startIndex) {
      if (startIndex === void 0) {
        startIndex = 0;
      }
      var lcHtml = html.toLowerCase();
      if (lcHtml.indexOf("[if ", startIndex) !== -1 && isConditionalComment(lcHtml, startIndex)) {
        var endIfIndex = lcHtml.indexOf("[endif]", startIndex);
        return lcHtml.indexOf(">", endIfIndex);
      } else {
        if (isBogus2) {
          var endIndex = lcHtml.indexOf(">", startIndex);
          return endIndex !== -1 ? endIndex : lcHtml.length;
        } else {
          var endCommentRegexp = /--!?>/g;
          endCommentRegexp.lastIndex = startIndex;
          var match2 = endCommentRegexp.exec(html);
          return match2 ? match2.index + match2[0].length : lcHtml.length;
        }
      }
    };
    var checkBogusAttribute = function(regExp, attrString) {
      var matches2 = regExp.exec(attrString);
      if (matches2) {
        var name_1 = matches2[1];
        var value2 = matches2[2];
        return typeof name_1 === "string" && name_1.toLowerCase() === "data-mce-bogus" ? value2 : null;
      } else {
        return null;
      }
    };
    var SaxParser = function(settings, schema) {
      if (schema === void 0) {
        schema = Schema();
      }
      settings = settings || {};
      if (settings.fix_self_closing !== false) {
        settings.fix_self_closing = true;
      }
      var comment = settings.comment ? settings.comment : noop;
      var cdata = settings.cdata ? settings.cdata : noop;
      var text = settings.text ? settings.text : noop;
      var start2 = settings.start ? settings.start : noop;
      var end2 = settings.end ? settings.end : noop;
      var pi = settings.pi ? settings.pi : noop;
      var doctype = settings.doctype ? settings.doctype : noop;
      var parseInternal = function(base64Extract, format) {
        if (format === void 0) {
          format = "html";
        }
        var html = base64Extract.html;
        var matches2, index = 0, value2, endRegExp;
        var stack = [];
        var attrList, i, textData, name2;
        var isInternalElement, isShortEnded;
        var elementRule, isValidElement, attr, attribsValue, validAttributesMap, validAttributePatterns;
        var attributesRequired, attributesDefault, attributesForced;
        var anyAttributesRequired, attrValue, idCount = 0;
        var decode2 = Entities.decode;
        var filteredUrlAttrs = Tools.makeMap("src,href,data,background,action,formaction,poster,xlink:href");
        var scriptUriRegExp = /((java|vb)script|mhtml):/i;
        var parsingMode = format === "html" ? 0 : 1;
        var processEndTag = function(name3) {
          var pos, i2;
          pos = stack.length;
          while (pos--) {
            if (stack[pos].name === name3) {
              break;
            }
          }
          if (pos >= 0) {
            for (i2 = stack.length - 1; i2 >= pos; i2--) {
              name3 = stack[i2];
              if (name3.valid) {
                end2(name3.name);
              }
            }
            stack.length = pos;
          }
        };
        var processText = function(value3, raw) {
          return text(restoreDataUris(value3, base64Extract), raw);
        };
        var processComment = function(value3) {
          if (value3 === "") {
            return;
          }
          if (value3.charAt(0) === ">") {
            value3 = " " + value3;
          }
          if (!settings.allow_conditional_comments && value3.substr(0, 3).toLowerCase() === "[if") {
            value3 = " " + value3;
          }
          comment(restoreDataUris(value3, base64Extract));
        };
        var processAttr = function(value3) {
          return restoreDataUris(value3, base64Extract);
        };
        var processMalformedComment = function(value3, startIndex) {
          var startTag = value3 || "";
          var isBogus2 = !startsWith(startTag, "--");
          var endIndex = findCommentEndIndex(html, isBogus2, startIndex);
          value3 = html.substr(startIndex, endIndex - startIndex);
          processComment(isBogus2 ? startTag + value3 : value3);
          return endIndex + 1;
        };
        var parseAttribute = function(tagName, name3, value3, val2, val3) {
          var attrRule, i2;
          var trimRegExp = /[\s\u0000-\u001F]+/g;
          name3 = name3.toLowerCase();
          value3 = processAttr(name3 in fillAttrsMap ? name3 : decode2(value3 || val2 || val3 || ""));
          if (validate2 && !isInternalElement && isValidPrefixAttrName(name3) === false) {
            attrRule = validAttributesMap[name3];
            if (!attrRule && validAttributePatterns) {
              i2 = validAttributePatterns.length;
              while (i2--) {
                attrRule = validAttributePatterns[i2];
                if (attrRule.pattern.test(name3)) {
                  break;
                }
              }
              if (i2 === -1) {
                attrRule = null;
              }
            }
            if (!attrRule) {
              return;
            }
            if (attrRule.validValues && !(value3 in attrRule.validValues)) {
              return;
            }
          }
          if (filteredUrlAttrs[name3] && !settings.allow_script_urls) {
            var uri = value3.replace(trimRegExp, "");
            try {
              uri = decodeURIComponent(uri);
            } catch (ex) {
              uri = unescape(uri);
            }
            if (scriptUriRegExp.test(uri)) {
              return;
            }
            if (isInvalidUri(settings, uri, tagName)) {
              return;
            }
          }
          if (isInternalElement && (name3 in filteredUrlAttrs || name3.indexOf("on") === 0)) {
            return;
          }
          attrList.map[name3] = value3;
          attrList.push({
            name: name3,
            value: value3
          });
        };
        var tokenRegExp = new RegExp(`<(?:(?:!--([\\w\\W]*?)--!?>)|(?:!\\[CDATA\\[([\\w\\W]*?)\\]\\]>)|(?:![Dd][Oo][Cc][Tt][Yy][Pp][Ee]([\\w\\W]*?)>)|(?:!(--)?)|(?:\\?([^\\s\\/<>]+) ?([\\w\\W]*?)[?/]>)|(?:\\/([A-Za-z][A-Za-z0-9\\-_\\:\\.]*)>)|(?:([A-Za-z][A-Za-z0-9\\-_:.]*)(\\s(?:[^'">]+(?:"[^"]*"|'[^']*'))*[^"'>]*(?:"[^">]*|'[^'>]*)?|\\s*|\\/)>))`, "g");
        var attrRegExp = /([\w:\-]+)(?:\s*=\s*(?:(?:\"((?:[^\"])*)\")|(?:\'((?:[^\'])*)\')|([^>\s]+)))?/g;
        var shortEndedElements = schema.getShortEndedElements();
        var selfClosing = settings.self_closing_elements || schema.getSelfClosingElements();
        var fillAttrsMap = schema.getBoolAttrs();
        var validate2 = settings.validate;
        var removeInternalElements = settings.remove_internals;
        var fixSelfClosing = settings.fix_self_closing;
        var specialElements = schema.getSpecialElements();
        var processHtml = html + ">";
        while (matches2 = tokenRegExp.exec(processHtml)) {
          var matchText = matches2[0];
          if (index < matches2.index) {
            processText(decode2(html.substr(index, matches2.index - index)));
          }
          if (value2 = matches2[7]) {
            value2 = value2.toLowerCase();
            if (value2.charAt(0) === ":") {
              value2 = value2.substr(1);
            }
            processEndTag(value2);
          } else if (value2 = matches2[8]) {
            if (matches2.index + matchText.length > html.length) {
              processText(decode2(html.substr(matches2.index)));
              index = matches2.index + matchText.length;
              continue;
            }
            value2 = value2.toLowerCase();
            if (value2.charAt(0) === ":") {
              value2 = value2.substr(1);
            }
            isShortEnded = value2 in shortEndedElements;
            if (fixSelfClosing && selfClosing[value2] && stack.length > 0 && stack[stack.length - 1].name === value2) {
              processEndTag(value2);
            }
            var bogusValue = checkBogusAttribute(attrRegExp, matches2[9]);
            if (bogusValue !== null) {
              if (bogusValue === "all") {
                index = findEndTagIndex(schema, html, tokenRegExp.lastIndex);
                tokenRegExp.lastIndex = index;
                continue;
              }
              isValidElement = false;
            }
            if (!validate2 || (elementRule = schema.getElementRule(value2))) {
              isValidElement = true;
              if (validate2) {
                validAttributesMap = elementRule.attributes;
                validAttributePatterns = elementRule.attributePatterns;
              }
              if (attribsValue = matches2[9]) {
                isInternalElement = attribsValue.indexOf("data-mce-type") !== -1;
                if (isInternalElement && removeInternalElements) {
                  isValidElement = false;
                }
                attrList = [];
                attrList.map = {};
                attribsValue.replace(attrRegExp, function(match2, name3, val, val2, val3) {
                  parseAttribute(value2, name3, val, val2, val3);
                  return "";
                });
              } else {
                attrList = [];
                attrList.map = {};
              }
              if (validate2 && !isInternalElement) {
                attributesRequired = elementRule.attributesRequired;
                attributesDefault = elementRule.attributesDefault;
                attributesForced = elementRule.attributesForced;
                anyAttributesRequired = elementRule.removeEmptyAttrs;
                if (anyAttributesRequired && !attrList.length) {
                  isValidElement = false;
                }
                if (attributesForced) {
                  i = attributesForced.length;
                  while (i--) {
                    attr = attributesForced[i];
                    name2 = attr.name;
                    attrValue = attr.value;
                    if (attrValue === "{$uid}") {
                      attrValue = "mce_" + idCount++;
                    }
                    attrList.map[name2] = attrValue;
                    attrList.push({
                      name: name2,
                      value: attrValue
                    });
                  }
                }
                if (attributesDefault) {
                  i = attributesDefault.length;
                  while (i--) {
                    attr = attributesDefault[i];
                    name2 = attr.name;
                    if (!(name2 in attrList.map)) {
                      attrValue = attr.value;
                      if (attrValue === "{$uid}") {
                        attrValue = "mce_" + idCount++;
                      }
                      attrList.map[name2] = attrValue;
                      attrList.push({
                        name: name2,
                        value: attrValue
                      });
                    }
                  }
                }
                if (attributesRequired) {
                  i = attributesRequired.length;
                  while (i--) {
                    if (attributesRequired[i] in attrList.map) {
                      break;
                    }
                  }
                  if (i === -1) {
                    isValidElement = false;
                  }
                }
                if (attr = attrList.map["data-mce-bogus"]) {
                  if (attr === "all") {
                    index = findEndTagIndex(schema, html, tokenRegExp.lastIndex);
                    tokenRegExp.lastIndex = index;
                    continue;
                  }
                  isValidElement = false;
                }
              }
              if (isValidElement) {
                start2(value2, attrList, isShortEnded);
              }
            } else {
              isValidElement = false;
            }
            if (endRegExp = specialElements[value2]) {
              endRegExp.lastIndex = index = matches2.index + matchText.length;
              if (matches2 = endRegExp.exec(html)) {
                if (isValidElement) {
                  textData = html.substr(index, matches2.index - index);
                }
                index = matches2.index + matches2[0].length;
              } else {
                textData = html.substr(index);
                index = html.length;
              }
              if (isValidElement) {
                if (textData.length > 0) {
                  processText(textData, true);
                }
                end2(value2);
              }
              tokenRegExp.lastIndex = index;
              continue;
            }
            if (!isShortEnded) {
              if (!attribsValue || attribsValue.indexOf("/") !== attribsValue.length - 1) {
                stack.push({
                  name: value2,
                  valid: isValidElement
                });
              } else if (isValidElement) {
                end2(value2);
              }
            }
          } else if (value2 = matches2[1]) {
            processComment(value2);
          } else if (value2 = matches2[2]) {
            var isValidCdataSection = parsingMode === 1 || settings.preserve_cdata || stack.length > 0 && schema.isValidChild(stack[stack.length - 1].name, "#cdata");
            if (isValidCdataSection) {
              cdata(value2);
            } else {
              index = processMalformedComment("", matches2.index + 2);
              tokenRegExp.lastIndex = index;
              continue;
            }
          } else if (value2 = matches2[3]) {
            doctype(value2);
          } else if ((value2 = matches2[4]) || matchText === "<!") {
            index = processMalformedComment(value2, matches2.index + matchText.length);
            tokenRegExp.lastIndex = index;
            continue;
          } else if (value2 = matches2[5]) {
            if (parsingMode === 1) {
              pi(value2, matches2[6]);
            } else {
              index = processMalformedComment("?", matches2.index + 2);
              tokenRegExp.lastIndex = index;
              continue;
            }
          }
          index = matches2.index + matchText.length;
        }
        if (index < html.length) {
          processText(decode2(html.substr(index)));
        }
        for (i = stack.length - 1; i >= 0; i--) {
          value2 = stack[i];
          if (value2.valid) {
            end2(value2.name);
          }
        }
      };
      var parse = function(html, format) {
        if (format === void 0) {
          format = "html";
        }
        parseInternal(extractBase64DataUris(html), format);
      };
      return { parse };
    };
    SaxParser.findEndTag = findEndTagIndex;
    var trimHtml = function(tempAttrs, html) {
      var trimContentRegExp = new RegExp(["\\s?(" + tempAttrs.join("|") + ')="[^"]+"'].join("|"), "gi");
      return html.replace(trimContentRegExp, "");
    };
    var trimInternal = function(serializer, html) {
      var content = html;
      var bogusAllRegExp = /<(\w+) [^>]*data-mce-bogus="all"[^>]*>/g;
      var endTagIndex, index, matchLength, matches2;
      var schema = serializer.schema;
      content = trimHtml(serializer.getTempAttrs(), content);
      var shortEndedElements = schema.getShortEndedElements();
      while (matches2 = bogusAllRegExp.exec(content)) {
        index = bogusAllRegExp.lastIndex;
        matchLength = matches2[0].length;
        if (shortEndedElements[matches2[1]]) {
          endTagIndex = index;
        } else {
          endTagIndex = SaxParser.findEndTag(schema, content, index);
        }
        content = content.substring(0, index - matchLength) + content.substring(endTagIndex);
        bogusAllRegExp.lastIndex = index - matchLength;
      }
      return trim$2(content);
    };
    var trimExternal = trimInternal;
    var trimEmptyContents = function(editor, html) {
      var blockName = getForcedRootBlock(editor);
      var emptyRegExp = new RegExp("^(<" + blockName + "[^>]*>(&nbsp;|&#160;|\\s|\xA0|<br \\/>|)<\\/" + blockName + ">[\r\n]*|<br \\/>[\r\n]*)$");
      return html.replace(emptyRegExp, "");
    };
    var getContentFromBody = function(editor, args, format, body) {
      var content;
      args.format = format;
      args.get = true;
      args.getInner = true;
      if (!args.no_events) {
        editor.fire("BeforeGetContent", args);
      }
      if (args.format === "raw") {
        content = Tools.trim(trimExternal(editor.serializer, body.innerHTML));
      } else if (args.format === "text") {
        content = editor.dom.isEmpty(body) ? "" : trim$2(body.innerText || body.textContent);
      } else if (args.format === "tree") {
        content = editor.serializer.serialize(body, args);
      } else {
        content = trimEmptyContents(editor, editor.serializer.serialize(body, args));
      }
      if (!contains([
        "text",
        "tree"
      ], args.format) && !isWsPreserveElement(SugarElement.fromDom(body))) {
        args.content = Tools.trim(content);
      } else {
        args.content = content;
      }
      if (!args.no_events) {
        editor.fire("GetContent", args);
      }
      return args.content;
    };
    var getContentInternal = function(editor, args, format) {
      return Optional.from(editor.getBody()).fold(constant(args.format === "tree" ? new AstNode("body", 11) : ""), function(body) {
        return getContentFromBody(editor, args, format, body);
      });
    };
    var each$7 = Tools.each;
    var ElementUtils = function(dom2) {
      var compare = function(node1, node2) {
        if (node1.nodeName !== node2.nodeName) {
          return false;
        }
        var getAttribs = function(node) {
          var attribs = {};
          each$7(dom2.getAttribs(node), function(attr) {
            var name2 = attr.nodeName.toLowerCase();
            if (name2.indexOf("_") !== 0 && name2 !== "style" && name2.indexOf("data-") !== 0) {
              attribs[name2] = dom2.getAttrib(node, name2);
            }
          });
          return attribs;
        };
        var compareObjects = function(obj1, obj2) {
          var value2, name2;
          for (name2 in obj1) {
            if (obj1.hasOwnProperty(name2)) {
              value2 = obj2[name2];
              if (typeof value2 === "undefined") {
                return false;
              }
              if (obj1[name2] !== value2) {
                return false;
              }
              delete obj2[name2];
            }
          }
          for (name2 in obj2) {
            if (obj2.hasOwnProperty(name2)) {
              return false;
            }
          }
          return true;
        };
        if (!compareObjects(getAttribs(node1), getAttribs(node2))) {
          return false;
        }
        if (!compareObjects(dom2.parseStyle(dom2.getAttrib(node1, "style")), dom2.parseStyle(dom2.getAttrib(node2, "style")))) {
          return false;
        }
        return !isBookmarkNode$1(node1) && !isBookmarkNode$1(node2);
      };
      return { compare };
    };
    var makeMap$3 = Tools.makeMap;
    var Writer = function(settings) {
      var html = [];
      settings = settings || {};
      var indent = settings.indent;
      var indentBefore = makeMap$3(settings.indent_before || "");
      var indentAfter = makeMap$3(settings.indent_after || "");
      var encode = Entities.getEncodeFunc(settings.entity_encoding || "raw", settings.entities);
      var htmlOutput = settings.element_format === "html";
      return {
        start: function(name2, attrs, empty2) {
          var i, l, attr, value2;
          if (indent && indentBefore[name2] && html.length > 0) {
            value2 = html[html.length - 1];
            if (value2.length > 0 && value2 !== "\n") {
              html.push("\n");
            }
          }
          html.push("<", name2);
          if (attrs) {
            for (i = 0, l = attrs.length; i < l; i++) {
              attr = attrs[i];
              html.push(" ", attr.name, '="', encode(attr.value, true), '"');
            }
          }
          if (!empty2 || htmlOutput) {
            html[html.length] = ">";
          } else {
            html[html.length] = " />";
          }
          if (empty2 && indent && indentAfter[name2] && html.length > 0) {
            value2 = html[html.length - 1];
            if (value2.length > 0 && value2 !== "\n") {
              html.push("\n");
            }
          }
        },
        end: function(name2) {
          var value2;
          html.push("</", name2, ">");
          if (indent && indentAfter[name2] && html.length > 0) {
            value2 = html[html.length - 1];
            if (value2.length > 0 && value2 !== "\n") {
              html.push("\n");
            }
          }
        },
        text: function(text, raw) {
          if (text.length > 0) {
            html[html.length] = raw ? text : encode(text);
          }
        },
        cdata: function(text) {
          html.push("<![CDATA[", text, "]]>");
        },
        comment: function(text) {
          html.push("<!--", text, "-->");
        },
        pi: function(name2, text) {
          if (text) {
            html.push("<?", name2, " ", encode(text), "?>");
          } else {
            html.push("<?", name2, "?>");
          }
          if (indent) {
            html.push("\n");
          }
        },
        doctype: function(text) {
          html.push("<!DOCTYPE", text, ">", indent ? "\n" : "");
        },
        reset: function() {
          html.length = 0;
        },
        getContent: function() {
          return html.join("").replace(/\n$/, "");
        }
      };
    };
    var HtmlSerializer = function(settings, schema) {
      if (schema === void 0) {
        schema = Schema();
      }
      var writer = Writer(settings);
      settings = settings || {};
      settings.validate = "validate" in settings ? settings.validate : true;
      var serialize2 = function(node) {
        var validate2 = settings.validate;
        var handlers = {
          3: function(node2) {
            writer.text(node2.value, node2.raw);
          },
          8: function(node2) {
            writer.comment(node2.value);
          },
          7: function(node2) {
            writer.pi(node2.name, node2.value);
          },
          10: function(node2) {
            writer.doctype(node2.value);
          },
          4: function(node2) {
            writer.cdata(node2.value);
          },
          11: function(node2) {
            if (node2 = node2.firstChild) {
              do {
                walk2(node2);
              } while (node2 = node2.next);
            }
          }
        };
        writer.reset();
        var walk2 = function(node2) {
          var handler = handlers[node2.type];
          var name2, isEmpty2, attrs, attrName, attrValue, sortedAttrs, i, l, elementRule;
          if (!handler) {
            name2 = node2.name;
            isEmpty2 = node2.shortEnded;
            attrs = node2.attributes;
            if (validate2 && attrs && attrs.length > 1) {
              sortedAttrs = [];
              sortedAttrs.map = {};
              elementRule = schema.getElementRule(node2.name);
              if (elementRule) {
                for (i = 0, l = elementRule.attributesOrder.length; i < l; i++) {
                  attrName = elementRule.attributesOrder[i];
                  if (attrName in attrs.map) {
                    attrValue = attrs.map[attrName];
                    sortedAttrs.map[attrName] = attrValue;
                    sortedAttrs.push({
                      name: attrName,
                      value: attrValue
                    });
                  }
                }
                for (i = 0, l = attrs.length; i < l; i++) {
                  attrName = attrs[i].name;
                  if (!(attrName in sortedAttrs.map)) {
                    attrValue = attrs.map[attrName];
                    sortedAttrs.map[attrName] = attrValue;
                    sortedAttrs.push({
                      name: attrName,
                      value: attrValue
                    });
                  }
                }
                attrs = sortedAttrs;
              }
            }
            writer.start(node2.name, attrs, isEmpty2);
            if (!isEmpty2) {
              if (node2 = node2.firstChild) {
                do {
                  walk2(node2);
                } while (node2 = node2.next);
              }
              writer.end(name2);
            }
          } else {
            handler(node2);
          }
        };
        if (node.type === 1 && !settings.inner) {
          walk2(node);
        } else {
          handlers[11](node);
        }
        return writer.getContent();
      };
      return { serialize: serialize2 };
    };
    var nonInheritableStyles = /* @__PURE__ */ new Set();
    (function() {
      var nonInheritableStylesArr = [
        "margin",
        "margin-left",
        "margin-right",
        "margin-top",
        "margin-bottom",
        "padding",
        "padding-left",
        "padding-right",
        "padding-top",
        "padding-bottom",
        "border",
        "border-width",
        "border-style",
        "border-color",
        "background",
        "background-attachment",
        "background-clip",
        "background-color",
        "background-image",
        "background-origin",
        "background-position",
        "background-repeat",
        "background-size",
        "float",
        "position",
        "left",
        "right",
        "top",
        "bottom",
        "z-index",
        "display",
        "transform",
        "width",
        "max-width",
        "min-width",
        "height",
        "max-height",
        "min-height",
        "overflow",
        "overflow-x",
        "overflow-y",
        "text-overflow",
        "vertical-align",
        "transition",
        "transition-delay",
        "transition-duration",
        "transition-property",
        "transition-timing-function"
      ];
      each(nonInheritableStylesArr, function(style) {
        nonInheritableStyles.add(style);
      });
    })();
    var shorthandStyleProps = [
      "font",
      "text-decoration",
      "text-emphasis"
    ];
    var getStyleProps = function(dom2, node) {
      return keys(dom2.parseStyle(dom2.getAttrib(node, "style")));
    };
    var isNonInheritableStyle = function(style) {
      return nonInheritableStyles.has(style);
    };
    var hasInheritableStyles = function(dom2, node) {
      return forall(getStyleProps(dom2, node), function(style) {
        return !isNonInheritableStyle(style);
      });
    };
    var getLonghandStyleProps = function(styles) {
      return filter(styles, function(style) {
        return exists(shorthandStyleProps, function(prop) {
          return startsWith(style, prop);
        });
      });
    };
    var hasStyleConflict = function(dom2, node, parentNode) {
      var nodeStyleProps = getStyleProps(dom2, node);
      var parentNodeStyleProps = getStyleProps(dom2, parentNode);
      var valueMismatch = function(prop) {
        var nodeValue = dom2.getStyle(node, prop);
        var parentValue = dom2.getStyle(parentNode, prop);
        return isNotEmpty(nodeValue) && isNotEmpty(parentValue) && nodeValue !== parentValue;
      };
      return exists(nodeStyleProps, function(nodeStyleProp) {
        var propExists = function(props) {
          return exists(props, function(prop) {
            return prop === nodeStyleProp;
          });
        };
        if (!propExists(parentNodeStyleProps) && propExists(shorthandStyleProps)) {
          var longhandProps = getLonghandStyleProps(parentNodeStyleProps);
          return exists(longhandProps, valueMismatch);
        } else {
          return valueMismatch(nodeStyleProp);
        }
      });
    };
    var isChar = function(forward, predicate, pos) {
      return Optional.from(pos.container()).filter(isText$1).exists(function(text) {
        var delta = forward ? 0 : -1;
        return predicate(text.data.charAt(pos.offset() + delta));
      });
    };
    var isBeforeSpace = curry(isChar, true, isWhiteSpace$1);
    var isAfterSpace = curry(isChar, false, isWhiteSpace$1);
    var isEmptyText = function(pos) {
      var container = pos.container();
      return isText$1(container) && (container.data.length === 0 || isZwsp$1(container.data) && BookmarkManager.isBookmarkNode(container.parentNode));
    };
    var matchesElementPosition = function(before2, predicate) {
      return function(pos) {
        return Optional.from(getChildNodeAtRelativeOffset(before2 ? 0 : -1, pos)).filter(predicate).isSome();
      };
    };
    var isImageBlock = function(node) {
      return isImg(node) && get$5(SugarElement.fromDom(node), "display") === "block";
    };
    var isCefNode = function(node) {
      return isContentEditableFalse(node) && !isBogusAll(node);
    };
    var isBeforeImageBlock = matchesElementPosition(true, isImageBlock);
    var isAfterImageBlock = matchesElementPosition(false, isImageBlock);
    var isBeforeMedia = matchesElementPosition(true, isMedia);
    var isAfterMedia = matchesElementPosition(false, isMedia);
    var isBeforeTable = matchesElementPosition(true, isTable);
    var isAfterTable = matchesElementPosition(false, isTable);
    var isBeforeContentEditableFalse = matchesElementPosition(true, isCefNode);
    var isAfterContentEditableFalse = matchesElementPosition(false, isCefNode);
    var getLastChildren$1 = function(elm) {
      var children2 = [];
      var rawNode = elm.dom;
      while (rawNode) {
        children2.push(SugarElement.fromDom(rawNode));
        rawNode = rawNode.lastChild;
      }
      return children2;
    };
    var removeTrailingBr = function(elm) {
      var allBrs = descendants$1(elm, "br");
      var brs = filter(getLastChildren$1(elm).slice(-1), isBr$1);
      if (allBrs.length === brs.length) {
        each(brs, remove);
      }
    };
    var fillWithPaddingBr = function(elm) {
      empty(elm);
      append(elm, SugarElement.fromHtml('<br data-mce-bogus="1">'));
    };
    var trimBlockTrailingBr = function(elm) {
      lastChild(elm).each(function(lastChild2) {
        prevSibling(lastChild2).each(function(lastChildPrevSibling) {
          if (isBlock(elm) && isBr$1(lastChild2) && isBlock(lastChildPrevSibling)) {
            remove(lastChild2);
          }
        });
      });
    };
    var dropLast = function(xs) {
      return xs.slice(0, -1);
    };
    var parentsUntil$1 = function(start2, root, predicate) {
      if (contains$2(root, start2)) {
        return dropLast(parents(start2, function(elm) {
          return predicate(elm) || eq$2(elm, root);
        }));
      } else {
        return [];
      }
    };
    var parents$1 = function(start2, root) {
      return parentsUntil$1(start2, root, never);
    };
    var parentsAndSelf = function(start2, root) {
      return [start2].concat(parents$1(start2, root));
    };
    var navigateIgnoreEmptyTextNodes = function(forward, root, from2) {
      return navigateIgnore(forward, root, from2, isEmptyText);
    };
    var getClosestBlock = function(root, pos) {
      return find(parentsAndSelf(SugarElement.fromDom(pos.container()), root), isBlock);
    };
    var isAtBeforeAfterBlockBoundary = function(forward, root, pos) {
      return navigateIgnoreEmptyTextNodes(forward, root.dom, pos).forall(function(newPos) {
        return getClosestBlock(root, pos).fold(function() {
          return isInSameBlock(newPos, pos, root.dom) === false;
        }, function(fromBlock) {
          return isInSameBlock(newPos, pos, root.dom) === false && contains$2(fromBlock, SugarElement.fromDom(newPos.container()));
        });
      });
    };
    var isAtBlockBoundary$1 = function(forward, root, pos) {
      return getClosestBlock(root, pos).fold(function() {
        return navigateIgnoreEmptyTextNodes(forward, root.dom, pos).forall(function(newPos) {
          return isInSameBlock(newPos, pos, root.dom) === false;
        });
      }, function(parent2) {
        return navigateIgnoreEmptyTextNodes(forward, parent2.dom, pos).isNone();
      });
    };
    var isAtStartOfBlock = curry(isAtBlockBoundary$1, false);
    var isAtEndOfBlock = curry(isAtBlockBoundary$1, true);
    var isBeforeBlock = curry(isAtBeforeAfterBlockBoundary, false);
    var isAfterBlock = curry(isAtBeforeAfterBlockBoundary, true);
    var isBr$5 = function(pos) {
      return getElementFromPosition(pos).exists(isBr$1);
    };
    var findBr = function(forward, root, pos) {
      var parentBlocks = filter(parentsAndSelf(SugarElement.fromDom(pos.container()), root), isBlock);
      var scope = head(parentBlocks).getOr(root);
      return fromPosition(forward, scope.dom, pos).filter(isBr$5);
    };
    var isBeforeBr = function(root, pos) {
      return getElementFromPosition(pos).exists(isBr$1) || findBr(true, root, pos).isSome();
    };
    var isAfterBr = function(root, pos) {
      return getElementFromPrevPosition(pos).exists(isBr$1) || findBr(false, root, pos).isSome();
    };
    var findPreviousBr = curry(findBr, false);
    var findNextBr = curry(findBr, true);
    var isInMiddleOfText = function(pos) {
      return CaretPosition.isTextPosition(pos) && !pos.isAtStart() && !pos.isAtEnd();
    };
    var getClosestBlock$1 = function(root, pos) {
      var parentBlocks = filter(parentsAndSelf(SugarElement.fromDom(pos.container()), root), isBlock);
      return head(parentBlocks).getOr(root);
    };
    var hasSpaceBefore = function(root, pos) {
      if (isInMiddleOfText(pos)) {
        return isAfterSpace(pos);
      } else {
        return isAfterSpace(pos) || prevPosition(getClosestBlock$1(root, pos).dom, pos).exists(isAfterSpace);
      }
    };
    var hasSpaceAfter = function(root, pos) {
      if (isInMiddleOfText(pos)) {
        return isBeforeSpace(pos);
      } else {
        return isBeforeSpace(pos) || nextPosition(getClosestBlock$1(root, pos).dom, pos).exists(isBeforeSpace);
      }
    };
    var isPreValue = function(value2) {
      return contains([
        "pre",
        "pre-wrap"
      ], value2);
    };
    var isInPre = function(pos) {
      return getElementFromPosition(pos).bind(function(elm) {
        return closest(elm, isElement);
      }).exists(function(elm) {
        return isPreValue(get$5(elm, "white-space"));
      });
    };
    var isAtBeginningOfBody = function(root, pos) {
      return prevPosition(root.dom, pos).isNone();
    };
    var isAtEndOfBody = function(root, pos) {
      return nextPosition(root.dom, pos).isNone();
    };
    var isAtLineBoundary = function(root, pos) {
      return isAtBeginningOfBody(root, pos) || isAtEndOfBody(root, pos) || isAtStartOfBlock(root, pos) || isAtEndOfBlock(root, pos) || isAfterBr(root, pos) || isBeforeBr(root, pos);
    };
    var needsToHaveNbsp = function(root, pos) {
      if (isInPre(pos)) {
        return false;
      } else {
        return isAtLineBoundary(root, pos) || hasSpaceBefore(root, pos) || hasSpaceAfter(root, pos);
      }
    };
    var needsToBeNbspLeft = function(root, pos) {
      if (isInPre(pos)) {
        return false;
      } else {
        return isAtStartOfBlock(root, pos) || isBeforeBlock(root, pos) || isAfterBr(root, pos) || hasSpaceBefore(root, pos);
      }
    };
    var leanRight = function(pos) {
      var container = pos.container();
      var offset = pos.offset();
      if (isText$1(container) && offset < container.data.length) {
        return CaretPosition(container, offset + 1);
      } else {
        return pos;
      }
    };
    var needsToBeNbspRight = function(root, pos) {
      if (isInPre(pos)) {
        return false;
      } else {
        return isAtEndOfBlock(root, pos) || isAfterBlock(root, pos) || isBeforeBr(root, pos) || hasSpaceAfter(root, pos);
      }
    };
    var needsToBeNbsp = function(root, pos) {
      return needsToBeNbspLeft(root, pos) || needsToBeNbspRight(root, leanRight(pos));
    };
    var isNbspAt = function(text, offset) {
      return isNbsp(text.charAt(offset));
    };
    var hasNbsp = function(pos) {
      var container = pos.container();
      return isText$1(container) && contains$1(container.data, nbsp);
    };
    var normalizeNbspMiddle = function(text) {
      var chars = text.split("");
      return map(chars, function(chr, i) {
        if (isNbsp(chr) && i > 0 && i < chars.length - 1 && isContent$1(chars[i - 1]) && isContent$1(chars[i + 1])) {
          return " ";
        } else {
          return chr;
        }
      }).join("");
    };
    var normalizeNbspAtStart = function(root, node) {
      var text = node.data;
      var firstPos = CaretPosition(node, 0);
      if (isNbspAt(text, 0) && !needsToBeNbsp(root, firstPos)) {
        node.data = " " + text.slice(1);
        return true;
      } else {
        return false;
      }
    };
    var normalizeNbspInMiddleOfTextNode = function(node) {
      var text = node.data;
      var newText = normalizeNbspMiddle(text);
      if (newText !== text) {
        node.data = newText;
        return true;
      } else {
        return false;
      }
    };
    var normalizeNbspAtEnd = function(root, node) {
      var text = node.data;
      var lastPos = CaretPosition(node, text.length - 1);
      if (isNbspAt(text, text.length - 1) && !needsToBeNbsp(root, lastPos)) {
        node.data = text.slice(0, -1) + " ";
        return true;
      } else {
        return false;
      }
    };
    var normalizeNbsps = function(root, pos) {
      return Optional.some(pos).filter(hasNbsp).bind(function(pos2) {
        var container = pos2.container();
        var normalized = normalizeNbspAtStart(root, container) || normalizeNbspInMiddleOfTextNode(container) || normalizeNbspAtEnd(root, container);
        return normalized ? Optional.some(pos2) : Optional.none();
      });
    };
    var normalizeNbspsInEditor = function(editor) {
      var root = SugarElement.fromDom(editor.getBody());
      if (editor.selection.isCollapsed()) {
        normalizeNbsps(root, CaretPosition.fromRangeStart(editor.selection.getRng())).each(function(pos) {
          editor.selection.setRng(pos.toRange());
        });
      }
    };
    var normalizeContent = function(content, isStartOfContent, isEndOfContent) {
      var result = foldl(content, function(acc, c) {
        if (isWhiteSpace$1(c) || isNbsp(c)) {
          if (acc.previousCharIsSpace || acc.str === "" && isStartOfContent || acc.str.length === content.length - 1 && isEndOfContent) {
            return {
              previousCharIsSpace: false,
              str: acc.str + nbsp
            };
          } else {
            return {
              previousCharIsSpace: true,
              str: acc.str + " "
            };
          }
        } else {
          return {
            previousCharIsSpace: false,
            str: acc.str + c
          };
        }
      }, {
        previousCharIsSpace: false,
        str: ""
      });
      return result.str;
    };
    var normalize$1 = function(node, offset, count2) {
      if (count2 === 0) {
        return;
      }
      var elm = SugarElement.fromDom(node);
      var root = ancestor(elm, isBlock).getOr(elm);
      var whitespace2 = node.data.slice(offset, offset + count2);
      var isEndOfContent = offset + count2 >= node.data.length && needsToBeNbspRight(root, CaretPosition(node, node.data.length));
      var isStartOfContent = offset === 0 && needsToBeNbspLeft(root, CaretPosition(node, 0));
      node.replaceData(offset, count2, normalizeContent(whitespace2, isStartOfContent, isEndOfContent));
    };
    var normalizeWhitespaceAfter = function(node, offset) {
      var content = node.data.slice(offset);
      var whitespaceCount = content.length - lTrim(content).length;
      return normalize$1(node, offset, whitespaceCount);
    };
    var normalizeWhitespaceBefore = function(node, offset) {
      var content = node.data.slice(0, offset);
      var whitespaceCount = content.length - rTrim(content).length;
      return normalize$1(node, offset - whitespaceCount, whitespaceCount);
    };
    var mergeTextNodes = function(prevNode, nextNode, normalizeWhitespace, mergeToPrev) {
      if (mergeToPrev === void 0) {
        mergeToPrev = true;
      }
      var whitespaceOffset = rTrim(prevNode.data).length;
      var newNode = mergeToPrev ? prevNode : nextNode;
      var removeNode2 = mergeToPrev ? nextNode : prevNode;
      if (mergeToPrev) {
        newNode.appendData(removeNode2.data);
      } else {
        newNode.insertData(0, removeNode2.data);
      }
      remove(SugarElement.fromDom(removeNode2));
      if (normalizeWhitespace) {
        normalizeWhitespaceAfter(newNode, whitespaceOffset);
      }
      return newNode;
    };
    var needsReposition = function(pos, elm) {
      var container = pos.container();
      var offset = pos.offset();
      return CaretPosition.isTextPosition(pos) === false && container === elm.parentNode && offset > CaretPosition.before(elm).offset();
    };
    var reposition = function(elm, pos) {
      return needsReposition(pos, elm) ? CaretPosition(pos.container(), pos.offset() - 1) : pos;
    };
    var beforeOrStartOf = function(node) {
      return isText$1(node) ? CaretPosition(node, 0) : CaretPosition.before(node);
    };
    var afterOrEndOf = function(node) {
      return isText$1(node) ? CaretPosition(node, node.data.length) : CaretPosition.after(node);
    };
    var getPreviousSiblingCaretPosition = function(elm) {
      if (isCaretCandidate(elm.previousSibling)) {
        return Optional.some(afterOrEndOf(elm.previousSibling));
      } else {
        return elm.previousSibling ? lastPositionIn(elm.previousSibling) : Optional.none();
      }
    };
    var getNextSiblingCaretPosition = function(elm) {
      if (isCaretCandidate(elm.nextSibling)) {
        return Optional.some(beforeOrStartOf(elm.nextSibling));
      } else {
        return elm.nextSibling ? firstPositionIn(elm.nextSibling) : Optional.none();
      }
    };
    var findCaretPositionBackwardsFromElm = function(rootElement, elm) {
      var startPosition = CaretPosition.before(elm.previousSibling ? elm.previousSibling : elm.parentNode);
      return prevPosition(rootElement, startPosition).fold(function() {
        return nextPosition(rootElement, CaretPosition.after(elm));
      }, Optional.some);
    };
    var findCaretPositionForwardsFromElm = function(rootElement, elm) {
      return nextPosition(rootElement, CaretPosition.after(elm)).fold(function() {
        return prevPosition(rootElement, CaretPosition.before(elm));
      }, Optional.some);
    };
    var findCaretPositionBackwards = function(rootElement, elm) {
      return getPreviousSiblingCaretPosition(elm).orThunk(function() {
        return getNextSiblingCaretPosition(elm);
      }).orThunk(function() {
        return findCaretPositionBackwardsFromElm(rootElement, elm);
      });
    };
    var findCaretPositionForward = function(rootElement, elm) {
      return getNextSiblingCaretPosition(elm).orThunk(function() {
        return getPreviousSiblingCaretPosition(elm);
      }).orThunk(function() {
        return findCaretPositionForwardsFromElm(rootElement, elm);
      });
    };
    var findCaretPosition$1 = function(forward, rootElement, elm) {
      return forward ? findCaretPositionForward(rootElement, elm) : findCaretPositionBackwards(rootElement, elm);
    };
    var findCaretPosOutsideElmAfterDelete = function(forward, rootElement, elm) {
      return findCaretPosition$1(forward, rootElement, elm).map(curry(reposition, elm));
    };
    var setSelection = function(editor, forward, pos) {
      pos.fold(function() {
        editor.focus();
      }, function(pos2) {
        editor.selection.setRng(pos2.toRange(), forward);
      });
    };
    var eqRawNode = function(rawNode) {
      return function(elm) {
        return elm.dom === rawNode;
      };
    };
    var isBlock$2 = function(editor, elm) {
      return elm && has(editor.schema.getBlockElements(), name(elm));
    };
    var paddEmptyBlock = function(elm) {
      if (isEmpty(elm)) {
        var br = SugarElement.fromHtml('<br data-mce-bogus="1">');
        empty(elm);
        append(elm, br);
        return Optional.some(CaretPosition.before(br.dom));
      } else {
        return Optional.none();
      }
    };
    var deleteNormalized = function(elm, afterDeletePosOpt, normalizeWhitespace) {
      var prevTextOpt = prevSibling(elm).filter(isText);
      var nextTextOpt = nextSibling(elm).filter(isText);
      remove(elm);
      return lift3(prevTextOpt, nextTextOpt, afterDeletePosOpt, function(prev, next, pos) {
        var prevNode = prev.dom, nextNode = next.dom;
        var offset = prevNode.data.length;
        mergeTextNodes(prevNode, nextNode, normalizeWhitespace);
        return pos.container() === nextNode ? CaretPosition(prevNode, offset) : pos;
      }).orThunk(function() {
        if (normalizeWhitespace) {
          prevTextOpt.each(function(elm2) {
            return normalizeWhitespaceBefore(elm2.dom, elm2.dom.length);
          });
          nextTextOpt.each(function(elm2) {
            return normalizeWhitespaceAfter(elm2.dom, 0);
          });
        }
        return afterDeletePosOpt;
      });
    };
    var isInlineElement = function(editor, element) {
      return has(editor.schema.getTextInlineElements(), name(element));
    };
    var deleteElement = function(editor, forward, elm, moveCaret2) {
      if (moveCaret2 === void 0) {
        moveCaret2 = true;
      }
      var afterDeletePos = findCaretPosOutsideElmAfterDelete(forward, editor.getBody(), elm.dom);
      var parentBlock = ancestor(elm, curry(isBlock$2, editor), eqRawNode(editor.getBody()));
      var normalizedAfterDeletePos = deleteNormalized(elm, afterDeletePos, isInlineElement(editor, elm));
      if (editor.dom.isEmpty(editor.getBody())) {
        editor.setContent("");
        editor.selection.setCursorLocation();
      } else {
        parentBlock.bind(paddEmptyBlock).fold(function() {
          if (moveCaret2) {
            setSelection(editor, forward, normalizedAfterDeletePos);
          }
        }, function(paddPos) {
          if (moveCaret2) {
            setSelection(editor, forward, Optional.some(paddPos));
          }
        });
      }
    };
    var tableCellRng = function(start2, end2) {
      return {
        start: start2,
        end: end2
      };
    };
    var tableSelection = function(rng, table, cells) {
      return {
        rng,
        table,
        cells
      };
    };
    var deleteAction = Adt.generate([
      { removeTable: ["element"] },
      { emptyCells: ["cells"] },
      {
        deleteCellSelection: [
          "rng",
          "cell"
        ]
      }
    ]);
    var isRootFromElement = function(root) {
      return function(cur) {
        return eq$2(root, cur);
      };
    };
    var getClosestCell = function(container, isRoot) {
      return closest$1(SugarElement.fromDom(container), "td,th", isRoot);
    };
    var getClosestTable = function(cell, isRoot) {
      return ancestor$1(cell, "table", isRoot);
    };
    var isExpandedCellRng = function(cellRng) {
      return !eq$2(cellRng.start, cellRng.end);
    };
    var getTableFromCellRng = function(cellRng, isRoot) {
      return getClosestTable(cellRng.start, isRoot).bind(function(startParentTable) {
        return getClosestTable(cellRng.end, isRoot).bind(function(endParentTable) {
          return someIf(eq$2(startParentTable, endParentTable), startParentTable);
        });
      });
    };
    var isSingleCellTable = function(cellRng, isRoot) {
      return !isExpandedCellRng(cellRng) && getTableFromCellRng(cellRng, isRoot).exists(function(table) {
        var rows = table.dom.rows;
        return rows.length === 1 && rows[0].cells.length === 1;
      });
    };
    var getTableCells = function(table) {
      return descendants$1(table, "td,th");
    };
    var getCellRng = function(rng, isRoot) {
      var startCell = getClosestCell(rng.startContainer, isRoot);
      var endCell = getClosestCell(rng.endContainer, isRoot);
      return lift2(startCell, endCell, tableCellRng);
    };
    var getCellRangeFromStartTable = function(cellRng, isRoot) {
      return getClosestTable(cellRng.start, isRoot).bind(function(table) {
        return last(getTableCells(table)).map(function(endCell) {
          return tableCellRng(cellRng.start, endCell);
        });
      });
    };
    var partialSelection = function(isRoot, rng) {
      var startCell = getClosestCell(rng.startContainer, isRoot);
      var endCell = getClosestCell(rng.endContainer, isRoot);
      return rng.collapsed ? Optional.none() : lift2(startCell, endCell, tableCellRng).fold(function() {
        return startCell.fold(function() {
          return endCell.bind(function(endCell2) {
            return getClosestTable(endCell2, isRoot).bind(function(table) {
              return head(getTableCells(table)).map(function(startCell2) {
                return tableCellRng(startCell2, endCell2);
              });
            });
          });
        }, function(startCell2) {
          return getClosestTable(startCell2, isRoot).bind(function(table) {
            return last(getTableCells(table)).map(function(endCell2) {
              return tableCellRng(startCell2, endCell2);
            });
          });
        });
      }, function(cellRng) {
        return isWithinSameTable(isRoot, cellRng) ? Optional.none() : getCellRangeFromStartTable(cellRng, isRoot);
      });
    };
    var isWithinSameTable = function(isRoot, cellRng) {
      return getTableFromCellRng(cellRng, isRoot).isSome();
    };
    var getTableSelectionFromCellRng = function(cellRng, isRoot) {
      return getTableFromCellRng(cellRng, isRoot).map(function(table) {
        return tableSelection(cellRng, table, getTableCells(table));
      });
    };
    var getTableSelection = function(optCellRng, rng, isRoot) {
      return optCellRng.filter(function(cellRng) {
        return isExpandedCellRng(cellRng) && isWithinSameTable(isRoot, cellRng);
      }).orThunk(function() {
        return partialSelection(isRoot, rng);
      }).bind(function(cRng) {
        return getTableSelectionFromCellRng(cRng, isRoot);
      });
    };
    var getCellIndex = function(cells, cell) {
      return findIndex(cells, function(x) {
        return eq$2(x, cell);
      });
    };
    var getSelectedCells = function(tableSelection2) {
      return lift2(getCellIndex(tableSelection2.cells, tableSelection2.rng.start), getCellIndex(tableSelection2.cells, tableSelection2.rng.end), function(startIndex, endIndex) {
        return tableSelection2.cells.slice(startIndex, endIndex + 1);
      });
    };
    var isSingleCellTableContentSelected = function(optCellRng, rng, isRoot) {
      return optCellRng.filter(function(cellRng) {
        return isSingleCellTable(cellRng, isRoot) && hasAllContentsSelected(cellRng.start, rng);
      }).map(function(cellRng) {
        return cellRng.start;
      });
    };
    var getAction = function(tableSelection2) {
      return getSelectedCells(tableSelection2).map(function(selected) {
        var cells = tableSelection2.cells;
        return selected.length === cells.length ? deleteAction.removeTable(tableSelection2.table) : deleteAction.emptyCells(selected);
      });
    };
    var getActionFromRange = function(root, rng) {
      var isRoot = isRootFromElement(root);
      var optCellRng = getCellRng(rng, isRoot);
      return isSingleCellTableContentSelected(optCellRng, rng, isRoot).map(function(cell) {
        return deleteAction.deleteCellSelection(rng, cell);
      }).orThunk(function() {
        return getTableSelection(optCellRng, rng, isRoot).bind(getAction);
      });
    };
    var freefallRtl = function(root) {
      var child2 = isComment(root) ? prevSibling(root) : lastChild(root);
      return child2.bind(freefallRtl).orThunk(function() {
        return Optional.some(root);
      });
    };
    var emptyCells = function(editor, cells) {
      each(cells, fillWithPaddingBr);
      editor.selection.setCursorLocation(cells[0].dom, 0);
      return true;
    };
    var deleteCellContents = function(editor, rng, cell) {
      rng.deleteContents();
      var lastNode = freefallRtl(cell).getOr(cell);
      var lastBlock = SugarElement.fromDom(editor.dom.getParent(lastNode.dom, editor.dom.isBlock));
      if (isEmpty(lastBlock)) {
        fillWithPaddingBr(lastBlock);
        editor.selection.setCursorLocation(lastBlock.dom, 0);
      }
      if (!eq$2(cell, lastBlock)) {
        var additionalCleanupNodes = parent(lastBlock).is(cell) ? [] : siblings(lastBlock);
        each(additionalCleanupNodes.concat(children(cell)), function(node) {
          if (!eq$2(node, lastBlock) && !contains$2(node, lastBlock)) {
            remove(node);
          }
        });
      }
      return true;
    };
    var deleteTableElement = function(editor, table) {
      deleteElement(editor, false, table);
      return true;
    };
    var deleteCellRange = function(editor, rootElm, rng) {
      return getActionFromRange(rootElm, rng).map(function(action2) {
        return action2.fold(curry(deleteTableElement, editor), curry(emptyCells, editor), curry(deleteCellContents, editor));
      });
    };
    var deleteCaptionRange = function(editor, caption) {
      return emptyElement(editor, caption);
    };
    var deleteTableRange = function(editor, rootElm, rng, startElm) {
      return getParentCaption(rootElm, startElm).fold(function() {
        return deleteCellRange(editor, rootElm, rng);
      }, function(caption) {
        return deleteCaptionRange(editor, caption);
      }).getOr(false);
    };
    var deleteRange = function(editor, startElm) {
      var rootNode = SugarElement.fromDom(editor.getBody());
      var rng = editor.selection.getRng();
      var selectedCells = getCellsFromEditor(editor);
      return selectedCells.length !== 0 ? emptyCells(editor, selectedCells) : deleteTableRange(editor, rootNode, rng, startElm);
    };
    var getParentCell = function(rootElm, elm) {
      return find(parentsAndSelf(elm, rootElm), isTableCell$1);
    };
    var getParentCaption = function(rootElm, elm) {
      return find(parentsAndSelf(elm, rootElm), function(elm2) {
        return name(elm2) === "caption";
      });
    };
    var deleteBetweenCells = function(editor, rootElm, forward, fromCell, from2) {
      return navigate(forward, editor.getBody(), from2).bind(function(to2) {
        return getParentCell(rootElm, SugarElement.fromDom(to2.getNode())).map(function(toCell) {
          return eq$2(toCell, fromCell) === false;
        });
      });
    };
    var emptyElement = function(editor, elm) {
      fillWithPaddingBr(elm);
      editor.selection.setCursorLocation(elm.dom, 0);
      return Optional.some(true);
    };
    var isDeleteOfLastCharPos = function(fromCaption, forward, from2, to2) {
      return firstPositionIn(fromCaption.dom).bind(function(first2) {
        return lastPositionIn(fromCaption.dom).map(function(last2) {
          return forward ? from2.isEqual(first2) && to2.isEqual(last2) : from2.isEqual(last2) && to2.isEqual(first2);
        });
      }).getOr(true);
    };
    var emptyCaretCaption = function(editor, elm) {
      return emptyElement(editor, elm);
    };
    var validateCaretCaption = function(rootElm, fromCaption, to2) {
      return getParentCaption(rootElm, SugarElement.fromDom(to2.getNode())).map(function(toCaption) {
        return eq$2(toCaption, fromCaption) === false;
      });
    };
    var deleteCaretInsideCaption = function(editor, rootElm, forward, fromCaption, from2) {
      return navigate(forward, editor.getBody(), from2).bind(function(to2) {
        return isDeleteOfLastCharPos(fromCaption, forward, from2, to2) ? emptyCaretCaption(editor, fromCaption) : validateCaretCaption(rootElm, fromCaption, to2);
      }).or(Optional.some(true));
    };
    var deleteCaretCells = function(editor, forward, rootElm, startElm) {
      var from2 = CaretPosition.fromRangeStart(editor.selection.getRng());
      return getParentCell(rootElm, startElm).bind(function(fromCell) {
        return isEmpty(fromCell) ? emptyElement(editor, fromCell) : deleteBetweenCells(editor, rootElm, forward, fromCell, from2);
      }).getOr(false);
    };
    var deleteCaretCaption = function(editor, forward, rootElm, fromCaption) {
      var from2 = CaretPosition.fromRangeStart(editor.selection.getRng());
      return isEmpty(fromCaption) ? emptyElement(editor, fromCaption) : deleteCaretInsideCaption(editor, rootElm, forward, fromCaption, from2);
    };
    var isNearTable = function(forward, pos) {
      return forward ? isBeforeTable(pos) : isAfterTable(pos);
    };
    var isBeforeOrAfterTable = function(editor, forward) {
      var fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());
      return isNearTable(forward, fromPos) || fromPosition(forward, editor.getBody(), fromPos).exists(function(pos) {
        return isNearTable(forward, pos);
      });
    };
    var deleteCaret = function(editor, forward, startElm) {
      var rootElm = SugarElement.fromDom(editor.getBody());
      return getParentCaption(rootElm, startElm).fold(function() {
        return deleteCaretCells(editor, forward, rootElm, startElm) || isBeforeOrAfterTable(editor, forward);
      }, function(fromCaption) {
        return deleteCaretCaption(editor, forward, rootElm, fromCaption).getOr(false);
      });
    };
    var backspaceDelete = function(editor, forward) {
      var startElm = SugarElement.fromDom(editor.selection.getStart(true));
      var cells = getCellsFromEditor(editor);
      return editor.selection.isCollapsed() && cells.length === 0 ? deleteCaret(editor, forward, startElm) : deleteRange(editor, startElm);
    };
    var createRange$1 = function(sc, so, ec, eo) {
      var rng = document.createRange();
      rng.setStart(sc, so);
      rng.setEnd(ec, eo);
      return rng;
    };
    var normalizeBlockSelectionRange = function(rng) {
      var startPos = CaretPosition.fromRangeStart(rng);
      var endPos = CaretPosition.fromRangeEnd(rng);
      var rootNode = rng.commonAncestorContainer;
      return fromPosition(false, rootNode, endPos).map(function(newEndPos) {
        if (!isInSameBlock(startPos, endPos, rootNode) && isInSameBlock(startPos, newEndPos, rootNode)) {
          return createRange$1(startPos.container(), startPos.offset(), newEndPos.container(), newEndPos.offset());
        } else {
          return rng;
        }
      }).getOr(rng);
    };
    var normalize$2 = function(rng) {
      return rng.collapsed ? rng : normalizeBlockSelectionRange(rng);
    };
    var hasOnlyOneChild = function(node) {
      return node.firstChild && node.firstChild === node.lastChild;
    };
    var isPaddingNode = function(node) {
      return node.name === "br" || node.value === nbsp;
    };
    var isPaddedEmptyBlock = function(schema, node) {
      var blockElements = schema.getBlockElements();
      return blockElements[node.name] && hasOnlyOneChild(node) && isPaddingNode(node.firstChild);
    };
    var isEmptyFragmentElement = function(schema, node) {
      var nonEmptyElements = schema.getNonEmptyElements();
      return node && (node.isEmpty(nonEmptyElements) || isPaddedEmptyBlock(schema, node));
    };
    var isListFragment = function(schema, fragment) {
      var firstChild2 = fragment.firstChild;
      var lastChild2 = fragment.lastChild;
      if (firstChild2 && firstChild2.name === "meta") {
        firstChild2 = firstChild2.next;
      }
      if (lastChild2 && lastChild2.attr("id") === "mce_marker") {
        lastChild2 = lastChild2.prev;
      }
      if (isEmptyFragmentElement(schema, lastChild2)) {
        lastChild2 = lastChild2.prev;
      }
      if (!firstChild2 || firstChild2 !== lastChild2) {
        return false;
      }
      return firstChild2.name === "ul" || firstChild2.name === "ol";
    };
    var cleanupDomFragment = function(domFragment) {
      var firstChild2 = domFragment.firstChild;
      var lastChild2 = domFragment.lastChild;
      if (firstChild2 && firstChild2.nodeName === "META") {
        firstChild2.parentNode.removeChild(firstChild2);
      }
      if (lastChild2 && lastChild2.id === "mce_marker") {
        lastChild2.parentNode.removeChild(lastChild2);
      }
      return domFragment;
    };
    var toDomFragment = function(dom2, serializer, fragment) {
      var html = serializer.serialize(fragment);
      var domFragment = dom2.createFragment(html);
      return cleanupDomFragment(domFragment);
    };
    var listItems$1 = function(elm) {
      return Tools.grep(elm.childNodes, function(child2) {
        return child2.nodeName === "LI";
      });
    };
    var isPadding = function(node) {
      return node.data === nbsp || isBr(node);
    };
    var isListItemPadded = function(node) {
      return node && node.firstChild && node.firstChild === node.lastChild && isPadding(node.firstChild);
    };
    var isEmptyOrPadded = function(elm) {
      return !elm.firstChild || isListItemPadded(elm);
    };
    var trimListItems = function(elms) {
      return elms.length > 0 && isEmptyOrPadded(elms[elms.length - 1]) ? elms.slice(0, -1) : elms;
    };
    var getParentLi = function(dom2, node) {
      var parentBlock = dom2.getParent(node, dom2.isBlock);
      return parentBlock && parentBlock.nodeName === "LI" ? parentBlock : null;
    };
    var isParentBlockLi = function(dom2, node) {
      return !!getParentLi(dom2, node);
    };
    var getSplit = function(parentNode, rng) {
      var beforeRng = rng.cloneRange();
      var afterRng = rng.cloneRange();
      beforeRng.setStartBefore(parentNode);
      afterRng.setEndAfter(parentNode);
      return [
        beforeRng.cloneContents(),
        afterRng.cloneContents()
      ];
    };
    var findFirstIn = function(node, rootNode) {
      var caretPos = CaretPosition.before(node);
      var caretWalker = CaretWalker(rootNode);
      var newCaretPos = caretWalker.next(caretPos);
      return newCaretPos ? newCaretPos.toRange() : null;
    };
    var findLastOf = function(node, rootNode) {
      var caretPos = CaretPosition.after(node);
      var caretWalker = CaretWalker(rootNode);
      var newCaretPos = caretWalker.prev(caretPos);
      return newCaretPos ? newCaretPos.toRange() : null;
    };
    var insertMiddle = function(target, elms, rootNode, rng) {
      var parts = getSplit(target, rng);
      var parentElm = target.parentNode;
      parentElm.insertBefore(parts[0], target);
      Tools.each(elms, function(li) {
        parentElm.insertBefore(li, target);
      });
      parentElm.insertBefore(parts[1], target);
      parentElm.removeChild(target);
      return findLastOf(elms[elms.length - 1], rootNode);
    };
    var insertBefore = function(target, elms, rootNode) {
      var parentElm = target.parentNode;
      Tools.each(elms, function(elm) {
        parentElm.insertBefore(elm, target);
      });
      return findFirstIn(target, rootNode);
    };
    var insertAfter = function(target, elms, rootNode, dom2) {
      dom2.insertAfter(elms.reverse(), target);
      return findLastOf(elms[0], rootNode);
    };
    var insertAtCaret = function(serializer, dom2, rng, fragment) {
      var domFragment = toDomFragment(dom2, serializer, fragment);
      var liTarget = getParentLi(dom2, rng.startContainer);
      var liElms = trimListItems(listItems$1(domFragment.firstChild));
      var BEGINNING = 1, END = 2;
      var rootNode = dom2.getRoot();
      var isAt = function(location) {
        var caretPos = CaretPosition.fromRangeStart(rng);
        var caretWalker = CaretWalker(dom2.getRoot());
        var newPos = location === BEGINNING ? caretWalker.prev(caretPos) : caretWalker.next(caretPos);
        return newPos ? getParentLi(dom2, newPos.getNode()) !== liTarget : true;
      };
      if (isAt(BEGINNING)) {
        return insertBefore(liTarget, liElms, rootNode);
      } else if (isAt(END)) {
        return insertAfter(liTarget, liElms, rootNode, dom2);
      }
      return insertMiddle(liTarget, liElms, rootNode, rng);
    };
    var trimOrPadLeftRight = function(dom2, rng, html) {
      var root = SugarElement.fromDom(dom2.getRoot());
      if (needsToBeNbspLeft(root, CaretPosition.fromRangeStart(rng))) {
        html = html.replace(/^ /, "&nbsp;");
      } else {
        html = html.replace(/^&nbsp;/, " ");
      }
      if (needsToBeNbspRight(root, CaretPosition.fromRangeEnd(rng))) {
        html = html.replace(/(&nbsp;| )(<br( \/)>)?$/, "&nbsp;");
      } else {
        html = html.replace(/&nbsp;(<br( \/)?>)?$/, " ");
      }
      return html;
    };
    var isTableCell$4 = isTableCell;
    var isTableCellContentSelected = function(dom2, rng, cell) {
      if (cell !== null) {
        var endCell = dom2.getParent(rng.endContainer, isTableCell$4);
        return cell === endCell && hasAllContentsSelected(SugarElement.fromDom(cell), rng);
      } else {
        return false;
      }
    };
    var validInsertion = function(editor, value2, parentNode) {
      if (parentNode.getAttribute("data-mce-bogus") === "all") {
        parentNode.parentNode.insertBefore(editor.dom.createFragment(value2), parentNode);
      } else {
        var node = parentNode.firstChild;
        var node2 = parentNode.lastChild;
        if (!node || node === node2 && node.nodeName === "BR") {
          editor.dom.setHTML(parentNode, value2);
        } else {
          editor.selection.setContent(value2);
        }
      }
    };
    var trimBrsFromTableCell = function(dom2, elm) {
      Optional.from(dom2.getParent(elm, "td,th")).map(SugarElement.fromDom).each(trimBlockTrailingBr);
    };
    var reduceInlineTextElements = function(editor, merge2) {
      var textInlineElements = editor.schema.getTextInlineElements();
      var dom2 = editor.dom;
      if (merge2) {
        var root_1 = editor.getBody();
        var elementUtils_1 = ElementUtils(dom2);
        Tools.each(dom2.select("*[data-mce-fragment]"), function(node) {
          var isInline2 = isNonNullable(textInlineElements[node.nodeName.toLowerCase()]);
          if (isInline2 && hasInheritableStyles(dom2, node)) {
            for (var parentNode = node.parentNode; isNonNullable(parentNode) && parentNode !== root_1; parentNode = parentNode.parentNode) {
              var styleConflict = hasStyleConflict(dom2, node, parentNode);
              if (styleConflict) {
                break;
              }
              if (elementUtils_1.compare(parentNode, node)) {
                dom2.remove(node, true);
                break;
              }
            }
          }
        });
      }
    };
    var markFragmentElements = function(fragment) {
      var node = fragment;
      while (node = node.walk()) {
        if (node.type === 1) {
          node.attr("data-mce-fragment", "1");
        }
      }
    };
    var unmarkFragmentElements = function(elm) {
      Tools.each(elm.getElementsByTagName("*"), function(elm2) {
        elm2.removeAttribute("data-mce-fragment");
      });
    };
    var isPartOfFragment = function(node) {
      return !!node.getAttribute("data-mce-fragment");
    };
    var canHaveChildren = function(editor, node) {
      return node && !editor.schema.getShortEndedElements()[node.nodeName];
    };
    var moveSelectionToMarker = function(editor, marker) {
      var nextRng;
      var dom2 = editor.dom, selection = editor.selection;
      var node2;
      var getContentEditableFalseParent = function(node3) {
        var root = editor.getBody();
        for (; node3 && node3 !== root; node3 = node3.parentNode) {
          if (dom2.getContentEditable(node3) === "false") {
            return node3;
          }
        }
        return null;
      };
      if (!marker) {
        return;
      }
      selection.scrollIntoView(marker);
      var parentEditableFalseElm = getContentEditableFalseParent(marker);
      if (parentEditableFalseElm) {
        dom2.remove(marker);
        selection.select(parentEditableFalseElm);
        return;
      }
      var rng = dom2.createRng();
      var node = marker.previousSibling;
      if (node && node.nodeType === 3) {
        rng.setStart(node, node.nodeValue.length);
        if (!Env.ie) {
          node2 = marker.nextSibling;
          if (node2 && node2.nodeType === 3) {
            node.appendData(node2.data);
            node2.parentNode.removeChild(node2);
          }
        }
      } else {
        rng.setStartBefore(marker);
        rng.setEndBefore(marker);
      }
      var findNextCaretRng = function(rng2) {
        var caretPos = CaretPosition.fromRangeStart(rng2);
        var caretWalker = CaretWalker(editor.getBody());
        caretPos = caretWalker.next(caretPos);
        if (caretPos) {
          return caretPos.toRange();
        }
      };
      var parentBlock = dom2.getParent(marker, dom2.isBlock);
      dom2.remove(marker);
      if (parentBlock && dom2.isEmpty(parentBlock)) {
        editor.$(parentBlock).empty();
        rng.setStart(parentBlock, 0);
        rng.setEnd(parentBlock, 0);
        if (!isTableCell$4(parentBlock) && !isPartOfFragment(parentBlock) && (nextRng = findNextCaretRng(rng))) {
          rng = nextRng;
          dom2.remove(parentBlock);
        } else {
          dom2.add(parentBlock, dom2.create("br", { "data-mce-bogus": "1" }));
        }
      }
      selection.setRng(rng);
    };
    var deleteSelectedContent = function(editor) {
      var dom2 = editor.dom;
      var rng = normalize$2(editor.selection.getRng());
      editor.selection.setRng(rng);
      var startCell = dom2.getParent(rng.startContainer, isTableCell$4);
      if (isTableCellContentSelected(dom2, rng, startCell)) {
        deleteCellContents(editor, rng, SugarElement.fromDom(startCell));
      } else {
        editor.getDoc().execCommand("Delete", false, null);
      }
    };
    var insertHtmlAtCaret = function(editor, value2, details) {
      var parentNode, rootNode, args;
      var marker, rng, node;
      var selection = editor.selection, dom2 = editor.dom;
      if (/^ | $/.test(value2)) {
        value2 = trimOrPadLeftRight(dom2, selection.getRng(), value2);
      }
      var parser = editor.parser;
      var merge2 = details.merge;
      var serializer = HtmlSerializer({ validate: shouldValidate(editor) }, editor.schema);
      var bookmarkHtml = '<span id="mce_marker" data-mce-type="bookmark">&#xFEFF;</span>';
      args = {
        content: value2,
        format: "html",
        selection: true,
        paste: details.paste
      };
      args = editor.fire("BeforeSetContent", args);
      if (args.isDefaultPrevented()) {
        editor.fire("SetContent", {
          content: args.content,
          format: "html",
          selection: true,
          paste: details.paste
        });
        return;
      }
      value2 = args.content;
      if (value2.indexOf("{$caret}") === -1) {
        value2 += "{$caret}";
      }
      value2 = value2.replace(/\{\$caret\}/, bookmarkHtml);
      rng = selection.getRng();
      var caretElement = rng.startContainer || (rng.parentElement ? rng.parentElement() : null);
      var body = editor.getBody();
      if (caretElement === body && selection.isCollapsed()) {
        if (dom2.isBlock(body.firstChild) && canHaveChildren(editor, body.firstChild) && dom2.isEmpty(body.firstChild)) {
          rng = dom2.createRng();
          rng.setStart(body.firstChild, 0);
          rng.setEnd(body.firstChild, 0);
          selection.setRng(rng);
        }
      }
      if (!selection.isCollapsed()) {
        deleteSelectedContent(editor);
      }
      parentNode = selection.getNode();
      var parserArgs = {
        context: parentNode.nodeName.toLowerCase(),
        data: details.data,
        insert: true
      };
      var fragment = parser.parse(value2, parserArgs);
      if (details.paste === true && isListFragment(editor.schema, fragment) && isParentBlockLi(dom2, parentNode)) {
        rng = insertAtCaret(serializer, dom2, selection.getRng(), fragment);
        selection.setRng(rng);
        editor.fire("SetContent", args);
        return;
      }
      markFragmentElements(fragment);
      node = fragment.lastChild;
      if (node.attr("id") === "mce_marker") {
        marker = node;
        for (node = node.prev; node; node = node.walk(true)) {
          if (node.type === 3 || !dom2.isBlock(node.name)) {
            if (editor.schema.isValidChild(node.parent.name, "span")) {
              node.parent.insert(marker, node, node.name === "br");
            }
            break;
          }
        }
      }
      editor._selectionOverrides.showBlockCaretContainer(parentNode);
      if (!parserArgs.invalid) {
        value2 = serializer.serialize(fragment);
        validInsertion(editor, value2, parentNode);
      } else {
        editor.selection.setContent(bookmarkHtml);
        parentNode = selection.getNode();
        rootNode = editor.getBody();
        if (parentNode.nodeType === 9) {
          parentNode = node = rootNode;
        } else {
          node = parentNode;
        }
        while (node !== rootNode) {
          parentNode = node;
          node = node.parentNode;
        }
        value2 = parentNode === rootNode ? rootNode.innerHTML : dom2.getOuterHTML(parentNode);
        value2 = serializer.serialize(parser.parse(value2.replace(/<span (id="mce_marker"|id=mce_marker).+?<\/span>/i, function() {
          return serializer.serialize(fragment);
        })));
        if (parentNode === rootNode) {
          dom2.setHTML(rootNode, value2);
        } else {
          dom2.setOuterHTML(parentNode, value2);
        }
      }
      reduceInlineTextElements(editor, merge2);
      moveSelectionToMarker(editor, dom2.get("mce_marker"));
      unmarkFragmentElements(editor.getBody());
      trimBrsFromTableCell(dom2, selection.getStart());
      editor.fire("SetContent", args);
      editor.addVisual();
    };
    var traverse = function(node, fn) {
      fn(node);
      if (node.firstChild) {
        traverse(node.firstChild, fn);
      }
      if (node.next) {
        traverse(node.next, fn);
      }
    };
    var findMatchingNodes = function(nodeFilters, attributeFilters, node) {
      var nodeMatches = {};
      var attrMatches = {};
      var matches2 = [];
      if (node.firstChild) {
        traverse(node.firstChild, function(node2) {
          each(nodeFilters, function(filter2) {
            if (filter2.name === node2.name) {
              if (nodeMatches[filter2.name]) {
                nodeMatches[filter2.name].nodes.push(node2);
              } else {
                nodeMatches[filter2.name] = {
                  filter: filter2,
                  nodes: [node2]
                };
              }
            }
          });
          each(attributeFilters, function(filter2) {
            if (typeof node2.attr(filter2.name) === "string") {
              if (attrMatches[filter2.name]) {
                attrMatches[filter2.name].nodes.push(node2);
              } else {
                attrMatches[filter2.name] = {
                  filter: filter2,
                  nodes: [node2]
                };
              }
            }
          });
        });
      }
      for (var name_1 in nodeMatches) {
        if (nodeMatches.hasOwnProperty(name_1)) {
          matches2.push(nodeMatches[name_1]);
        }
      }
      for (var name_2 in attrMatches) {
        if (attrMatches.hasOwnProperty(name_2)) {
          matches2.push(attrMatches[name_2]);
        }
      }
      return matches2;
    };
    var filter$3 = function(nodeFilters, attributeFilters, node) {
      var matches2 = findMatchingNodes(nodeFilters, attributeFilters, node);
      each(matches2, function(match2) {
        each(match2.filter.callbacks, function(callback) {
          callback(match2.nodes, match2.filter.name, {});
        });
      });
    };
    var defaultFormat = "html";
    var isTreeNode = function(content) {
      return content instanceof AstNode;
    };
    var moveSelection = function(editor) {
      if (hasFocus$1(editor)) {
        firstPositionIn(editor.getBody()).each(function(pos) {
          var node = pos.getNode();
          var caretPos = isTable(node) ? firstPositionIn(node).getOr(pos) : pos;
          editor.selection.setRng(caretPos.toRange());
        });
      }
    };
    var setEditorHtml = function(editor, html) {
      editor.dom.setHTML(editor.getBody(), html);
      moveSelection(editor);
    };
    var setContentString = function(editor, body, content, args) {
      var forcedRootBlockName, padd;
      if (content.length === 0 || /^\s+$/.test(content)) {
        padd = '<br data-mce-bogus="1">';
        if (body.nodeName === "TABLE") {
          content = "<tr><td>" + padd + "</td></tr>";
        } else if (/^(UL|OL)$/.test(body.nodeName)) {
          content = "<li>" + padd + "</li>";
        }
        forcedRootBlockName = getForcedRootBlock(editor);
        if (forcedRootBlockName && editor.schema.isValidChild(body.nodeName.toLowerCase(), forcedRootBlockName.toLowerCase())) {
          content = padd;
          content = editor.dom.createHTML(forcedRootBlockName, getForcedRootBlockAttrs(editor), content);
        } else if (!content) {
          content = '<br data-mce-bogus="1">';
        }
        setEditorHtml(editor, content);
        editor.fire("SetContent", args);
      } else {
        if (args.format !== "raw") {
          content = HtmlSerializer({ validate: editor.validate }, editor.schema).serialize(editor.parser.parse(content, {
            isRootContent: true,
            insert: true
          }));
        }
        args.content = isWsPreserveElement(SugarElement.fromDom(body)) ? content : Tools.trim(content);
        setEditorHtml(editor, args.content);
        if (!args.no_events) {
          editor.fire("SetContent", args);
        }
      }
      return args.content;
    };
    var setContentTree = function(editor, body, content, args) {
      filter$3(editor.parser.getNodeFilters(), editor.parser.getAttributeFilters(), content);
      var html = HtmlSerializer({ validate: editor.validate }, editor.schema).serialize(content);
      args.content = isWsPreserveElement(SugarElement.fromDom(body)) ? html : Tools.trim(html);
      setEditorHtml(editor, args.content);
      if (!args.no_events) {
        editor.fire("SetContent", args);
      }
      return content;
    };
    var setContentInternal = function(editor, content, args) {
      args.format = args.format ? args.format : defaultFormat;
      args.set = true;
      args.content = isTreeNode(content) ? "" : content;
      if (!args.no_events) {
        editor.fire("BeforeSetContent", args);
      }
      if (!isTreeNode(content)) {
        content = args.content;
      }
      return Optional.from(editor.getBody()).fold(constant(content), function(body) {
        return isTreeNode(content) ? setContentTree(editor, body, content, args) : setContentString(editor, body, content, args);
      });
    };
    var sibling$2 = function(scope, predicate) {
      return sibling(scope, predicate).isSome();
    };
    var ensureIsRoot = function(isRoot) {
      return isFunction(isRoot) ? isRoot : never;
    };
    var ancestor$3 = function(scope, transform, isRoot) {
      var element = scope.dom;
      var stop2 = ensureIsRoot(isRoot);
      while (element.parentNode) {
        element = element.parentNode;
        var el = SugarElement.fromDom(element);
        var transformed = transform(el);
        if (transformed.isSome()) {
          return transformed;
        } else if (stop2(el)) {
          break;
        }
      }
      return Optional.none();
    };
    var closest$2 = function(scope, transform, isRoot) {
      var current = transform(scope);
      var stop2 = ensureIsRoot(isRoot);
      return current.orThunk(function() {
        return stop2(scope) ? Optional.none() : ancestor$3(scope, transform, stop2);
      });
    };
    var isEq$2 = isEq;
    var matchesUnInheritedFormatSelector = function(ed, node, name2) {
      var formatList = ed.formatter.get(name2);
      if (formatList) {
        for (var i = 0; i < formatList.length; i++) {
          if (formatList[i].inherit === false && ed.dom.is(node, formatList[i].selector)) {
            return true;
          }
        }
      }
      return false;
    };
    var matchParents = function(editor, node, name2, vars) {
      var root = editor.dom.getRoot();
      if (node === root) {
        return false;
      }
      node = editor.dom.getParent(node, function(node2) {
        if (matchesUnInheritedFormatSelector(editor, node2, name2)) {
          return true;
        }
        return node2.parentNode === root || !!matchNode(editor, node2, name2, vars, true);
      });
      return matchNode(editor, node, name2, vars);
    };
    var matchName = function(dom2, node, format) {
      if (isEq$2(node, format.inline)) {
        return true;
      }
      if (isEq$2(node, format.block)) {
        return true;
      }
      if (format.selector) {
        return node.nodeType === 1 && dom2.is(node, format.selector);
      }
    };
    var matchItems = function(dom2, node, format, itemName, similar, vars) {
      var key, value2;
      var items = format[itemName];
      var i;
      if (format.onmatch) {
        return format.onmatch(node, format, itemName);
      }
      if (items) {
        if (typeof items.length === "undefined") {
          for (key in items) {
            if (items.hasOwnProperty(key)) {
              if (itemName === "attributes") {
                value2 = dom2.getAttrib(node, key);
              } else {
                value2 = getStyle(dom2, node, key);
              }
              if (similar && !value2 && !format.exact) {
                return;
              }
              if ((!similar || format.exact) && !isEq$2(value2, normalizeStyleValue(dom2, replaceVars(items[key], vars), key))) {
                return;
              }
            }
          }
        } else {
          for (i = 0; i < items.length; i++) {
            if (itemName === "attributes" ? dom2.getAttrib(node, items[i]) : getStyle(dom2, node, items[i])) {
              return format;
            }
          }
        }
      }
      return format;
    };
    var matchNode = function(ed, node, name2, vars, similar) {
      var formatList = ed.formatter.get(name2);
      var format, i, x, classes;
      var dom2 = ed.dom;
      if (formatList && node) {
        for (i = 0; i < formatList.length; i++) {
          format = formatList[i];
          if (matchName(ed.dom, node, format) && matchItems(dom2, node, format, "attributes", similar, vars) && matchItems(dom2, node, format, "styles", similar, vars)) {
            if (classes = format.classes) {
              for (x = 0; x < classes.length; x++) {
                if (!ed.dom.hasClass(node, replaceVars(classes[x], vars))) {
                  return;
                }
              }
            }
            return format;
          }
        }
      }
    };
    var match = function(editor, name2, vars, node) {
      if (node) {
        return matchParents(editor, node, name2, vars);
      }
      node = editor.selection.getNode();
      if (matchParents(editor, node, name2, vars)) {
        return true;
      }
      var startNode = editor.selection.getStart();
      if (startNode !== node) {
        if (matchParents(editor, startNode, name2, vars)) {
          return true;
        }
      }
      return false;
    };
    var matchAll = function(editor, names, vars) {
      var matchedFormatNames = [];
      var checkedMap = {};
      var startElement = editor.selection.getStart();
      editor.dom.getParent(startElement, function(node) {
        for (var i = 0; i < names.length; i++) {
          var name_1 = names[i];
          if (!checkedMap[name_1] && matchNode(editor, node, name_1, vars)) {
            checkedMap[name_1] = true;
            matchedFormatNames.push(name_1);
          }
        }
      }, editor.dom.getRoot());
      return matchedFormatNames;
    };
    var closest$3 = function(editor, names) {
      var isRoot = function(elm) {
        return eq$2(elm, SugarElement.fromDom(editor.getBody()));
      };
      var match2 = function(elm, name2) {
        return matchNode(editor, elm.dom, name2) ? Optional.some(name2) : Optional.none();
      };
      return Optional.from(editor.selection.getStart(true)).bind(function(rawElm) {
        return closest$2(SugarElement.fromDom(rawElm), function(elm) {
          return findMap(names, function(name2) {
            return match2(elm, name2);
          });
        }, isRoot);
      }).getOrNull();
    };
    var canApply = function(editor, name2) {
      var formatList = editor.formatter.get(name2);
      var startNode, parents2, i, x, selector;
      var dom2 = editor.dom;
      if (formatList) {
        startNode = editor.selection.getStart();
        parents2 = getParents$1(dom2, startNode);
        for (x = formatList.length - 1; x >= 0; x--) {
          selector = formatList[x].selector;
          if (!selector || formatList[x].defaultBlock) {
            return true;
          }
          for (i = parents2.length - 1; i >= 0; i--) {
            if (dom2.is(parents2[i], selector)) {
              return true;
            }
          }
        }
      }
      return false;
    };
    var matchAllOnNode = function(editor, node, formatNames) {
      return foldl(formatNames, function(acc, name2) {
        var matchSimilar = isVariableFormatName(editor, name2);
        if (editor.formatter.matchNode(node, name2, {}, matchSimilar)) {
          return acc.concat([name2]);
        } else {
          return acc;
        }
      }, []);
    };
    var ZWSP$1 = ZWSP, CARET_ID$1 = "_mce_caret";
    var importNode = function(ownerDocument, node) {
      return ownerDocument.importNode(node, true);
    };
    var getEmptyCaretContainers = function(node) {
      var nodes = [];
      while (node) {
        if (node.nodeType === 3 && node.nodeValue !== ZWSP$1 || node.childNodes.length > 1) {
          return [];
        }
        if (node.nodeType === 1) {
          nodes.push(node);
        }
        node = node.firstChild;
      }
      return nodes;
    };
    var isCaretContainerEmpty = function(node) {
      return getEmptyCaretContainers(node).length > 0;
    };
    var findFirstTextNode = function(node) {
      if (node) {
        var walker = new DomTreeWalker(node, node);
        for (node = walker.current(); node; node = walker.next()) {
          if (isText$1(node)) {
            return node;
          }
        }
      }
      return null;
    };
    var createCaretContainer = function(fill) {
      var caretContainer = SugarElement.fromTag("span");
      setAll(caretContainer, {
        "id": CARET_ID$1,
        "data-mce-bogus": "1",
        "data-mce-type": "format-caret"
      });
      if (fill) {
        append(caretContainer, SugarElement.fromText(ZWSP$1));
      }
      return caretContainer;
    };
    var trimZwspFromCaretContainer = function(caretContainerNode) {
      var textNode = findFirstTextNode(caretContainerNode);
      if (textNode && textNode.nodeValue.charAt(0) === ZWSP$1) {
        textNode.deleteData(0, 1);
      }
      return textNode;
    };
    var removeCaretContainerNode = function(editor, node, moveCaret2) {
      if (moveCaret2 === void 0) {
        moveCaret2 = true;
      }
      var dom2 = editor.dom, selection = editor.selection;
      if (isCaretContainerEmpty(node)) {
        deleteElement(editor, false, SugarElement.fromDom(node), moveCaret2);
      } else {
        var rng = selection.getRng();
        var block = dom2.getParent(node, dom2.isBlock);
        var startContainer = rng.startContainer;
        var startOffset = rng.startOffset;
        var endContainer = rng.endContainer;
        var endOffset = rng.endOffset;
        var textNode = trimZwspFromCaretContainer(node);
        dom2.remove(node, true);
        if (startContainer === textNode && startOffset > 0) {
          rng.setStart(textNode, startOffset - 1);
        }
        if (endContainer === textNode && endOffset > 0) {
          rng.setEnd(textNode, endOffset - 1);
        }
        if (block && dom2.isEmpty(block)) {
          fillWithPaddingBr(SugarElement.fromDom(block));
        }
        selection.setRng(rng);
      }
    };
    var removeCaretContainer = function(editor, node, moveCaret2) {
      if (moveCaret2 === void 0) {
        moveCaret2 = true;
      }
      var dom2 = editor.dom, selection = editor.selection;
      if (!node) {
        node = getParentCaretContainer(editor.getBody(), selection.getStart());
        if (!node) {
          while (node = dom2.get(CARET_ID$1)) {
            removeCaretContainerNode(editor, node, false);
          }
        }
      } else {
        removeCaretContainerNode(editor, node, moveCaret2);
      }
    };
    var insertCaretContainerNode = function(editor, caretContainer, formatNode) {
      var dom2 = editor.dom, block = dom2.getParent(formatNode, curry(isTextBlock$1, editor));
      if (block && dom2.isEmpty(block)) {
        formatNode.parentNode.replaceChild(caretContainer, formatNode);
      } else {
        removeTrailingBr(SugarElement.fromDom(formatNode));
        if (dom2.isEmpty(formatNode)) {
          formatNode.parentNode.replaceChild(caretContainer, formatNode);
        } else {
          dom2.insertAfter(caretContainer, formatNode);
        }
      }
    };
    var appendNode = function(parentNode, node) {
      parentNode.appendChild(node);
      return node;
    };
    var insertFormatNodesIntoCaretContainer = function(formatNodes, caretContainer) {
      var innerMostFormatNode = foldr(formatNodes, function(parentNode, formatNode) {
        return appendNode(parentNode, formatNode.cloneNode(false));
      }, caretContainer);
      return appendNode(innerMostFormatNode, innerMostFormatNode.ownerDocument.createTextNode(ZWSP$1));
    };
    var cleanFormatNode = function(editor, caretContainer, formatNode, name2, vars, similar) {
      var formatter = editor.formatter;
      var dom2 = editor.dom;
      var validFormats = filter(keys(formatter.get()), function(formatName) {
        return formatName !== name2 && !contains$1(formatName, "removeformat");
      });
      var matchedFormats = matchAllOnNode(editor, formatNode, validFormats);
      var uniqueFormats = filter(matchedFormats, function(fmtName) {
        return !areSimilarFormats(editor, fmtName, name2);
      });
      if (uniqueFormats.length > 0) {
        var clonedFormatNode = formatNode.cloneNode(false);
        dom2.add(caretContainer, clonedFormatNode);
        formatter.remove(name2, vars, clonedFormatNode, similar);
        dom2.remove(clonedFormatNode);
        return Optional.some(clonedFormatNode);
      } else {
        return Optional.none();
      }
    };
    var applyCaretFormat = function(editor, name2, vars) {
      var caretContainer, textNode;
      var selection = editor.selection;
      var selectionRng = selection.getRng();
      var offset = selectionRng.startOffset;
      var container = selectionRng.startContainer;
      var text = container.nodeValue;
      caretContainer = getParentCaretContainer(editor.getBody(), selection.getStart());
      if (caretContainer) {
        textNode = findFirstTextNode(caretContainer);
      }
      var wordcharRegex = /[^\s\u00a0\u00ad\u200b\ufeff]/;
      if (text && offset > 0 && offset < text.length && wordcharRegex.test(text.charAt(offset)) && wordcharRegex.test(text.charAt(offset - 1))) {
        var bookmark = selection.getBookmark();
        selectionRng.collapse(true);
        var rng = expandRng(editor, selectionRng, editor.formatter.get(name2));
        rng = split$1(rng);
        editor.formatter.apply(name2, vars, rng);
        selection.moveToBookmark(bookmark);
      } else {
        if (!caretContainer || textNode.nodeValue !== ZWSP$1) {
          caretContainer = importNode(editor.getDoc(), createCaretContainer(true).dom);
          textNode = caretContainer.firstChild;
          selectionRng.insertNode(caretContainer);
          offset = 1;
          editor.formatter.apply(name2, vars, caretContainer);
        } else {
          editor.formatter.apply(name2, vars, caretContainer);
        }
        selection.setCursorLocation(textNode, offset);
      }
    };
    var removeCaretFormat = function(editor, name2, vars, similar) {
      var dom2 = editor.dom;
      var selection = editor.selection;
      var hasContentAfter, node, formatNode;
      var parents2 = [];
      var rng = selection.getRng();
      var container = rng.startContainer;
      var offset = rng.startOffset;
      node = container;
      if (container.nodeType === 3) {
        if (offset !== container.nodeValue.length) {
          hasContentAfter = true;
        }
        node = node.parentNode;
      }
      while (node) {
        if (matchNode(editor, node, name2, vars, similar)) {
          formatNode = node;
          break;
        }
        if (node.nextSibling) {
          hasContentAfter = true;
        }
        parents2.push(node);
        node = node.parentNode;
      }
      if (!formatNode) {
        return;
      }
      if (hasContentAfter) {
        var bookmark = selection.getBookmark();
        rng.collapse(true);
        var expandedRng = expandRng(editor, rng, editor.formatter.get(name2), true);
        expandedRng = split$1(expandedRng);
        editor.formatter.remove(name2, vars, expandedRng, similar);
        selection.moveToBookmark(bookmark);
      } else {
        var caretContainer = getParentCaretContainer(editor.getBody(), formatNode);
        var newCaretContainer = createCaretContainer(false).dom;
        insertCaretContainerNode(editor, newCaretContainer, caretContainer !== null ? caretContainer : formatNode);
        var cleanedFormatNode = cleanFormatNode(editor, newCaretContainer, formatNode, name2, vars, similar);
        var caretTextNode = insertFormatNodesIntoCaretContainer(parents2.concat(cleanedFormatNode.toArray()), newCaretContainer);
        removeCaretContainerNode(editor, caretContainer, false);
        selection.setCursorLocation(caretTextNode, 1);
        if (dom2.isEmpty(formatNode)) {
          dom2.remove(formatNode);
        }
      }
    };
    var disableCaretContainer = function(editor, keyCode) {
      var selection = editor.selection, body = editor.getBody();
      removeCaretContainer(editor, null, false);
      if ((keyCode === 8 || keyCode === 46) && selection.isCollapsed() && selection.getStart().innerHTML === ZWSP$1) {
        removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()));
      }
      if (keyCode === 37 || keyCode === 39) {
        removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()));
      }
    };
    var setup$3 = function(editor) {
      editor.on("mouseup keydown", function(e) {
        disableCaretContainer(editor, e.keyCode);
      });
    };
    var replaceWithCaretFormat = function(targetNode, formatNodes) {
      var caretContainer = createCaretContainer(false);
      var innerMost = insertFormatNodesIntoCaretContainer(formatNodes, caretContainer.dom);
      before(SugarElement.fromDom(targetNode), caretContainer);
      remove(SugarElement.fromDom(targetNode));
      return CaretPosition(innerMost, 0);
    };
    var isFormatElement = function(editor, element) {
      var inlineElements = editor.schema.getTextInlineElements();
      return inlineElements.hasOwnProperty(name(element)) && !isCaretNode(element.dom) && !isBogus(element.dom);
    };
    var isEmptyCaretFormatElement = function(element) {
      return isCaretNode(element.dom) && isCaretContainerEmpty(element.dom);
    };
    var postProcessHooks = {};
    var filter$4 = filter$2;
    var each$8 = each$2;
    var addPostProcessHook = function(name2, hook) {
      var hooks = postProcessHooks[name2];
      if (!hooks) {
        postProcessHooks[name2] = [];
      }
      postProcessHooks[name2].push(hook);
    };
    var postProcess = function(name2, editor) {
      each$8(postProcessHooks[name2], function(hook) {
        hook(editor);
      });
    };
    addPostProcessHook("pre", function(editor) {
      var rng = editor.selection.getRng();
      var blocks2;
      var hasPreSibling = function(pre) {
        return isPre(pre.previousSibling) && indexOf$1(blocks2, pre.previousSibling) !== -1;
      };
      var joinPre = function(pre1, pre2) {
        DomQuery(pre2).remove();
        DomQuery(pre1).append("<br><br>").append(pre2.childNodes);
      };
      var isPre = matchNodeNames(["pre"]);
      if (!rng.collapsed) {
        blocks2 = editor.selection.getSelectedBlocks();
        each$8(filter$4(filter$4(blocks2, isPre), hasPreSibling), function(pre) {
          joinPre(pre.previousSibling, pre);
        });
      }
    });
    var each$9 = Tools.each;
    var isElementNode = function(node) {
      return isElement$1(node) && !isBookmarkNode$1(node) && !isCaretNode(node) && !isBogus(node);
    };
    var findElementSibling = function(node, siblingName) {
      var sibling2;
      for (sibling2 = node; sibling2; sibling2 = sibling2[siblingName]) {
        if (isText$1(sibling2) && sibling2.nodeValue.length !== 0) {
          return node;
        }
        if (isElement$1(sibling2) && !isBookmarkNode$1(sibling2)) {
          return sibling2;
        }
      }
      return node;
    };
    var mergeSiblingsNodes = function(dom2, prev, next) {
      var sibling2, tmpSibling;
      var elementUtils = ElementUtils(dom2);
      if (prev && next) {
        prev = findElementSibling(prev, "previousSibling");
        next = findElementSibling(next, "nextSibling");
        if (elementUtils.compare(prev, next)) {
          for (sibling2 = prev.nextSibling; sibling2 && sibling2 !== next; ) {
            tmpSibling = sibling2;
            sibling2 = sibling2.nextSibling;
            prev.appendChild(tmpSibling);
          }
          dom2.remove(next);
          Tools.each(Tools.grep(next.childNodes), function(node) {
            prev.appendChild(node);
          });
          return prev;
        }
      }
      return next;
    };
    var mergeSiblings = function(dom2, format, vars, node) {
      if (node && format.merge_siblings !== false) {
        var newNode = mergeSiblingsNodes(dom2, getNonWhiteSpaceSibling(node), node);
        mergeSiblingsNodes(dom2, newNode, getNonWhiteSpaceSibling(newNode, true));
      }
    };
    var clearChildStyles = function(dom2, format, node) {
      if (format.clear_child_styles) {
        var selector = format.links ? "*:not(a)" : "*";
        each$9(dom2.select(selector, node), function(node2) {
          if (isElementNode(node2)) {
            each$9(format.styles, function(value2, name2) {
              dom2.setStyle(node2, name2, "");
            });
          }
        });
      }
    };
    var processChildElements = function(node, filter2, process2) {
      each$9(node.childNodes, function(node2) {
        if (isElementNode(node2)) {
          if (filter2(node2)) {
            process2(node2);
          }
          if (node2.hasChildNodes()) {
            processChildElements(node2, filter2, process2);
          }
        }
      });
    };
    var unwrapEmptySpan = function(dom2, node) {
      if (node.nodeName === "SPAN" && dom2.getAttribs(node).length === 0) {
        dom2.remove(node, true);
      }
    };
    var hasStyle = function(dom2, name2) {
      return function(node) {
        return !!(node && getStyle(dom2, node, name2));
      };
    };
    var applyStyle = function(dom2, name2, value2) {
      return function(node) {
        dom2.setStyle(node, name2, value2);
        if (node.getAttribute("style") === "") {
          node.removeAttribute("style");
        }
        unwrapEmptySpan(dom2, node);
      };
    };
    var removeResult = Adt.generate([
      { keep: [] },
      { rename: ["name"] },
      { removed: [] }
    ]);
    var MCE_ATTR_RE = /^(src|href|style)$/;
    var each$a = Tools.each;
    var isEq$3 = isEq;
    var isTableCellOrRow = function(node) {
      return /^(TR|TH|TD)$/.test(node.nodeName);
    };
    var isChildOfInlineParent = function(dom2, node, parent2) {
      return dom2.isChildOf(node, parent2) && node !== parent2 && !dom2.isBlock(parent2);
    };
    var getContainer = function(ed, rng, start2) {
      var container, offset;
      container = rng[start2 ? "startContainer" : "endContainer"];
      offset = rng[start2 ? "startOffset" : "endOffset"];
      if (isElement$1(container)) {
        var lastIdx = container.childNodes.length - 1;
        if (!start2 && offset) {
          offset--;
        }
        container = container.childNodes[offset > lastIdx ? lastIdx : offset];
      }
      if (isText$1(container) && start2 && offset >= container.nodeValue.length) {
        container = new DomTreeWalker(container, ed.getBody()).next() || container;
      }
      if (isText$1(container) && !start2 && offset === 0) {
        container = new DomTreeWalker(container, ed.getBody()).prev() || container;
      }
      return container;
    };
    var normalizeTableSelection = function(node, start2) {
      var prop = start2 ? "firstChild" : "lastChild";
      if (isTableCellOrRow(node) && node[prop]) {
        var childNode = node[prop];
        if (node.nodeName === "TR") {
          return childNode[prop] || childNode;
        } else {
          return childNode;
        }
      }
      return node;
    };
    var wrap$2 = function(dom2, node, name2, attrs) {
      var wrapper = dom2.create(name2, attrs);
      node.parentNode.insertBefore(wrapper, node);
      wrapper.appendChild(node);
      return wrapper;
    };
    var wrapWithSiblings = function(dom2, node, next, name2, attrs) {
      var start2 = SugarElement.fromDom(node);
      var wrapper = SugarElement.fromDom(dom2.create(name2, attrs));
      var siblings2 = next ? nextSiblings(start2) : prevSiblings(start2);
      append$1(wrapper, siblings2);
      if (next) {
        before(start2, wrapper);
        prepend(wrapper, start2);
      } else {
        after(start2, wrapper);
        append(wrapper, start2);
      }
      return wrapper.dom;
    };
    var matchName$1 = function(dom2, node, format) {
      if (isEq$3(node, format.inline)) {
        return true;
      }
      if (isEq$3(node, format.block)) {
        return true;
      }
      if (format.selector) {
        return isElement$1(node) && dom2.is(node, format.selector);
      }
    };
    var isColorFormatAndAnchor = function(node, format) {
      return format.links && node.nodeName === "A";
    };
    var find$3 = function(dom2, node, next, inc) {
      node = getNonWhiteSpaceSibling(node, next, inc);
      return !node || (node.nodeName === "BR" || dom2.isBlock(node));
    };
    var removeNode$1 = function(ed, node, format) {
      var parentNode = node.parentNode;
      var rootBlockElm;
      var dom2 = ed.dom, forcedRootBlock = getForcedRootBlock(ed);
      if (format.block) {
        if (!forcedRootBlock) {
          if (dom2.isBlock(node) && !dom2.isBlock(parentNode)) {
            if (!find$3(dom2, node, false) && !find$3(dom2, node.firstChild, true, true)) {
              node.insertBefore(dom2.create("br"), node.firstChild);
            }
            if (!find$3(dom2, node, true) && !find$3(dom2, node.lastChild, false, true)) {
              node.appendChild(dom2.create("br"));
            }
          }
        } else {
          if (parentNode === dom2.getRoot()) {
            if (!format.list_block || !isEq$3(node, format.list_block)) {
              each(from$1(node.childNodes), function(node2) {
                if (isValid(ed, forcedRootBlock, node2.nodeName.toLowerCase())) {
                  if (!rootBlockElm) {
                    rootBlockElm = wrap$2(dom2, node2, forcedRootBlock);
                    dom2.setAttribs(rootBlockElm, ed.settings.forced_root_block_attrs);
                  } else {
                    rootBlockElm.appendChild(node2);
                  }
                } else {
                  rootBlockElm = 0;
                }
              });
            }
          }
        }
      }
      if (format.selector && format.inline && !isEq$3(format.inline, node)) {
        return;
      }
      dom2.remove(node, true);
    };
    var removeFormatInternal = function(ed, format, vars, node, compareNode) {
      var stylesModified;
      var dom2 = ed.dom;
      if (!matchName$1(dom2, node, format) && !isColorFormatAndAnchor(node, format)) {
        return removeResult.keep();
      }
      var elm = node;
      if (format.inline && format.remove === "all" && isArray(format.preserve_attributes)) {
        var attrsToPreserve = filter(dom2.getAttribs(elm), function(attr) {
          return contains(format.preserve_attributes, attr.name.toLowerCase());
        });
        dom2.removeAllAttribs(elm);
        each(attrsToPreserve, function(attr) {
          return dom2.setAttrib(elm, attr.name, attr.value);
        });
        if (attrsToPreserve.length > 0) {
          return removeResult.rename("span");
        }
      }
      if (format.remove !== "all") {
        each$a(format.styles, function(value2, name2) {
          value2 = normalizeStyleValue(dom2, replaceVars(value2, vars), name2 + "");
          if (isNumber(name2)) {
            name2 = value2;
            compareNode = null;
          }
          if (format.remove_similar || (!compareNode || isEq$3(getStyle(dom2, compareNode, name2), value2))) {
            dom2.setStyle(elm, name2, "");
          }
          stylesModified = true;
        });
        if (stylesModified && dom2.getAttrib(elm, "style") === "") {
          elm.removeAttribute("style");
          elm.removeAttribute("data-mce-style");
        }
        each$a(format.attributes, function(value2, name2) {
          var valueOut;
          value2 = replaceVars(value2, vars);
          if (isNumber(name2)) {
            name2 = value2;
            compareNode = null;
          }
          if (format.remove_similar || (!compareNode || isEq$3(dom2.getAttrib(compareNode, name2), value2))) {
            if (name2 === "class") {
              value2 = dom2.getAttrib(elm, name2);
              if (value2) {
                valueOut = "";
                each(value2.split(/\s+/), function(cls) {
                  if (/mce\-\w+/.test(cls)) {
                    valueOut += (valueOut ? " " : "") + cls;
                  }
                });
                if (valueOut) {
                  dom2.setAttrib(elm, name2, valueOut);
                  return;
                }
              }
            }
            if (MCE_ATTR_RE.test(name2)) {
              elm.removeAttribute("data-mce-" + name2);
            }
            if (name2 === "style" && matchNodeNames(["li"])(elm) && dom2.getStyle(elm, "list-style-type") === "none") {
              elm.removeAttribute(name2);
              dom2.setStyle(elm, "list-style-type", "none");
              return;
            }
            if (name2 === "class") {
              elm.removeAttribute("className");
            }
            elm.removeAttribute(name2);
          }
        });
        each$a(format.classes, function(value2) {
          value2 = replaceVars(value2, vars);
          if (!compareNode || dom2.hasClass(compareNode, value2)) {
            dom2.removeClass(elm, value2);
          }
        });
        var attrs = dom2.getAttribs(elm);
        for (var i = 0; i < attrs.length; i++) {
          var attrName = attrs[i].nodeName;
          if (attrName.indexOf("_") !== 0 && attrName.indexOf("data-") !== 0) {
            return removeResult.keep();
          }
        }
      }
      if (format.remove !== "none") {
        removeNode$1(ed, elm, format);
        return removeResult.removed();
      }
      return removeResult.keep();
    };
    var removeFormat = function(ed, format, vars, node, compareNode) {
      return removeFormatInternal(ed, format, vars, node, compareNode).fold(never, function(newName) {
        ed.dom.rename(node, newName);
        return true;
      }, always);
    };
    var findFormatRoot = function(editor, container, name2, vars, similar) {
      var formatRoot;
      each(getParents$1(editor.dom, container.parentNode).reverse(), function(parent2) {
        if (!formatRoot && parent2.id !== "_start" && parent2.id !== "_end") {
          var format = matchNode(editor, parent2, name2, vars, similar);
          if (format && format.split !== false) {
            formatRoot = parent2;
          }
        }
      });
      return formatRoot;
    };
    var removeFormatFromClone = function(editor, format, vars, clone2) {
      return removeFormatInternal(editor, format, vars, clone2, clone2).fold(constant(clone2), function(newName) {
        var fragment = editor.dom.createFragment();
        fragment.appendChild(clone2);
        return editor.dom.rename(clone2, newName);
      }, constant(null));
    };
    var wrapAndSplit = function(editor, formatList, formatRoot, container, target, split2, format, vars) {
      var clone2, lastClone, firstClone;
      var dom2 = editor.dom;
      if (formatRoot) {
        var formatRootParent = formatRoot.parentNode;
        for (var parent_1 = container.parentNode; parent_1 && parent_1 !== formatRootParent; parent_1 = parent_1.parentNode) {
          clone2 = dom2.clone(parent_1, false);
          for (var i = 0; i < formatList.length; i++) {
            clone2 = removeFormatFromClone(editor, formatList[i], vars, clone2);
            if (clone2 === null) {
              break;
            }
          }
          if (clone2) {
            if (lastClone) {
              clone2.appendChild(lastClone);
            }
            if (!firstClone) {
              firstClone = clone2;
            }
            lastClone = clone2;
          }
        }
        if (split2 && (!format.mixed || !dom2.isBlock(formatRoot))) {
          container = dom2.split(formatRoot, container);
        }
        if (lastClone) {
          target.parentNode.insertBefore(lastClone, target);
          firstClone.appendChild(target);
          if (format.inline) {
            mergeSiblings(dom2, format, vars, lastClone);
          }
        }
      }
      return container;
    };
    var remove$6 = function(ed, name2, vars, node, similar) {
      var formatList = ed.formatter.get(name2);
      var format = formatList[0];
      var contentEditable = true;
      var dom2 = ed.dom;
      var selection = ed.selection;
      var splitToFormatRoot = function(container) {
        var formatRoot = findFormatRoot(ed, container, name2, vars, similar);
        return wrapAndSplit(ed, formatList, formatRoot, container, container, true, format, vars);
      };
      var isRemoveBookmarkNode = function(node2) {
        return isBookmarkNode$1(node2) && isElement$1(node2) && (node2.id === "_start" || node2.id === "_end");
      };
      var process2 = function(node2) {
        var lastContentEditable, hasContentEditableState2;
        var parentNode = node2.parentNode;
        if (isText$1(node2) && hasBlockChildren(dom2, parentNode)) {
          removeFormat(ed, format, vars, parentNode, parentNode);
        }
        if (isElement$1(node2) && dom2.getContentEditable(node2)) {
          lastContentEditable = contentEditable;
          contentEditable = dom2.getContentEditable(node2) === "true";
          hasContentEditableState2 = true;
        }
        var children2 = from$1(node2.childNodes);
        if (contentEditable && !hasContentEditableState2) {
          for (var i2 = 0; i2 < formatList.length; i2++) {
            if (removeFormat(ed, formatList[i2], vars, node2, node2)) {
              break;
            }
          }
        }
        if (format.deep) {
          if (children2.length) {
            for (var i2 = 0; i2 < children2.length; i2++) {
              process2(children2[i2]);
            }
            if (hasContentEditableState2) {
              contentEditable = lastContentEditable;
            }
          }
        }
      };
      var unwrap2 = function(start2) {
        var node2 = dom2.get(start2 ? "_start" : "_end");
        var out = node2[start2 ? "firstChild" : "lastChild"];
        if (isRemoveBookmarkNode(out)) {
          out = out[start2 ? "firstChild" : "lastChild"];
        }
        if (isText$1(out) && out.data.length === 0) {
          out = start2 ? node2.previousSibling || node2.nextSibling : node2.nextSibling || node2.previousSibling;
        }
        dom2.remove(node2, true);
        return out;
      };
      var removeRngStyle = function(rng2) {
        var startContainer, endContainer;
        var expandedRng = expandRng(ed, rng2, formatList, rng2.collapsed);
        if (format.split) {
          expandedRng = split$1(expandedRng);
          startContainer = getContainer(ed, expandedRng, true);
          endContainer = getContainer(ed, expandedRng);
          if (startContainer !== endContainer) {
            startContainer = normalizeTableSelection(startContainer, true);
            endContainer = normalizeTableSelection(endContainer, false);
            if (isChildOfInlineParent(dom2, startContainer, endContainer)) {
              var marker = Optional.from(startContainer.firstChild).getOr(startContainer);
              splitToFormatRoot(wrapWithSiblings(dom2, marker, true, "span", {
                "id": "_start",
                "data-mce-type": "bookmark"
              }));
              unwrap2(true);
              return;
            }
            if (isChildOfInlineParent(dom2, endContainer, startContainer)) {
              var marker = Optional.from(endContainer.lastChild).getOr(endContainer);
              splitToFormatRoot(wrapWithSiblings(dom2, marker, false, "span", {
                "id": "_end",
                "data-mce-type": "bookmark"
              }));
              unwrap2(false);
              return;
            }
            startContainer = wrap$2(dom2, startContainer, "span", {
              "id": "_start",
              "data-mce-type": "bookmark"
            });
            endContainer = wrap$2(dom2, endContainer, "span", {
              "id": "_end",
              "data-mce-type": "bookmark"
            });
            var newRng = dom2.createRng();
            newRng.setStartAfter(startContainer);
            newRng.setEndBefore(endContainer);
            walk$1(dom2, newRng, function(nodes) {
              each(nodes, function(n) {
                if (!isBookmarkNode$1(n) && !isBookmarkNode$1(n.parentNode)) {
                  splitToFormatRoot(n);
                }
              });
            });
            splitToFormatRoot(startContainer);
            splitToFormatRoot(endContainer);
            startContainer = unwrap2(true);
            endContainer = unwrap2();
          } else {
            startContainer = endContainer = splitToFormatRoot(startContainer);
          }
          expandedRng.startContainer = startContainer.parentNode ? startContainer.parentNode : startContainer;
          expandedRng.startOffset = dom2.nodeIndex(startContainer);
          expandedRng.endContainer = endContainer.parentNode ? endContainer.parentNode : endContainer;
          expandedRng.endOffset = dom2.nodeIndex(endContainer) + 1;
        }
        walk$1(dom2, expandedRng, function(nodes) {
          each(nodes, function(node2) {
            process2(node2);
            var textDecorations = [
              "underline",
              "line-through",
              "overline"
            ];
            each(textDecorations, function(decoration) {
              if (isElement$1(node2) && ed.dom.getStyle(node2, "text-decoration") === decoration && node2.parentNode && getTextDecoration(dom2, node2.parentNode) === decoration) {
                removeFormat(ed, {
                  deep: false,
                  exact: true,
                  inline: "span",
                  styles: { textDecoration: decoration }
                }, null, node2);
              }
            });
          });
        });
      };
      if (node) {
        if (isNode(node)) {
          var rng = dom2.createRng();
          rng.setStartBefore(node);
          rng.setEndAfter(node);
          removeRngStyle(rng);
        } else {
          removeRngStyle(node);
        }
        return;
      }
      if (dom2.getContentEditable(selection.getNode()) === "false") {
        node = selection.getNode();
        for (var i = 0; i < formatList.length; i++) {
          if (formatList[i].ceFalseOverride) {
            if (removeFormat(ed, formatList[i], vars, node, node)) {
              break;
            }
          }
        }
        return;
      }
      if (!selection.isCollapsed() || !format.inline || getCellsFromEditor(ed).length) {
        preserve(selection, true, function() {
          runOnRanges(ed, removeRngStyle);
        });
        if (format.inline && match(ed, name2, vars, selection.getStart())) {
          moveStart(dom2, selection, selection.getRng());
        }
        ed.nodeChanged();
      } else {
        removeCaretFormat(ed, name2, vars, similar);
      }
    };
    var each$b = Tools.each;
    var mergeTextDecorationsAndColor = function(dom2, format, vars, node) {
      var processTextDecorationsAndColor = function(n) {
        if (n.nodeType === 1 && n.parentNode && n.parentNode.nodeType === 1) {
          var textDecoration = getTextDecoration(dom2, n.parentNode);
          if (dom2.getStyle(n, "color") && textDecoration) {
            dom2.setStyle(n, "text-decoration", textDecoration);
          } else if (dom2.getStyle(n, "text-decoration") === textDecoration) {
            dom2.setStyle(n, "text-decoration", null);
          }
        }
      };
      if (format.styles && (format.styles.color || format.styles.textDecoration)) {
        Tools.walk(node, processTextDecorationsAndColor, "childNodes");
        processTextDecorationsAndColor(node);
      }
    };
    var mergeBackgroundColorAndFontSize = function(dom2, format, vars, node) {
      if (format.styles && format.styles.backgroundColor) {
        processChildElements(node, hasStyle(dom2, "fontSize"), applyStyle(dom2, "backgroundColor", replaceVars(format.styles.backgroundColor, vars)));
      }
    };
    var mergeSubSup = function(dom2, format, vars, node) {
      if (format.inline === "sub" || format.inline === "sup") {
        processChildElements(node, hasStyle(dom2, "fontSize"), applyStyle(dom2, "fontSize", ""));
        dom2.remove(dom2.select(format.inline === "sup" ? "sub" : "sup", node), true);
      }
    };
    var mergeWithChildren = function(editor, formatList, vars, node) {
      each$b(formatList, function(format) {
        each$b(editor.dom.select(format.inline, node), function(child2) {
          if (!isElementNode(child2)) {
            return;
          }
          removeFormat(editor, format, vars, child2, format.exact ? child2 : null);
        });
        clearChildStyles(editor.dom, format, node);
      });
    };
    var mergeWithParents = function(editor, format, name2, vars, node) {
      if (matchNode(editor, node.parentNode, name2, vars)) {
        if (removeFormat(editor, format, vars, node)) {
          return;
        }
      }
      if (format.merge_with_parents) {
        editor.dom.getParent(node.parentNode, function(parent2) {
          if (matchNode(editor, parent2, name2, vars)) {
            removeFormat(editor, format, vars, node);
            return true;
          }
        });
      }
    };
    var each$c = Tools.each;
    var hasFormatProperty = function(format, prop) {
      return hasNonNullableKey(format, prop);
    };
    var isElementNode$1 = function(node) {
      return node && node.nodeType === 1 && !isBookmarkNode$1(node) && !isCaretNode(node) && !isBogus(node);
    };
    var canFormatBR = function(editor, format, node, parentName) {
      if (canFormatEmptyLines(editor) && isInlineFormat(format)) {
        var validBRParentElements = __assign2(__assign2({}, editor.schema.getTextBlockElements()), {
          td: {},
          th: {},
          li: {},
          dt: {},
          dd: {},
          figcaption: {},
          caption: {},
          details: {},
          summary: {}
        });
        var hasCaretNodeSibling = sibling$2(SugarElement.fromDom(node), function(sibling2) {
          return isCaretNode(sibling2.dom);
        });
        return hasNonNullableKey(validBRParentElements, parentName) && isEmpty(SugarElement.fromDom(node.parentNode), false) && !hasCaretNodeSibling;
      } else {
        return false;
      }
    };
    var applyFormat = function(ed, name2, vars, node) {
      var formatList = ed.formatter.get(name2);
      var format = formatList[0];
      var isCollapsed = !node && ed.selection.isCollapsed();
      var dom2 = ed.dom;
      var selection = ed.selection;
      var setElementFormat = function(elm, fmt) {
        fmt = fmt || format;
        if (elm) {
          if (fmt.onformat) {
            fmt.onformat(elm, fmt, vars, node);
          }
          each$c(fmt.styles, function(value2, name3) {
            dom2.setStyle(elm, name3, replaceVars(value2, vars));
          });
          if (fmt.styles) {
            var styleVal = dom2.getAttrib(elm, "style");
            if (styleVal) {
              dom2.setAttrib(elm, "data-mce-style", styleVal);
            }
          }
          each$c(fmt.attributes, function(value2, name3) {
            dom2.setAttrib(elm, name3, replaceVars(value2, vars));
          });
          each$c(fmt.classes, function(value2) {
            value2 = replaceVars(value2, vars);
            if (!dom2.hasClass(elm, value2)) {
              dom2.addClass(elm, value2);
            }
          });
        }
      };
      var applyNodeStyle = function(formatList2, node2) {
        var found = false;
        if (!isSelectorFormat(format)) {
          return false;
        }
        each$c(formatList2, function(format2) {
          if ("collapsed" in format2 && format2.collapsed !== isCollapsed) {
            return;
          }
          if (dom2.is(node2, format2.selector) && !isCaretNode(node2)) {
            setElementFormat(node2, format2);
            found = true;
            return false;
          }
        });
        return found;
      };
      var applyRngStyle = function(dom3, rng2, bookmark, nodeSpecific) {
        var newWrappers = [];
        var contentEditable = true;
        var wrapName = format.inline || format.block;
        var wrapElm = dom3.create(wrapName);
        setElementFormat(wrapElm);
        walk$1(dom3, rng2, function(nodes) {
          var currentWrapElm;
          var process2 = function(node2) {
            var hasContentEditableState2 = false;
            var lastContentEditable = contentEditable;
            var nodeName = node2.nodeName.toLowerCase();
            var parentName = node2.parentNode.nodeName.toLowerCase();
            if (isElement$1(node2) && dom3.getContentEditable(node2)) {
              lastContentEditable = contentEditable;
              contentEditable = dom3.getContentEditable(node2) === "true";
              hasContentEditableState2 = true;
            }
            if (isBr(node2) && !canFormatBR(ed, format, node2, parentName)) {
              currentWrapElm = null;
              if (isBlockFormat(format)) {
                dom3.remove(node2);
              }
              return;
            }
            if (format.wrapper && matchNode(ed, node2, name2, vars)) {
              currentWrapElm = null;
              return;
            }
            if (contentEditable && !hasContentEditableState2 && isBlockFormat(format) && !format.wrapper && isTextBlock$1(ed, nodeName) && isValid(ed, parentName, wrapName)) {
              var elm = dom3.rename(node2, wrapName);
              setElementFormat(elm);
              newWrappers.push(elm);
              currentWrapElm = null;
              return;
            }
            if (isSelectorFormat(format)) {
              var found = applyNodeStyle(formatList, node2);
              if (isText$1(node2) && hasBlockChildren(dom3, node2.parentNode)) {
                applyNodeStyle(formatList, node2.parentNode);
              }
              if (!hasFormatProperty(format, "inline") || found) {
                currentWrapElm = null;
                return;
              }
            }
            if (contentEditable && !hasContentEditableState2 && isValid(ed, wrapName, nodeName) && isValid(ed, parentName, wrapName) && !(!nodeSpecific && node2.nodeType === 3 && node2.nodeValue.length === 1 && node2.nodeValue.charCodeAt(0) === 65279) && !isCaretNode(node2) && (!hasFormatProperty(format, "inline") || !dom3.isBlock(node2))) {
              if (!currentWrapElm) {
                currentWrapElm = dom3.clone(wrapElm, false);
                node2.parentNode.insertBefore(currentWrapElm, node2);
                newWrappers.push(currentWrapElm);
              }
              currentWrapElm.appendChild(node2);
            } else {
              currentWrapElm = null;
              each$c(Tools.grep(node2.childNodes), process2);
              if (hasContentEditableState2) {
                contentEditable = lastContentEditable;
              }
              currentWrapElm = null;
            }
          };
          each$c(nodes, process2);
        });
        if (format.links === true) {
          each$c(newWrappers, function(node2) {
            var process2 = function(node3) {
              if (node3.nodeName === "A") {
                setElementFormat(node3, format);
              }
              each$c(Tools.grep(node3.childNodes), process2);
            };
            process2(node2);
          });
        }
        each$c(newWrappers, function(node2) {
          var getChildCount = function(node3) {
            var count2 = 0;
            each$c(node3.childNodes, function(node4) {
              if (!isEmptyTextNode(node4) && !isBookmarkNode$1(node4)) {
                count2++;
              }
            });
            return count2;
          };
          var getChildElementNode = function(root) {
            var child2 = false;
            each$c(root.childNodes, function(node3) {
              if (isElementNode$1(node3)) {
                child2 = node3;
                return false;
              }
            });
            return child2;
          };
          var mergeStyles = function(node3) {
            var clone2;
            var child2 = getChildElementNode(node3);
            if (child2 && !isBookmarkNode$1(child2) && matchName(dom3, child2, format)) {
              clone2 = dom3.clone(child2, false);
              setElementFormat(clone2);
              dom3.replace(clone2, node3, true);
              dom3.remove(child2, true);
            }
            return clone2 || node3;
          };
          var childCount = getChildCount(node2);
          if ((newWrappers.length > 1 || !dom3.isBlock(node2)) && childCount === 0) {
            dom3.remove(node2, true);
            return;
          }
          if (isInlineFormat(format) || format.wrapper) {
            if (!format.exact && childCount === 1) {
              node2 = mergeStyles(node2);
            }
            mergeWithChildren(ed, formatList, vars, node2);
            mergeWithParents(ed, format, name2, vars, node2);
            mergeBackgroundColorAndFontSize(dom3, format, vars, node2);
            mergeTextDecorationsAndColor(dom3, format, vars, node2);
            mergeSubSup(dom3, format, vars, node2);
            mergeSiblings(dom3, format, vars, node2);
          }
        });
      };
      if (dom2.getContentEditable(selection.getNode()) === "false") {
        node = selection.getNode();
        for (var i = 0, l = formatList.length; i < l; i++) {
          var formatItem = formatList[i];
          if (formatItem.ceFalseOverride && isSelectorFormat(formatItem) && dom2.is(node, formatItem.selector)) {
            setElementFormat(node, formatItem);
            return;
          }
        }
        return;
      }
      if (format) {
        if (node) {
          if (isNode(node)) {
            if (!applyNodeStyle(formatList, node)) {
              var rng = dom2.createRng();
              rng.setStartBefore(node);
              rng.setEndAfter(node);
              applyRngStyle(dom2, expandRng(ed, rng, formatList), null, true);
            }
          } else {
            applyRngStyle(dom2, node, null, true);
          }
        } else {
          if (!isCollapsed || !isInlineFormat(format) || getCellsFromEditor(ed).length) {
            var curSelNode = selection.getNode();
            var firstFormat = formatList[0];
            if (!ed.settings.forced_root_block && firstFormat.defaultBlock && !dom2.getParent(curSelNode, dom2.isBlock)) {
              applyFormat(ed, firstFormat.defaultBlock);
            }
            selection.setRng(normalize$2(selection.getRng()));
            preserve(selection, true, function(bookmark) {
              runOnRanges(ed, function(selectionRng, fake) {
                var expandedRng = fake ? selectionRng : expandRng(ed, selectionRng, formatList);
                applyRngStyle(dom2, expandedRng);
              });
            });
            moveStart(dom2, selection, selection.getRng());
            ed.nodeChanged();
          } else {
            applyCaretFormat(ed, name2, vars);
          }
        }
        postProcess(name2, ed);
      }
    };
    var setup$4 = function(registeredFormatListeners, editor) {
      var currentFormats = Cell({});
      registeredFormatListeners.set({});
      editor.on("NodeChange", function(e) {
        updateAndFireChangeCallbacks(editor, e.element, currentFormats, registeredFormatListeners.get());
      });
    };
    var updateAndFireChangeCallbacks = function(editor, elm, currentFormats, formatChangeData) {
      var formatsList = keys(currentFormats.get());
      var newFormats = {};
      var matchedFormats = {};
      var parents2 = filter(getParents$1(editor.dom, elm), function(node) {
        return node.nodeType === 1 && !node.getAttribute("data-mce-bogus");
      });
      each$1(formatChangeData, function(data2, format) {
        Tools.each(parents2, function(node) {
          if (editor.formatter.matchNode(node, format, {}, data2.similar)) {
            if (formatsList.indexOf(format) === -1) {
              each(data2.callbacks, function(callback) {
                callback(true, {
                  node,
                  format,
                  parents: parents2
                });
              });
              newFormats[format] = data2.callbacks;
            }
            matchedFormats[format] = data2.callbacks;
            return false;
          }
          if (matchesUnInheritedFormatSelector(editor, node, format)) {
            return false;
          }
        });
      });
      var remainingFormats = filterRemainingFormats(currentFormats.get(), matchedFormats, elm, parents2);
      currentFormats.set(__assign2(__assign2({}, newFormats), remainingFormats));
    };
    var filterRemainingFormats = function(currentFormats, matchedFormats, elm, parents2) {
      return bifilter(currentFormats, function(callbacks, format) {
        if (!has(matchedFormats, format)) {
          each(callbacks, function(callback) {
            callback(false, {
              node: elm,
              format,
              parents: parents2
            });
          });
          return false;
        } else {
          return true;
        }
      }).t;
    };
    var addListeners = function(registeredFormatListeners, formats, callback, similar) {
      var formatChangeItems = registeredFormatListeners.get();
      each(formats.split(","), function(format) {
        if (!formatChangeItems[format]) {
          formatChangeItems[format] = {
            similar,
            callbacks: []
          };
        }
        formatChangeItems[format].callbacks.push(callback);
      });
      registeredFormatListeners.set(formatChangeItems);
    };
    var removeListeners = function(registeredFormatListeners, formats, callback) {
      var formatChangeItems = registeredFormatListeners.get();
      each(formats.split(","), function(format) {
        formatChangeItems[format].callbacks = filter(formatChangeItems[format].callbacks, function(c) {
          return c !== callback;
        });
        if (formatChangeItems[format].callbacks.length === 0) {
          delete formatChangeItems[format];
        }
      });
      registeredFormatListeners.set(formatChangeItems);
    };
    var formatChangedInternal = function(editor, registeredFormatListeners, formats, callback, similar) {
      if (registeredFormatListeners.get() === null) {
        setup$4(registeredFormatListeners, editor);
      }
      addListeners(registeredFormatListeners, formats, callback, similar);
      return {
        unbind: function() {
          return removeListeners(registeredFormatListeners, formats, callback);
        }
      };
    };
    var toggle = function(editor, name2, vars, node) {
      var fmt = editor.formatter.get(name2);
      if (match(editor, name2, vars, node) && (!("toggle" in fmt[0]) || fmt[0].toggle)) {
        remove$6(editor, name2, vars, node);
      } else {
        applyFormat(editor, name2, vars, node);
      }
    };
    var fromElements = function(elements, scope) {
      var doc2 = scope || document;
      var fragment = doc2.createDocumentFragment();
      each(elements, function(element) {
        fragment.appendChild(element.dom);
      });
      return SugarElement.fromDom(fragment);
    };
    var tableModel = function(element, width, rows) {
      return {
        element,
        width,
        rows
      };
    };
    var tableRow = function(element, cells) {
      return {
        element,
        cells
      };
    };
    var cellPosition = function(x, y) {
      return {
        x,
        y
      };
    };
    var getSpan = function(td, key) {
      var value2 = parseInt(get$4(td, key), 10);
      return isNaN(value2) ? 1 : value2;
    };
    var fillout = function(table, x, y, tr, td) {
      var rowspan = getSpan(td, "rowspan");
      var colspan = getSpan(td, "colspan");
      var rows = table.rows;
      for (var y2 = y; y2 < y + rowspan; y2++) {
        if (!rows[y2]) {
          rows[y2] = tableRow(deep(tr), []);
        }
        for (var x2 = x; x2 < x + colspan; x2++) {
          var cells = rows[y2].cells;
          cells[x2] = y2 === y && x2 === x ? td : shallow(td);
        }
      }
    };
    var cellExists = function(table, x, y) {
      var rows = table.rows;
      var cells = rows[y] ? rows[y].cells : [];
      return !!cells[x];
    };
    var skipCellsX = function(table, x, y) {
      while (cellExists(table, x, y)) {
        x++;
      }
      return x;
    };
    var getWidth = function(rows) {
      return foldl(rows, function(acc, row) {
        return row.cells.length > acc ? row.cells.length : acc;
      }, 0);
    };
    var findElementPos = function(table, element) {
      var rows = table.rows;
      for (var y = 0; y < rows.length; y++) {
        var cells = rows[y].cells;
        for (var x = 0; x < cells.length; x++) {
          if (eq$2(cells[x], element)) {
            return Optional.some(cellPosition(x, y));
          }
        }
      }
      return Optional.none();
    };
    var extractRows = function(table, sx, sy, ex, ey) {
      var newRows = [];
      var rows = table.rows;
      for (var y = sy; y <= ey; y++) {
        var cells = rows[y].cells;
        var slice2 = sx < ex ? cells.slice(sx, ex + 1) : cells.slice(ex, sx + 1);
        newRows.push(tableRow(rows[y].element, slice2));
      }
      return newRows;
    };
    var subTable = function(table, startPos, endPos) {
      var sx = startPos.x, sy = startPos.y;
      var ex = endPos.x, ey = endPos.y;
      var newRows = sy < ey ? extractRows(table, sx, sy, ex, ey) : extractRows(table, sx, ey, ex, sy);
      return tableModel(table.element, getWidth(newRows), newRows);
    };
    var createDomTable = function(table, rows) {
      var tableElement = shallow(table.element);
      var tableBody = SugarElement.fromTag("tbody");
      append$1(tableBody, rows);
      append(tableElement, tableBody);
      return tableElement;
    };
    var modelRowsToDomRows = function(table) {
      return map(table.rows, function(row) {
        var cells = map(row.cells, function(cell) {
          var td = deep(cell);
          remove$1(td, "colspan");
          remove$1(td, "rowspan");
          return td;
        });
        var tr = shallow(row.element);
        append$1(tr, cells);
        return tr;
      });
    };
    var fromDom$1 = function(tableElm) {
      var table = tableModel(shallow(tableElm), 0, []);
      each(descendants$1(tableElm, "tr"), function(tr, y) {
        each(descendants$1(tr, "td,th"), function(td, x) {
          fillout(table, skipCellsX(table, x, y), y, tr, td);
        });
      });
      return tableModel(table.element, getWidth(table.rows), table.rows);
    };
    var toDom = function(table) {
      return createDomTable(table, modelRowsToDomRows(table));
    };
    var subsection = function(table, startElement, endElement) {
      return findElementPos(table, startElement).bind(function(startPos) {
        return findElementPos(table, endElement).map(function(endPos) {
          return subTable(table, startPos, endPos);
        });
      });
    };
    var findParentListContainer = function(parents2) {
      return find(parents2, function(elm) {
        return name(elm) === "ul" || name(elm) === "ol";
      });
    };
    var getFullySelectedListWrappers = function(parents2, rng) {
      return find(parents2, function(elm) {
        return name(elm) === "li" && hasAllContentsSelected(elm, rng);
      }).fold(constant([]), function(_li) {
        return findParentListContainer(parents2).map(function(listCont) {
          var listElm = SugarElement.fromTag(name(listCont));
          var listStyles = filter$1(getAllRaw(listCont), function(_style, name2) {
            return startsWith(name2, "list-style");
          });
          setAll$1(listElm, listStyles);
          return [
            SugarElement.fromTag("li"),
            listElm
          ];
        }).getOr([]);
      });
    };
    var wrap$3 = function(innerElm, elms) {
      var wrapped = foldl(elms, function(acc, elm) {
        append(elm, acc);
        return elm;
      }, innerElm);
      return elms.length > 0 ? fromElements([wrapped]) : wrapped;
    };
    var directListWrappers = function(commonAnchorContainer) {
      if (isListItem(commonAnchorContainer)) {
        return parent(commonAnchorContainer).filter(isList).fold(constant([]), function(listElm) {
          return [
            commonAnchorContainer,
            listElm
          ];
        });
      } else {
        return isList(commonAnchorContainer) ? [commonAnchorContainer] : [];
      }
    };
    var getWrapElements = function(rootNode, rng) {
      var commonAnchorContainer = SugarElement.fromDom(rng.commonAncestorContainer);
      var parents2 = parentsAndSelf(commonAnchorContainer, rootNode);
      var wrapElements = filter(parents2, function(elm) {
        return isInline(elm) || isHeading(elm);
      });
      var listWrappers = getFullySelectedListWrappers(parents2, rng);
      var allWrappers = wrapElements.concat(listWrappers.length ? listWrappers : directListWrappers(commonAnchorContainer));
      return map(allWrappers, shallow);
    };
    var emptyFragment = function() {
      return fromElements([]);
    };
    var getFragmentFromRange = function(rootNode, rng) {
      return wrap$3(SugarElement.fromDom(rng.cloneContents()), getWrapElements(rootNode, rng));
    };
    var getParentTable = function(rootElm, cell) {
      return ancestor$1(cell, "table", curry(eq$2, rootElm));
    };
    var getTableFragment = function(rootNode, selectedTableCells) {
      return getParentTable(rootNode, selectedTableCells[0]).bind(function(tableElm) {
        var firstCell = selectedTableCells[0];
        var lastCell = selectedTableCells[selectedTableCells.length - 1];
        var fullTableModel = fromDom$1(tableElm);
        return subsection(fullTableModel, firstCell, lastCell).map(function(sectionedTableModel) {
          return fromElements([toDom(sectionedTableModel)]);
        });
      }).getOrThunk(emptyFragment);
    };
    var getSelectionFragment = function(rootNode, ranges) {
      return ranges.length > 0 && ranges[0].collapsed ? emptyFragment() : getFragmentFromRange(rootNode, ranges[0]);
    };
    var read$1 = function(rootNode, ranges) {
      var selectedCells = getCellsFromElementOrRanges(ranges, rootNode);
      return selectedCells.length > 0 ? getTableFragment(rootNode, selectedCells) : getSelectionFragment(rootNode, ranges);
    };
    var trimLeadingCollapsibleText = function(text) {
      return text.replace(/^[ \f\n\r\t\v]+/, "");
    };
    var isCollapsibleWhitespace = function(text, index) {
      return index >= 0 && index < text.length && isWhiteSpace$1(text.charAt(index));
    };
    var getInnerText = function(bin, shouldTrim) {
      var text = trim$2(bin.innerText);
      return shouldTrim ? trimLeadingCollapsibleText(text) : text;
    };
    var getContextNodeName = function(parentBlockOpt) {
      return parentBlockOpt.map(function(block) {
        return block.nodeName;
      }).getOr("div").toLowerCase();
    };
    var getTextContent = function(editor) {
      return Optional.from(editor.selection.getRng()).map(function(rng) {
        var parentBlockOpt = Optional.from(editor.dom.getParent(rng.commonAncestorContainer, editor.dom.isBlock));
        var body = editor.getBody();
        var contextNodeName = getContextNodeName(parentBlockOpt);
        var shouldTrimSpaces = Env.browser.isIE() && contextNodeName !== "pre";
        var bin = editor.dom.add(body, contextNodeName, {
          "data-mce-bogus": "all",
          "style": "overflow: hidden; opacity: 0;"
        }, rng.cloneContents());
        var text = getInnerText(bin, shouldTrimSpaces);
        var nonRenderedText = trim$2(bin.textContent);
        editor.dom.remove(bin);
        if (isCollapsibleWhitespace(nonRenderedText, 0) || isCollapsibleWhitespace(nonRenderedText, nonRenderedText.length - 1)) {
          var parentBlock = parentBlockOpt.getOr(body);
          var parentBlockText = getInnerText(parentBlock, shouldTrimSpaces);
          var textIndex = parentBlockText.indexOf(text);
          if (textIndex === -1) {
            return text;
          } else {
            var hasProceedingSpace = isCollapsibleWhitespace(parentBlockText, textIndex - 1);
            var hasTrailingSpace = isCollapsibleWhitespace(parentBlockText, textIndex + text.length);
            return (hasProceedingSpace ? " " : "") + text + (hasTrailingSpace ? " " : "");
          }
        } else {
          return text;
        }
      }).getOr("");
    };
    var getSerializedContent = function(editor, args) {
      var rng = editor.selection.getRng(), tmpElm = editor.dom.create("body");
      var sel = editor.selection.getSel();
      var ranges = processRanges(editor, getRanges(sel));
      var fragment = args.contextual ? read$1(SugarElement.fromDom(editor.getBody()), ranges).dom : rng.cloneContents();
      if (fragment) {
        tmpElm.appendChild(fragment);
      }
      return editor.selection.serializer.serialize(tmpElm, args);
    };
    var getSelectedContentInternal = function(editor, format, args) {
      if (args === void 0) {
        args = {};
      }
      args.get = true;
      args.format = format;
      args.selection = true;
      args = editor.fire("BeforeGetContent", args);
      if (args.isDefaultPrevented()) {
        editor.fire("GetContent", args);
        return args.content;
      }
      if (args.format === "text") {
        return getTextContent(editor);
      } else {
        args.getInner = true;
        var content = getSerializedContent(editor, args);
        if (args.format === "tree") {
          return content;
        } else {
          args.content = editor.selection.isCollapsed() ? "" : content;
          editor.fire("GetContent", args);
          return args.content;
        }
      }
    };
    var KEEP = 0, INSERT = 1, DELETE = 2;
    var diff = function(left, right) {
      var size = left.length + right.length + 2;
      var vDown = new Array(size);
      var vUp = new Array(size);
      var snake = function(start2, end2, diag) {
        return {
          start: start2,
          end: end2,
          diag
        };
      };
      var buildScript = function(start1, end1, start2, end2, script2) {
        var middle = getMiddleSnake(start1, end1, start2, end2);
        if (middle === null || middle.start === end1 && middle.diag === end1 - end2 || middle.end === start1 && middle.diag === start1 - start2) {
          var i = start1;
          var j = start2;
          while (i < end1 || j < end2) {
            if (i < end1 && j < end2 && left[i] === right[j]) {
              script2.push([
                KEEP,
                left[i]
              ]);
              ++i;
              ++j;
            } else {
              if (end1 - start1 > end2 - start2) {
                script2.push([
                  DELETE,
                  left[i]
                ]);
                ++i;
              } else {
                script2.push([
                  INSERT,
                  right[j]
                ]);
                ++j;
              }
            }
          }
        } else {
          buildScript(start1, middle.start, start2, middle.start - middle.diag, script2);
          for (var i2 = middle.start; i2 < middle.end; ++i2) {
            script2.push([
              KEEP,
              left[i2]
            ]);
          }
          buildScript(middle.end, end1, middle.end - middle.diag, end2, script2);
        }
      };
      var buildSnake = function(start2, diag, end1, end2) {
        var end3 = start2;
        while (end3 - diag < end2 && end3 < end1 && left[end3] === right[end3 - diag]) {
          ++end3;
        }
        return snake(start2, end3, diag);
      };
      var getMiddleSnake = function(start1, end1, start2, end2) {
        var m = end1 - start1;
        var n = end2 - start2;
        if (m === 0 || n === 0) {
          return null;
        }
        var delta = m - n;
        var sum = n + m;
        var offset = (sum % 2 === 0 ? sum : sum + 1) / 2;
        vDown[1 + offset] = start1;
        vUp[1 + offset] = end1 + 1;
        var d, k, i, x, y;
        for (d = 0; d <= offset; ++d) {
          for (k = -d; k <= d; k += 2) {
            i = k + offset;
            if (k === -d || k !== d && vDown[i - 1] < vDown[i + 1]) {
              vDown[i] = vDown[i + 1];
            } else {
              vDown[i] = vDown[i - 1] + 1;
            }
            x = vDown[i];
            y = x - start1 + start2 - k;
            while (x < end1 && y < end2 && left[x] === right[y]) {
              vDown[i] = ++x;
              ++y;
            }
            if (delta % 2 !== 0 && delta - d <= k && k <= delta + d) {
              if (vUp[i - delta] <= vDown[i]) {
                return buildSnake(vUp[i - delta], k + start1 - start2, end1, end2);
              }
            }
          }
          for (k = delta - d; k <= delta + d; k += 2) {
            i = k + offset - delta;
            if (k === delta - d || k !== delta + d && vUp[i + 1] <= vUp[i - 1]) {
              vUp[i] = vUp[i + 1] - 1;
            } else {
              vUp[i] = vUp[i - 1];
            }
            x = vUp[i] - 1;
            y = x - start1 + start2 - k;
            while (x >= start1 && y >= start2 && left[x] === right[y]) {
              vUp[i] = x--;
              y--;
            }
            if (delta % 2 === 0 && -d <= k && k <= d) {
              if (vUp[i] <= vDown[i + delta]) {
                return buildSnake(vUp[i], k + start1 - start2, end1, end2);
              }
            }
          }
        }
      };
      var script = [];
      buildScript(0, left.length, 0, right.length, script);
      return script;
    };
    var getOuterHtml = function(elm) {
      if (isElement$1(elm)) {
        return elm.outerHTML;
      } else if (isText$1(elm)) {
        return Entities.encodeRaw(elm.data, false);
      } else if (isComment$1(elm)) {
        return "<!--" + elm.data + "-->";
      }
      return "";
    };
    var createFragment$1 = function(html) {
      var node;
      var container = document.createElement("div");
      var frag = document.createDocumentFragment();
      if (html) {
        container.innerHTML = html;
      }
      while (node = container.firstChild) {
        frag.appendChild(node);
      }
      return frag;
    };
    var insertAt = function(elm, html, index) {
      var fragment = createFragment$1(html);
      if (elm.hasChildNodes() && index < elm.childNodes.length) {
        var target = elm.childNodes[index];
        target.parentNode.insertBefore(fragment, target);
      } else {
        elm.appendChild(fragment);
      }
    };
    var removeAt = function(elm, index) {
      if (elm.hasChildNodes() && index < elm.childNodes.length) {
        var target = elm.childNodes[index];
        target.parentNode.removeChild(target);
      }
    };
    var applyDiff = function(diff2, elm) {
      var index = 0;
      each(diff2, function(action2) {
        if (action2[0] === KEEP) {
          index++;
        } else if (action2[0] === INSERT) {
          insertAt(elm, action2[1], index);
          index++;
        } else if (action2[0] === DELETE) {
          removeAt(elm, index);
        }
      });
    };
    var read$2 = function(elm) {
      return filter(map(from$1(elm.childNodes), getOuterHtml), function(item) {
        return item.length > 0;
      });
    };
    var write = function(fragments, elm) {
      var currentFragments = map(from$1(elm.childNodes), getOuterHtml);
      applyDiff(diff(currentFragments, fragments), elm);
      return elm;
    };
    var undoLevelDocument = Cell(Optional.none());
    var lazyTempDocument = function() {
      return undoLevelDocument.get().getOrThunk(function() {
        var doc2 = document.implementation.createHTMLDocument("undo");
        undoLevelDocument.set(Optional.some(doc2));
        return doc2;
      });
    };
    var hasIframes = function(html) {
      return html.indexOf("</iframe>") !== -1;
    };
    var createFragmentedLevel = function(fragments) {
      return {
        type: "fragmented",
        fragments,
        content: "",
        bookmark: null,
        beforeBookmark: null
      };
    };
    var createCompleteLevel = function(content) {
      return {
        type: "complete",
        fragments: null,
        content,
        bookmark: null,
        beforeBookmark: null
      };
    };
    var createFromEditor = function(editor) {
      var fragments = read$2(editor.getBody());
      var trimmedFragments = bind(fragments, function(html) {
        var trimmed = trimInternal(editor.serializer, html);
        return trimmed.length > 0 ? [trimmed] : [];
      });
      var content = trimmedFragments.join("");
      return hasIframes(content) ? createFragmentedLevel(trimmedFragments) : createCompleteLevel(content);
    };
    var applyToEditor = function(editor, level, before2) {
      if (level.type === "fragmented") {
        write(level.fragments, editor.getBody());
      } else {
        editor.setContent(level.content, { format: "raw" });
      }
      editor.selection.moveToBookmark(before2 ? level.beforeBookmark : level.bookmark);
    };
    var getLevelContent = function(level) {
      return level.type === "fragmented" ? level.fragments.join("") : level.content;
    };
    var getCleanLevelContent = function(level) {
      var elm = SugarElement.fromTag("body", lazyTempDocument());
      set$1(elm, getLevelContent(level));
      each(descendants$1(elm, "*[data-mce-bogus]"), unwrap);
      return get$7(elm);
    };
    var hasEqualContent = function(level1, level2) {
      return getLevelContent(level1) === getLevelContent(level2);
    };
    var hasEqualCleanedContent = function(level1, level2) {
      return getCleanLevelContent(level1) === getCleanLevelContent(level2);
    };
    var isEq$4 = function(level1, level2) {
      if (!level1 || !level2) {
        return false;
      } else if (hasEqualContent(level1, level2)) {
        return true;
      } else {
        return hasEqualCleanedContent(level1, level2);
      }
    };
    var isUnlocked = function(locks) {
      return locks.get() === 0;
    };
    var setTyping = function(undoManager, typing, locks) {
      if (isUnlocked(locks)) {
        undoManager.typing = typing;
      }
    };
    var endTyping = function(undoManager, locks) {
      if (undoManager.typing) {
        setTyping(undoManager, false, locks);
        undoManager.add();
      }
    };
    var endTypingLevelIgnoreLocks = function(undoManager) {
      if (undoManager.typing) {
        undoManager.typing = false;
        undoManager.add();
      }
    };
    var beforeChange = function(editor, locks, beforeBookmark) {
      if (isUnlocked(locks)) {
        beforeBookmark.set(Optional.some(getUndoBookmark(editor.selection)));
      }
    };
    var addUndoLevel = function(editor, undoManager, index, locks, beforeBookmark, level, event) {
      var currentLevel = createFromEditor(editor);
      level = level || {};
      level = Tools.extend(level, currentLevel);
      if (isUnlocked(locks) === false || editor.removed) {
        return null;
      }
      var lastLevel = undoManager.data[index.get()];
      if (editor.fire("BeforeAddUndo", {
        level,
        lastLevel,
        originalEvent: event
      }).isDefaultPrevented()) {
        return null;
      }
      if (lastLevel && isEq$4(lastLevel, level)) {
        return null;
      }
      if (undoManager.data[index.get()]) {
        beforeBookmark.get().each(function(bm) {
          undoManager.data[index.get()].beforeBookmark = bm;
        });
      }
      var customUndoRedoLevels = getCustomUndoRedoLevels(editor);
      if (customUndoRedoLevels) {
        if (undoManager.data.length > customUndoRedoLevels) {
          for (var i = 0; i < undoManager.data.length - 1; i++) {
            undoManager.data[i] = undoManager.data[i + 1];
          }
          undoManager.data.length--;
          index.set(undoManager.data.length);
        }
      }
      level.bookmark = getUndoBookmark(editor.selection);
      if (index.get() < undoManager.data.length - 1) {
        undoManager.data.length = index.get() + 1;
      }
      undoManager.data.push(level);
      index.set(undoManager.data.length - 1);
      var args = {
        level,
        lastLevel,
        originalEvent: event
      };
      if (index.get() > 0) {
        editor.setDirty(true);
        editor.fire("AddUndo", args);
        editor.fire("change", args);
      } else {
        editor.fire("AddUndo", args);
      }
      return level;
    };
    var clear = function(editor, undoManager, index) {
      undoManager.data = [];
      index.set(0);
      undoManager.typing = false;
      editor.fire("ClearUndos");
    };
    var extra = function(editor, undoManager, index, callback1, callback2) {
      if (undoManager.transact(callback1)) {
        var bookmark = undoManager.data[index.get()].bookmark;
        var lastLevel = undoManager.data[index.get() - 1];
        applyToEditor(editor, lastLevel, true);
        if (undoManager.transact(callback2)) {
          undoManager.data[index.get() - 1].beforeBookmark = bookmark;
        }
      }
    };
    var redo = function(editor, index, data2) {
      var level;
      if (index.get() < data2.length - 1) {
        index.set(index.get() + 1);
        level = data2[index.get()];
        applyToEditor(editor, level, false);
        editor.setDirty(true);
        editor.fire("Redo", { level });
      }
      return level;
    };
    var undo = function(editor, undoManager, locks, index) {
      var level;
      if (undoManager.typing) {
        undoManager.add();
        undoManager.typing = false;
        setTyping(undoManager, false, locks);
      }
      if (index.get() > 0) {
        index.set(index.get() - 1);
        level = undoManager.data[index.get()];
        applyToEditor(editor, level, true);
        editor.setDirty(true);
        editor.fire("Undo", { level });
      }
      return level;
    };
    var reset = function(undoManager) {
      undoManager.clear();
      undoManager.add();
    };
    var hasUndo = function(editor, undoManager, index) {
      return index.get() > 0 || undoManager.typing && undoManager.data[0] && !isEq$4(createFromEditor(editor), undoManager.data[0]);
    };
    var hasRedo = function(undoManager, index) {
      return index.get() < undoManager.data.length - 1 && !undoManager.typing;
    };
    var transact = function(undoManager, locks, callback) {
      endTyping(undoManager, locks);
      undoManager.beforeChange();
      undoManager.ignore(callback);
      return undoManager.add();
    };
    var ignore = function(locks, callback) {
      try {
        locks.set(locks.get() + 1);
        callback();
      } finally {
        locks.set(locks.get() - 1);
      }
    };
    var addVisualInternal = function(editor, elm) {
      var dom2 = editor.dom;
      var scope = isNonNullable(elm) ? elm : editor.getBody();
      if (isUndefined(editor.hasVisual)) {
        editor.hasVisual = isVisualAidsEnabled(editor);
      }
      each(dom2.select("table,a", scope), function(matchedElm) {
        switch (matchedElm.nodeName) {
          case "TABLE":
            var cls = getVisualAidsTableClass(editor);
            var value2 = dom2.getAttrib(matchedElm, "border");
            if ((!value2 || value2 === "0") && editor.hasVisual) {
              dom2.addClass(matchedElm, cls);
            } else {
              dom2.removeClass(matchedElm, cls);
            }
            break;
          case "A":
            if (!dom2.getAttrib(matchedElm, "href")) {
              var value_1 = dom2.getAttrib(matchedElm, "name") || matchedElm.id;
              var cls_1 = getVisualAidsAnchorClass(editor);
              if (value_1 && editor.hasVisual) {
                dom2.addClass(matchedElm, cls_1);
              } else {
                dom2.removeClass(matchedElm, cls_1);
              }
            }
            break;
        }
      });
      editor.fire("VisualAid", {
        element: elm,
        hasVisual: editor.hasVisual
      });
    };
    var makePlainAdaptor = function(editor) {
      return {
        undoManager: {
          beforeChange: function(locks, beforeBookmark) {
            return beforeChange(editor, locks, beforeBookmark);
          },
          addUndoLevel: function(undoManager, index, locks, beforeBookmark, level, event) {
            return addUndoLevel(editor, undoManager, index, locks, beforeBookmark, level, event);
          },
          undo: function(undoManager, locks, index) {
            return undo(editor, undoManager, locks, index);
          },
          redo: function(index, data2) {
            return redo(editor, index, data2);
          },
          clear: function(undoManager, index) {
            return clear(editor, undoManager, index);
          },
          reset: function(undoManager) {
            return reset(undoManager);
          },
          hasUndo: function(undoManager, index) {
            return hasUndo(editor, undoManager, index);
          },
          hasRedo: function(undoManager, index) {
            return hasRedo(undoManager, index);
          },
          transact: function(undoManager, locks, callback) {
            return transact(undoManager, locks, callback);
          },
          ignore: function(locks, callback) {
            return ignore(locks, callback);
          },
          extra: function(undoManager, index, callback1, callback2) {
            return extra(editor, undoManager, index, callback1, callback2);
          }
        },
        formatter: {
          match: function(name2, vars, node) {
            return match(editor, name2, vars, node);
          },
          matchAll: function(names, vars) {
            return matchAll(editor, names, vars);
          },
          matchNode: function(node, name2, vars, similar) {
            return matchNode(editor, node, name2, vars, similar);
          },
          canApply: function(name2) {
            return canApply(editor, name2);
          },
          closest: function(names) {
            return closest$3(editor, names);
          },
          apply: function(name2, vars, node) {
            return applyFormat(editor, name2, vars, node);
          },
          remove: function(name2, vars, node, similar) {
            return remove$6(editor, name2, vars, node, similar);
          },
          toggle: function(name2, vars, node) {
            return toggle(editor, name2, vars, node);
          },
          formatChanged: function(registeredFormatListeners, formats, callback, similar) {
            return formatChangedInternal(editor, registeredFormatListeners, formats, callback, similar);
          }
        },
        editor: {
          getContent: function(args, format) {
            return getContentInternal(editor, args, format);
          },
          setContent: function(content, args) {
            return setContentInternal(editor, content, args);
          },
          insertContent: function(value2, details) {
            return insertHtmlAtCaret(editor, value2, details);
          },
          addVisual: function(elm) {
            return addVisualInternal(editor, elm);
          }
        },
        selection: {
          getContent: function(format, args) {
            return getSelectedContentInternal(editor, format, args);
          }
        },
        raw: {
          getModel: function() {
            return Optional.none();
          }
        }
      };
    };
    var makeRtcAdaptor = function(rtcEditor) {
      var defaultVars = function(vars) {
        return isObject(vars) ? vars : {};
      };
      var unsupported = die("Unimplemented feature for rtc");
      var undoManager = rtcEditor.undoManager, formatter = rtcEditor.formatter, editor = rtcEditor.editor, selection = rtcEditor.selection, raw = rtcEditor.raw;
      var ignore2 = noop;
      return {
        undoManager: {
          beforeChange: ignore2,
          addUndoLevel: unsupported,
          undo: function() {
            return undoManager.undo();
          },
          redo: function() {
            return undoManager.redo();
          },
          clear: function() {
            return undoManager.clear();
          },
          reset: function() {
            return undoManager.reset();
          },
          hasUndo: function() {
            return undoManager.hasUndo();
          },
          hasRedo: function() {
            return undoManager.hasRedo();
          },
          transact: function(_undoManager, _locks, fn) {
            return undoManager.transact(fn);
          },
          ignore: function(_locks, callback) {
            return undoManager.ignore(callback);
          },
          extra: function(_undoManager, _index, callback1, callback2) {
            return undoManager.extra(callback1, callback2);
          }
        },
        formatter: {
          match: function(name2, vars, _node) {
            return formatter.match(name2, defaultVars(vars));
          },
          matchAll: unsupported,
          matchNode: unsupported,
          canApply: function(name2) {
            return formatter.canApply(name2);
          },
          closest: function(names) {
            return formatter.closest(names);
          },
          apply: function(name2, vars, _node) {
            return formatter.apply(name2, defaultVars(vars));
          },
          remove: function(name2, vars, _node, _similar) {
            return formatter.remove(name2, defaultVars(vars));
          },
          toggle: function(name2, vars, _node) {
            return formatter.toggle(name2, defaultVars(vars));
          },
          formatChanged: function(_rfl, formats, callback, similar) {
            return formatter.formatChanged(formats, callback, similar);
          }
        },
        editor: {
          getContent: function(args, _format) {
            return editor.getContent(args);
          },
          setContent: function(content, args) {
            return editor.setContent(content, args);
          },
          insertContent: function(content, _details) {
            return editor.insertContent(content);
          },
          addVisual: ignore2
        },
        selection: {
          getContent: function(_format, args) {
            return selection.getContent(args);
          }
        },
        raw: {
          getModel: function() {
            return Optional.some(raw.getRawModel());
          }
        }
      };
    };
    var makeNoopAdaptor = function() {
      var nul = constant(null);
      var empty2 = constant("");
      return {
        undoManager: {
          beforeChange: noop,
          addUndoLevel: nul,
          undo: nul,
          redo: nul,
          clear: noop,
          reset: noop,
          hasUndo: never,
          hasRedo: never,
          transact: nul,
          ignore: noop,
          extra: noop
        },
        formatter: {
          match: never,
          matchAll: constant([]),
          matchNode: never,
          canApply: never,
          closest: empty2,
          apply: noop,
          remove: noop,
          toggle: noop,
          formatChanged: constant({ unbind: noop })
        },
        editor: {
          getContent: empty2,
          setContent: empty2,
          insertContent: noop,
          addVisual: noop
        },
        selection: { getContent: empty2 },
        raw: { getModel: constant(Optional.none()) }
      };
    };
    var isRtc = function(editor) {
      return has(editor.plugins, "rtc");
    };
    var getRtcSetup = function(editor) {
      return get$1(editor.plugins, "rtc").bind(function(rtcPlugin) {
        return Optional.from(rtcPlugin.setup);
      });
    };
    var setup$5 = function(editor) {
      var editorCast = editor;
      return getRtcSetup(editor).fold(function() {
        editorCast.rtcInstance = makePlainAdaptor(editor);
        return Optional.none();
      }, function(setup2) {
        return Optional.some(setup2().then(function(rtcEditor) {
          editorCast.rtcInstance = makeRtcAdaptor(rtcEditor);
          return rtcEditor.rtc.isRemote;
        }, function(err) {
          editorCast.rtcInstance = makeNoopAdaptor();
          return promiseObj.reject(err);
        }));
      });
    };
    var getRtcInstanceWithFallback = function(editor) {
      return editor.rtcInstance ? editor.rtcInstance : makePlainAdaptor(editor);
    };
    var getRtcInstanceWithError = function(editor) {
      var rtcInstance = editor.rtcInstance;
      if (!rtcInstance) {
        throw new Error("Failed to get RTC instance not yet initialized.");
      } else {
        return rtcInstance;
      }
    };
    var beforeChange$1 = function(editor, locks, beforeBookmark) {
      getRtcInstanceWithError(editor).undoManager.beforeChange(locks, beforeBookmark);
    };
    var addUndoLevel$1 = function(editor, undoManager, index, locks, beforeBookmark, level, event) {
      return getRtcInstanceWithError(editor).undoManager.addUndoLevel(undoManager, index, locks, beforeBookmark, level, event);
    };
    var undo$1 = function(editor, undoManager, locks, index) {
      return getRtcInstanceWithError(editor).undoManager.undo(undoManager, locks, index);
    };
    var redo$1 = function(editor, index, data2) {
      return getRtcInstanceWithError(editor).undoManager.redo(index, data2);
    };
    var clear$1 = function(editor, undoManager, index) {
      getRtcInstanceWithError(editor).undoManager.clear(undoManager, index);
    };
    var reset$1 = function(editor, undoManager) {
      getRtcInstanceWithError(editor).undoManager.reset(undoManager);
    };
    var hasUndo$1 = function(editor, undoManager, index) {
      return getRtcInstanceWithError(editor).undoManager.hasUndo(undoManager, index);
    };
    var hasRedo$1 = function(editor, undoManager, index) {
      return getRtcInstanceWithError(editor).undoManager.hasRedo(undoManager, index);
    };
    var transact$1 = function(editor, undoManager, locks, callback) {
      return getRtcInstanceWithError(editor).undoManager.transact(undoManager, locks, callback);
    };
    var ignore$1 = function(editor, locks, callback) {
      getRtcInstanceWithError(editor).undoManager.ignore(locks, callback);
    };
    var extra$1 = function(editor, undoManager, index, callback1, callback2) {
      getRtcInstanceWithError(editor).undoManager.extra(undoManager, index, callback1, callback2);
    };
    var matchFormat = function(editor, name2, vars, node) {
      return getRtcInstanceWithError(editor).formatter.match(name2, vars, node);
    };
    var matchAllFormats = function(editor, names, vars) {
      return getRtcInstanceWithError(editor).formatter.matchAll(names, vars);
    };
    var matchNodeFormat = function(editor, node, name2, vars, similar) {
      return getRtcInstanceWithError(editor).formatter.matchNode(node, name2, vars, similar);
    };
    var canApplyFormat = function(editor, name2) {
      return getRtcInstanceWithError(editor).formatter.canApply(name2);
    };
    var closestFormat = function(editor, names) {
      return getRtcInstanceWithError(editor).formatter.closest(names);
    };
    var applyFormat$1 = function(editor, name2, vars, node) {
      getRtcInstanceWithError(editor).formatter.apply(name2, vars, node);
    };
    var removeFormat$1 = function(editor, name2, vars, node, similar) {
      getRtcInstanceWithError(editor).formatter.remove(name2, vars, node, similar);
    };
    var toggleFormat = function(editor, name2, vars, node) {
      getRtcInstanceWithError(editor).formatter.toggle(name2, vars, node);
    };
    var formatChanged = function(editor, registeredFormatListeners, formats, callback, similar) {
      if (similar === void 0) {
        similar = false;
      }
      return getRtcInstanceWithError(editor).formatter.formatChanged(registeredFormatListeners, formats, callback, similar);
    };
    var getContent = function(editor, args, format) {
      return getRtcInstanceWithFallback(editor).editor.getContent(args, format);
    };
    var setContent = function(editor, content, args) {
      return getRtcInstanceWithFallback(editor).editor.setContent(content, args);
    };
    var insertContent = function(editor, value2, details) {
      return getRtcInstanceWithFallback(editor).editor.insertContent(value2, details);
    };
    var getSelectedContent = function(editor, format, args) {
      return getRtcInstanceWithError(editor).selection.getContent(format, args);
    };
    var addVisual = function(editor, elm) {
      return getRtcInstanceWithError(editor).editor.addVisual(elm);
    };
    var getContent$1 = function(editor, args) {
      if (args === void 0) {
        args = {};
      }
      var format = args.format ? args.format : "html";
      return getSelectedContent(editor, format, args);
    };
    var removeEmpty = function(text) {
      if (text.dom.length === 0) {
        remove(text);
        return Optional.none();
      } else {
        return Optional.some(text);
      }
    };
    var walkPastBookmark = function(node, start2) {
      return node.filter(function(elm) {
        return BookmarkManager.isBookmarkNode(elm.dom);
      }).bind(start2 ? nextSibling : prevSibling);
    };
    var merge = function(outer, inner, rng, start2) {
      var outerElm = outer.dom;
      var innerElm = inner.dom;
      var oldLength = start2 ? outerElm.length : innerElm.length;
      if (start2) {
        mergeTextNodes(outerElm, innerElm, false, !start2);
        rng.setStart(innerElm, oldLength);
      } else {
        mergeTextNodes(innerElm, outerElm, false, !start2);
        rng.setEnd(innerElm, oldLength);
      }
    };
    var normalizeTextIfRequired = function(inner, start2) {
      parent(inner).each(function(root) {
        var text = inner.dom;
        if (start2 && needsToBeNbspLeft(root, CaretPosition(text, 0))) {
          normalizeWhitespaceAfter(text, 0);
        } else if (!start2 && needsToBeNbspRight(root, CaretPosition(text, text.length))) {
          normalizeWhitespaceBefore(text, text.length);
        }
      });
    };
    var mergeAndNormalizeText = function(outerNode, innerNode, rng, start2) {
      outerNode.bind(function(outer) {
        var normalizer = start2 ? normalizeWhitespaceBefore : normalizeWhitespaceAfter;
        normalizer(outer.dom, start2 ? outer.dom.length : 0);
        return innerNode.filter(isText).map(function(inner) {
          return merge(outer, inner, rng, start2);
        });
      }).orThunk(function() {
        var innerTextNode = walkPastBookmark(innerNode, start2).or(innerNode).filter(isText);
        return innerTextNode.map(function(inner) {
          return normalizeTextIfRequired(inner, start2);
        });
      });
    };
    var rngSetContent = function(rng, fragment) {
      var firstChild2 = Optional.from(fragment.firstChild).map(SugarElement.fromDom);
      var lastChild2 = Optional.from(fragment.lastChild).map(SugarElement.fromDom);
      rng.deleteContents();
      rng.insertNode(fragment);
      var prevText = firstChild2.bind(prevSibling).filter(isText).bind(removeEmpty);
      var nextText = lastChild2.bind(nextSibling).filter(isText).bind(removeEmpty);
      mergeAndNormalizeText(prevText, firstChild2, rng, true);
      mergeAndNormalizeText(nextText, lastChild2, rng, false);
      rng.collapse(false);
    };
    var setupArgs = function(args, content) {
      return __assign2(__assign2({ format: "html" }, args), {
        set: true,
        selection: true,
        content
      });
    };
    var cleanContent = function(editor, args) {
      if (args.format !== "raw") {
        var rng = editor.selection.getRng();
        var contextBlock = editor.dom.getParent(rng.commonAncestorContainer, editor.dom.isBlock);
        var contextArgs = contextBlock ? { context: contextBlock.nodeName.toLowerCase() } : {};
        var node = editor.parser.parse(args.content, __assign2(__assign2({
          isRootContent: true,
          forced_root_block: false
        }, contextArgs), args));
        return HtmlSerializer({ validate: editor.validate }, editor.schema).serialize(node);
      } else {
        return args.content;
      }
    };
    var setContent$1 = function(editor, content, args) {
      if (args === void 0) {
        args = {};
      }
      var contentArgs = setupArgs(args, content);
      if (!contentArgs.no_events) {
        contentArgs = editor.fire("BeforeSetContent", contentArgs);
        if (contentArgs.isDefaultPrevented()) {
          editor.fire("SetContent", contentArgs);
          return;
        }
      }
      args.content = cleanContent(editor, contentArgs);
      var rng = editor.selection.getRng();
      rngSetContent(rng, rng.createContextualFragment(args.content));
      editor.selection.setRng(rng);
      scrollRangeIntoView(editor, rng);
      if (!contentArgs.no_events) {
        editor.fire("SetContent", contentArgs);
      }
    };
    var deleteFromCallbackMap = function(callbackMap, selector, callback) {
      if (callbackMap && callbackMap.hasOwnProperty(selector)) {
        var newCallbacks = filter(callbackMap[selector], function(cb) {
          return cb !== callback;
        });
        if (newCallbacks.length === 0) {
          delete callbackMap[selector];
        } else {
          callbackMap[selector] = newCallbacks;
        }
      }
    };
    function SelectorChanged(dom2, editor) {
      var selectorChangedData;
      var currentSelectors;
      return {
        selectorChangedWithUnbind: function(selector, callback) {
          if (!selectorChangedData) {
            selectorChangedData = {};
            currentSelectors = {};
            editor.on("NodeChange", function(e) {
              var node = e.element, parents2 = dom2.getParents(node, null, dom2.getRoot()), matchedSelectors = {};
              Tools.each(selectorChangedData, function(callbacks, selector2) {
                Tools.each(parents2, function(node2) {
                  if (dom2.is(node2, selector2)) {
                    if (!currentSelectors[selector2]) {
                      Tools.each(callbacks, function(callback2) {
                        callback2(true, {
                          node: node2,
                          selector: selector2,
                          parents: parents2
                        });
                      });
                      currentSelectors[selector2] = callbacks;
                    }
                    matchedSelectors[selector2] = callbacks;
                    return false;
                  }
                });
              });
              Tools.each(currentSelectors, function(callbacks, selector2) {
                if (!matchedSelectors[selector2]) {
                  delete currentSelectors[selector2];
                  Tools.each(callbacks, function(callback2) {
                    callback2(false, {
                      node,
                      selector: selector2,
                      parents: parents2
                    });
                  });
                }
              });
            });
          }
          if (!selectorChangedData[selector]) {
            selectorChangedData[selector] = [];
          }
          selectorChangedData[selector].push(callback);
          return {
            unbind: function() {
              deleteFromCallbackMap(selectorChangedData, selector, callback);
              deleteFromCallbackMap(currentSelectors, selector, callback);
            }
          };
        }
      };
    }
    var isNativeIeSelection = function(rng) {
      return !!rng.select;
    };
    var isAttachedToDom = function(node) {
      return !!(node && node.ownerDocument) && contains$2(SugarElement.fromDom(node.ownerDocument), SugarElement.fromDom(node));
    };
    var isValidRange = function(rng) {
      if (!rng) {
        return false;
      } else if (isNativeIeSelection(rng)) {
        return true;
      } else {
        return isAttachedToDom(rng.startContainer) && isAttachedToDom(rng.endContainer);
      }
    };
    var EditorSelection = function(dom2, win, serializer, editor) {
      var selectedRange;
      var explicitRange;
      var selectorChangedWithUnbind = SelectorChanged(dom2, editor).selectorChangedWithUnbind;
      var setCursorLocation = function(node, offset) {
        var rng = dom2.createRng();
        if (isNonNullable(node) && isNonNullable(offset)) {
          rng.setStart(node, offset);
          rng.setEnd(node, offset);
          setRng(rng);
          collapse2(false);
        } else {
          moveEndPoint$1(dom2, rng, editor.getBody(), true);
          setRng(rng);
        }
      };
      var getContent2 = function(args) {
        return getContent$1(editor, args);
      };
      var setContent2 = function(content, args) {
        return setContent$1(editor, content, args);
      };
      var getStart2 = function(real) {
        return getStart$2(editor.getBody(), getRng$1(), real);
      };
      var getEnd$1 = function(real) {
        return getEnd(editor.getBody(), getRng$1(), real);
      };
      var getBookmark2 = function(type2, normalized) {
        return bookmarkManager.getBookmark(type2, normalized);
      };
      var moveToBookmark2 = function(bookmark) {
        return bookmarkManager.moveToBookmark(bookmark);
      };
      var select2 = function(node, content) {
        select$1(dom2, node, content).each(setRng);
        return node;
      };
      var isCollapsed = function() {
        var rng = getRng$1(), sel = getSel();
        if (!rng || rng.item) {
          return false;
        }
        if (rng.compareEndPoints) {
          return rng.compareEndPoints("StartToEnd", rng) === 0;
        }
        return !sel || rng.collapsed;
      };
      var collapse2 = function(toStart) {
        var rng = getRng$1();
        rng.collapse(!!toStart);
        setRng(rng);
      };
      var getSel = function() {
        return win.getSelection ? win.getSelection() : win.document.selection;
      };
      var getRng$1 = function() {
        var selection, rng, elm;
        var tryCompareBoundaryPoints = function(how, sourceRange, destinationRange) {
          try {
            return sourceRange.compareBoundaryPoints(how, destinationRange);
          } catch (ex) {
            return -1;
          }
        };
        var doc2 = win.document;
        if (editor.bookmark !== void 0 && hasFocus$1(editor) === false) {
          var bookmark = getRng(editor);
          if (bookmark.isSome()) {
            return bookmark.map(function(r2) {
              return processRanges(editor, [r2])[0];
            }).getOr(doc2.createRange());
          }
        }
        try {
          if ((selection = getSel()) && !isRestrictedNode(selection.anchorNode)) {
            if (selection.rangeCount > 0) {
              rng = selection.getRangeAt(0);
            } else {
              rng = selection.createRange ? selection.createRange() : doc2.createRange();
            }
            rng = processRanges(editor, [rng])[0];
          }
        } catch (ex) {
        }
        if (!rng) {
          rng = doc2.createRange ? doc2.createRange() : doc2.body.createTextRange();
        }
        if (rng.setStart && rng.startContainer.nodeType === 9 && rng.collapsed) {
          elm = dom2.getRoot();
          rng.setStart(elm, 0);
          rng.setEnd(elm, 0);
        }
        if (selectedRange && explicitRange) {
          if (tryCompareBoundaryPoints(rng.START_TO_START, rng, selectedRange) === 0 && tryCompareBoundaryPoints(rng.END_TO_END, rng, selectedRange) === 0) {
            rng = explicitRange;
          } else {
            selectedRange = null;
            explicitRange = null;
          }
        }
        return rng;
      };
      var setRng = function(rng, forward) {
        var node;
        if (!isValidRange(rng)) {
          return;
        }
        var ieRange = isNativeIeSelection(rng) ? rng : null;
        if (ieRange) {
          explicitRange = null;
          try {
            ieRange.select();
          } catch (ex) {
          }
          return;
        }
        var sel = getSel();
        var evt = editor.fire("SetSelectionRange", {
          range: rng,
          forward
        });
        rng = evt.range;
        if (sel) {
          explicitRange = rng;
          try {
            sel.removeAllRanges();
            sel.addRange(rng);
          } catch (ex) {
          }
          if (forward === false && sel.extend) {
            sel.collapse(rng.endContainer, rng.endOffset);
            sel.extend(rng.startContainer, rng.startOffset);
          }
          selectedRange = sel.rangeCount > 0 ? sel.getRangeAt(0) : null;
        }
        if (!rng.collapsed && rng.startContainer === rng.endContainer && sel.setBaseAndExtent && !Env.ie) {
          if (rng.endOffset - rng.startOffset < 2) {
            if (rng.startContainer.hasChildNodes()) {
              node = rng.startContainer.childNodes[rng.startOffset];
              if (node && node.tagName === "IMG") {
                sel.setBaseAndExtent(rng.startContainer, rng.startOffset, rng.endContainer, rng.endOffset);
                if (sel.anchorNode !== rng.startContainer || sel.focusNode !== rng.endContainer) {
                  sel.setBaseAndExtent(node, 0, node, 1);
                }
              }
            }
          }
        }
        editor.fire("AfterSetSelectionRange", {
          range: rng,
          forward
        });
      };
      var setNode = function(elm) {
        setContent2(dom2.getOuterHTML(elm));
        return elm;
      };
      var getNode2 = function() {
        return getNode$1(editor.getBody(), getRng$1());
      };
      var getSelectedBlocks$1 = function(startElm, endElm) {
        return getSelectedBlocks(dom2, getRng$1(), startElm, endElm);
      };
      var isForward = function() {
        var sel = getSel();
        var anchorNode = sel === null || sel === void 0 ? void 0 : sel.anchorNode;
        var focusNode = sel === null || sel === void 0 ? void 0 : sel.focusNode;
        if (!sel || !anchorNode || !focusNode || isRestrictedNode(anchorNode) || isRestrictedNode(focusNode)) {
          return true;
        }
        var anchorRange = dom2.createRng();
        anchorRange.setStart(anchorNode, sel.anchorOffset);
        anchorRange.collapse(true);
        var focusRange = dom2.createRng();
        focusRange.setStart(focusNode, sel.focusOffset);
        focusRange.collapse(true);
        return anchorRange.compareBoundaryPoints(anchorRange.START_TO_START, focusRange) <= 0;
      };
      var normalize$12 = function() {
        var rng = getRng$1();
        var sel = getSel();
        if (!hasMultipleRanges(sel) && hasAnyRanges(editor)) {
          var normRng = normalize(dom2, rng);
          normRng.each(function(normRng2) {
            setRng(normRng2, isForward());
          });
          return normRng.getOr(rng);
        }
        return rng;
      };
      var selectorChanged = function(selector, callback) {
        selectorChangedWithUnbind(selector, callback);
        return exports;
      };
      var getScrollContainer = function() {
        var scrollContainer;
        var node = dom2.getRoot();
        while (node && node.nodeName !== "BODY") {
          if (node.scrollHeight > node.clientHeight) {
            scrollContainer = node;
            break;
          }
          node = node.parentNode;
        }
        return scrollContainer;
      };
      var scrollIntoView = function(elm, alignToTop) {
        return scrollElementIntoView(editor, elm, alignToTop);
      };
      var placeCaretAt = function(clientX, clientY) {
        return setRng(fromPoint$1(clientX, clientY, editor.getDoc()));
      };
      var getBoundingClientRect2 = function() {
        var rng = getRng$1();
        return rng.collapsed ? CaretPosition.fromRangeStart(rng).getClientRects()[0] : rng.getBoundingClientRect();
      };
      var destroy2 = function() {
        win = selectedRange = explicitRange = null;
        controlSelection.destroy();
      };
      var exports = {
        bookmarkManager: null,
        controlSelection: null,
        dom: dom2,
        win,
        serializer,
        editor,
        collapse: collapse2,
        setCursorLocation,
        getContent: getContent2,
        setContent: setContent2,
        getBookmark: getBookmark2,
        moveToBookmark: moveToBookmark2,
        select: select2,
        isCollapsed,
        isForward,
        setNode,
        getNode: getNode2,
        getSel,
        setRng,
        getRng: getRng$1,
        getStart: getStart2,
        getEnd: getEnd$1,
        getSelectedBlocks: getSelectedBlocks$1,
        normalize: normalize$12,
        selectorChanged,
        selectorChangedWithUnbind,
        getScrollContainer,
        scrollIntoView,
        placeCaretAt,
        getBoundingClientRect: getBoundingClientRect2,
        destroy: destroy2
      };
      var bookmarkManager = BookmarkManager(exports);
      var controlSelection = ControlSelection(exports, editor);
      exports.bookmarkManager = bookmarkManager;
      exports.controlSelection = controlSelection;
      return exports;
    };
    var removeAttrs = function(node, names) {
      each(names, function(name2) {
        node.attr(name2, null);
      });
    };
    var addFontToSpansFilter = function(domParser, styles, fontSizes) {
      domParser.addNodeFilter("font", function(nodes) {
        each(nodes, function(node) {
          var props = styles.parse(node.attr("style"));
          var color = node.attr("color");
          var face = node.attr("face");
          var size = node.attr("size");
          if (color) {
            props.color = color;
          }
          if (face) {
            props["font-family"] = face;
          }
          if (size) {
            props["font-size"] = fontSizes[parseInt(node.attr("size"), 10) - 1];
          }
          node.name = "span";
          node.attr("style", styles.serialize(props));
          removeAttrs(node, [
            "color",
            "face",
            "size"
          ]);
        });
      });
    };
    var addStrikeToSpanFilter = function(domParser, styles) {
      domParser.addNodeFilter("strike", function(nodes) {
        each(nodes, function(node) {
          var props = styles.parse(node.attr("style"));
          props["text-decoration"] = "line-through";
          node.name = "span";
          node.attr("style", styles.serialize(props));
        });
      });
    };
    var addFilters = function(domParser, settings) {
      var styles = Styles();
      if (settings.convert_fonts_to_spans) {
        addFontToSpansFilter(domParser, styles, Tools.explode(settings.font_size_legacy_values));
      }
      addStrikeToSpanFilter(domParser, styles);
    };
    var register$1 = function(domParser, settings) {
      if (settings.inline_styles) {
        addFilters(domParser, settings);
      }
    };
    var blobUriToBlob = function(url) {
      return new promiseObj(function(resolve2, reject) {
        var rejectWithError = function() {
          reject("Cannot convert " + url + " to Blob. Resource might not exist or is inaccessible.");
        };
        try {
          var xhr_1 = new XMLHttpRequest();
          xhr_1.open("GET", url, true);
          xhr_1.responseType = "blob";
          xhr_1.onload = function() {
            if (xhr_1.status === 200) {
              resolve2(xhr_1.response);
            } else {
              rejectWithError();
            }
          };
          xhr_1.onerror = rejectWithError;
          xhr_1.send();
        } catch (ex) {
          rejectWithError();
        }
      });
    };
    var parseDataUri$1 = function(uri) {
      var type2;
      var uriParts = decodeURIComponent(uri).split(",");
      var matches2 = /data:([^;]+)/.exec(uriParts[0]);
      if (matches2) {
        type2 = matches2[1];
      }
      return {
        type: type2,
        data: uriParts[1]
      };
    };
    var buildBlob = function(type2, data2) {
      var str;
      try {
        str = atob(data2);
      } catch (e) {
        return Optional.none();
      }
      var arr2 = new Uint8Array(str.length);
      for (var i = 0; i < arr2.length; i++) {
        arr2[i] = str.charCodeAt(i);
      }
      return Optional.some(new Blob([arr2], { type: type2 }));
    };
    var dataUriToBlob = function(uri) {
      return new promiseObj(function(resolve2) {
        var _a = parseDataUri$1(uri), type2 = _a.type, data2 = _a.data;
        buildBlob(type2, data2).fold(function() {
          return resolve2(new Blob([]));
        }, resolve2);
      });
    };
    var uriToBlob = function(url) {
      if (url.indexOf("blob:") === 0) {
        return blobUriToBlob(url);
      }
      if (url.indexOf("data:") === 0) {
        return dataUriToBlob(url);
      }
      return null;
    };
    var blobToDataUri = function(blob) {
      return new promiseObj(function(resolve2) {
        var reader = new FileReader();
        reader.onloadend = function() {
          resolve2(reader.result);
        };
        reader.readAsDataURL(blob);
      });
    };
    var count = 0;
    var uniqueId = function(prefix) {
      return (prefix || "blobid") + count++;
    };
    var imageToBlobInfo = function(blobCache, img, resolve2, reject) {
      var base64, blobInfo;
      if (img.src.indexOf("blob:") === 0) {
        blobInfo = blobCache.getByUri(img.src);
        if (blobInfo) {
          resolve2({
            image: img,
            blobInfo
          });
        } else {
          uriToBlob(img.src).then(function(blob) {
            blobToDataUri(blob).then(function(dataUri) {
              base64 = parseDataUri$1(dataUri).data;
              blobInfo = blobCache.create(uniqueId(), blob, base64);
              blobCache.add(blobInfo);
              resolve2({
                image: img,
                blobInfo
              });
            });
          }, function(err) {
            reject(err);
          });
        }
        return;
      }
      var _a = parseDataUri$1(img.src), data2 = _a.data, type2 = _a.type;
      base64 = data2;
      blobInfo = blobCache.getByData(base64, type2);
      if (blobInfo) {
        resolve2({
          image: img,
          blobInfo
        });
      } else {
        uriToBlob(img.src).then(function(blob) {
          blobInfo = blobCache.create(uniqueId(), blob, base64);
          blobCache.add(blobInfo);
          resolve2({
            image: img,
            blobInfo
          });
        }, function(err) {
          reject(err);
        });
      }
    };
    var getAllImages = function(elm) {
      return elm ? from$1(elm.getElementsByTagName("img")) : [];
    };
    var ImageScanner = function(uploadStatus, blobCache) {
      var cachedPromises = {};
      var findAll2 = function(elm, predicate) {
        if (!predicate) {
          predicate = always;
        }
        var images = filter(getAllImages(elm), function(img) {
          var src = img.src;
          if (!Env.fileApi) {
            return false;
          }
          if (img.hasAttribute("data-mce-bogus")) {
            return false;
          }
          if (img.hasAttribute("data-mce-placeholder")) {
            return false;
          }
          if (!src || src === Env.transparentSrc) {
            return false;
          }
          if (src.indexOf("blob:") === 0) {
            return !uploadStatus.isUploaded(src) && predicate(img);
          }
          if (src.indexOf("data:") === 0) {
            return predicate(img);
          }
          return false;
        });
        var promises = map(images, function(img) {
          if (cachedPromises[img.src] !== void 0) {
            return new promiseObj(function(resolve2) {
              cachedPromises[img.src].then(function(imageInfo) {
                if (typeof imageInfo === "string") {
                  return imageInfo;
                }
                resolve2({
                  image: img,
                  blobInfo: imageInfo.blobInfo
                });
              });
            });
          }
          var newPromise = new promiseObj(function(resolve2, reject) {
            imageToBlobInfo(blobCache, img, resolve2, reject);
          }).then(function(result) {
            delete cachedPromises[result.image.src];
            return result;
          }).catch(function(error2) {
            delete cachedPromises[img.src];
            return error2;
          });
          cachedPromises[img.src] = newPromise;
          return newPromise;
        });
        return promiseObj.all(promises);
      };
      return { findAll: findAll2 };
    };
    var paddEmptyNode = function(settings, args, blockElements, node) {
      var brPreferred = settings.padd_empty_with_br || args.insert;
      if (brPreferred && blockElements[node.name]) {
        node.empty().append(new AstNode("br", 1)).shortEnded = true;
      } else {
        node.empty().append(new AstNode("#text", 3)).value = nbsp;
      }
    };
    var isPaddedWithNbsp = function(node) {
      return hasOnlyChild(node, "#text") && node.firstChild.value === nbsp;
    };
    var hasOnlyChild = function(node, name2) {
      return node && node.firstChild && node.firstChild === node.lastChild && node.firstChild.name === name2;
    };
    var isPadded = function(schema, node) {
      var rule = schema.getElementRule(node.name);
      return rule && rule.paddEmpty;
    };
    var isEmpty$2 = function(schema, nonEmptyElements, whitespaceElements, node) {
      return node.isEmpty(nonEmptyElements, whitespaceElements, function(node2) {
        return isPadded(schema, node2);
      });
    };
    var isLineBreakNode = function(node, blockElements) {
      return node && (blockElements[node.name] || node.name === "br");
    };
    var isBogusImage = function(img) {
      return img.attr("data-mce-bogus");
    };
    var isInternalImageSource = function(img) {
      return img.attr("src") === Env.transparentSrc || img.attr("data-mce-placeholder");
    };
    var isValidDataImg = function(img, settings) {
      if (settings.images_dataimg_filter) {
        var imgElem_1 = new Image();
        imgElem_1.src = img.attr("src");
        each$1(img.attributes.map, function(value2, key) {
          imgElem_1.setAttribute(key, value2);
        });
        return settings.images_dataimg_filter(imgElem_1);
      } else {
        return true;
      }
    };
    var registerBase64ImageFilter = function(parser, settings) {
      var blobCache = settings.blob_cache;
      var processImage = function(img) {
        var inputSrc = img.attr("src");
        if (isInternalImageSource(img) || isBogusImage(img)) {
          return;
        }
        parseDataUri(inputSrc).filter(function() {
          return isValidDataImg(img, settings);
        }).bind(function(_a) {
          var type2 = _a.type, data2 = _a.data;
          return Optional.from(blobCache.getByData(data2, type2)).orThunk(function() {
            return buildBlob(type2, data2).map(function(blob) {
              var blobInfo = blobCache.create(uniqueId(), blob, data2);
              blobCache.add(blobInfo);
              return blobInfo;
            });
          });
        }).each(function(blobInfo) {
          img.attr("src", blobInfo.blobUri());
        });
      };
      if (blobCache) {
        parser.addAttributeFilter("src", function(nodes) {
          return each(nodes, processImage);
        });
      }
    };
    var register$2 = function(parser, settings) {
      var schema = parser.schema;
      if (settings.remove_trailing_brs) {
        parser.addNodeFilter("br", function(nodes, _, args) {
          var i;
          var l = nodes.length;
          var node;
          var blockElements = Tools.extend({}, schema.getBlockElements());
          var nonEmptyElements = schema.getNonEmptyElements();
          var parent2, lastParent, prev, prevName;
          var whiteSpaceElements = schema.getWhiteSpaceElements();
          var elementRule, textNode;
          blockElements.body = 1;
          for (i = 0; i < l; i++) {
            node = nodes[i];
            parent2 = node.parent;
            if (blockElements[node.parent.name] && node === parent2.lastChild) {
              prev = node.prev;
              while (prev) {
                prevName = prev.name;
                if (prevName !== "span" || prev.attr("data-mce-type") !== "bookmark") {
                  if (prevName === "br") {
                    node = null;
                  }
                  break;
                }
                prev = prev.prev;
              }
              if (node) {
                node.remove();
                if (isEmpty$2(schema, nonEmptyElements, whiteSpaceElements, parent2)) {
                  elementRule = schema.getElementRule(parent2.name);
                  if (elementRule) {
                    if (elementRule.removeEmpty) {
                      parent2.remove();
                    } else if (elementRule.paddEmpty) {
                      paddEmptyNode(settings, args, blockElements, parent2);
                    }
                  }
                }
              }
            } else {
              lastParent = node;
              while (parent2 && parent2.firstChild === lastParent && parent2.lastChild === lastParent) {
                lastParent = parent2;
                if (blockElements[parent2.name]) {
                  break;
                }
                parent2 = parent2.parent;
              }
              if (lastParent === parent2 && settings.padd_empty_with_br !== true) {
                textNode = new AstNode("#text", 3);
                textNode.value = nbsp;
                node.replace(textNode);
              }
            }
          }
        });
      }
      parser.addAttributeFilter("href", function(nodes) {
        var i = nodes.length;
        var appendRel = function(rel) {
          var parts = rel.split(" ").filter(function(p) {
            return p.length > 0;
          });
          return parts.concat(["noopener"]).sort().join(" ");
        };
        var addNoOpener = function(rel) {
          var newRel = rel ? Tools.trim(rel) : "";
          if (!/\b(noopener)\b/g.test(newRel)) {
            return appendRel(newRel);
          } else {
            return newRel;
          }
        };
        if (!settings.allow_unsafe_link_target) {
          while (i--) {
            var node = nodes[i];
            if (node.name === "a" && node.attr("target") === "_blank") {
              node.attr("rel", addNoOpener(node.attr("rel")));
            }
          }
        }
      });
      if (!settings.allow_html_in_named_anchor) {
        parser.addAttributeFilter("id,name", function(nodes) {
          var i = nodes.length, sibling2, prevSibling2, parent2, node;
          while (i--) {
            node = nodes[i];
            if (node.name === "a" && node.firstChild && !node.attr("href")) {
              parent2 = node.parent;
              sibling2 = node.lastChild;
              do {
                prevSibling2 = sibling2.prev;
                parent2.insert(sibling2, node);
                sibling2 = prevSibling2;
              } while (sibling2);
            }
          }
        });
      }
      if (settings.fix_list_elements) {
        parser.addNodeFilter("ul,ol", function(nodes) {
          var i = nodes.length, node, parentNode;
          while (i--) {
            node = nodes[i];
            parentNode = node.parent;
            if (parentNode.name === "ul" || parentNode.name === "ol") {
              if (node.prev && node.prev.name === "li") {
                node.prev.append(node);
              } else {
                var li = new AstNode("li", 1);
                li.attr("style", "list-style-type: none");
                node.wrap(li);
              }
            }
          }
        });
      }
      if (settings.validate && schema.getValidClasses()) {
        parser.addAttributeFilter("class", function(nodes) {
          var i = nodes.length, node, classList, ci, className, classValue;
          var validClasses = schema.getValidClasses();
          var validClassesMap, valid;
          while (i--) {
            node = nodes[i];
            classList = node.attr("class").split(" ");
            classValue = "";
            for (ci = 0; ci < classList.length; ci++) {
              className = classList[ci];
              valid = false;
              validClassesMap = validClasses["*"];
              if (validClassesMap && validClassesMap[className]) {
                valid = true;
              }
              validClassesMap = validClasses[node.name];
              if (!valid && validClassesMap && validClassesMap[className]) {
                valid = true;
              }
              if (valid) {
                if (classValue) {
                  classValue += " ";
                }
                classValue += className;
              }
            }
            if (!classValue.length) {
              classValue = null;
            }
            node.attr("class", classValue);
          }
        });
      }
      registerBase64ImageFilter(parser, settings);
    };
    var makeMap$4 = Tools.makeMap, each$d = Tools.each, explode$2 = Tools.explode, extend$2 = Tools.extend;
    var DomParser = function(settings, schema) {
      if (schema === void 0) {
        schema = Schema();
      }
      var nodeFilters = {};
      var attributeFilters = [];
      var matchedNodes = {};
      var matchedAttributes = {};
      settings = settings || {};
      settings.validate = "validate" in settings ? settings.validate : true;
      settings.root_name = settings.root_name || "body";
      var fixInvalidChildren = function(nodes) {
        var ni, node, parent2, parents2, newParent, currentNode, tempNode, childNode, i;
        var sibling2, nextNode;
        var nonSplitableElements = makeMap$4("tr,td,th,tbody,thead,tfoot,table");
        var nonEmptyElements = schema.getNonEmptyElements();
        var whitespaceElements = schema.getWhiteSpaceElements();
        var textBlockElements = schema.getTextBlockElements();
        var specialElements = schema.getSpecialElements();
        for (ni = 0; ni < nodes.length; ni++) {
          node = nodes[ni];
          if (!node.parent || node.fixed) {
            continue;
          }
          if (textBlockElements[node.name] && node.parent.name === "li") {
            sibling2 = node.next;
            while (sibling2) {
              if (textBlockElements[sibling2.name]) {
                sibling2.name = "li";
                sibling2.fixed = true;
                node.parent.insert(sibling2, node.parent);
              } else {
                break;
              }
              sibling2 = sibling2.next;
            }
            node.unwrap(node);
            continue;
          }
          parents2 = [node];
          for (parent2 = node.parent; parent2 && !schema.isValidChild(parent2.name, node.name) && !nonSplitableElements[parent2.name]; parent2 = parent2.parent) {
            parents2.push(parent2);
          }
          if (parent2 && parents2.length > 1) {
            parents2.reverse();
            newParent = currentNode = filterNode(parents2[0].clone());
            for (i = 0; i < parents2.length - 1; i++) {
              if (schema.isValidChild(currentNode.name, parents2[i].name)) {
                tempNode = filterNode(parents2[i].clone());
                currentNode.append(tempNode);
              } else {
                tempNode = currentNode;
              }
              for (childNode = parents2[i].firstChild; childNode && childNode !== parents2[i + 1]; ) {
                nextNode = childNode.next;
                tempNode.append(childNode);
                childNode = nextNode;
              }
              currentNode = tempNode;
            }
            if (!isEmpty$2(schema, nonEmptyElements, whitespaceElements, newParent)) {
              parent2.insert(newParent, parents2[0], true);
              parent2.insert(node, newParent);
            } else {
              parent2.insert(node, parents2[0], true);
            }
            parent2 = parents2[0];
            if (isEmpty$2(schema, nonEmptyElements, whitespaceElements, parent2) || hasOnlyChild(parent2, "br")) {
              parent2.empty().remove();
            }
          } else if (node.parent) {
            if (node.name === "li") {
              sibling2 = node.prev;
              if (sibling2 && (sibling2.name === "ul" || sibling2.name === "ol")) {
                sibling2.append(node);
                continue;
              }
              sibling2 = node.next;
              if (sibling2 && (sibling2.name === "ul" || sibling2.name === "ol")) {
                sibling2.insert(node, sibling2.firstChild, true);
                continue;
              }
              node.wrap(filterNode(new AstNode("ul", 1)));
              continue;
            }
            if (schema.isValidChild(node.parent.name, "div") && schema.isValidChild("div", node.name)) {
              node.wrap(filterNode(new AstNode("div", 1)));
            } else {
              if (specialElements[node.name]) {
                node.empty().remove();
              } else {
                node.unwrap();
              }
            }
          }
        }
      };
      var filterNode = function(node) {
        var i, name2, list;
        name2 = node.name;
        if (name2 in nodeFilters) {
          list = matchedNodes[name2];
          if (list) {
            list.push(node);
          } else {
            matchedNodes[name2] = [node];
          }
        }
        i = attributeFilters.length;
        while (i--) {
          name2 = attributeFilters[i].name;
          if (name2 in node.attributes.map) {
            list = matchedAttributes[name2];
            if (list) {
              list.push(node);
            } else {
              matchedAttributes[name2] = [node];
            }
          }
        }
        return node;
      };
      var addNodeFilter = function(name2, callback) {
        each$d(explode$2(name2), function(name3) {
          var list = nodeFilters[name3];
          if (!list) {
            nodeFilters[name3] = list = [];
          }
          list.push(callback);
        });
      };
      var getNodeFilters = function() {
        var out = [];
        for (var name_1 in nodeFilters) {
          if (nodeFilters.hasOwnProperty(name_1)) {
            out.push({
              name: name_1,
              callbacks: nodeFilters[name_1]
            });
          }
        }
        return out;
      };
      var addAttributeFilter = function(name2, callback) {
        each$d(explode$2(name2), function(name3) {
          var i;
          for (i = 0; i < attributeFilters.length; i++) {
            if (attributeFilters[i].name === name3) {
              attributeFilters[i].callbacks.push(callback);
              return;
            }
          }
          attributeFilters.push({
            name: name3,
            callbacks: [callback]
          });
        });
      };
      var getAttributeFilters = function() {
        return [].concat(attributeFilters);
      };
      var parse = function(html, args) {
        var nodes, i, l, fi, fl, list, name2;
        var invalidChildren = [];
        var isInWhiteSpacePreservedElement;
        var node;
        var getRootBlockName = function(name3) {
          if (name3 === false) {
            return "";
          } else if (name3 === true) {
            return "p";
          } else {
            return name3;
          }
        };
        args = args || {};
        matchedNodes = {};
        matchedAttributes = {};
        var blockElements = extend$2(makeMap$4("script,style,head,html,body,title,meta,param"), schema.getBlockElements());
        var nonEmptyElements = schema.getNonEmptyElements();
        var children2 = schema.children;
        var validate2 = settings.validate;
        var forcedRootBlockName = "forced_root_block" in args ? args.forced_root_block : settings.forced_root_block;
        var rootBlockName = getRootBlockName(forcedRootBlockName);
        var whiteSpaceElements = schema.getWhiteSpaceElements();
        var startWhiteSpaceRegExp = /^[ \t\r\n]+/;
        var endWhiteSpaceRegExp = /[ \t\r\n]+$/;
        var allWhiteSpaceRegExp = /[ \t\r\n]+/g;
        var isAllWhiteSpaceRegExp = /^[ \t\r\n]+$/;
        isInWhiteSpacePreservedElement = whiteSpaceElements.hasOwnProperty(args.context) || whiteSpaceElements.hasOwnProperty(settings.root_name);
        var addRootBlocks2 = function() {
          var node2 = rootNode.firstChild, next, rootBlockNode;
          var trim2 = function(rootBlockNode2) {
            if (rootBlockNode2) {
              node2 = rootBlockNode2.firstChild;
              if (node2 && node2.type === 3) {
                node2.value = node2.value.replace(startWhiteSpaceRegExp, "");
              }
              node2 = rootBlockNode2.lastChild;
              if (node2 && node2.type === 3) {
                node2.value = node2.value.replace(endWhiteSpaceRegExp, "");
              }
            }
          };
          if (!schema.isValidChild(rootNode.name, rootBlockName.toLowerCase())) {
            return;
          }
          while (node2) {
            next = node2.next;
            if (node2.type === 3 || node2.type === 1 && node2.name !== "p" && !blockElements[node2.name] && !node2.attr("data-mce-type")) {
              if (!rootBlockNode) {
                rootBlockNode = createNode(rootBlockName, 1);
                rootBlockNode.attr(settings.forced_root_block_attrs);
                rootNode.insert(rootBlockNode, node2);
                rootBlockNode.append(node2);
              } else {
                rootBlockNode.append(node2);
              }
            } else {
              trim2(rootBlockNode);
              rootBlockNode = null;
            }
            node2 = next;
          }
          trim2(rootBlockNode);
        };
        var createNode = function(name3, type2) {
          var node2 = new AstNode(name3, type2);
          var list2;
          if (name3 in nodeFilters) {
            list2 = matchedNodes[name3];
            if (list2) {
              list2.push(node2);
            } else {
              matchedNodes[name3] = [node2];
            }
          }
          return node2;
        };
        var removeWhitespaceBefore = function(node2) {
          var textNode, textNodeNext, textVal, sibling2;
          var blockElements2 = schema.getBlockElements();
          for (textNode = node2.prev; textNode && textNode.type === 3; ) {
            textVal = textNode.value.replace(endWhiteSpaceRegExp, "");
            if (textVal.length > 0) {
              textNode.value = textVal;
              return;
            }
            textNodeNext = textNode.next;
            if (textNodeNext) {
              if (textNodeNext.type === 3 && textNodeNext.value.length) {
                textNode = textNode.prev;
                continue;
              }
              if (!blockElements2[textNodeNext.name] && textNodeNext.name !== "script" && textNodeNext.name !== "style") {
                textNode = textNode.prev;
                continue;
              }
            }
            sibling2 = textNode.prev;
            textNode.remove();
            textNode = sibling2;
          }
        };
        var cloneAndExcludeBlocks = function(input) {
          var name3;
          var output = {};
          for (name3 in input) {
            if (name3 !== "li" && name3 !== "p") {
              output[name3] = input[name3];
            }
          }
          return output;
        };
        var parser = SaxParser({
          validate: validate2,
          allow_html_data_urls: settings.allow_html_data_urls,
          allow_svg_data_urls: settings.allow_svg_data_urls,
          allow_script_urls: settings.allow_script_urls,
          allow_conditional_comments: settings.allow_conditional_comments,
          preserve_cdata: settings.preserve_cdata,
          self_closing_elements: cloneAndExcludeBlocks(schema.getSelfClosingElements()),
          cdata: function(text) {
            node.append(createNode("#cdata", 4)).value = text;
          },
          text: function(text, raw) {
            var textNode;
            if (!isInWhiteSpacePreservedElement) {
              text = text.replace(allWhiteSpaceRegExp, " ");
              if (isLineBreakNode(node.lastChild, blockElements)) {
                text = text.replace(startWhiteSpaceRegExp, "");
              }
            }
            if (text.length !== 0) {
              textNode = createNode("#text", 3);
              textNode.raw = !!raw;
              node.append(textNode).value = text;
            }
          },
          comment: function(text) {
            node.append(createNode("#comment", 8)).value = text;
          },
          pi: function(name3, text) {
            node.append(createNode(name3, 7)).value = text;
            removeWhitespaceBefore(node);
          },
          doctype: function(text) {
            var newNode = node.append(createNode("#doctype", 10));
            newNode.value = text;
            removeWhitespaceBefore(node);
          },
          start: function(name3, attrs, empty2) {
            var newNode, attrFiltersLen, attrName, parent2;
            var elementRule = validate2 ? schema.getElementRule(name3) : {};
            if (elementRule) {
              newNode = createNode(elementRule.outputName || name3, 1);
              newNode.attributes = attrs;
              newNode.shortEnded = empty2;
              node.append(newNode);
              parent2 = children2[node.name];
              if (parent2 && children2[newNode.name] && !parent2[newNode.name]) {
                invalidChildren.push(newNode);
              }
              attrFiltersLen = attributeFilters.length;
              while (attrFiltersLen--) {
                attrName = attributeFilters[attrFiltersLen].name;
                if (attrName in attrs.map) {
                  list = matchedAttributes[attrName];
                  if (list) {
                    list.push(newNode);
                  } else {
                    matchedAttributes[attrName] = [newNode];
                  }
                }
              }
              if (blockElements[name3]) {
                removeWhitespaceBefore(newNode);
              }
              if (!empty2) {
                node = newNode;
              }
              if (!isInWhiteSpacePreservedElement && whiteSpaceElements[name3]) {
                isInWhiteSpacePreservedElement = true;
              }
            }
          },
          end: function(name3) {
            var textNode, text, sibling2, tempNode;
            var elementRule = validate2 ? schema.getElementRule(name3) : {};
            if (elementRule) {
              if (blockElements[name3]) {
                if (!isInWhiteSpacePreservedElement) {
                  textNode = node.firstChild;
                  if (textNode && textNode.type === 3) {
                    text = textNode.value.replace(startWhiteSpaceRegExp, "");
                    if (text.length > 0) {
                      textNode.value = text;
                      textNode = textNode.next;
                    } else {
                      sibling2 = textNode.next;
                      textNode.remove();
                      textNode = sibling2;
                      while (textNode && textNode.type === 3) {
                        text = textNode.value;
                        sibling2 = textNode.next;
                        if (text.length === 0 || isAllWhiteSpaceRegExp.test(text)) {
                          textNode.remove();
                          textNode = sibling2;
                        }
                        textNode = sibling2;
                      }
                    }
                  }
                  textNode = node.lastChild;
                  if (textNode && textNode.type === 3) {
                    text = textNode.value.replace(endWhiteSpaceRegExp, "");
                    if (text.length > 0) {
                      textNode.value = text;
                      textNode = textNode.prev;
                    } else {
                      sibling2 = textNode.prev;
                      textNode.remove();
                      textNode = sibling2;
                      while (textNode && textNode.type === 3) {
                        text = textNode.value;
                        sibling2 = textNode.prev;
                        if (text.length === 0 || isAllWhiteSpaceRegExp.test(text)) {
                          textNode.remove();
                          textNode = sibling2;
                        }
                        textNode = sibling2;
                      }
                    }
                  }
                }
              }
              if (isInWhiteSpacePreservedElement && whiteSpaceElements[name3]) {
                isInWhiteSpacePreservedElement = false;
              }
              if (elementRule.removeEmpty && isEmpty$2(schema, nonEmptyElements, whiteSpaceElements, node)) {
                tempNode = node.parent;
                if (blockElements[node.name]) {
                  node.empty().remove();
                } else {
                  node.unwrap();
                }
                node = tempNode;
                return;
              }
              if (elementRule.paddEmpty && (isPaddedWithNbsp(node) || isEmpty$2(schema, nonEmptyElements, whiteSpaceElements, node))) {
                paddEmptyNode(settings, args, blockElements, node);
              }
              node = node.parent;
            }
          }
        }, schema);
        var rootNode = node = new AstNode(args.context || settings.root_name, 11);
        parser.parse(html, args.format);
        if (validate2 && invalidChildren.length) {
          if (!args.context) {
            fixInvalidChildren(invalidChildren);
          } else {
            args.invalid = true;
          }
        }
        if (rootBlockName && (rootNode.name === "body" || args.isRootContent)) {
          addRootBlocks2();
        }
        if (!args.invalid) {
          for (name2 in matchedNodes) {
            if (!matchedNodes.hasOwnProperty(name2)) {
              continue;
            }
            list = nodeFilters[name2];
            nodes = matchedNodes[name2];
            fi = nodes.length;
            while (fi--) {
              if (!nodes[fi].parent) {
                nodes.splice(fi, 1);
              }
            }
            for (i = 0, l = list.length; i < l; i++) {
              list[i](nodes, name2, args);
            }
          }
          for (i = 0, l = attributeFilters.length; i < l; i++) {
            list = attributeFilters[i];
            if (list.name in matchedAttributes) {
              nodes = matchedAttributes[list.name];
              fi = nodes.length;
              while (fi--) {
                if (!nodes[fi].parent) {
                  nodes.splice(fi, 1);
                }
              }
              for (fi = 0, fl = list.callbacks.length; fi < fl; fi++) {
                list.callbacks[fi](nodes, list.name, args);
              }
            }
          }
        }
        return rootNode;
      };
      var exports = {
        schema,
        addAttributeFilter,
        getAttributeFilters,
        addNodeFilter,
        getNodeFilters,
        filterNode,
        parse
      };
      register$2(exports, settings);
      register$1(exports, settings);
      return exports;
    };
    var register$3 = function(htmlParser, settings, dom2) {
      htmlParser.addAttributeFilter("data-mce-tabindex", function(nodes, name2) {
        var i = nodes.length, node;
        while (i--) {
          node = nodes[i];
          node.attr("tabindex", node.attr("data-mce-tabindex"));
          node.attr(name2, null);
        }
      });
      htmlParser.addAttributeFilter("src,href,style", function(nodes, name2) {
        var i = nodes.length, node, value2;
        var internalName = "data-mce-" + name2;
        var urlConverter = settings.url_converter;
        var urlConverterScope = settings.url_converter_scope;
        while (i--) {
          node = nodes[i];
          value2 = node.attr(internalName);
          if (value2 !== void 0) {
            node.attr(name2, value2.length > 0 ? value2 : null);
            node.attr(internalName, null);
          } else {
            value2 = node.attr(name2);
            if (name2 === "style") {
              value2 = dom2.serializeStyle(dom2.parseStyle(value2), node.name);
            } else if (urlConverter) {
              value2 = urlConverter.call(urlConverterScope, value2, name2, node.name);
            }
            node.attr(name2, value2.length > 0 ? value2 : null);
          }
        }
      });
      htmlParser.addAttributeFilter("class", function(nodes) {
        var i = nodes.length, node, value2;
        while (i--) {
          node = nodes[i];
          value2 = node.attr("class");
          if (value2) {
            value2 = node.attr("class").replace(/(?:^|\s)mce-item-\w+(?!\S)/g, "");
            node.attr("class", value2.length > 0 ? value2 : null);
          }
        }
      });
      htmlParser.addAttributeFilter("data-mce-type", function(nodes, name2, args) {
        var i = nodes.length, node;
        while (i--) {
          node = nodes[i];
          if (node.attr("data-mce-type") === "bookmark" && !args.cleanup) {
            var hasChildren = Optional.from(node.firstChild).exists(function(firstChild2) {
              return !isZwsp$1(firstChild2.value);
            });
            if (hasChildren) {
              node.unwrap();
            } else {
              node.remove();
            }
          }
        }
      });
      htmlParser.addNodeFilter("noscript", function(nodes) {
        var i = nodes.length, node;
        while (i--) {
          node = nodes[i].firstChild;
          if (node) {
            node.value = Entities.decode(node.value);
          }
        }
      });
      htmlParser.addNodeFilter("script,style", function(nodes, name2) {
        var i = nodes.length, node, value2, type2;
        var trim2 = function(value3) {
          return value3.replace(/(<!--\[CDATA\[|\]\]-->)/g, "\n").replace(/^[\r\n]*|[\r\n]*$/g, "").replace(/^\s*((<!--)?(\s*\/\/)?\s*<!\[CDATA\[|(<!--\s*)?\/\*\s*<!\[CDATA\[\s*\*\/|(\/\/)?\s*<!--|\/\*\s*<!--\s*\*\/)\s*[\r\n]*/gi, "").replace(/\s*(\/\*\s*\]\]>\s*\*\/(-->)?|\s*\/\/\s*\]\]>(-->)?|\/\/\s*(-->)?|\]\]>|\/\*\s*-->\s*\*\/|\s*-->\s*)\s*$/g, "");
        };
        while (i--) {
          node = nodes[i];
          value2 = node.firstChild ? node.firstChild.value : "";
          if (name2 === "script") {
            type2 = node.attr("type");
            if (type2) {
              node.attr("type", type2 === "mce-no/type" ? null : type2.replace(/^mce\-/, ""));
            }
            if (settings.element_format === "xhtml" && value2.length > 0) {
              node.firstChild.value = "// <![CDATA[\n" + trim2(value2) + "\n// ]]>";
            }
          } else {
            if (settings.element_format === "xhtml" && value2.length > 0) {
              node.firstChild.value = "<!--\n" + trim2(value2) + "\n-->";
            }
          }
        }
      });
      htmlParser.addNodeFilter("#comment", function(nodes) {
        var i = nodes.length, node;
        while (i--) {
          node = nodes[i];
          if (settings.preserve_cdata && node.value.indexOf("[CDATA[") === 0) {
            node.name = "#cdata";
            node.type = 4;
            node.value = dom2.decode(node.value.replace(/^\[CDATA\[|\]\]$/g, ""));
          } else if (node.value.indexOf("mce:protected ") === 0) {
            node.name = "#text";
            node.type = 3;
            node.raw = true;
            node.value = unescape(node.value).substr(14);
          }
        }
      });
      htmlParser.addNodeFilter("xml:namespace,input", function(nodes, name2) {
        var i = nodes.length, node;
        while (i--) {
          node = nodes[i];
          if (node.type === 7) {
            node.remove();
          } else if (node.type === 1) {
            if (name2 === "input" && !node.attr("type")) {
              node.attr("type", "text");
            }
          }
        }
      });
      htmlParser.addAttributeFilter("data-mce-type", function(nodes) {
        each(nodes, function(node) {
          if (node.attr("data-mce-type") === "format-caret") {
            if (node.isEmpty(htmlParser.schema.getNonEmptyElements())) {
              node.remove();
            } else {
              node.unwrap();
            }
          }
        });
      });
      htmlParser.addAttributeFilter("data-mce-src,data-mce-href,data-mce-style,data-mce-selected,data-mce-expando,data-mce-type,data-mce-resize,data-mce-placeholder", function(nodes, name2) {
        var i = nodes.length;
        while (i--) {
          nodes[i].attr(name2, null);
        }
      });
    };
    var trimTrailingBr = function(rootNode) {
      var isBr2 = function(node) {
        return node && node.name === "br";
      };
      var brNode1 = rootNode.lastChild;
      if (isBr2(brNode1)) {
        var brNode2 = brNode1.prev;
        if (isBr2(brNode2)) {
          brNode1.remove();
          brNode2.remove();
        }
      }
    };
    var preProcess = function(editor, node, args) {
      var doc2, oldDoc;
      var dom2 = editor.dom;
      node = node.cloneNode(true);
      var impl = document.implementation;
      if (impl.createHTMLDocument) {
        doc2 = impl.createHTMLDocument("");
        Tools.each(node.nodeName === "BODY" ? node.childNodes : [node], function(node2) {
          doc2.body.appendChild(doc2.importNode(node2, true));
        });
        if (node.nodeName !== "BODY") {
          node = doc2.body.firstChild;
        } else {
          node = doc2.body;
        }
        oldDoc = dom2.doc;
        dom2.doc = doc2;
      }
      firePreProcess(editor, __assign2(__assign2({}, args), { node }));
      if (oldDoc) {
        dom2.doc = oldDoc;
      }
      return node;
    };
    var shouldFireEvent = function(editor, args) {
      return editor && editor.hasEventListeners("PreProcess") && !args.no_events;
    };
    var process = function(editor, node, args) {
      return shouldFireEvent(editor, args) ? preProcess(editor, node, args) : node;
    };
    var addTempAttr = function(htmlParser, tempAttrs, name2) {
      if (Tools.inArray(tempAttrs, name2) === -1) {
        htmlParser.addAttributeFilter(name2, function(nodes, name3) {
          var i = nodes.length;
          while (i--) {
            nodes[i].attr(name3, null);
          }
        });
        tempAttrs.push(name2);
      }
    };
    var postProcess$1 = function(editor, args, content) {
      if (!args.no_events && editor) {
        var outArgs = firePostProcess(editor, __assign2(__assign2({}, args), { content }));
        return outArgs.content;
      } else {
        return content;
      }
    };
    var getHtmlFromNode = function(dom2, node, args) {
      var html = trim$2(args.getInner ? node.innerHTML : dom2.getOuterHTML(node));
      return args.selection || isWsPreserveElement(SugarElement.fromDom(node)) ? html : Tools.trim(html);
    };
    var parseHtml = function(htmlParser, html, args) {
      var parserArgs = args.selection ? __assign2({ forced_root_block: false }, args) : args;
      var rootNode = htmlParser.parse(html, parserArgs);
      trimTrailingBr(rootNode);
      return rootNode;
    };
    var serializeNode = function(settings, schema, node) {
      var htmlSerializer = HtmlSerializer(settings, schema);
      return htmlSerializer.serialize(node);
    };
    var toHtml = function(editor, settings, schema, rootNode, args) {
      var content = serializeNode(settings, schema, rootNode);
      return postProcess$1(editor, args, content);
    };
    var DomSerializerImpl = function(settings, editor) {
      var tempAttrs = ["data-mce-selected"];
      var dom2 = editor && editor.dom ? editor.dom : DOMUtils.DOM;
      var schema = editor && editor.schema ? editor.schema : Schema(settings);
      settings.entity_encoding = settings.entity_encoding || "named";
      settings.remove_trailing_brs = "remove_trailing_brs" in settings ? settings.remove_trailing_brs : true;
      var htmlParser = DomParser(settings, schema);
      register$3(htmlParser, settings, dom2);
      var serialize2 = function(node, parserArgs) {
        if (parserArgs === void 0) {
          parserArgs = {};
        }
        var args = __assign2({ format: "html" }, parserArgs);
        var targetNode = process(editor, node, args);
        var html = getHtmlFromNode(dom2, targetNode, args);
        var rootNode = parseHtml(htmlParser, html, args);
        return args.format === "tree" ? rootNode : toHtml(editor, settings, schema, rootNode, args);
      };
      return {
        schema,
        addNodeFilter: htmlParser.addNodeFilter,
        addAttributeFilter: htmlParser.addAttributeFilter,
        serialize: serialize2,
        addRules: function(rules) {
          schema.addValidElements(rules);
        },
        setRules: function(rules) {
          schema.setValidElements(rules);
        },
        addTempAttr: curry(addTempAttr, htmlParser, tempAttrs),
        getTempAttrs: constant(tempAttrs),
        getNodeFilters: htmlParser.getNodeFilters,
        getAttributeFilters: htmlParser.getAttributeFilters
      };
    };
    var DomSerializer = function(settings, editor) {
      var domSerializer = DomSerializerImpl(settings, editor);
      return {
        schema: domSerializer.schema,
        addNodeFilter: domSerializer.addNodeFilter,
        addAttributeFilter: domSerializer.addAttributeFilter,
        serialize: domSerializer.serialize,
        addRules: domSerializer.addRules,
        setRules: domSerializer.setRules,
        addTempAttr: domSerializer.addTempAttr,
        getTempAttrs: domSerializer.getTempAttrs,
        getNodeFilters: domSerializer.getNodeFilters,
        getAttributeFilters: domSerializer.getAttributeFilters
      };
    };
    var defaultFormat$1 = "html";
    var getContent$2 = function(editor, args) {
      if (args === void 0) {
        args = {};
      }
      var format = args.format ? args.format : defaultFormat$1;
      return getContent(editor, args, format);
    };
    var setContent$2 = function(editor, content, args) {
      if (args === void 0) {
        args = {};
      }
      return setContent(editor, content, args);
    };
    var DOM$3 = DOMUtils.DOM;
    var restoreOriginalStyles = function(editor) {
      DOM$3.setStyle(editor.id, "display", editor.orgDisplay);
    };
    var safeDestroy = function(x) {
      return Optional.from(x).each(function(x2) {
        return x2.destroy();
      });
    };
    var clearDomReferences = function(editor) {
      editor.contentAreaContainer = editor.formElement = editor.container = editor.editorContainer = null;
      editor.bodyElement = editor.contentDocument = editor.contentWindow = null;
      editor.iframeElement = editor.targetElm = null;
      if (editor.selection) {
        editor.selection = editor.selection.win = editor.selection.dom = editor.selection.dom.doc = null;
      }
    };
    var restoreForm = function(editor) {
      var form = editor.formElement;
      if (form) {
        if (form._mceOldSubmit) {
          form.submit = form._mceOldSubmit;
          form._mceOldSubmit = null;
        }
        DOM$3.unbind(form, "submit reset", editor.formEventDelegate);
      }
    };
    var remove$7 = function(editor) {
      if (!editor.removed) {
        var _selectionOverrides = editor._selectionOverrides, editorUpload = editor.editorUpload;
        var body = editor.getBody();
        var element = editor.getElement();
        if (body) {
          editor.save({ is_removing: true });
        }
        editor.removed = true;
        editor.unbindAllNativeEvents();
        if (editor.hasHiddenInput && element) {
          DOM$3.remove(element.nextSibling);
        }
        fireRemove(editor);
        editor.editorManager.remove(editor);
        if (!editor.inline && body) {
          restoreOriginalStyles(editor);
        }
        fireDetach(editor);
        DOM$3.remove(editor.getContainer());
        safeDestroy(_selectionOverrides);
        safeDestroy(editorUpload);
        editor.destroy();
      }
    };
    var destroy = function(editor, automatic) {
      var selection = editor.selection, dom2 = editor.dom;
      if (editor.destroyed) {
        return;
      }
      if (!automatic && !editor.removed) {
        editor.remove();
        return;
      }
      if (!automatic) {
        editor.editorManager.off("beforeunload", editor._beforeUnload);
        if (editor.theme && editor.theme.destroy) {
          editor.theme.destroy();
        }
        safeDestroy(selection);
        safeDestroy(dom2);
      }
      restoreForm(editor);
      clearDomReferences(editor);
      editor.destroyed = true;
    };
    var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
    var deep$1 = function(old, nu2) {
      var bothObjects = isObject(old) && isObject(nu2);
      return bothObjects ? deepMerge(old, nu2) : nu2;
    };
    var baseMerge = function(merger) {
      return function() {
        var objects = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          objects[_i] = arguments[_i];
        }
        if (objects.length === 0) {
          throw new Error("Can't merge zero objects");
        }
        var ret = {};
        for (var j = 0; j < objects.length; j++) {
          var curObject = objects[j];
          for (var key in curObject) {
            if (hasOwnProperty$2.call(curObject, key)) {
              ret[key] = merger(ret[key], curObject[key]);
            }
          }
        }
        return ret;
      };
    };
    var deepMerge = baseMerge(deep$1);
    var sectionResult = function(sections, settings) {
      return {
        sections: constant(sections),
        settings: constant(settings)
      };
    };
    var deviceDetection = detect$3().deviceType;
    var isTouch = deviceDetection.isTouch();
    var isPhone = deviceDetection.isPhone();
    var isTablet = deviceDetection.isTablet();
    var legacyMobilePlugins = [
      "lists",
      "autolink",
      "autosave"
    ];
    var defaultTouchSettings = {
      table_grid: false,
      object_resizing: false,
      resize: false
    };
    var normalizePlugins = function(plugins) {
      var pluginNames = isArray(plugins) ? plugins.join(" ") : plugins;
      var trimmedPlugins = map(isString(pluginNames) ? pluginNames.split(" ") : [], trim);
      return filter(trimmedPlugins, function(item) {
        return item.length > 0;
      });
    };
    var filterLegacyMobilePlugins = function(plugins) {
      return filter(plugins, curry(contains, legacyMobilePlugins));
    };
    var extractSections = function(keys2, settings) {
      var result = bifilter(settings, function(value2, key) {
        return contains(keys2, key);
      });
      return sectionResult(result.t, result.f);
    };
    var getSection = function(sectionResult2, name2, defaults) {
      if (defaults === void 0) {
        defaults = {};
      }
      var sections = sectionResult2.sections();
      var sectionSettings = sections.hasOwnProperty(name2) ? sections[name2] : {};
      return Tools.extend({}, defaults, sectionSettings);
    };
    var hasSection = function(sectionResult2, name2) {
      return sectionResult2.sections().hasOwnProperty(name2);
    };
    var isSectionTheme = function(sectionResult2, name2, theme) {
      var section = sectionResult2.sections();
      return hasSection(sectionResult2, name2) && section[name2].theme === theme;
    };
    var getSectionConfig = function(sectionResult2, name2) {
      return hasSection(sectionResult2, name2) ? sectionResult2.sections()[name2] : {};
    };
    var getToolbarMode = function(settings, defaultVal) {
      return get$1(settings, "toolbar_mode").orThunk(function() {
        return get$1(settings, "toolbar_drawer").map(function(val) {
          return val === false ? "wrap" : val;
        });
      }).getOr(defaultVal);
    };
    var getDefaultSettings = function(settings, id, documentBaseUrl, isTouch2, editor) {
      var baseDefaults = {
        id,
        theme: "silver",
        toolbar_mode: getToolbarMode(settings, "floating"),
        plugins: "",
        document_base_url: documentBaseUrl,
        add_form_submit_trigger: true,
        submit_patch: true,
        add_unload_trigger: true,
        convert_urls: true,
        relative_urls: true,
        remove_script_host: true,
        object_resizing: true,
        doctype: "<!DOCTYPE html>",
        visual: true,
        font_size_legacy_values: "xx-small,small,medium,large,x-large,xx-large,300%",
        forced_root_block: "p",
        hidden_input: true,
        inline_styles: true,
        convert_fonts_to_spans: true,
        indent: true,
        indent_before: "p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,tfoot,tbody,tr,section,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist",
        indent_after: "p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,tfoot,tbody,tr,section,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist",
        entity_encoding: "named",
        url_converter: editor.convertURL,
        url_converter_scope: editor
      };
      return __assign2(__assign2({}, baseDefaults), isTouch2 ? defaultTouchSettings : {});
    };
    var getDefaultMobileSettings = function(mobileSettings, isPhone2) {
      var defaultMobileSettings = {
        resize: false,
        toolbar_mode: getToolbarMode(mobileSettings, "scrolling"),
        toolbar_sticky: false
      };
      var defaultPhoneSettings = { menubar: false };
      return __assign2(__assign2(__assign2({}, defaultTouchSettings), defaultMobileSettings), isPhone2 ? defaultPhoneSettings : {});
    };
    var getExternalPlugins$1 = function(overrideSettings, settings) {
      var userDefinedExternalPlugins = settings.external_plugins ? settings.external_plugins : {};
      if (overrideSettings && overrideSettings.external_plugins) {
        return Tools.extend({}, overrideSettings.external_plugins, userDefinedExternalPlugins);
      } else {
        return userDefinedExternalPlugins;
      }
    };
    var combinePlugins = function(forcedPlugins, plugins) {
      return [].concat(normalizePlugins(forcedPlugins)).concat(normalizePlugins(plugins));
    };
    var getPlatformPlugins = function(isMobileDevice, sectionResult2, desktopPlugins, mobilePlugins) {
      if (isMobileDevice && isSectionTheme(sectionResult2, "mobile", "mobile")) {
        return filterLegacyMobilePlugins(mobilePlugins);
      } else if (isMobileDevice && hasSection(sectionResult2, "mobile")) {
        return mobilePlugins;
      } else {
        return desktopPlugins;
      }
    };
    var processPlugins = function(isMobileDevice, sectionResult2, defaultOverrideSettings, settings) {
      var forcedPlugins = normalizePlugins(defaultOverrideSettings.forced_plugins);
      var desktopPlugins = normalizePlugins(settings.plugins);
      var mobileConfig = getSectionConfig(sectionResult2, "mobile");
      var mobilePlugins = mobileConfig.plugins ? normalizePlugins(mobileConfig.plugins) : desktopPlugins;
      var platformPlugins = getPlatformPlugins(isMobileDevice, sectionResult2, desktopPlugins, mobilePlugins);
      var combinedPlugins = combinePlugins(forcedPlugins, platformPlugins);
      if (Env.browser.isIE() && contains(combinedPlugins, "rtc")) {
        throw new Error("RTC plugin is not supported on IE 11.");
      }
      return Tools.extend(settings, { plugins: combinedPlugins.join(" ") });
    };
    var isOnMobile = function(isMobileDevice, sectionResult2) {
      return isMobileDevice && hasSection(sectionResult2, "mobile");
    };
    var combineSettings = function(isMobileDevice, isPhone2, defaultSettings, defaultOverrideSettings, settings) {
      var defaultDeviceSettings = isMobileDevice ? { mobile: getDefaultMobileSettings(settings.mobile || {}, isPhone2) } : {};
      var sectionResult2 = extractSections(["mobile"], deepMerge(defaultDeviceSettings, settings));
      var extendedSettings = Tools.extend(defaultSettings, defaultOverrideSettings, sectionResult2.settings(), isOnMobile(isMobileDevice, sectionResult2) ? getSection(sectionResult2, "mobile") : {}, {
        validate: true,
        external_plugins: getExternalPlugins$1(defaultOverrideSettings, sectionResult2.settings())
      });
      return processPlugins(isMobileDevice, sectionResult2, defaultOverrideSettings, extendedSettings);
    };
    var getEditorSettings = function(editor, id, documentBaseUrl, defaultOverrideSettings, settings) {
      var defaultSettings = getDefaultSettings(settings, id, documentBaseUrl, isTouch, editor);
      return combineSettings(isPhone || isTablet, isPhone, defaultSettings, defaultOverrideSettings, settings);
    };
    var getFiltered = function(predicate, editor, name2) {
      return Optional.from(editor.settings[name2]).filter(predicate);
    };
    var getParamObject = function(value2) {
      var output = {};
      if (typeof value2 === "string") {
        each(value2.indexOf("=") > 0 ? value2.split(/[;,](?![^=;,]*(?:[;,]|$))/) : value2.split(","), function(val) {
          var arr2 = val.split("=");
          if (arr2.length > 1) {
            output[Tools.trim(arr2[0])] = Tools.trim(arr2[1]);
          } else {
            output[Tools.trim(arr2[0])] = Tools.trim(arr2[0]);
          }
        });
      } else {
        output = value2;
      }
      return output;
    };
    var isArrayOf = function(p) {
      return function(a) {
        return isArray(a) && forall(a, p);
      };
    };
    var getParam = function(editor, name2, defaultVal, type2) {
      var value2 = name2 in editor.settings ? editor.settings[name2] : defaultVal;
      if (type2 === "hash") {
        return getParamObject(value2);
      } else if (type2 === "string") {
        return getFiltered(isString, editor, name2).getOr(defaultVal);
      } else if (type2 === "number") {
        return getFiltered(isNumber, editor, name2).getOr(defaultVal);
      } else if (type2 === "boolean") {
        return getFiltered(isBoolean, editor, name2).getOr(defaultVal);
      } else if (type2 === "object") {
        return getFiltered(isObject, editor, name2).getOr(defaultVal);
      } else if (type2 === "array") {
        return getFiltered(isArray, editor, name2).getOr(defaultVal);
      } else if (type2 === "string[]") {
        return getFiltered(isArrayOf(isString), editor, name2).getOr(defaultVal);
      } else if (type2 === "function") {
        return getFiltered(isFunction, editor, name2).getOr(defaultVal);
      } else {
        return value2;
      }
    };
    var CreateIconManager = function() {
      var lookup = {};
      var add2 = function(id, iconPack) {
        lookup[id] = iconPack;
      };
      var get2 = function(id) {
        if (lookup[id]) {
          return lookup[id];
        }
        return { icons: {} };
      };
      var has$12 = function(id) {
        return has(lookup, id);
      };
      return {
        add: add2,
        get: get2,
        has: has$12
      };
    };
    var IconManager = CreateIconManager();
    var getProp = function(propName, elm) {
      var rawElm = elm.dom;
      return rawElm[propName];
    };
    var getComputedSizeProp = function(propName, elm) {
      return parseInt(get$5(elm, propName), 10);
    };
    var getClientWidth = curry(getProp, "clientWidth");
    var getClientHeight = curry(getProp, "clientHeight");
    var getMarginTop = curry(getComputedSizeProp, "margin-top");
    var getMarginLeft = curry(getComputedSizeProp, "margin-left");
    var getBoundingClientRect$1 = function(elm) {
      return elm.dom.getBoundingClientRect();
    };
    var isInsideElementContentArea = function(bodyElm, clientX, clientY) {
      var clientWidth = getClientWidth(bodyElm);
      var clientHeight = getClientHeight(bodyElm);
      return clientX >= 0 && clientY >= 0 && clientX <= clientWidth && clientY <= clientHeight;
    };
    var transpose = function(inline, elm, clientX, clientY) {
      var clientRect = getBoundingClientRect$1(elm);
      var deltaX = inline ? clientRect.left + elm.dom.clientLeft + getMarginLeft(elm) : 0;
      var deltaY = inline ? clientRect.top + elm.dom.clientTop + getMarginTop(elm) : 0;
      var x = clientX - deltaX;
      var y = clientY - deltaY;
      return {
        x,
        y
      };
    };
    var isXYInContentArea = function(editor, clientX, clientY) {
      var bodyElm = SugarElement.fromDom(editor.getBody());
      var targetElm = editor.inline ? bodyElm : documentElement(bodyElm);
      var transposedPoint = transpose(editor.inline, targetElm, clientX, clientY);
      return isInsideElementContentArea(targetElm, transposedPoint.x, transposedPoint.y);
    };
    var fromDomSafe = function(node) {
      return Optional.from(node).map(SugarElement.fromDom);
    };
    var isEditorAttachedToDom = function(editor) {
      var rawContainer = editor.inline ? editor.getBody() : editor.getContentAreaContainer();
      return fromDomSafe(rawContainer).map(inBody).getOr(false);
    };
    var NotificationManagerImpl = function() {
      var unimplemented = function() {
        throw new Error("Theme did not provide a NotificationManager implementation.");
      };
      return {
        open: unimplemented,
        close: unimplemented,
        reposition: unimplemented,
        getArgs: unimplemented
      };
    };
    var NotificationManager = function(editor) {
      var notifications = [];
      var getImplementation = function() {
        var theme = editor.theme;
        return theme && theme.getNotificationManagerImpl ? theme.getNotificationManagerImpl() : NotificationManagerImpl();
      };
      var getTopNotification = function() {
        return Optional.from(notifications[0]);
      };
      var isEqual2 = function(a, b) {
        return a.type === b.type && a.text === b.text && !a.progressBar && !a.timeout && !b.progressBar && !b.timeout;
      };
      var reposition2 = function() {
        if (notifications.length > 0) {
          getImplementation().reposition(notifications);
        }
      };
      var addNotification = function(notification) {
        notifications.push(notification);
      };
      var closeNotification = function(notification) {
        findIndex(notifications, function(otherNotification) {
          return otherNotification === notification;
        }).each(function(index) {
          notifications.splice(index, 1);
        });
      };
      var open = function(spec, fireEvent2) {
        if (fireEvent2 === void 0) {
          fireEvent2 = true;
        }
        if (editor.removed || !isEditorAttachedToDom(editor)) {
          return;
        }
        if (fireEvent2) {
          editor.fire("BeforeOpenNotification", { notification: spec });
        }
        return find(notifications, function(notification) {
          return isEqual2(getImplementation().getArgs(notification), spec);
        }).getOrThunk(function() {
          editor.editorManager.setActive(editor);
          var notification = getImplementation().open(spec, function() {
            closeNotification(notification);
            reposition2();
            getTopNotification().fold(function() {
              return editor.focus();
            }, function(top) {
              return focus(SugarElement.fromDom(top.getEl()));
            });
          });
          addNotification(notification);
          reposition2();
          editor.fire("OpenNotification", { notification: __assign2({}, notification) });
          return notification;
        });
      };
      var close = function() {
        getTopNotification().each(function(notification) {
          getImplementation().close(notification);
          closeNotification(notification);
          reposition2();
        });
      };
      var getNotifications = function() {
        return notifications;
      };
      var registerEvents2 = function(editor2) {
        editor2.on("SkinLoaded", function() {
          var serviceMessage = getServiceMessage(editor2);
          if (serviceMessage) {
            open({
              text: serviceMessage,
              type: "warning",
              timeout: 0
            }, false);
          }
        });
        editor2.on("ResizeEditor ResizeWindow NodeChange", function() {
          Delay.requestAnimationFrame(reposition2);
        });
        editor2.on("remove", function() {
          each(notifications.slice(), function(notification) {
            getImplementation().close(notification);
          });
        });
      };
      registerEvents2(editor);
      return {
        open,
        close,
        getNotifications
      };
    };
    var PluginManager = AddOnManager.PluginManager;
    var ThemeManager = AddOnManager.ThemeManager;
    function WindowManagerImpl() {
      var unimplemented = function() {
        throw new Error("Theme did not provide a WindowManager implementation.");
      };
      return {
        open: unimplemented,
        openUrl: unimplemented,
        alert: unimplemented,
        confirm: unimplemented,
        close: unimplemented,
        getParams: unimplemented,
        setParams: unimplemented
      };
    }
    var WindowManager = function(editor) {
      var dialogs = [];
      var getImplementation = function() {
        var theme = editor.theme;
        return theme && theme.getWindowManagerImpl ? theme.getWindowManagerImpl() : WindowManagerImpl();
      };
      var funcBind = function(scope, f) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return f ? f.apply(scope, args) : void 0;
        };
      };
      var fireOpenEvent = function(dialog) {
        editor.fire("OpenWindow", { dialog });
      };
      var fireCloseEvent = function(dialog) {
        editor.fire("CloseWindow", { dialog });
      };
      var addDialog = function(dialog) {
        dialogs.push(dialog);
        fireOpenEvent(dialog);
      };
      var closeDialog = function(dialog) {
        fireCloseEvent(dialog);
        dialogs = filter(dialogs, function(otherDialog) {
          return otherDialog !== dialog;
        });
        if (dialogs.length === 0) {
          editor.focus();
        }
      };
      var getTopDialog = function() {
        return Optional.from(dialogs[dialogs.length - 1]);
      };
      var storeSelectionAndOpenDialog = function(openDialog) {
        editor.editorManager.setActive(editor);
        store(editor);
        var dialog = openDialog();
        addDialog(dialog);
        return dialog;
      };
      var open = function(args, params) {
        return storeSelectionAndOpenDialog(function() {
          return getImplementation().open(args, params, closeDialog);
        });
      };
      var openUrl = function(args) {
        return storeSelectionAndOpenDialog(function() {
          return getImplementation().openUrl(args, closeDialog);
        });
      };
      var alert = function(message, callback, scope) {
        var windowManagerImpl = getImplementation();
        windowManagerImpl.alert(message, funcBind(scope ? scope : windowManagerImpl, callback));
      };
      var confirm = function(message, callback, scope) {
        var windowManagerImpl = getImplementation();
        windowManagerImpl.confirm(message, funcBind(scope ? scope : windowManagerImpl, callback));
      };
      var close = function() {
        getTopDialog().each(function(dialog) {
          getImplementation().close(dialog);
          closeDialog(dialog);
        });
      };
      editor.on("remove", function() {
        each(dialogs, function(dialog) {
          getImplementation().close(dialog);
        });
      });
      return {
        open,
        openUrl,
        alert,
        confirm,
        close
      };
    };
    var displayNotification = function(editor, message) {
      editor.notificationManager.open({
        type: "error",
        text: message
      });
    };
    var displayError = function(editor, message) {
      if (editor._skinLoaded) {
        displayNotification(editor, message);
      } else {
        editor.on("SkinLoaded", function() {
          displayNotification(editor, message);
        });
      }
    };
    var uploadError = function(editor, message) {
      displayError(editor, I18n.translate([
        "Failed to upload image: {0}",
        message
      ]));
    };
    var logError = function(editor, errorType, msg) {
      fireError(editor, errorType, { message: msg });
      console.error(msg);
    };
    var createLoadError = function(type2, url, name2) {
      return name2 ? "Failed to load " + type2 + ": " + name2 + " from url " + url : "Failed to load " + type2 + " url: " + url;
    };
    var pluginLoadError = function(editor, url, name2) {
      logError(editor, "PluginLoadError", createLoadError("plugin", url, name2));
    };
    var iconsLoadError = function(editor, url, name2) {
      logError(editor, "IconsLoadError", createLoadError("icons", url, name2));
    };
    var languageLoadError = function(editor, url, name2) {
      logError(editor, "LanguageLoadError", createLoadError("language", url, name2));
    };
    var pluginInitError = function(editor, name2, err) {
      var message = I18n.translate([
        "Failed to initialize plugin: {0}",
        name2
      ]);
      fireError(editor, "PluginLoadError", { message });
      initError(message, err);
      displayError(editor, message);
    };
    var initError = function(message) {
      var x = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        x[_i - 1] = arguments[_i];
      }
      var console2 = window.console;
      if (console2) {
        if (console2.error) {
          console2.error.apply(console2, __spreadArrays([message], x));
        } else {
          console2.log.apply(console2, __spreadArrays([message], x));
        }
      }
    };
    var isContentCssSkinName = function(url) {
      return /^[a-z0-9\-]+$/i.test(url);
    };
    var getContentCssUrls = function(editor) {
      return transformToUrls(editor, getContentCss(editor));
    };
    var getFontCssUrls = function(editor) {
      return transformToUrls(editor, getFontCss(editor));
    };
    var transformToUrls = function(editor, cssLinks) {
      var skinUrl = editor.editorManager.baseURL + "/skins/content";
      var suffix = editor.editorManager.suffix;
      var contentCssFile = "content" + suffix + ".css";
      var inline = editor.inline === true;
      return map(cssLinks, function(url) {
        if (isContentCssSkinName(url) && !inline) {
          return skinUrl + "/" + url + "/" + contentCssFile;
        } else {
          return editor.documentBaseURI.toAbsolute(url);
        }
      });
    };
    var appendContentCssFromSettings = function(editor) {
      editor.contentCSS = editor.contentCSS.concat(getContentCssUrls(editor), getFontCssUrls(editor));
    };
    var UploadStatus = function() {
      var PENDING = 1, UPLOADED = 2;
      var blobUriStatuses = {};
      var createStatus = function(status, resultUri) {
        return {
          status,
          resultUri
        };
      };
      var hasBlobUri = function(blobUri) {
        return blobUri in blobUriStatuses;
      };
      var getResultUri = function(blobUri) {
        var result = blobUriStatuses[blobUri];
        return result ? result.resultUri : null;
      };
      var isPending = function(blobUri) {
        return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === PENDING : false;
      };
      var isUploaded = function(blobUri) {
        return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === UPLOADED : false;
      };
      var markPending = function(blobUri) {
        blobUriStatuses[blobUri] = createStatus(PENDING, null);
      };
      var markUploaded = function(blobUri, resultUri) {
        blobUriStatuses[blobUri] = createStatus(UPLOADED, resultUri);
      };
      var removeFailed = function(blobUri) {
        delete blobUriStatuses[blobUri];
      };
      var destroy2 = function() {
        blobUriStatuses = {};
      };
      return {
        hasBlobUri,
        getResultUri,
        isPending,
        isUploaded,
        markPending,
        markUploaded,
        removeFailed,
        destroy: destroy2
      };
    };
    var count$1 = 0;
    var seed = function() {
      var rnd = function() {
        return Math.round(Math.random() * 4294967295).toString(36);
      };
      var now = new Date().getTime();
      return "s" + now.toString(36) + rnd() + rnd() + rnd();
    };
    var uuid2 = function(prefix) {
      return prefix + count$1++ + seed();
    };
    var BlobCache = function() {
      var cache = [];
      var mimeToExt = function(mime) {
        var mimes = {
          "image/jpeg": "jpg",
          "image/jpg": "jpg",
          "image/gif": "gif",
          "image/png": "png",
          "image/apng": "apng",
          "image/avif": "avif",
          "image/svg+xml": "svg",
          "image/webp": "webp",
          "image/bmp": "bmp",
          "image/tiff": "tiff"
        };
        return mimes[mime.toLowerCase()] || "dat";
      };
      var create2 = function(o, blob, base64, name2, filename) {
        if (isString(o)) {
          var id = o;
          return toBlobInfo({
            id,
            name: name2,
            filename,
            blob,
            base64
          });
        } else if (isObject(o)) {
          return toBlobInfo(o);
        } else {
          throw new Error("Unknown input type");
        }
      };
      var toBlobInfo = function(o) {
        if (!o.blob || !o.base64) {
          throw new Error("blob and base64 representations of the image are required for BlobInfo to be created");
        }
        var id = o.id || uuid2("blobid");
        var name2 = o.name || id;
        var blob = o.blob;
        return {
          id: constant(id),
          name: constant(name2),
          filename: constant(o.filename || name2 + "." + mimeToExt(blob.type)),
          blob: constant(blob),
          base64: constant(o.base64),
          blobUri: constant(o.blobUri || URL.createObjectURL(blob)),
          uri: constant(o.uri)
        };
      };
      var add2 = function(blobInfo) {
        if (!get2(blobInfo.id())) {
          cache.push(blobInfo);
        }
      };
      var findFirst = function(predicate) {
        return find(cache, predicate).getOrUndefined();
      };
      var get2 = function(id) {
        return findFirst(function(cachedBlobInfo) {
          return cachedBlobInfo.id() === id;
        });
      };
      var getByUri = function(blobUri) {
        return findFirst(function(blobInfo) {
          return blobInfo.blobUri() === blobUri;
        });
      };
      var getByData = function(base64, type2) {
        return findFirst(function(blobInfo) {
          return blobInfo.base64() === base64 && blobInfo.blob().type === type2;
        });
      };
      var removeByUri = function(blobUri) {
        cache = filter(cache, function(blobInfo) {
          if (blobInfo.blobUri() === blobUri) {
            URL.revokeObjectURL(blobInfo.blobUri());
            return false;
          }
          return true;
        });
      };
      var destroy2 = function() {
        each(cache, function(cachedBlobInfo) {
          URL.revokeObjectURL(cachedBlobInfo.blobUri());
        });
        cache = [];
      };
      return {
        create: create2,
        add: add2,
        get: get2,
        getByUri,
        getByData,
        findFirst,
        removeByUri,
        destroy: destroy2
      };
    };
    var Uploader = function(uploadStatus, settings) {
      var pendingPromises = {};
      var pathJoin = function(path1, path2) {
        if (path1) {
          return path1.replace(/\/$/, "") + "/" + path2.replace(/^\//, "");
        }
        return path2;
      };
      var defaultHandler = function(blobInfo, success, failure, progress) {
        var xhr = new XMLHttpRequest();
        xhr.open("POST", settings.url);
        xhr.withCredentials = settings.credentials;
        xhr.upload.onprogress = function(e) {
          progress(e.loaded / e.total * 100);
        };
        xhr.onerror = function() {
          failure("Image upload failed due to a XHR Transport error. Code: " + xhr.status);
        };
        xhr.onload = function() {
          if (xhr.status < 200 || xhr.status >= 300) {
            failure("HTTP Error: " + xhr.status);
            return;
          }
          var json = JSON.parse(xhr.responseText);
          if (!json || typeof json.location !== "string") {
            failure("Invalid JSON: " + xhr.responseText);
            return;
          }
          success(pathJoin(settings.basePath, json.location));
        };
        var formData = new FormData();
        formData.append("file", blobInfo.blob(), blobInfo.filename());
        xhr.send(formData);
      };
      var noUpload = function() {
        return new promiseObj(function(resolve2) {
          resolve2([]);
        });
      };
      var handlerSuccess = function(blobInfo, url) {
        return {
          url,
          blobInfo,
          status: true
        };
      };
      var handlerFailure = function(blobInfo, message, options) {
        return {
          url: "",
          blobInfo,
          status: false,
          error: {
            message,
            options
          }
        };
      };
      var resolvePending = function(blobUri, result) {
        Tools.each(pendingPromises[blobUri], function(resolve2) {
          resolve2(result);
        });
        delete pendingPromises[blobUri];
      };
      var uploadBlobInfo = function(blobInfo, handler, openNotification2) {
        uploadStatus.markPending(blobInfo.blobUri());
        return new promiseObj(function(resolve2) {
          var notification, progress;
          try {
            var closeNotification_1 = function() {
              if (notification) {
                notification.close();
                progress = noop;
              }
            };
            var success = function(url) {
              closeNotification_1();
              uploadStatus.markUploaded(blobInfo.blobUri(), url);
              resolvePending(blobInfo.blobUri(), handlerSuccess(blobInfo, url));
              resolve2(handlerSuccess(blobInfo, url));
            };
            var failure = function(error2, options) {
              var failureOptions = options ? options : {};
              closeNotification_1();
              uploadStatus.removeFailed(blobInfo.blobUri());
              resolvePending(blobInfo.blobUri(), handlerFailure(blobInfo, error2, failureOptions));
              resolve2(handlerFailure(blobInfo, error2, failureOptions));
            };
            progress = function(percent) {
              if (percent < 0 || percent > 100) {
                return;
              }
              Optional.from(notification).orThunk(function() {
                return Optional.from(openNotification2).map(apply);
              }).each(function(n) {
                notification = n;
                n.progressBar.value(percent);
              });
            };
            handler(blobInfo, success, failure, progress);
          } catch (ex) {
            resolve2(handlerFailure(blobInfo, ex.message, {}));
          }
        });
      };
      var isDefaultHandler = function(handler) {
        return handler === defaultHandler;
      };
      var pendingUploadBlobInfo = function(blobInfo) {
        var blobUri = blobInfo.blobUri();
        return new promiseObj(function(resolve2) {
          pendingPromises[blobUri] = pendingPromises[blobUri] || [];
          pendingPromises[blobUri].push(resolve2);
        });
      };
      var uploadBlobs = function(blobInfos, openNotification2) {
        blobInfos = Tools.grep(blobInfos, function(blobInfo) {
          return !uploadStatus.isUploaded(blobInfo.blobUri());
        });
        return promiseObj.all(Tools.map(blobInfos, function(blobInfo) {
          return uploadStatus.isPending(blobInfo.blobUri()) ? pendingUploadBlobInfo(blobInfo) : uploadBlobInfo(blobInfo, settings.handler, openNotification2);
        }));
      };
      var upload = function(blobInfos, openNotification2) {
        return !settings.url && isDefaultHandler(settings.handler) ? noUpload() : uploadBlobs(blobInfos, openNotification2);
      };
      if (isFunction(settings.handler) === false) {
        settings.handler = defaultHandler;
      }
      return { upload };
    };
    var openNotification = function(editor) {
      return function() {
        return editor.notificationManager.open({
          text: editor.translate("Image uploading..."),
          type: "info",
          timeout: -1,
          progressBar: true
        });
      };
    };
    var createUploader = function(editor, uploadStatus) {
      return Uploader(uploadStatus, {
        url: getImageUploadUrl(editor),
        basePath: getImageUploadBasePath(editor),
        credentials: getImagesUploadCredentials(editor),
        handler: getImagesUploadHandler(editor)
      });
    };
    var ImageUploader = function(editor) {
      var uploadStatus = UploadStatus();
      var uploader = createUploader(editor, uploadStatus);
      return {
        upload: function(blobInfos, showNotification) {
          if (showNotification === void 0) {
            showNotification = true;
          }
          return uploader.upload(blobInfos, showNotification ? openNotification(editor) : void 0);
        }
      };
    };
    var UploadChangeHandler = function(editor) {
      var lastChangedLevel = Cell(null);
      editor.on("change AddUndo", function(e) {
        lastChangedLevel.set(__assign2({}, e.level));
      });
      var fireIfChanged = function() {
        var data2 = editor.undoManager.data;
        last(data2).filter(function(level) {
          return !isEq$4(lastChangedLevel.get(), level);
        }).each(function(level) {
          editor.setDirty(true);
          editor.fire("change", {
            level,
            lastLevel: get(data2, data2.length - 2).getOrNull()
          });
        });
      };
      return { fireIfChanged };
    };
    var EditorUpload = function(editor) {
      var blobCache = BlobCache();
      var uploader, imageScanner;
      var uploadStatus = UploadStatus();
      var urlFilters = [];
      var changeHandler = UploadChangeHandler(editor);
      var aliveGuard = function(callback) {
        return function(result) {
          if (editor.selection) {
            return callback(result);
          }
          return [];
        };
      };
      var cacheInvalidator = function(url) {
        return url + (url.indexOf("?") === -1 ? "?" : "&") + new Date().getTime();
      };
      var replaceString = function(content, search2, replace) {
        var index = 0;
        do {
          index = content.indexOf(search2, index);
          if (index !== -1) {
            content = content.substring(0, index) + replace + content.substr(index + search2.length);
            index += replace.length - search2.length + 1;
          }
        } while (index !== -1);
        return content;
      };
      var replaceImageUrl = function(content, targetUrl, replacementUrl) {
        var replacementString = 'src="' + replacementUrl + '"' + (replacementUrl === Env.transparentSrc ? ' data-mce-placeholder="1"' : "");
        content = replaceString(content, 'src="' + targetUrl + '"', replacementString);
        content = replaceString(content, 'data-mce-src="' + targetUrl + '"', 'data-mce-src="' + replacementUrl + '"');
        return content;
      };
      var replaceUrlInUndoStack = function(targetUrl, replacementUrl) {
        each(editor.undoManager.data, function(level) {
          if (level.type === "fragmented") {
            level.fragments = map(level.fragments, function(fragment) {
              return replaceImageUrl(fragment, targetUrl, replacementUrl);
            });
          } else {
            level.content = replaceImageUrl(level.content, targetUrl, replacementUrl);
          }
        });
      };
      var replaceImageUriInView = function(image, resultUri) {
        var src = editor.convertURL(resultUri, "src");
        replaceUrlInUndoStack(image.src, resultUri);
        editor.$(image).attr({
          "src": shouldReuseFileName(editor) ? cacheInvalidator(resultUri) : resultUri,
          "data-mce-src": src
        });
      };
      var uploadImages = function(callback) {
        if (!uploader) {
          uploader = createUploader(editor, uploadStatus);
        }
        return scanForImages().then(aliveGuard(function(imageInfos) {
          var blobInfos = map(imageInfos, function(imageInfo) {
            return imageInfo.blobInfo;
          });
          return uploader.upload(blobInfos, openNotification(editor)).then(aliveGuard(function(result) {
            var imagesToRemove = [];
            var filteredResult = map(result, function(uploadInfo, index) {
              var blobInfo = imageInfos[index].blobInfo;
              var image = imageInfos[index].image;
              if (uploadInfo.status && shouldReplaceBlobUris(editor)) {
                blobCache.removeByUri(image.src);
                replaceImageUriInView(image, uploadInfo.url);
              } else if (uploadInfo.error) {
                if (uploadInfo.error.options.remove) {
                  replaceUrlInUndoStack(image.getAttribute("src"), Env.transparentSrc);
                  imagesToRemove.push(image);
                }
                uploadError(editor, uploadInfo.error.message);
              }
              return {
                element: image,
                status: uploadInfo.status,
                uploadUri: uploadInfo.url,
                blobInfo
              };
            });
            if (filteredResult.length > 0) {
              changeHandler.fireIfChanged();
            }
            if (imagesToRemove.length > 0) {
              if (isRtc(editor)) {
                console.error("Removing images on failed uploads is currently unsupported for RTC");
              } else {
                editor.undoManager.transact(function() {
                  each(imagesToRemove, function(element) {
                    editor.dom.remove(element);
                    blobCache.removeByUri(element.src);
                  });
                });
              }
            }
            if (callback) {
              callback(filteredResult);
            }
            return filteredResult;
          }));
        }));
      };
      var uploadImagesAuto = function(callback) {
        if (isAutomaticUploadsEnabled(editor)) {
          return uploadImages(callback);
        }
      };
      var isValidDataUriImage = function(imgElm) {
        if (forall(urlFilters, function(filter2) {
          return filter2(imgElm);
        }) === false) {
          return false;
        }
        if (imgElm.getAttribute("src").indexOf("data:") === 0) {
          var dataImgFilter = getImagesDataImgFilter(editor);
          return dataImgFilter(imgElm);
        }
        return true;
      };
      var addFilter = function(filter2) {
        urlFilters.push(filter2);
      };
      var scanForImages = function() {
        if (!imageScanner) {
          imageScanner = ImageScanner(uploadStatus, blobCache);
        }
        return imageScanner.findAll(editor.getBody(), isValidDataUriImage).then(aliveGuard(function(result) {
          result = filter(result, function(resultItem) {
            if (typeof resultItem === "string") {
              displayError(editor, resultItem);
              return false;
            }
            return true;
          });
          each(result, function(resultItem) {
            replaceUrlInUndoStack(resultItem.image.src, resultItem.blobInfo.blobUri());
            resultItem.image.src = resultItem.blobInfo.blobUri();
            resultItem.image.removeAttribute("data-mce-src");
          });
          return result;
        }));
      };
      var destroy2 = function() {
        blobCache.destroy();
        uploadStatus.destroy();
        imageScanner = uploader = null;
      };
      var replaceBlobUris = function(content) {
        return content.replace(/src="(blob:[^"]+)"/g, function(match2, blobUri) {
          var resultUri = uploadStatus.getResultUri(blobUri);
          if (resultUri) {
            return 'src="' + resultUri + '"';
          }
          var blobInfo = blobCache.getByUri(blobUri);
          if (!blobInfo) {
            blobInfo = foldl(editor.editorManager.get(), function(result, editor2) {
              return result || editor2.editorUpload && editor2.editorUpload.blobCache.getByUri(blobUri);
            }, null);
          }
          if (blobInfo) {
            var blob = blobInfo.blob();
            return 'src="data:' + blob.type + ";base64," + blobInfo.base64() + '"';
          }
          return match2;
        });
      };
      editor.on("SetContent", function() {
        if (isAutomaticUploadsEnabled(editor)) {
          uploadImagesAuto();
        } else {
          scanForImages();
        }
      });
      editor.on("RawSaveContent", function(e) {
        e.content = replaceBlobUris(e.content);
      });
      editor.on("GetContent", function(e) {
        if (e.source_view || e.format === "raw" || e.format === "tree") {
          return;
        }
        e.content = replaceBlobUris(e.content);
      });
      editor.on("PostRender", function() {
        editor.parser.addNodeFilter("img", function(images) {
          each(images, function(img) {
            var src = img.attr("src");
            if (blobCache.getByUri(src)) {
              return;
            }
            var resultUri = uploadStatus.getResultUri(src);
            if (resultUri) {
              img.attr("src", resultUri);
            }
          });
        });
      });
      return {
        blobCache,
        addFilter,
        uploadImages,
        uploadImagesAuto,
        scanForImages,
        destroy: destroy2
      };
    };
    var get$a = function(dom2) {
      var formats = {
        valigntop: [{
          selector: "td,th",
          styles: { verticalAlign: "top" }
        }],
        valignmiddle: [{
          selector: "td,th",
          styles: { verticalAlign: "middle" }
        }],
        valignbottom: [{
          selector: "td,th",
          styles: { verticalAlign: "bottom" }
        }],
        alignleft: [
          {
            selector: "figure.image",
            collapsed: false,
            classes: "align-left",
            ceFalseOverride: true,
            preview: "font-family font-size"
          },
          {
            selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li",
            styles: { textAlign: "left" },
            inherit: false,
            preview: false,
            defaultBlock: "div"
          },
          {
            selector: "img,table,audio,video",
            collapsed: false,
            styles: { float: "left" },
            preview: "font-family font-size"
          }
        ],
        aligncenter: [
          {
            selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li",
            styles: { textAlign: "center" },
            inherit: false,
            preview: "font-family font-size",
            defaultBlock: "div"
          },
          {
            selector: "figure.image",
            collapsed: false,
            classes: "align-center",
            ceFalseOverride: true,
            preview: "font-family font-size"
          },
          {
            selector: "img,audio,video",
            collapsed: false,
            styles: {
              display: "block",
              marginLeft: "auto",
              marginRight: "auto"
            },
            preview: false
          },
          {
            selector: "table",
            collapsed: false,
            styles: {
              marginLeft: "auto",
              marginRight: "auto"
            },
            preview: "font-family font-size"
          }
        ],
        alignright: [
          {
            selector: "figure.image",
            collapsed: false,
            classes: "align-right",
            ceFalseOverride: true,
            preview: "font-family font-size"
          },
          {
            selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li",
            styles: { textAlign: "right" },
            inherit: false,
            preview: "font-family font-size",
            defaultBlock: "div"
          },
          {
            selector: "img,table,audio,video",
            collapsed: false,
            styles: { float: "right" },
            preview: "font-family font-size"
          }
        ],
        alignjustify: [{
          selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li",
          styles: { textAlign: "justify" },
          inherit: false,
          defaultBlock: "div",
          preview: "font-family font-size"
        }],
        bold: [
          {
            inline: "strong",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          },
          {
            inline: "span",
            styles: { fontWeight: "bold" }
          },
          {
            inline: "b",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          }
        ],
        italic: [
          {
            inline: "em",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          },
          {
            inline: "span",
            styles: { fontStyle: "italic" }
          },
          {
            inline: "i",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          }
        ],
        underline: [
          {
            inline: "span",
            styles: { textDecoration: "underline" },
            exact: true
          },
          {
            inline: "u",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          }
        ],
        strikethrough: [
          {
            inline: "span",
            styles: { textDecoration: "line-through" },
            exact: true
          },
          {
            inline: "strike",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          },
          {
            inline: "s",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          }
        ],
        forecolor: {
          inline: "span",
          styles: { color: "%value" },
          links: true,
          remove_similar: true,
          clear_child_styles: true
        },
        hilitecolor: {
          inline: "span",
          styles: { backgroundColor: "%value" },
          links: true,
          remove_similar: true,
          clear_child_styles: true
        },
        fontname: {
          inline: "span",
          toggle: false,
          styles: { fontFamily: "%value" },
          clear_child_styles: true
        },
        fontsize: {
          inline: "span",
          toggle: false,
          styles: { fontSize: "%value" },
          clear_child_styles: true
        },
        lineheight: {
          selector: "h1,h2,h3,h4,h5,h6,p,li,td,th,div",
          defaultBlock: "p",
          styles: { lineHeight: "%value" }
        },
        fontsize_class: {
          inline: "span",
          attributes: { class: "%value" }
        },
        blockquote: {
          block: "blockquote",
          wrapper: true,
          remove: "all"
        },
        subscript: { inline: "sub" },
        superscript: { inline: "sup" },
        code: { inline: "code" },
        link: {
          inline: "a",
          selector: "a",
          remove: "all",
          split: true,
          deep: true,
          onmatch: function(node, _fmt, _itemName) {
            return isElement$1(node) && node.hasAttribute("href");
          },
          onformat: function(elm, _fmt, vars) {
            Tools.each(vars, function(value2, key) {
              dom2.setAttrib(elm, key, value2);
            });
          }
        },
        removeformat: [
          {
            selector: "b,strong,em,i,font,u,strike,s,sub,sup,dfn,code,samp,kbd,var,cite,mark,q,del,ins,small",
            remove: "all",
            split: true,
            expand: false,
            block_expand: true,
            deep: true
          },
          {
            selector: "span",
            attributes: [
              "style",
              "class"
            ],
            remove: "empty",
            split: true,
            expand: false,
            deep: true
          },
          {
            selector: "*",
            attributes: [
              "style",
              "class"
            ],
            split: false,
            expand: false,
            deep: true
          }
        ]
      };
      Tools.each("p h1 h2 h3 h4 h5 h6 div address pre dt dd samp".split(/\s/), function(name2) {
        formats[name2] = {
          block: name2,
          remove: "all"
        };
      });
      return formats;
    };
    var FormatRegistry = function(editor) {
      var formats = {};
      var get2 = function(name2) {
        return name2 ? formats[name2] : formats;
      };
      var has$12 = function(name2) {
        return has(formats, name2);
      };
      var register2 = function(name2, format) {
        if (name2) {
          if (typeof name2 !== "string") {
            Tools.each(name2, function(format2, name3) {
              register2(name3, format2);
            });
          } else {
            if (!isArray(format)) {
              format = [format];
            }
            Tools.each(format, function(format2) {
              if (typeof format2.deep === "undefined") {
                format2.deep = !format2.selector;
              }
              if (typeof format2.split === "undefined") {
                format2.split = !format2.selector || format2.inline;
              }
              if (typeof format2.remove === "undefined" && format2.selector && !format2.inline) {
                format2.remove = "none";
              }
              if (format2.selector && format2.inline) {
                format2.mixed = true;
                format2.block_expand = true;
              }
              if (typeof format2.classes === "string") {
                format2.classes = format2.classes.split(/\s+/);
              }
            });
            formats[name2] = format;
          }
        }
      };
      var unregister = function(name2) {
        if (name2 && formats[name2]) {
          delete formats[name2];
        }
        return formats;
      };
      register2(get$a(editor.dom));
      register2(getFormats(editor));
      return {
        get: get2,
        has: has$12,
        register: register2,
        unregister
      };
    };
    var each$e = Tools.each;
    var dom = DOMUtils.DOM;
    var parsedSelectorToHtml = function(ancestry, editor) {
      var elm, item, fragment;
      var schema = editor && editor.schema || Schema({});
      var decorate = function(elm2, item2) {
        if (item2.classes.length) {
          dom.addClass(elm2, item2.classes.join(" "));
        }
        dom.setAttribs(elm2, item2.attrs);
      };
      var createElement = function(sItem) {
        item = typeof sItem === "string" ? {
          name: sItem,
          classes: [],
          attrs: {}
        } : sItem;
        var elm2 = dom.create(item.name);
        decorate(elm2, item);
        return elm2;
      };
      var getRequiredParent = function(elm2, candidate) {
        var name2 = typeof elm2 !== "string" ? elm2.nodeName.toLowerCase() : elm2;
        var elmRule = schema.getElementRule(name2);
        var parentsRequired = elmRule && elmRule.parentsRequired;
        if (parentsRequired && parentsRequired.length) {
          return candidate && Tools.inArray(parentsRequired, candidate) !== -1 ? candidate : parentsRequired[0];
        } else {
          return false;
        }
      };
      var wrapInHtml = function(elm2, ancestry2, siblings2) {
        var parent2, parentCandidate;
        var ancestor2 = ancestry2.length > 0 && ancestry2[0];
        var ancestorName = ancestor2 && ancestor2.name;
        var parentRequired = getRequiredParent(elm2, ancestorName);
        if (parentRequired) {
          if (ancestorName === parentRequired) {
            parentCandidate = ancestry2[0];
            ancestry2 = ancestry2.slice(1);
          } else {
            parentCandidate = parentRequired;
          }
        } else if (ancestor2) {
          parentCandidate = ancestry2[0];
          ancestry2 = ancestry2.slice(1);
        } else if (!siblings2) {
          return elm2;
        }
        if (parentCandidate) {
          parent2 = createElement(parentCandidate);
          parent2.appendChild(elm2);
        }
        if (siblings2) {
          if (!parent2) {
            parent2 = dom.create("div");
            parent2.appendChild(elm2);
          }
          Tools.each(siblings2, function(sibling2) {
            var siblingElm = createElement(sibling2);
            parent2.insertBefore(siblingElm, elm2);
          });
        }
        return wrapInHtml(parent2, ancestry2, parentCandidate && parentCandidate.siblings);
      };
      if (ancestry && ancestry.length) {
        item = ancestry[0];
        elm = createElement(item);
        fragment = dom.create("div");
        fragment.appendChild(wrapInHtml(elm, ancestry.slice(1), item.siblings));
        return fragment;
      } else {
        return "";
      }
    };
    var parseSelectorItem = function(item) {
      var tagName;
      var obj = {
        classes: [],
        attrs: {}
      };
      item = obj.selector = Tools.trim(item);
      if (item !== "*") {
        tagName = item.replace(/(?:([#\.]|::?)([\w\-]+)|(\[)([^\]]+)\]?)/g, function($0, $1, $2, $3, $4) {
          switch ($1) {
            case "#":
              obj.attrs.id = $2;
              break;
            case ".":
              obj.classes.push($2);
              break;
            case ":":
              if (Tools.inArray("checked disabled enabled read-only required".split(" "), $2) !== -1) {
                obj.attrs[$2] = $2;
              }
              break;
          }
          if ($3 === "[") {
            var m = $4.match(/([\w\-]+)(?:\=\"([^\"]+))?/);
            if (m) {
              obj.attrs[m[1]] = m[2];
            }
          }
          return "";
        });
      }
      obj.name = tagName || "div";
      return obj;
    };
    var parseSelector = function(selector) {
      if (!selector || typeof selector !== "string") {
        return [];
      }
      selector = selector.split(/\s*,\s*/)[0];
      selector = selector.replace(/\s*(~\+|~|\+|>)\s*/g, "$1");
      return Tools.map(selector.split(/(?:>|\s+(?![^\[\]]+\]))/), function(item) {
        var siblings2 = Tools.map(item.split(/(?:~\+|~|\+)/), parseSelectorItem);
        var obj = siblings2.pop();
        if (siblings2.length) {
          obj.siblings = siblings2;
        }
        return obj;
      }).reverse();
    };
    var getCssText = function(editor, format) {
      var name2, previewFrag;
      var previewCss = "", parentFontSize;
      var previewStyles = getPreviewStyles(editor);
      if (previewStyles === "") {
        return "";
      }
      var removeVars = function(val) {
        return val.replace(/%(\w+)/g, "");
      };
      if (typeof format === "string") {
        format = editor.formatter.get(format);
        if (!format) {
          return;
        }
        format = format[0];
      }
      if ("preview" in format) {
        var previewOpt = get$1(format, "preview");
        if (previewOpt.is(false)) {
          return "";
        } else {
          previewStyles = previewOpt.getOr(previewStyles);
        }
      }
      name2 = format.block || format.inline || "span";
      var items = parseSelector(format.selector);
      if (items.length) {
        if (!items[0].name) {
          items[0].name = name2;
        }
        name2 = format.selector;
        previewFrag = parsedSelectorToHtml(items, editor);
      } else {
        previewFrag = parsedSelectorToHtml([name2], editor);
      }
      var previewElm = dom.select(name2, previewFrag)[0] || previewFrag.firstChild;
      each$e(format.styles, function(value2, name3) {
        var newValue = removeVars(value2);
        if (newValue) {
          dom.setStyle(previewElm, name3, newValue);
        }
      });
      each$e(format.attributes, function(value2, name3) {
        var newValue = removeVars(value2);
        if (newValue) {
          dom.setAttrib(previewElm, name3, newValue);
        }
      });
      each$e(format.classes, function(value2) {
        var newValue = removeVars(value2);
        if (!dom.hasClass(previewElm, newValue)) {
          dom.addClass(previewElm, newValue);
        }
      });
      editor.fire("PreviewFormats");
      dom.setStyles(previewFrag, {
        position: "absolute",
        left: -65535
      });
      editor.getBody().appendChild(previewFrag);
      parentFontSize = dom.getStyle(editor.getBody(), "fontSize", true);
      parentFontSize = /px$/.test(parentFontSize) ? parseInt(parentFontSize, 10) : 0;
      each$e(previewStyles.split(" "), function(name3) {
        var value2 = dom.getStyle(previewElm, name3, true);
        if (name3 === "background-color" && /transparent|rgba\s*\([^)]+,\s*0\)/.test(value2)) {
          value2 = dom.getStyle(editor.getBody(), name3, true);
          if (dom.toHex(value2).toLowerCase() === "#ffffff") {
            return;
          }
        }
        if (name3 === "color") {
          if (dom.toHex(value2).toLowerCase() === "#000000") {
            return;
          }
        }
        if (name3 === "font-size") {
          if (/em|%$/.test(value2)) {
            if (parentFontSize === 0) {
              return;
            }
            var numValue = parseFloat(value2) / (/%$/.test(value2) ? 100 : 1);
            value2 = numValue * parentFontSize + "px";
          }
        }
        if (name3 === "border" && value2) {
          previewCss += "padding:0 2px;";
        }
        previewCss += name3 + ":" + value2 + ";";
      });
      editor.fire("AfterPreviewFormats");
      dom.remove(previewFrag);
      return previewCss;
    };
    var setup$6 = function(editor) {
      editor.addShortcut("meta+b", "", "Bold");
      editor.addShortcut("meta+i", "", "Italic");
      editor.addShortcut("meta+u", "", "Underline");
      for (var i = 1; i <= 6; i++) {
        editor.addShortcut("access+" + i, "", [
          "FormatBlock",
          false,
          "h" + i
        ]);
      }
      editor.addShortcut("access+7", "", [
        "FormatBlock",
        false,
        "p"
      ]);
      editor.addShortcut("access+8", "", [
        "FormatBlock",
        false,
        "div"
      ]);
      editor.addShortcut("access+9", "", [
        "FormatBlock",
        false,
        "address"
      ]);
    };
    var Formatter = function(editor) {
      var formats = FormatRegistry(editor);
      var formatChangeState = Cell(null);
      setup$6(editor);
      setup$3(editor);
      return {
        get: formats.get,
        has: formats.has,
        register: formats.register,
        unregister: formats.unregister,
        apply: function(name2, vars, node) {
          applyFormat$1(editor, name2, vars, node);
        },
        remove: function(name2, vars, node, similar) {
          removeFormat$1(editor, name2, vars, node, similar);
        },
        toggle: function(name2, vars, node) {
          toggleFormat(editor, name2, vars, node);
        },
        match: function(name2, vars, node) {
          return matchFormat(editor, name2, vars, node);
        },
        closest: function(names) {
          return closestFormat(editor, names);
        },
        matchAll: function(names, vars) {
          return matchAllFormats(editor, names, vars);
        },
        matchNode: function(node, names, vars, similar) {
          return matchNodeFormat(editor, node, names, vars, similar);
        },
        canApply: function(name2) {
          return canApplyFormat(editor, name2);
        },
        formatChanged: function(formats2, callback, similar) {
          return formatChanged(editor, formatChangeState, formats2, callback, similar);
        },
        getCssText: curry(getCssText, editor)
      };
    };
    var registerEvents$1 = function(editor, undoManager, locks) {
      var isFirstTypedCharacter = Cell(false);
      var addNonTypingUndoLevel = function(e) {
        setTyping(undoManager, false, locks);
        undoManager.add({}, e);
      };
      editor.on("init", function() {
        undoManager.add();
      });
      editor.on("BeforeExecCommand", function(e) {
        var cmd = e.command.toLowerCase();
        if (cmd !== "undo" && cmd !== "redo" && cmd !== "mcerepaint") {
          endTyping(undoManager, locks);
          undoManager.beforeChange();
        }
      });
      editor.on("ExecCommand", function(e) {
        var cmd = e.command.toLowerCase();
        if (cmd !== "undo" && cmd !== "redo" && cmd !== "mcerepaint") {
          addNonTypingUndoLevel(e);
        }
      });
      editor.on("ObjectResizeStart cut", function() {
        undoManager.beforeChange();
      });
      editor.on("SaveContent ObjectResized blur", addNonTypingUndoLevel);
      editor.on("dragend", addNonTypingUndoLevel);
      editor.on("keyup", function(e) {
        var keyCode = e.keyCode;
        if (e.isDefaultPrevented()) {
          return;
        }
        if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || keyCode === 45 || e.ctrlKey) {
          addNonTypingUndoLevel();
          editor.nodeChanged();
        }
        if (keyCode === 46 || keyCode === 8) {
          editor.nodeChanged();
        }
        if (isFirstTypedCharacter.get() && undoManager.typing && isEq$4(createFromEditor(editor), undoManager.data[0]) === false) {
          if (editor.isDirty() === false) {
            editor.setDirty(true);
            editor.fire("change", {
              level: undoManager.data[0],
              lastLevel: null
            });
          }
          editor.fire("TypingUndo");
          isFirstTypedCharacter.set(false);
          editor.nodeChanged();
        }
      });
      editor.on("keydown", function(e) {
        var keyCode = e.keyCode;
        if (e.isDefaultPrevented()) {
          return;
        }
        if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || keyCode === 45) {
          if (undoManager.typing) {
            addNonTypingUndoLevel(e);
          }
          return;
        }
        var modKey = e.ctrlKey && !e.altKey || e.metaKey;
        if ((keyCode < 16 || keyCode > 20) && keyCode !== 224 && keyCode !== 91 && !undoManager.typing && !modKey) {
          undoManager.beforeChange();
          setTyping(undoManager, true, locks);
          undoManager.add({}, e);
          isFirstTypedCharacter.set(true);
        }
      });
      editor.on("mousedown", function(e) {
        if (undoManager.typing) {
          addNonTypingUndoLevel(e);
        }
      });
      var isInsertReplacementText = function(event) {
        return event.inputType === "insertReplacementText";
      };
      var isInsertTextDataNull = function(event) {
        return event.inputType === "insertText" && event.data === null;
      };
      var isInsertFromPasteOrDrop = function(event) {
        return event.inputType === "insertFromPaste" || event.inputType === "insertFromDrop";
      };
      editor.on("input", function(e) {
        if (e.inputType && (isInsertReplacementText(e) || isInsertTextDataNull(e) || isInsertFromPasteOrDrop(e))) {
          addNonTypingUndoLevel(e);
        }
      });
      editor.on("AddUndo Undo Redo ClearUndos", function(e) {
        if (!e.isDefaultPrevented()) {
          editor.nodeChanged();
        }
      });
    };
    var addKeyboardShortcuts = function(editor) {
      editor.addShortcut("meta+z", "", "Undo");
      editor.addShortcut("meta+y,meta+shift+z", "", "Redo");
    };
    var UndoManager = function(editor) {
      var beforeBookmark = Cell(Optional.none());
      var locks = Cell(0);
      var index = Cell(0);
      var undoManager = {
        data: [],
        typing: false,
        beforeChange: function() {
          beforeChange$1(editor, locks, beforeBookmark);
        },
        add: function(level, event) {
          return addUndoLevel$1(editor, undoManager, index, locks, beforeBookmark, level, event);
        },
        undo: function() {
          return undo$1(editor, undoManager, locks, index);
        },
        redo: function() {
          return redo$1(editor, index, undoManager.data);
        },
        clear: function() {
          clear$1(editor, undoManager, index);
        },
        reset: function() {
          reset$1(editor, undoManager);
        },
        hasUndo: function() {
          return hasUndo$1(editor, undoManager, index);
        },
        hasRedo: function() {
          return hasRedo$1(editor, undoManager, index);
        },
        transact: function(callback) {
          return transact$1(editor, undoManager, locks, callback);
        },
        ignore: function(callback) {
          ignore$1(editor, locks, callback);
        },
        extra: function(callback1, callback2) {
          extra$1(editor, undoManager, index, callback1, callback2);
        }
      };
      if (!isRtc(editor)) {
        registerEvents$1(editor, undoManager, locks);
      }
      addKeyboardShortcuts(editor);
      return undoManager;
    };
    var nonTypingKeycodes = [
      9,
      27,
      VK.HOME,
      VK.END,
      19,
      20,
      44,
      144,
      145,
      33,
      34,
      45,
      16,
      17,
      18,
      91,
      92,
      93,
      VK.DOWN,
      VK.UP,
      VK.LEFT,
      VK.RIGHT
    ].concat(Env.browser.isFirefox() ? [224] : []);
    var placeholderAttr = "data-mce-placeholder";
    var isKeyboardEvent = function(e) {
      return e.type === "keydown" || e.type === "keyup";
    };
    var isDeleteEvent = function(e) {
      var keyCode = e.keyCode;
      return keyCode === VK.BACKSPACE || keyCode === VK.DELETE;
    };
    var isNonTypingKeyboardEvent = function(e) {
      if (isKeyboardEvent(e)) {
        var keyCode = e.keyCode;
        return !isDeleteEvent(e) && (VK.metaKeyPressed(e) || e.altKey || keyCode >= 112 && keyCode <= 123 || contains(nonTypingKeycodes, keyCode));
      } else {
        return false;
      }
    };
    var isTypingKeyboardEvent = function(e) {
      return isKeyboardEvent(e) && !(isDeleteEvent(e) || e.type === "keyup" && e.keyCode === 229);
    };
    var isVisuallyEmpty = function(dom2, rootElm, forcedRootBlock) {
      if (isEmpty(SugarElement.fromDom(rootElm), false)) {
        var isForcedRootBlockFalse = forcedRootBlock === "";
        var firstElement2 = rootElm.firstElementChild;
        if (!firstElement2) {
          return true;
        } else if (dom2.getStyle(rootElm.firstElementChild, "padding-left") || dom2.getStyle(rootElm.firstElementChild, "padding-right")) {
          return false;
        } else {
          return isForcedRootBlockFalse ? !dom2.isBlock(firstElement2) : forcedRootBlock === firstElement2.nodeName.toLowerCase();
        }
      } else {
        return false;
      }
    };
    var setup$7 = function(editor) {
      var dom2 = editor.dom;
      var rootBlock = getForcedRootBlock(editor);
      var placeholder = getPlaceholder(editor);
      var updatePlaceholder = function(e, initial) {
        if (isNonTypingKeyboardEvent(e)) {
          return;
        }
        var body = editor.getBody();
        var showPlaceholder = isTypingKeyboardEvent(e) ? false : isVisuallyEmpty(dom2, body, rootBlock);
        var isPlaceholderShown = dom2.getAttrib(body, placeholderAttr) !== "";
        if (isPlaceholderShown !== showPlaceholder || initial) {
          dom2.setAttrib(body, placeholderAttr, showPlaceholder ? placeholder : null);
          dom2.setAttrib(body, "aria-placeholder", showPlaceholder ? placeholder : null);
          firePlaceholderToggle(editor, showPlaceholder);
          editor.on(showPlaceholder ? "keydown" : "keyup", updatePlaceholder);
          editor.off(showPlaceholder ? "keyup" : "keydown", updatePlaceholder);
        }
      };
      if (placeholder) {
        editor.on("init", function(e) {
          updatePlaceholder(e, true);
          editor.on("change SetContent ExecCommand", updatePlaceholder);
          editor.on("paste", function(e2) {
            return Delay.setEditorTimeout(editor, function() {
              return updatePlaceholder(e2);
            });
          });
        });
      }
    };
    var strongRtl = /[\u0591-\u07FF\uFB1D-\uFDFF\uFE70-\uFEFC]/;
    var hasStrongRtl = function(text) {
      return strongRtl.test(text);
    };
    var isInlineTarget = function(editor, elm) {
      return is$1(SugarElement.fromDom(elm), getInlineBoundarySelector(editor));
    };
    var isRtl$1 = function(element) {
      return DOMUtils.DOM.getStyle(element, "direction", true) === "rtl" || hasStrongRtl(element.textContent);
    };
    var findInlineParents = function(isInlineTarget2, rootNode, pos) {
      return filter(DOMUtils.DOM.getParents(pos.container(), "*", rootNode), isInlineTarget2);
    };
    var findRootInline = function(isInlineTarget2, rootNode, pos) {
      var parents2 = findInlineParents(isInlineTarget2, rootNode, pos);
      return Optional.from(parents2[parents2.length - 1]);
    };
    var hasSameParentBlock = function(rootNode, node1, node2) {
      var block1 = getParentBlock(node1, rootNode);
      var block2 = getParentBlock(node2, rootNode);
      return block1 && block1 === block2;
    };
    var isAtZwsp = function(pos) {
      return isBeforeInline(pos) || isAfterInline(pos);
    };
    var normalizePosition = function(forward, pos) {
      if (!pos) {
        return pos;
      }
      var container = pos.container(), offset = pos.offset();
      if (forward) {
        if (isCaretContainerInline(container)) {
          if (isText$1(container.nextSibling)) {
            return CaretPosition(container.nextSibling, 0);
          } else {
            return CaretPosition.after(container);
          }
        } else {
          return isBeforeInline(pos) ? CaretPosition(container, offset + 1) : pos;
        }
      } else {
        if (isCaretContainerInline(container)) {
          if (isText$1(container.previousSibling)) {
            return CaretPosition(container.previousSibling, container.previousSibling.data.length);
          } else {
            return CaretPosition.before(container);
          }
        } else {
          return isAfterInline(pos) ? CaretPosition(container, offset - 1) : pos;
        }
      }
    };
    var normalizeForwards = curry(normalizePosition, true);
    var normalizeBackwards = curry(normalizePosition, false);
    var isBeforeRoot = function(rootNode) {
      return function(elm) {
        return eq$2(rootNode, SugarElement.fromDom(elm.dom.parentNode));
      };
    };
    var getParentBlock$1 = function(rootNode, elm) {
      return contains$2(rootNode, elm) ? closest(elm, function(element) {
        return isTextBlock(element) || isListItem(element);
      }, isBeforeRoot(rootNode)) : Optional.none();
    };
    var placeCaretInEmptyBody = function(editor) {
      var body = editor.getBody();
      var node = body.firstChild && editor.dom.isBlock(body.firstChild) ? body.firstChild : body;
      editor.selection.setCursorLocation(node, 0);
    };
    var paddEmptyBody = function(editor) {
      if (editor.dom.isEmpty(editor.getBody())) {
        editor.setContent("");
        placeCaretInEmptyBody(editor);
      }
    };
    var willDeleteLastPositionInElement = function(forward, fromPos, elm) {
      return lift2(firstPositionIn(elm), lastPositionIn(elm), function(firstPos, lastPos) {
        var normalizedFirstPos = normalizePosition(true, firstPos);
        var normalizedLastPos = normalizePosition(false, lastPos);
        var normalizedFromPos = normalizePosition(false, fromPos);
        if (forward) {
          return nextPosition(elm, normalizedFromPos).exists(function(nextPos) {
            return nextPos.isEqual(normalizedLastPos) && fromPos.isEqual(normalizedFirstPos);
          });
        } else {
          return prevPosition(elm, normalizedFromPos).exists(function(prevPos) {
            return prevPos.isEqual(normalizedFirstPos) && fromPos.isEqual(normalizedLastPos);
          });
        }
      }).getOr(true);
    };
    var blockPosition = function(block, position) {
      return {
        block,
        position
      };
    };
    var blockBoundary = function(from2, to2) {
      return {
        from: from2,
        to: to2
      };
    };
    var getBlockPosition = function(rootNode, pos) {
      var rootElm = SugarElement.fromDom(rootNode);
      var containerElm = SugarElement.fromDom(pos.container());
      return getParentBlock$1(rootElm, containerElm).map(function(block) {
        return blockPosition(block, pos);
      });
    };
    var isDifferentBlocks = function(blockBoundary2) {
      return eq$2(blockBoundary2.from.block, blockBoundary2.to.block) === false;
    };
    var hasSameParent = function(blockBoundary2) {
      return parent(blockBoundary2.from.block).bind(function(parent1) {
        return parent(blockBoundary2.to.block).filter(function(parent2) {
          return eq$2(parent1, parent2);
        });
      }).isSome();
    };
    var isEditable = function(blockBoundary2) {
      return isContentEditableFalse(blockBoundary2.from.block.dom) === false && isContentEditableFalse(blockBoundary2.to.block.dom) === false;
    };
    var skipLastBr = function(rootNode, forward, blockPosition2) {
      if (isBr(blockPosition2.position.getNode()) && isEmpty(blockPosition2.block) === false) {
        return positionIn(false, blockPosition2.block.dom).bind(function(lastPositionInBlock) {
          if (lastPositionInBlock.isEqual(blockPosition2.position)) {
            return fromPosition(forward, rootNode, lastPositionInBlock).bind(function(to2) {
              return getBlockPosition(rootNode, to2);
            });
          } else {
            return Optional.some(blockPosition2);
          }
        }).getOr(blockPosition2);
      } else {
        return blockPosition2;
      }
    };
    var readFromRange = function(rootNode, forward, rng) {
      var fromBlockPos = getBlockPosition(rootNode, CaretPosition.fromRangeStart(rng));
      var toBlockPos = fromBlockPos.bind(function(blockPos) {
        return fromPosition(forward, rootNode, blockPos.position).bind(function(to2) {
          return getBlockPosition(rootNode, to2).map(function(blockPos2) {
            return skipLastBr(rootNode, forward, blockPos2);
          });
        });
      });
      return lift2(fromBlockPos, toBlockPos, blockBoundary).filter(function(blockBoundary2) {
        return isDifferentBlocks(blockBoundary2) && hasSameParent(blockBoundary2) && isEditable(blockBoundary2);
      });
    };
    var read$3 = function(rootNode, forward, rng) {
      return rng.collapsed ? readFromRange(rootNode, forward, rng) : Optional.none();
    };
    var getChildrenUntilBlockBoundary = function(block) {
      var children$1 = children(block);
      return findIndex(children$1, isBlock).fold(function() {
        return children$1;
      }, function(index) {
        return children$1.slice(0, index);
      });
    };
    var extractChildren = function(block) {
      var children2 = getChildrenUntilBlockBoundary(block);
      each(children2, remove);
      return children2;
    };
    var removeEmptyRoot = function(rootNode, block) {
      var parents2 = parentsAndSelf(block, rootNode);
      return find(parents2.reverse(), function(element) {
        return isEmpty(element);
      }).each(remove);
    };
    var isEmptyBefore = function(el) {
      return filter(prevSiblings(el), function(el2) {
        return !isEmpty(el2);
      }).length === 0;
    };
    var nestedBlockMerge = function(rootNode, fromBlock, toBlock, insertionPoint) {
      if (isEmpty(toBlock)) {
        fillWithPaddingBr(toBlock);
        return firstPositionIn(toBlock.dom);
      }
      if (isEmptyBefore(insertionPoint) && isEmpty(fromBlock)) {
        before(insertionPoint, SugarElement.fromTag("br"));
      }
      var position = prevPosition(toBlock.dom, CaretPosition.before(insertionPoint.dom));
      each(extractChildren(fromBlock), function(child2) {
        before(insertionPoint, child2);
      });
      removeEmptyRoot(rootNode, fromBlock);
      return position;
    };
    var sidelongBlockMerge = function(rootNode, fromBlock, toBlock) {
      if (isEmpty(toBlock)) {
        remove(toBlock);
        if (isEmpty(fromBlock)) {
          fillWithPaddingBr(fromBlock);
        }
        return firstPositionIn(fromBlock.dom);
      }
      var position = lastPositionIn(toBlock.dom);
      each(extractChildren(fromBlock), function(child2) {
        append(toBlock, child2);
      });
      removeEmptyRoot(rootNode, fromBlock);
      return position;
    };
    var findInsertionPoint = function(toBlock, block) {
      var parentsAndSelf$1 = parentsAndSelf(block, toBlock);
      return Optional.from(parentsAndSelf$1[parentsAndSelf$1.length - 1]);
    };
    var getInsertionPoint = function(fromBlock, toBlock) {
      return contains$2(toBlock, fromBlock) ? findInsertionPoint(toBlock, fromBlock) : Optional.none();
    };
    var trimBr = function(first2, block) {
      positionIn(first2, block.dom).map(function(position) {
        return position.getNode();
      }).map(SugarElement.fromDom).filter(isBr$1).each(remove);
    };
    var mergeBlockInto = function(rootNode, fromBlock, toBlock) {
      trimBr(true, fromBlock);
      trimBr(false, toBlock);
      return getInsertionPoint(fromBlock, toBlock).fold(curry(sidelongBlockMerge, rootNode, fromBlock, toBlock), curry(nestedBlockMerge, rootNode, fromBlock, toBlock));
    };
    var mergeBlocks = function(rootNode, forward, block1, block2) {
      return forward ? mergeBlockInto(rootNode, block2, block1) : mergeBlockInto(rootNode, block1, block2);
    };
    var backspaceDelete$1 = function(editor, forward) {
      var rootNode = SugarElement.fromDom(editor.getBody());
      var position = read$3(rootNode.dom, forward, editor.selection.getRng()).bind(function(blockBoundary2) {
        return mergeBlocks(rootNode, forward, blockBoundary2.from.block, blockBoundary2.to.block);
      });
      position.each(function(pos) {
        editor.selection.setRng(pos.toRange());
      });
      return position.isSome();
    };
    var deleteRangeMergeBlocks = function(rootNode, selection) {
      var rng = selection.getRng();
      return lift2(getParentBlock$1(rootNode, SugarElement.fromDom(rng.startContainer)), getParentBlock$1(rootNode, SugarElement.fromDom(rng.endContainer)), function(block1, block2) {
        if (eq$2(block1, block2) === false) {
          rng.deleteContents();
          mergeBlocks(rootNode, true, block1, block2).each(function(pos) {
            selection.setRng(pos.toRange());
          });
          return true;
        } else {
          return false;
        }
      }).getOr(false);
    };
    var isRawNodeInTable = function(root, rawNode) {
      var node = SugarElement.fromDom(rawNode);
      var isRoot = curry(eq$2, root);
      return ancestor(node, isTableCell$1, isRoot).isSome();
    };
    var isSelectionInTable = function(root, rng) {
      return isRawNodeInTable(root, rng.startContainer) || isRawNodeInTable(root, rng.endContainer);
    };
    var isEverythingSelected = function(root, rng) {
      var noPrevious = prevPosition(root.dom, CaretPosition.fromRangeStart(rng)).isNone();
      var noNext = nextPosition(root.dom, CaretPosition.fromRangeEnd(rng)).isNone();
      return !isSelectionInTable(root, rng) && noPrevious && noNext;
    };
    var emptyEditor = function(editor) {
      editor.setContent("");
      editor.selection.setCursorLocation();
      return true;
    };
    var deleteRange$1 = function(editor) {
      var rootNode = SugarElement.fromDom(editor.getBody());
      var rng = editor.selection.getRng();
      return isEverythingSelected(rootNode, rng) ? emptyEditor(editor) : deleteRangeMergeBlocks(rootNode, editor.selection);
    };
    var backspaceDelete$2 = function(editor, _forward) {
      return editor.selection.isCollapsed() ? false : deleteRange$1(editor);
    };
    var isContentEditableTrue$2 = isContentEditableTrue;
    var isContentEditableFalse$7 = isContentEditableFalse;
    var showCaret = function(direction, editor, node, before2, scrollIntoView) {
      return Optional.from(editor._selectionOverrides.showCaret(direction, node, before2, scrollIntoView));
    };
    var getNodeRange = function(node) {
      var rng = node.ownerDocument.createRange();
      rng.selectNode(node);
      return rng;
    };
    var selectNode = function(editor, node) {
      var e = editor.fire("BeforeObjectSelected", { target: node });
      if (e.isDefaultPrevented()) {
        return Optional.none();
      }
      return Optional.some(getNodeRange(node));
    };
    var renderCaretAtRange = function(editor, range2, scrollIntoView) {
      var normalizedRange = normalizeRange(1, editor.getBody(), range2);
      var caretPosition = CaretPosition.fromRangeStart(normalizedRange);
      var caretPositionNode = caretPosition.getNode();
      if (isInlineFakeCaretTarget(caretPositionNode)) {
        return showCaret(1, editor, caretPositionNode, !caretPosition.isAtEnd(), false);
      }
      var caretPositionBeforeNode = caretPosition.getNode(true);
      if (isInlineFakeCaretTarget(caretPositionBeforeNode)) {
        return showCaret(1, editor, caretPositionBeforeNode, false, false);
      }
      var ceRoot = editor.dom.getParent(caretPosition.getNode(), function(node) {
        return isContentEditableFalse$7(node) || isContentEditableTrue$2(node);
      });
      if (isInlineFakeCaretTarget(ceRoot)) {
        return showCaret(1, editor, ceRoot, false, scrollIntoView);
      }
      return Optional.none();
    };
    var renderRangeCaret = function(editor, range2, scrollIntoView) {
      return range2.collapsed ? renderCaretAtRange(editor, range2, scrollIntoView).getOr(range2) : range2;
    };
    var isBeforeBoundary = function(pos) {
      return isBeforeContentEditableFalse(pos) || isBeforeMedia(pos);
    };
    var isAfterBoundary = function(pos) {
      return isAfterContentEditableFalse(pos) || isAfterMedia(pos);
    };
    var trimEmptyTextNode$1 = function(dom2, node) {
      if (isText$1(node) && node.data.length === 0) {
        dom2.remove(node);
      }
    };
    var deleteContentAndShowCaret = function(editor, range2, node, direction, forward, peekCaretPosition) {
      showCaret(direction, editor, peekCaretPosition.getNode(!forward), forward, true).each(function(caretRange) {
        if (range2.collapsed) {
          var deleteRange2 = range2.cloneRange();
          if (forward) {
            deleteRange2.setEnd(caretRange.startContainer, caretRange.startOffset);
          } else {
            deleteRange2.setStart(caretRange.endContainer, caretRange.endOffset);
          }
          deleteRange2.deleteContents();
        } else {
          range2.deleteContents();
        }
        editor.selection.setRng(caretRange);
      });
      trimEmptyTextNode$1(editor.dom, node);
      return true;
    };
    var deleteBoundaryText = function(editor, forward) {
      var range2 = editor.selection.getRng();
      if (!isText$1(range2.commonAncestorContainer)) {
        return false;
      }
      var direction = forward ? HDirection.Forwards : HDirection.Backwards;
      var caretWalker = CaretWalker(editor.getBody());
      var getNextPosFn = curry(getVisualCaretPosition, forward ? caretWalker.next : caretWalker.prev);
      var isBeforeFn = forward ? isBeforeBoundary : isAfterBoundary;
      var caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range2);
      var nextCaretPosition = normalizePosition(forward, getNextPosFn(caretPosition));
      if (!nextCaretPosition || !isMoveInsideSameBlock(caretPosition, nextCaretPosition)) {
        return false;
      } else if (isBeforeFn(nextCaretPosition)) {
        return deleteContentAndShowCaret(editor, range2, caretPosition.getNode(), direction, forward, nextCaretPosition);
      }
      var peekCaretPosition = getNextPosFn(nextCaretPosition);
      if (peekCaretPosition && isBeforeFn(peekCaretPosition)) {
        if (isMoveInsideSameBlock(nextCaretPosition, peekCaretPosition)) {
          return deleteContentAndShowCaret(editor, range2, caretPosition.getNode(), direction, forward, peekCaretPosition);
        }
      }
      return false;
    };
    var backspaceDelete$3 = function(editor, forward) {
      return deleteBoundaryText(editor, forward);
    };
    var isCompoundElement = function(node) {
      return isTableCell$1(SugarElement.fromDom(node)) || isListItem(SugarElement.fromDom(node));
    };
    var DeleteAction = Adt.generate([
      { remove: ["element"] },
      { moveToElement: ["element"] },
      { moveToPosition: ["position"] }
    ]);
    var isAtContentEditableBlockCaret = function(forward, from2) {
      var elm = from2.getNode(forward === false);
      var caretLocation = forward ? "after" : "before";
      return isElement$1(elm) && elm.getAttribute("data-mce-caret") === caretLocation;
    };
    var isDeleteFromCefDifferentBlocks = function(root, forward, from2, to2) {
      var inSameBlock = function(elm) {
        return isInline(SugarElement.fromDom(elm)) && !isInSameBlock(from2, to2, root);
      };
      return getRelativeCefElm(!forward, from2).fold(function() {
        return getRelativeCefElm(forward, to2).fold(never, inSameBlock);
      }, inSameBlock);
    };
    var deleteEmptyBlockOrMoveToCef = function(root, forward, from2, to2) {
      var toCefElm = to2.getNode(forward === false);
      return getParentBlock$1(SugarElement.fromDom(root), SugarElement.fromDom(from2.getNode())).map(function(blockElm) {
        return isEmpty(blockElm) ? DeleteAction.remove(blockElm.dom) : DeleteAction.moveToElement(toCefElm);
      }).orThunk(function() {
        return Optional.some(DeleteAction.moveToElement(toCefElm));
      });
    };
    var findCefPosition = function(root, forward, from2) {
      return fromPosition(forward, root, from2).bind(function(to2) {
        if (isCompoundElement(to2.getNode())) {
          return Optional.none();
        } else if (isDeleteFromCefDifferentBlocks(root, forward, from2, to2)) {
          return Optional.none();
        } else if (forward && isContentEditableFalse(to2.getNode())) {
          return deleteEmptyBlockOrMoveToCef(root, forward, from2, to2);
        } else if (forward === false && isContentEditableFalse(to2.getNode(true))) {
          return deleteEmptyBlockOrMoveToCef(root, forward, from2, to2);
        } else if (forward && isAfterContentEditableFalse(from2)) {
          return Optional.some(DeleteAction.moveToPosition(to2));
        } else if (forward === false && isBeforeContentEditableFalse(from2)) {
          return Optional.some(DeleteAction.moveToPosition(to2));
        } else {
          return Optional.none();
        }
      });
    };
    var getContentEditableBlockAction = function(forward, elm) {
      if (forward && isContentEditableFalse(elm.nextSibling)) {
        return Optional.some(DeleteAction.moveToElement(elm.nextSibling));
      } else if (forward === false && isContentEditableFalse(elm.previousSibling)) {
        return Optional.some(DeleteAction.moveToElement(elm.previousSibling));
      } else {
        return Optional.none();
      }
    };
    var skipMoveToActionFromInlineCefToContent = function(root, from2, deleteAction2) {
      return deleteAction2.fold(function(elm) {
        return Optional.some(DeleteAction.remove(elm));
      }, function(elm) {
        return Optional.some(DeleteAction.moveToElement(elm));
      }, function(to2) {
        if (isInSameBlock(from2, to2, root)) {
          return Optional.none();
        } else {
          return Optional.some(DeleteAction.moveToPosition(to2));
        }
      });
    };
    var getContentEditableAction = function(root, forward, from2) {
      if (isAtContentEditableBlockCaret(forward, from2)) {
        return getContentEditableBlockAction(forward, from2.getNode(forward === false)).fold(function() {
          return findCefPosition(root, forward, from2);
        }, Optional.some);
      } else {
        return findCefPosition(root, forward, from2).bind(function(deleteAction2) {
          return skipMoveToActionFromInlineCefToContent(root, from2, deleteAction2);
        });
      }
    };
    var read$4 = function(root, forward, rng) {
      var normalizedRange = normalizeRange(forward ? 1 : -1, root, rng);
      var from2 = CaretPosition.fromRangeStart(normalizedRange);
      var rootElement = SugarElement.fromDom(root);
      if (forward === false && isAfterContentEditableFalse(from2)) {
        return Optional.some(DeleteAction.remove(from2.getNode(true)));
      } else if (forward && isBeforeContentEditableFalse(from2)) {
        return Optional.some(DeleteAction.remove(from2.getNode()));
      } else if (forward === false && isBeforeContentEditableFalse(from2) && isAfterBr(rootElement, from2)) {
        return findPreviousBr(rootElement, from2).map(function(br) {
          return DeleteAction.remove(br.getNode());
        });
      } else if (forward && isAfterContentEditableFalse(from2) && isBeforeBr(rootElement, from2)) {
        return findNextBr(rootElement, from2).map(function(br) {
          return DeleteAction.remove(br.getNode());
        });
      } else {
        return getContentEditableAction(root, forward, from2);
      }
    };
    var deleteElement$1 = function(editor, forward) {
      return function(element) {
        editor._selectionOverrides.hideFakeCaret();
        deleteElement(editor, forward, SugarElement.fromDom(element));
        return true;
      };
    };
    var moveToElement = function(editor, forward) {
      return function(element) {
        var pos = forward ? CaretPosition.before(element) : CaretPosition.after(element);
        editor.selection.setRng(pos.toRange());
        return true;
      };
    };
    var moveToPosition = function(editor) {
      return function(pos) {
        editor.selection.setRng(pos.toRange());
        return true;
      };
    };
    var getAncestorCe = function(editor, node) {
      return Optional.from(getContentEditableRoot(editor.getBody(), node));
    };
    var backspaceDeleteCaret = function(editor, forward) {
      var selectedNode = editor.selection.getNode();
      return getAncestorCe(editor, selectedNode).filter(isContentEditableFalse).fold(function() {
        return read$4(editor.getBody(), forward, editor.selection.getRng()).exists(function(deleteAction2) {
          return deleteAction2.fold(deleteElement$1(editor, forward), moveToElement(editor, forward), moveToPosition(editor));
        });
      }, always);
    };
    var deleteOffscreenSelection = function(rootElement) {
      each(descendants$1(rootElement, ".mce-offscreen-selection"), remove);
    };
    var backspaceDeleteRange = function(editor, forward) {
      var selectedNode = editor.selection.getNode();
      if (isContentEditableFalse(selectedNode)) {
        var hasCefAncestor = getAncestorCe(editor, selectedNode.parentNode).filter(isContentEditableFalse);
        return hasCefAncestor.fold(function() {
          deleteOffscreenSelection(SugarElement.fromDom(editor.getBody()));
          deleteElement(editor, forward, SugarElement.fromDom(editor.selection.getNode()));
          paddEmptyBody(editor);
          return true;
        }, always);
      }
      return false;
    };
    var paddEmptyElement = function(editor) {
      var dom2 = editor.dom, selection = editor.selection;
      var ceRoot = getContentEditableRoot(editor.getBody(), selection.getNode());
      if (isContentEditableTrue(ceRoot) && dom2.isBlock(ceRoot) && dom2.isEmpty(ceRoot)) {
        var br = dom2.create("br", { "data-mce-bogus": "1" });
        dom2.setHTML(ceRoot, "");
        ceRoot.appendChild(br);
        selection.setRng(CaretPosition.before(br).toRange());
      }
      return true;
    };
    var backspaceDelete$4 = function(editor, forward) {
      if (editor.selection.isCollapsed()) {
        return backspaceDeleteCaret(editor, forward);
      } else {
        return backspaceDeleteRange(editor, forward);
      }
    };
    var deleteCaret$1 = function(editor, forward) {
      var fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());
      return fromPosition(forward, editor.getBody(), fromPos).filter(function(pos) {
        return forward ? isBeforeImageBlock(pos) : isAfterImageBlock(pos);
      }).bind(function(pos) {
        return Optional.from(getChildNodeAtRelativeOffset(forward ? 0 : -1, pos));
      }).exists(function(elm) {
        editor.selection.select(elm);
        return true;
      });
    };
    var backspaceDelete$5 = function(editor, forward) {
      return editor.selection.isCollapsed() ? deleteCaret$1(editor, forward) : false;
    };
    var isText$8 = isText$1;
    var startsWithCaretContainer$1 = function(node) {
      return isText$8(node) && node.data[0] === ZWSP;
    };
    var endsWithCaretContainer$1 = function(node) {
      return isText$8(node) && node.data[node.data.length - 1] === ZWSP;
    };
    var createZwsp = function(node) {
      return node.ownerDocument.createTextNode(ZWSP);
    };
    var insertBefore$1 = function(node) {
      if (isText$8(node.previousSibling)) {
        if (endsWithCaretContainer$1(node.previousSibling)) {
          return node.previousSibling;
        } else {
          node.previousSibling.appendData(ZWSP);
          return node.previousSibling;
        }
      } else if (isText$8(node)) {
        if (startsWithCaretContainer$1(node)) {
          return node;
        } else {
          node.insertData(0, ZWSP);
          return node;
        }
      } else {
        var newNode = createZwsp(node);
        node.parentNode.insertBefore(newNode, node);
        return newNode;
      }
    };
    var insertAfter$1 = function(node) {
      if (isText$8(node.nextSibling)) {
        if (startsWithCaretContainer$1(node.nextSibling)) {
          return node.nextSibling;
        } else {
          node.nextSibling.insertData(0, ZWSP);
          return node.nextSibling;
        }
      } else if (isText$8(node)) {
        if (endsWithCaretContainer$1(node)) {
          return node;
        } else {
          node.appendData(ZWSP);
          return node;
        }
      } else {
        var newNode = createZwsp(node);
        if (node.nextSibling) {
          node.parentNode.insertBefore(newNode, node.nextSibling);
        } else {
          node.parentNode.appendChild(newNode);
        }
        return newNode;
      }
    };
    var insertInline$1 = function(before2, node) {
      return before2 ? insertBefore$1(node) : insertAfter$1(node);
    };
    var insertInlineBefore = curry(insertInline$1, true);
    var insertInlineAfter = curry(insertInline$1, false);
    var insertInlinePos = function(pos, before2) {
      if (isText$1(pos.container())) {
        return insertInline$1(before2, pos.container());
      } else {
        return insertInline$1(before2, pos.getNode());
      }
    };
    var isPosCaretContainer = function(pos, caret) {
      var caretNode = caret.get();
      return caretNode && pos.container() === caretNode && isCaretContainerInline(caretNode);
    };
    var renderCaret = function(caret, location) {
      return location.fold(function(element) {
        remove$5(caret.get());
        var text = insertInlineBefore(element);
        caret.set(text);
        return Optional.some(CaretPosition(text, text.length - 1));
      }, function(element) {
        return firstPositionIn(element).map(function(pos) {
          if (!isPosCaretContainer(pos, caret)) {
            remove$5(caret.get());
            var text = insertInlinePos(pos, true);
            caret.set(text);
            return CaretPosition(text, 1);
          } else {
            return CaretPosition(caret.get(), 1);
          }
        });
      }, function(element) {
        return lastPositionIn(element).map(function(pos) {
          if (!isPosCaretContainer(pos, caret)) {
            remove$5(caret.get());
            var text = insertInlinePos(pos, false);
            caret.set(text);
            return CaretPosition(text, text.length - 1);
          } else {
            return CaretPosition(caret.get(), caret.get().length - 1);
          }
        });
      }, function(element) {
        remove$5(caret.get());
        var text = insertInlineAfter(element);
        caret.set(text);
        return Optional.some(CaretPosition(text, 1));
      });
    };
    var evaluateUntil = function(fns, args) {
      for (var i = 0; i < fns.length; i++) {
        var result = fns[i].apply(null, args);
        if (result.isSome()) {
          return result;
        }
      }
      return Optional.none();
    };
    var Location = Adt.generate([
      { before: ["element"] },
      { start: ["element"] },
      { end: ["element"] },
      { after: ["element"] }
    ]);
    var rescope = function(rootNode, node) {
      var parentBlock = getParentBlock(node, rootNode);
      return parentBlock ? parentBlock : rootNode;
    };
    var before$4 = function(isInlineTarget2, rootNode, pos) {
      var nPos = normalizeForwards(pos);
      var scope = rescope(rootNode, nPos.container());
      return findRootInline(isInlineTarget2, scope, nPos).fold(function() {
        return nextPosition(scope, nPos).bind(curry(findRootInline, isInlineTarget2, scope)).map(function(inline) {
          return Location.before(inline);
        });
      }, Optional.none);
    };
    var isNotInsideFormatCaretContainer = function(rootNode, elm) {
      return getParentCaretContainer(rootNode, elm) === null;
    };
    var findInsideRootInline = function(isInlineTarget2, rootNode, pos) {
      return findRootInline(isInlineTarget2, rootNode, pos).filter(curry(isNotInsideFormatCaretContainer, rootNode));
    };
    var start = function(isInlineTarget2, rootNode, pos) {
      var nPos = normalizeBackwards(pos);
      return findInsideRootInline(isInlineTarget2, rootNode, nPos).bind(function(inline) {
        var prevPos = prevPosition(inline, nPos);
        return prevPos.isNone() ? Optional.some(Location.start(inline)) : Optional.none();
      });
    };
    var end = function(isInlineTarget2, rootNode, pos) {
      var nPos = normalizeForwards(pos);
      return findInsideRootInline(isInlineTarget2, rootNode, nPos).bind(function(inline) {
        var nextPos = nextPosition(inline, nPos);
        return nextPos.isNone() ? Optional.some(Location.end(inline)) : Optional.none();
      });
    };
    var after$3 = function(isInlineTarget2, rootNode, pos) {
      var nPos = normalizeBackwards(pos);
      var scope = rescope(rootNode, nPos.container());
      return findRootInline(isInlineTarget2, scope, nPos).fold(function() {
        return prevPosition(scope, nPos).bind(curry(findRootInline, isInlineTarget2, scope)).map(function(inline) {
          return Location.after(inline);
        });
      }, Optional.none);
    };
    var isValidLocation = function(location) {
      return isRtl$1(getElement(location)) === false;
    };
    var readLocation = function(isInlineTarget2, rootNode, pos) {
      var location = evaluateUntil([
        before$4,
        start,
        end,
        after$3
      ], [
        isInlineTarget2,
        rootNode,
        pos
      ]);
      return location.filter(isValidLocation);
    };
    var getElement = function(location) {
      return location.fold(identity, identity, identity, identity);
    };
    var getName = function(location) {
      return location.fold(constant("before"), constant("start"), constant("end"), constant("after"));
    };
    var outside = function(location) {
      return location.fold(Location.before, Location.before, Location.after, Location.after);
    };
    var inside = function(location) {
      return location.fold(Location.start, Location.start, Location.end, Location.end);
    };
    var isEq$5 = function(location1, location2) {
      return getName(location1) === getName(location2) && getElement(location1) === getElement(location2);
    };
    var betweenInlines = function(forward, isInlineTarget2, rootNode, from2, to2, location) {
      return lift2(findRootInline(isInlineTarget2, rootNode, from2), findRootInline(isInlineTarget2, rootNode, to2), function(fromInline, toInline) {
        if (fromInline !== toInline && hasSameParentBlock(rootNode, fromInline, toInline)) {
          return Location.after(forward ? fromInline : toInline);
        } else {
          return location;
        }
      }).getOr(location);
    };
    var skipNoMovement = function(fromLocation, toLocation) {
      return fromLocation.fold(always, function(fromLocation2) {
        return !isEq$5(fromLocation2, toLocation);
      });
    };
    var findLocationTraverse = function(forward, isInlineTarget2, rootNode, fromLocation, pos) {
      var from2 = normalizePosition(forward, pos);
      var to2 = fromPosition(forward, rootNode, from2).map(curry(normalizePosition, forward));
      var location = to2.fold(function() {
        return fromLocation.map(outside);
      }, function(to3) {
        return readLocation(isInlineTarget2, rootNode, to3).map(curry(betweenInlines, forward, isInlineTarget2, rootNode, from2, to3)).filter(curry(skipNoMovement, fromLocation));
      });
      return location.filter(isValidLocation);
    };
    var findLocationSimple = function(forward, location) {
      if (forward) {
        return location.fold(compose(Optional.some, Location.start), Optional.none, compose(Optional.some, Location.after), Optional.none);
      } else {
        return location.fold(Optional.none, compose(Optional.some, Location.before), Optional.none, compose(Optional.some, Location.end));
      }
    };
    var findLocation = function(forward, isInlineTarget2, rootNode, pos) {
      var from2 = normalizePosition(forward, pos);
      var fromLocation = readLocation(isInlineTarget2, rootNode, from2);
      return readLocation(isInlineTarget2, rootNode, from2).bind(curry(findLocationSimple, forward)).orThunk(function() {
        return findLocationTraverse(forward, isInlineTarget2, rootNode, fromLocation, pos);
      });
    };
    curry(findLocation, false);
    curry(findLocation, true);
    var hasSelectionModifyApi = function(editor) {
      return isFunction(editor.selection.getSel().modify);
    };
    var moveRel = function(forward, selection, pos) {
      var delta = forward ? 1 : -1;
      selection.setRng(CaretPosition(pos.container(), pos.offset() + delta).toRange());
      selection.getSel().modify("move", forward ? "forward" : "backward", "word");
      return true;
    };
    var moveByWord = function(forward, editor) {
      var rng = editor.selection.getRng();
      var pos = forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);
      if (!hasSelectionModifyApi(editor)) {
        return false;
      } else if (forward && isBeforeInline(pos)) {
        return moveRel(true, editor.selection, pos);
      } else if (!forward && isAfterInline(pos)) {
        return moveRel(false, editor.selection, pos);
      } else {
        return false;
      }
    };
    var BreakType;
    (function(BreakType2) {
      BreakType2[BreakType2["Br"] = 0] = "Br";
      BreakType2[BreakType2["Block"] = 1] = "Block";
      BreakType2[BreakType2["Wrap"] = 2] = "Wrap";
      BreakType2[BreakType2["Eol"] = 3] = "Eol";
    })(BreakType || (BreakType = {}));
    var flip = function(direction, positions) {
      return direction === HDirection.Backwards ? reverse(positions) : positions;
    };
    var walk$3 = function(direction, caretWalker, pos) {
      return direction === HDirection.Forwards ? caretWalker.next(pos) : caretWalker.prev(pos);
    };
    var getBreakType = function(scope, direction, currentPos, nextPos) {
      if (isBr(nextPos.getNode(direction === HDirection.Forwards))) {
        return BreakType.Br;
      } else if (isInSameBlock(currentPos, nextPos) === false) {
        return BreakType.Block;
      } else {
        return BreakType.Wrap;
      }
    };
    var getPositionsUntil = function(predicate, direction, scope, start2) {
      var caretWalker = CaretWalker(scope);
      var currentPos = start2, nextPos;
      var positions = [];
      while (currentPos) {
        nextPos = walk$3(direction, caretWalker, currentPos);
        if (!nextPos) {
          break;
        }
        if (isBr(nextPos.getNode(false))) {
          if (direction === HDirection.Forwards) {
            return {
              positions: flip(direction, positions).concat([nextPos]),
              breakType: BreakType.Br,
              breakAt: Optional.some(nextPos)
            };
          } else {
            return {
              positions: flip(direction, positions),
              breakType: BreakType.Br,
              breakAt: Optional.some(nextPos)
            };
          }
        }
        if (!nextPos.isVisible()) {
          currentPos = nextPos;
          continue;
        }
        if (predicate(currentPos, nextPos)) {
          var breakType = getBreakType(scope, direction, currentPos, nextPos);
          return {
            positions: flip(direction, positions),
            breakType,
            breakAt: Optional.some(nextPos)
          };
        }
        positions.push(nextPos);
        currentPos = nextPos;
      }
      return {
        positions: flip(direction, positions),
        breakType: BreakType.Eol,
        breakAt: Optional.none()
      };
    };
    var getAdjacentLinePositions = function(direction, getPositionsUntilBreak, scope, start2) {
      return getPositionsUntilBreak(scope, start2).breakAt.map(function(pos) {
        var positions = getPositionsUntilBreak(scope, pos).positions;
        return direction === HDirection.Backwards ? positions.concat(pos) : [pos].concat(positions);
      }).getOr([]);
    };
    var findClosestHorizontalPositionFromPoint = function(positions, x) {
      return foldl(positions, function(acc, newPos) {
        return acc.fold(function() {
          return Optional.some(newPos);
        }, function(lastPos) {
          return lift2(head(lastPos.getClientRects()), head(newPos.getClientRects()), function(lastRect, newRect) {
            var lastDist = Math.abs(x - lastRect.left);
            var newDist = Math.abs(x - newRect.left);
            return newDist <= lastDist ? newPos : lastPos;
          }).or(acc);
        });
      }, Optional.none());
    };
    var findClosestHorizontalPosition = function(positions, pos) {
      return head(pos.getClientRects()).bind(function(targetRect) {
        return findClosestHorizontalPositionFromPoint(positions, targetRect.left);
      });
    };
    var getPositionsUntilPreviousLine = curry(getPositionsUntil, CaretPosition.isAbove, -1);
    var getPositionsUntilNextLine = curry(getPositionsUntil, CaretPosition.isBelow, 1);
    var isAtFirstLine = function(scope, pos) {
      return getPositionsUntilPreviousLine(scope, pos).breakAt.isNone();
    };
    var isAtLastLine = function(scope, pos) {
      return getPositionsUntilNextLine(scope, pos).breakAt.isNone();
    };
    var getPositionsAbove = curry(getAdjacentLinePositions, -1, getPositionsUntilPreviousLine);
    var getPositionsBelow = curry(getAdjacentLinePositions, 1, getPositionsUntilNextLine);
    var getFirstLinePositions = function(scope) {
      return firstPositionIn(scope).map(function(pos) {
        return [pos].concat(getPositionsUntilNextLine(scope, pos).positions);
      }).getOr([]);
    };
    var getLastLinePositions = function(scope) {
      return lastPositionIn(scope).map(function(pos) {
        return getPositionsUntilPreviousLine(scope, pos).positions.concat(pos);
      }).getOr([]);
    };
    var getNodeClientRects = function(node) {
      var toArrayWithNode = function(clientRects) {
        return map(clientRects, function(clientRect) {
          clientRect = clone$2(clientRect);
          clientRect.node = node;
          return clientRect;
        });
      };
      if (isElement$1(node)) {
        return toArrayWithNode(node.getClientRects());
      }
      if (isText$1(node)) {
        var rng = node.ownerDocument.createRange();
        rng.setStart(node, 0);
        rng.setEnd(node, node.data.length);
        return toArrayWithNode(rng.getClientRects());
      }
    };
    var getClientRects = function(nodes) {
      return bind(nodes, getNodeClientRects);
    };
    var VDirection;
    (function(VDirection2) {
      VDirection2[VDirection2["Up"] = -1] = "Up";
      VDirection2[VDirection2["Down"] = 1] = "Down";
    })(VDirection || (VDirection = {}));
    var findUntil$1 = function(direction, root, predicateFn, node) {
      while (node = findNode(node, direction, isEditableCaretCandidate, root)) {
        if (predicateFn(node)) {
          return;
        }
      }
    };
    var walkUntil = function(direction, isAboveFn, isBeflowFn, root, predicateFn, caretPosition) {
      var line = 0;
      var result = [];
      var add2 = function(node2) {
        var i, clientRect, clientRects;
        clientRects = getClientRects([node2]);
        if (direction === -1) {
          clientRects = clientRects.reverse();
        }
        for (i = 0; i < clientRects.length; i++) {
          clientRect = clientRects[i];
          if (isBeflowFn(clientRect, targetClientRect)) {
            continue;
          }
          if (result.length > 0 && isAboveFn(clientRect, last$1(result))) {
            line++;
          }
          clientRect.line = line;
          if (predicateFn(clientRect)) {
            return true;
          }
          result.push(clientRect);
        }
      };
      var targetClientRect = last$1(caretPosition.getClientRects());
      if (!targetClientRect) {
        return result;
      }
      var node = caretPosition.getNode();
      add2(node);
      findUntil$1(direction, root, add2, node);
      return result;
    };
    var aboveLineNumber = function(lineNumber, clientRect) {
      return clientRect.line > lineNumber;
    };
    var isLineNumber = function(lineNumber, clientRect) {
      return clientRect.line === lineNumber;
    };
    var upUntil = curry(walkUntil, VDirection.Up, isAbove, isBelow);
    var downUntil = curry(walkUntil, VDirection.Down, isBelow, isAbove);
    var positionsUntil = function(direction, root, predicateFn, node) {
      var caretWalker = CaretWalker(root);
      var walkFn, isBelowFn, isAboveFn, caretPosition;
      var result = [];
      var line = 0, clientRect;
      var getClientRect = function(caretPosition2) {
        if (direction === 1) {
          return last$1(caretPosition2.getClientRects());
        }
        return last$1(caretPosition2.getClientRects());
      };
      if (direction === 1) {
        walkFn = caretWalker.next;
        isBelowFn = isBelow;
        isAboveFn = isAbove;
        caretPosition = CaretPosition.after(node);
      } else {
        walkFn = caretWalker.prev;
        isBelowFn = isAbove;
        isAboveFn = isBelow;
        caretPosition = CaretPosition.before(node);
      }
      var targetClientRect = getClientRect(caretPosition);
      do {
        if (!caretPosition.isVisible()) {
          continue;
        }
        clientRect = getClientRect(caretPosition);
        if (isAboveFn(clientRect, targetClientRect)) {
          continue;
        }
        if (result.length > 0 && isBelowFn(clientRect, last$1(result))) {
          line++;
        }
        clientRect = clone$2(clientRect);
        clientRect.position = caretPosition;
        clientRect.line = line;
        if (predicateFn(clientRect)) {
          return result;
        }
        result.push(clientRect);
      } while (caretPosition = walkFn(caretPosition));
      return result;
    };
    var isAboveLine = function(lineNumber) {
      return function(clientRect) {
        return aboveLineNumber(lineNumber, clientRect);
      };
    };
    var isLine = function(lineNumber) {
      return function(clientRect) {
        return isLineNumber(lineNumber, clientRect);
      };
    };
    var isContentEditableFalse$8 = isContentEditableFalse;
    var findNode$1 = findNode;
    var distanceToRectLeft = function(clientRect, clientX) {
      return Math.abs(clientRect.left - clientX);
    };
    var distanceToRectRight = function(clientRect, clientX) {
      return Math.abs(clientRect.right - clientX);
    };
    var isInsideX = function(clientX, clientRect) {
      return clientX >= clientRect.left && clientX <= clientRect.right;
    };
    var isInsideY = function(clientY, clientRect) {
      return clientY >= clientRect.top && clientY <= clientRect.bottom;
    };
    var findClosestClientRect = function(clientRects, clientX) {
      return reduce(clientRects, function(oldClientRect, clientRect) {
        var oldDistance = Math.min(distanceToRectLeft(oldClientRect, clientX), distanceToRectRight(oldClientRect, clientX));
        var newDistance = Math.min(distanceToRectLeft(clientRect, clientX), distanceToRectRight(clientRect, clientX));
        if (isInsideX(clientX, clientRect)) {
          return clientRect;
        }
        if (isInsideX(clientX, oldClientRect)) {
          return oldClientRect;
        }
        if (newDistance === oldDistance && isContentEditableFalse$8(clientRect.node)) {
          return clientRect;
        }
        if (newDistance < oldDistance) {
          return clientRect;
        }
        return oldClientRect;
      });
    };
    var walkUntil$1 = function(direction, root, predicateFn, startNode, includeChildren) {
      var node = findNode$1(startNode, direction, isEditableCaretCandidate, root, !includeChildren);
      do {
        if (!node || predicateFn(node)) {
          return;
        }
      } while (node = findNode$1(node, direction, isEditableCaretCandidate, root));
    };
    var findLineNodeRects = function(root, targetNodeRect, includeChildren) {
      if (includeChildren === void 0) {
        includeChildren = true;
      }
      var clientRects = [];
      var collect = function(checkPosFn, node) {
        var lineRects = filter(getClientRects([node]), function(clientRect) {
          return !checkPosFn(clientRect, targetNodeRect);
        });
        clientRects = clientRects.concat(lineRects);
        return lineRects.length === 0;
      };
      clientRects.push(targetNodeRect);
      walkUntil$1(VDirection.Up, root, curry(collect, isAbove), targetNodeRect.node, includeChildren);
      walkUntil$1(VDirection.Down, root, curry(collect, isBelow), targetNodeRect.node, includeChildren);
      return clientRects;
    };
    var getFakeCaretTargets = function(root) {
      return filter(from$1(root.getElementsByTagName("*")), isFakeCaretTarget);
    };
    var caretInfo = function(clientRect, clientX) {
      return {
        node: clientRect.node,
        before: distanceToRectLeft(clientRect, clientX) < distanceToRectRight(clientRect, clientX)
      };
    };
    var closestFakeCaret = function(root, clientX, clientY) {
      var fakeTargetNodeRects = getClientRects(getFakeCaretTargets(root));
      var targetNodeRects = filter(fakeTargetNodeRects, curry(isInsideY, clientY));
      var closestNodeRect = findClosestClientRect(targetNodeRects, clientX);
      if (closestNodeRect) {
        var includeChildren = !isTable(closestNodeRect.node) && !isMedia(closestNodeRect.node);
        closestNodeRect = findClosestClientRect(findLineNodeRects(root, closestNodeRect, includeChildren), clientX);
        if (closestNodeRect && isFakeCaretTarget(closestNodeRect.node)) {
          return caretInfo(closestNodeRect, clientX);
        }
      }
      return null;
    };
    var moveToRange = function(editor, rng) {
      editor.selection.setRng(rng);
      scrollRangeIntoView(editor, editor.selection.getRng());
    };
    var renderRangeCaretOpt = function(editor, range2, scrollIntoView) {
      return Optional.some(renderRangeCaret(editor, range2, scrollIntoView));
    };
    var moveHorizontally = function(editor, direction, range2, isBefore, isAfter, isElement2) {
      var forwards = direction === HDirection.Forwards;
      var caretWalker = CaretWalker(editor.getBody());
      var getNextPosFn = curry(getVisualCaretPosition, forwards ? caretWalker.next : caretWalker.prev);
      var isBeforeFn = forwards ? isBefore : isAfter;
      if (!range2.collapsed) {
        var node = getSelectedNode(range2);
        if (isElement2(node)) {
          return showCaret(direction, editor, node, direction === HDirection.Backwards, false);
        }
      }
      var caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range2);
      if (isBeforeFn(caretPosition)) {
        return selectNode(editor, caretPosition.getNode(!forwards));
      }
      var nextCaretPosition = normalizePosition(forwards, getNextPosFn(caretPosition));
      var rangeIsInContainerBlock = isRangeInCaretContainerBlock(range2);
      if (!nextCaretPosition) {
        return rangeIsInContainerBlock ? Optional.some(range2) : Optional.none();
      }
      if (isBeforeFn(nextCaretPosition)) {
        return showCaret(direction, editor, nextCaretPosition.getNode(!forwards), forwards, false);
      }
      var peekCaretPosition = getNextPosFn(nextCaretPosition);
      if (peekCaretPosition && isBeforeFn(peekCaretPosition)) {
        if (isMoveInsideSameBlock(nextCaretPosition, peekCaretPosition)) {
          return showCaret(direction, editor, peekCaretPosition.getNode(!forwards), forwards, false);
        }
      }
      if (rangeIsInContainerBlock) {
        return renderRangeCaretOpt(editor, nextCaretPosition.toRange(), false);
      }
      return Optional.none();
    };
    var moveVertically = function(editor, direction, range2, isBefore, isAfter, isElement2) {
      var caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range2);
      var caretClientRect = last$1(caretPosition.getClientRects());
      var forwards = direction === VDirection.Down;
      if (!caretClientRect) {
        return Optional.none();
      }
      var walkerFn = forwards ? downUntil : upUntil;
      var linePositions = walkerFn(editor.getBody(), isAboveLine(1), caretPosition);
      var nextLinePositions = filter(linePositions, isLine(1));
      var clientX = caretClientRect.left;
      var nextLineRect = findClosestClientRect(nextLinePositions, clientX);
      if (nextLineRect && isElement2(nextLineRect.node)) {
        var dist1 = Math.abs(clientX - nextLineRect.left);
        var dist2 = Math.abs(clientX - nextLineRect.right);
        return showCaret(direction, editor, nextLineRect.node, dist1 < dist2, false);
      }
      var currentNode;
      if (isBefore(caretPosition)) {
        currentNode = caretPosition.getNode();
      } else if (isAfter(caretPosition)) {
        currentNode = caretPosition.getNode(true);
      } else {
        currentNode = getSelectedNode(range2);
      }
      if (currentNode) {
        var caretPositions = positionsUntil(direction, editor.getBody(), isAboveLine(1), currentNode);
        var closestNextLineRect = findClosestClientRect(filter(caretPositions, isLine(1)), clientX);
        if (closestNextLineRect) {
          return renderRangeCaretOpt(editor, closestNextLineRect.position.toRange(), false);
        }
        closestNextLineRect = last$1(filter(caretPositions, isLine(0)));
        if (closestNextLineRect) {
          return renderRangeCaretOpt(editor, closestNextLineRect.position.toRange(), false);
        }
      }
      if (nextLinePositions.length === 0) {
        return getLineEndPoint(editor, forwards).filter(forwards ? isAfter : isBefore).map(function(pos) {
          return renderRangeCaret(editor, pos.toRange(), false);
        });
      }
      return Optional.none();
    };
    var getLineEndPoint = function(editor, forward) {
      var rng = editor.selection.getRng();
      var body = editor.getBody();
      if (forward) {
        var from2 = CaretPosition.fromRangeEnd(rng);
        var result = getPositionsUntilNextLine(body, from2);
        return last(result.positions);
      } else {
        var from2 = CaretPosition.fromRangeStart(rng);
        var result = getPositionsUntilPreviousLine(body, from2);
        return head(result.positions);
      }
    };
    var moveToLineEndPoint = function(editor, forward, isElementPosition) {
      return getLineEndPoint(editor, forward).filter(isElementPosition).exists(function(pos) {
        editor.selection.setRng(pos.toRange());
        return true;
      });
    };
    var setCaretPosition = function(editor, pos) {
      var rng = editor.dom.createRng();
      rng.setStart(pos.container(), pos.offset());
      rng.setEnd(pos.container(), pos.offset());
      editor.selection.setRng(rng);
    };
    var setSelected = function(state, elm) {
      if (state) {
        elm.setAttribute("data-mce-selected", "inline-boundary");
      } else {
        elm.removeAttribute("data-mce-selected");
      }
    };
    var renderCaretLocation = function(editor, caret, location) {
      return renderCaret(caret, location).map(function(pos) {
        setCaretPosition(editor, pos);
        return location;
      });
    };
    var findLocation$1 = function(editor, caret, forward) {
      var rootNode = editor.getBody();
      var from2 = CaretPosition.fromRangeStart(editor.selection.getRng());
      var isInlineTarget$1 = curry(isInlineTarget, editor);
      var location = findLocation(forward, isInlineTarget$1, rootNode, from2);
      return location.bind(function(location2) {
        return renderCaretLocation(editor, caret, location2);
      });
    };
    var toggleInlines = function(isInlineTarget2, dom2, elms) {
      var inlineBoundaries = map(descendants$1(SugarElement.fromDom(dom2.getRoot()), '*[data-mce-selected="inline-boundary"]'), function(e) {
        return e.dom;
      });
      var selectedInlines = filter(inlineBoundaries, isInlineTarget2);
      var targetInlines = filter(elms, isInlineTarget2);
      each(difference(selectedInlines, targetInlines), curry(setSelected, false));
      each(difference(targetInlines, selectedInlines), curry(setSelected, true));
    };
    var safeRemoveCaretContainer = function(editor, caret) {
      if (editor.selection.isCollapsed() && editor.composing !== true && caret.get()) {
        var pos = CaretPosition.fromRangeStart(editor.selection.getRng());
        if (CaretPosition.isTextPosition(pos) && isAtZwsp(pos) === false) {
          setCaretPosition(editor, removeAndReposition(caret.get(), pos));
          caret.set(null);
        }
      }
    };
    var renderInsideInlineCaret = function(isInlineTarget2, editor, caret, elms) {
      if (editor.selection.isCollapsed()) {
        var inlines = filter(elms, isInlineTarget2);
        each(inlines, function(_inline) {
          var pos = CaretPosition.fromRangeStart(editor.selection.getRng());
          readLocation(isInlineTarget2, editor.getBody(), pos).bind(function(location) {
            return renderCaretLocation(editor, caret, location);
          });
        });
      }
    };
    var move = function(editor, caret, forward) {
      return isInlineBoundariesEnabled(editor) ? findLocation$1(editor, caret, forward).isSome() : false;
    };
    var moveWord = function(forward, editor, _caret) {
      return isInlineBoundariesEnabled(editor) ? moveByWord(forward, editor) : false;
    };
    var setupSelectedState = function(editor) {
      var caret = Cell(null);
      var isInlineTarget$1 = curry(isInlineTarget, editor);
      editor.on("NodeChange", function(e) {
        if (isInlineBoundariesEnabled(editor) && !(Env.browser.isIE() && e.initial)) {
          toggleInlines(isInlineTarget$1, editor.dom, e.parents);
          safeRemoveCaretContainer(editor, caret);
          renderInsideInlineCaret(isInlineTarget$1, editor, caret, e.parents);
        }
      });
      return caret;
    };
    var moveNextWord = curry(moveWord, true);
    var movePrevWord = curry(moveWord, false);
    var moveToLineEndPoint$1 = function(editor, forward, caret) {
      if (isInlineBoundariesEnabled(editor)) {
        var linePoint = getLineEndPoint(editor, forward).getOrThunk(function() {
          var rng = editor.selection.getRng();
          return forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);
        });
        return readLocation(curry(isInlineTarget, editor), editor.getBody(), linePoint).exists(function(loc) {
          var outsideLoc = outside(loc);
          return renderCaret(caret, outsideLoc).exists(function(pos) {
            setCaretPosition(editor, pos);
            return true;
          });
        });
      } else {
        return false;
      }
    };
    var rangeFromPositions = function(from2, to2) {
      var range2 = document.createRange();
      range2.setStart(from2.container(), from2.offset());
      range2.setEnd(to2.container(), to2.offset());
      return range2;
    };
    var hasOnlyTwoOrLessPositionsLeft = function(elm) {
      return lift2(firstPositionIn(elm), lastPositionIn(elm), function(firstPos, lastPos) {
        var normalizedFirstPos = normalizePosition(true, firstPos);
        var normalizedLastPos = normalizePosition(false, lastPos);
        return nextPosition(elm, normalizedFirstPos).forall(function(pos) {
          return pos.isEqual(normalizedLastPos);
        });
      }).getOr(true);
    };
    var setCaretLocation = function(editor, caret) {
      return function(location) {
        return renderCaret(caret, location).exists(function(pos) {
          setCaretPosition(editor, pos);
          return true;
        });
      };
    };
    var deleteFromTo = function(editor, caret, from2, to2) {
      var rootNode = editor.getBody();
      var isInlineTarget$1 = curry(isInlineTarget, editor);
      editor.undoManager.ignore(function() {
        editor.selection.setRng(rangeFromPositions(from2, to2));
        editor.execCommand("Delete");
        readLocation(isInlineTarget$1, rootNode, CaretPosition.fromRangeStart(editor.selection.getRng())).map(inside).map(setCaretLocation(editor, caret));
      });
      editor.nodeChanged();
    };
    var rescope$1 = function(rootNode, node) {
      var parentBlock = getParentBlock(node, rootNode);
      return parentBlock ? parentBlock : rootNode;
    };
    var backspaceDeleteCollapsed = function(editor, caret, forward, from2) {
      var rootNode = rescope$1(editor.getBody(), from2.container());
      var isInlineTarget$1 = curry(isInlineTarget, editor);
      var fromLocation = readLocation(isInlineTarget$1, rootNode, from2);
      return fromLocation.bind(function(location) {
        if (forward) {
          return location.fold(constant(Optional.some(inside(location))), Optional.none, constant(Optional.some(outside(location))), Optional.none);
        } else {
          return location.fold(Optional.none, constant(Optional.some(outside(location))), Optional.none, constant(Optional.some(inside(location))));
        }
      }).map(setCaretLocation(editor, caret)).getOrThunk(function() {
        var toPosition = navigate(forward, rootNode, from2);
        var toLocation = toPosition.bind(function(pos) {
          return readLocation(isInlineTarget$1, rootNode, pos);
        });
        return lift2(fromLocation, toLocation, function() {
          return findRootInline(isInlineTarget$1, rootNode, from2).exists(function(elm) {
            if (hasOnlyTwoOrLessPositionsLeft(elm)) {
              deleteElement(editor, forward, SugarElement.fromDom(elm));
              return true;
            } else {
              return false;
            }
          });
        }).orThunk(function() {
          return toLocation.bind(function(_) {
            return toPosition.map(function(to2) {
              if (forward) {
                deleteFromTo(editor, caret, from2, to2);
              } else {
                deleteFromTo(editor, caret, to2, from2);
              }
              return true;
            });
          });
        }).getOr(false);
      });
    };
    var backspaceDelete$6 = function(editor, caret, forward) {
      if (editor.selection.isCollapsed() && isInlineBoundariesEnabled(editor)) {
        var from2 = CaretPosition.fromRangeStart(editor.selection.getRng());
        return backspaceDeleteCollapsed(editor, caret, forward, from2);
      }
      return false;
    };
    var getParentInlines = function(rootElm, startElm) {
      var parents2 = parentsAndSelf(startElm, rootElm);
      return findIndex(parents2, isBlock).fold(constant(parents2), function(index) {
        return parents2.slice(0, index);
      });
    };
    var hasOnlyOneChild$1 = function(elm) {
      return children(elm).length === 1;
    };
    var deleteLastPosition = function(forward, editor, target, parentInlines) {
      var isFormatElement$1 = curry(isFormatElement, editor);
      var formatNodes = map(filter(parentInlines, isFormatElement$1), function(elm) {
        return elm.dom;
      });
      if (formatNodes.length === 0) {
        deleteElement(editor, forward, target);
      } else {
        var pos = replaceWithCaretFormat(target.dom, formatNodes);
        editor.selection.setRng(pos.toRange());
      }
    };
    var deleteCaret$2 = function(editor, forward) {
      var rootElm = SugarElement.fromDom(editor.getBody());
      var startElm = SugarElement.fromDom(editor.selection.getStart());
      var parentInlines = filter(getParentInlines(rootElm, startElm), hasOnlyOneChild$1);
      return last(parentInlines).exists(function(target) {
        var fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());
        if (willDeleteLastPositionInElement(forward, fromPos, target.dom) && !isEmptyCaretFormatElement(target)) {
          deleteLastPosition(forward, editor, target, parentInlines);
          return true;
        } else {
          return false;
        }
      });
    };
    var backspaceDelete$7 = function(editor, forward) {
      return editor.selection.isCollapsed() ? deleteCaret$2(editor, forward) : false;
    };
    var deleteElement$2 = function(editor, forward, element) {
      editor._selectionOverrides.hideFakeCaret();
      deleteElement(editor, forward, SugarElement.fromDom(element));
      return true;
    };
    var deleteCaret$3 = function(editor, forward) {
      var isNearMedia = forward ? isBeforeMedia : isAfterMedia;
      var direction = forward ? HDirection.Forwards : HDirection.Backwards;
      var fromPos = getNormalizedRangeEndPoint(direction, editor.getBody(), editor.selection.getRng());
      if (isNearMedia(fromPos)) {
        return deleteElement$2(editor, forward, fromPos.getNode(!forward));
      } else {
        return Optional.from(normalizePosition(forward, fromPos)).filter(function(pos) {
          return isNearMedia(pos) && isMoveInsideSameBlock(fromPos, pos);
        }).exists(function(pos) {
          return deleteElement$2(editor, forward, pos.getNode(!forward));
        });
      }
    };
    var deleteRange$2 = function(editor, forward) {
      var selectedNode = editor.selection.getNode();
      return isMedia(selectedNode) ? deleteElement$2(editor, forward, selectedNode) : false;
    };
    var backspaceDelete$8 = function(editor, forward) {
      return editor.selection.isCollapsed() ? deleteCaret$3(editor, forward) : deleteRange$2(editor, forward);
    };
    var isEditable$1 = function(target) {
      return closest(target, function(elm) {
        return isContentEditableTrue(elm.dom) || isContentEditableFalse(elm.dom);
      }).exists(function(elm) {
        return isContentEditableTrue(elm.dom);
      });
    };
    var parseIndentValue = function(value2) {
      var number = parseInt(value2, 10);
      return isNaN(number) ? 0 : number;
    };
    var getIndentStyleName = function(useMargin, element) {
      var indentStyleName = useMargin || isTable$1(element) ? "margin" : "padding";
      var suffix = get$5(element, "direction") === "rtl" ? "-right" : "-left";
      return indentStyleName + suffix;
    };
    var indentElement = function(dom2, command, useMargin, value2, unit, element) {
      var indentStyleName = getIndentStyleName(useMargin, SugarElement.fromDom(element));
      if (command === "outdent") {
        var styleValue = Math.max(0, parseIndentValue(element.style[indentStyleName]) - value2);
        dom2.setStyle(element, indentStyleName, styleValue ? styleValue + unit : "");
      } else {
        var styleValue = parseIndentValue(element.style[indentStyleName]) + value2 + unit;
        dom2.setStyle(element, indentStyleName, styleValue);
      }
    };
    var validateBlocks = function(editor, blocks2) {
      return forall(blocks2, function(block) {
        var indentStyleName = getIndentStyleName(shouldIndentUseMargin(editor), block);
        var intentValue = getRaw(block, indentStyleName).map(parseIndentValue).getOr(0);
        var contentEditable = editor.dom.getContentEditable(block.dom);
        return contentEditable !== "false" && intentValue > 0;
      });
    };
    var canOutdent = function(editor) {
      var blocks2 = getBlocksToIndent(editor);
      return !editor.mode.isReadOnly() && (blocks2.length > 1 || validateBlocks(editor, blocks2));
    };
    var isListComponent = function(el) {
      return isList(el) || isListItem(el);
    };
    var parentIsListComponent = function(el) {
      return parent(el).map(isListComponent).getOr(false);
    };
    var getBlocksToIndent = function(editor) {
      return filter(map(editor.selection.getSelectedBlocks(), SugarElement.fromDom), function(el) {
        return !isListComponent(el) && !parentIsListComponent(el) && isEditable$1(el);
      });
    };
    var handle = function(editor, command) {
      var dom2 = editor.dom, selection = editor.selection, formatter = editor.formatter;
      var indentation = getIndentation(editor);
      var indentUnit = /[a-z%]+$/i.exec(indentation)[0];
      var indentValue = parseInt(indentation, 10);
      var useMargin = shouldIndentUseMargin(editor);
      var forcedRootBlock = getForcedRootBlock(editor);
      if (!editor.queryCommandState("InsertUnorderedList") && !editor.queryCommandState("InsertOrderedList")) {
        if (forcedRootBlock === "" && !dom2.getParent(selection.getNode(), dom2.isBlock)) {
          formatter.apply("div");
        }
      }
      each(getBlocksToIndent(editor), function(block) {
        indentElement(dom2, command, useMargin, indentValue, indentUnit, block.dom);
      });
    };
    var backspaceDelete$9 = function(editor, _forward) {
      if (editor.selection.isCollapsed() && canOutdent(editor)) {
        var dom2 = editor.dom;
        var rng = editor.selection.getRng();
        var pos = CaretPosition.fromRangeStart(rng);
        var block = dom2.getParent(rng.startContainer, dom2.isBlock);
        if (block !== null && isAtStartOfBlock(SugarElement.fromDom(block), pos)) {
          handle(editor, "outdent");
          return true;
        }
      }
      return false;
    };
    var nativeCommand = function(editor, command) {
      editor.getDoc().execCommand(command, false, null);
    };
    var deleteCommand = function(editor, caret) {
      if (backspaceDelete$9(editor)) {
        return;
      } else if (backspaceDelete$4(editor, false)) {
        return;
      } else if (backspaceDelete$3(editor, false)) {
        return;
      } else if (backspaceDelete$6(editor, caret, false)) {
        return;
      } else if (backspaceDelete$1(editor, false)) {
        return;
      } else if (backspaceDelete(editor)) {
        return;
      } else if (backspaceDelete$5(editor, false)) {
        return;
      } else if (backspaceDelete$8(editor, false)) {
        return;
      } else if (backspaceDelete$2(editor)) {
        return;
      } else if (backspaceDelete$7(editor, false)) {
        return;
      } else {
        nativeCommand(editor, "Delete");
        paddEmptyBody(editor);
      }
    };
    var forwardDeleteCommand = function(editor, caret) {
      if (backspaceDelete$4(editor, true)) {
        return;
      } else if (backspaceDelete$3(editor, true)) {
        return;
      } else if (backspaceDelete$6(editor, caret, true)) {
        return;
      } else if (backspaceDelete$1(editor, true)) {
        return;
      } else if (backspaceDelete(editor)) {
        return;
      } else if (backspaceDelete$5(editor, true)) {
        return;
      } else if (backspaceDelete$8(editor, true)) {
        return;
      } else if (backspaceDelete$2(editor)) {
        return;
      } else if (backspaceDelete$7(editor, true)) {
        return;
      } else {
        nativeCommand(editor, "ForwardDelete");
      }
    };
    var setup$8 = function(editor, caret) {
      editor.addCommand("delete", function() {
        deleteCommand(editor, caret);
      });
      editor.addCommand("forwardDelete", function() {
        forwardDeleteCommand(editor, caret);
      });
    };
    var SIGNIFICANT_MOVE = 5;
    var LONGPRESS_DELAY = 400;
    var getTouch = function(event) {
      if (event.touches === void 0 || event.touches.length !== 1) {
        return Optional.none();
      }
      return Optional.some(event.touches[0]);
    };
    var isFarEnough = function(touch, data2) {
      var distX = Math.abs(touch.clientX - data2.x);
      var distY = Math.abs(touch.clientY - data2.y);
      return distX > SIGNIFICANT_MOVE || distY > SIGNIFICANT_MOVE;
    };
    var setup$9 = function(editor) {
      var startData = Cell(Optional.none());
      var longpressFired = Cell(false);
      var debounceLongpress = last$2(function(e) {
        editor.fire("longpress", __assign2(__assign2({}, e), { type: "longpress" }));
        longpressFired.set(true);
      }, LONGPRESS_DELAY);
      editor.on("touchstart", function(e) {
        getTouch(e).each(function(touch) {
          debounceLongpress.cancel();
          var data2 = {
            x: touch.clientX,
            y: touch.clientY,
            target: e.target
          };
          debounceLongpress.throttle(e);
          longpressFired.set(false);
          startData.set(Optional.some(data2));
        });
      }, true);
      editor.on("touchmove", function(e) {
        debounceLongpress.cancel();
        getTouch(e).each(function(touch) {
          startData.get().each(function(data2) {
            if (isFarEnough(touch, data2)) {
              startData.set(Optional.none());
              longpressFired.set(false);
              editor.fire("longpresscancel");
            }
          });
        });
      }, true);
      editor.on("touchend touchcancel", function(e) {
        debounceLongpress.cancel();
        if (e.type === "touchcancel") {
          return;
        }
        startData.get().filter(function(data2) {
          return data2.target.isEqualNode(e.target);
        }).each(function() {
          if (longpressFired.get()) {
            e.preventDefault();
          } else {
            editor.fire("tap", __assign2(__assign2({}, e), { type: "tap" }));
          }
        });
      }, true);
    };
    var isBlockElement = function(blockElements, node) {
      return blockElements.hasOwnProperty(node.nodeName);
    };
    var isValidTarget = function(blockElements, node) {
      if (isText$1(node)) {
        return true;
      } else if (isElement$1(node)) {
        return !isBlockElement(blockElements, node) && !isBookmarkNode$1(node);
      } else {
        return false;
      }
    };
    var hasBlockParent = function(blockElements, root, node) {
      return exists(parents$1(SugarElement.fromDom(node), SugarElement.fromDom(root)), function(elm) {
        return isBlockElement(blockElements, elm.dom);
      });
    };
    var shouldRemoveTextNode = function(blockElements, node) {
      if (isText$1(node)) {
        if (node.nodeValue.length === 0) {
          return true;
        } else if (/^\s+$/.test(node.nodeValue) && (!node.nextSibling || isBlockElement(blockElements, node.nextSibling))) {
          return true;
        }
      }
      return false;
    };
    var addRootBlocks = function(editor) {
      var dom2 = editor.dom, selection = editor.selection;
      var schema = editor.schema, blockElements = schema.getBlockElements();
      var node = selection.getStart();
      var rootNode = editor.getBody();
      var rootBlockNode, tempNode, wrapped;
      var forcedRootBlock = getForcedRootBlock(editor);
      if (!node || !isElement$1(node) || !forcedRootBlock) {
        return;
      }
      var rootNodeName = rootNode.nodeName.toLowerCase();
      if (!schema.isValidChild(rootNodeName, forcedRootBlock.toLowerCase()) || hasBlockParent(blockElements, rootNode, node)) {
        return;
      }
      var rng = selection.getRng();
      var startContainer = rng.startContainer;
      var startOffset = rng.startOffset;
      var endContainer = rng.endContainer;
      var endOffset = rng.endOffset;
      var restoreSelection = hasFocus$1(editor);
      node = rootNode.firstChild;
      while (node) {
        if (isValidTarget(blockElements, node)) {
          if (shouldRemoveTextNode(blockElements, node)) {
            tempNode = node;
            node = node.nextSibling;
            dom2.remove(tempNode);
            continue;
          }
          if (!rootBlockNode) {
            rootBlockNode = dom2.create(forcedRootBlock, getForcedRootBlockAttrs(editor));
            node.parentNode.insertBefore(rootBlockNode, node);
            wrapped = true;
          }
          tempNode = node;
          node = node.nextSibling;
          rootBlockNode.appendChild(tempNode);
        } else {
          rootBlockNode = null;
          node = node.nextSibling;
        }
      }
      if (wrapped && restoreSelection) {
        rng.setStart(startContainer, startOffset);
        rng.setEnd(endContainer, endOffset);
        selection.setRng(rng);
        editor.nodeChanged();
      }
    };
    var setup$a = function(editor) {
      if (getForcedRootBlock(editor)) {
        editor.on("NodeChange", curry(addRootBlocks, editor));
      }
    };
    var findBlockCaretContainer = function(editor) {
      return descendant(SugarElement.fromDom(editor.getBody()), "*[data-mce-caret]").fold(constant(null), function(elm) {
        return elm.dom;
      });
    };
    var removeIeControlRect = function(editor) {
      editor.selection.setRng(editor.selection.getRng());
    };
    var showBlockCaretContainer = function(editor, blockCaretContainer) {
      if (blockCaretContainer.hasAttribute("data-mce-caret")) {
        showCaretContainerBlock(blockCaretContainer);
        removeIeControlRect(editor);
        editor.selection.scrollIntoView(blockCaretContainer);
      }
    };
    var handleBlockContainer = function(editor, e) {
      var blockCaretContainer = findBlockCaretContainer(editor);
      if (!blockCaretContainer) {
        return;
      }
      if (e.type === "compositionstart") {
        e.preventDefault();
        e.stopPropagation();
        showBlockCaretContainer(editor, blockCaretContainer);
        return;
      }
      if (hasContent(blockCaretContainer)) {
        showBlockCaretContainer(editor, blockCaretContainer);
        editor.undoManager.add();
      }
    };
    var setup$b = function(editor) {
      editor.on("keyup compositionstart", curry(handleBlockContainer, editor));
    };
    var isContentEditableFalse$9 = isContentEditableFalse;
    var moveToCeFalseHorizontally = function(direction, editor, range2) {
      return moveHorizontally(editor, direction, range2, isBeforeContentEditableFalse, isAfterContentEditableFalse, isContentEditableFalse$9);
    };
    var moveToCeFalseVertically = function(direction, editor, range2) {
      var isBefore = function(caretPosition) {
        return isBeforeContentEditableFalse(caretPosition) || isBeforeTable(caretPosition);
      };
      var isAfter = function(caretPosition) {
        return isAfterContentEditableFalse(caretPosition) || isAfterTable(caretPosition);
      };
      return moveVertically(editor, direction, range2, isBefore, isAfter, isContentEditableFalse$9);
    };
    var createTextBlock = function(editor) {
      var textBlock = editor.dom.create(getForcedRootBlock(editor));
      if (!Env.ie || Env.ie >= 11) {
        textBlock.innerHTML = '<br data-mce-bogus="1">';
      }
      return textBlock;
    };
    var exitPreBlock = function(editor, direction, range2) {
      var caretWalker = CaretWalker(editor.getBody());
      var getVisualCaretPosition$1 = curry(getVisualCaretPosition, direction === 1 ? caretWalker.next : caretWalker.prev);
      if (range2.collapsed && hasForcedRootBlock(editor)) {
        var pre = editor.dom.getParent(range2.startContainer, "PRE");
        if (!pre) {
          return;
        }
        var caretPos = getVisualCaretPosition$1(CaretPosition.fromRangeStart(range2));
        if (!caretPos) {
          var newBlock = createTextBlock(editor);
          if (direction === 1) {
            editor.$(pre).after(newBlock);
          } else {
            editor.$(pre).before(newBlock);
          }
          editor.selection.select(newBlock, true);
          editor.selection.collapse();
        }
      }
    };
    var getHorizontalRange = function(editor, forward) {
      var direction = forward ? HDirection.Forwards : HDirection.Backwards;
      var range2 = editor.selection.getRng();
      return moveToCeFalseHorizontally(direction, editor, range2).orThunk(function() {
        exitPreBlock(editor, direction, range2);
        return Optional.none();
      });
    };
    var getVerticalRange = function(editor, down) {
      var direction = down ? 1 : -1;
      var range2 = editor.selection.getRng();
      return moveToCeFalseVertically(direction, editor, range2).orThunk(function() {
        exitPreBlock(editor, direction, range2);
        return Optional.none();
      });
    };
    var moveH = function(editor, forward) {
      return getHorizontalRange(editor, forward).exists(function(newRange) {
        moveToRange(editor, newRange);
        return true;
      });
    };
    var moveV = function(editor, down) {
      return getVerticalRange(editor, down).exists(function(newRange) {
        moveToRange(editor, newRange);
        return true;
      });
    };
    var moveToLineEndPoint$2 = function(editor, forward) {
      var isCefPosition = forward ? isAfterContentEditableFalse : isBeforeContentEditableFalse;
      return moveToLineEndPoint(editor, forward, isCefPosition);
    };
    var isTarget = function(node) {
      return contains(["figcaption"], name(node));
    };
    var rangeBefore = function(target) {
      var rng = document.createRange();
      rng.setStartBefore(target.dom);
      rng.setEndBefore(target.dom);
      return rng;
    };
    var insertElement = function(root, elm, forward) {
      if (forward) {
        append(root, elm);
      } else {
        prepend(root, elm);
      }
    };
    var insertBr = function(root, forward) {
      var br = SugarElement.fromTag("br");
      insertElement(root, br, forward);
      return rangeBefore(br);
    };
    var insertBlock$1 = function(root, forward, blockName, attrs) {
      var block = SugarElement.fromTag(blockName);
      var br = SugarElement.fromTag("br");
      setAll(block, attrs);
      append(block, br);
      insertElement(root, block, forward);
      return rangeBefore(br);
    };
    var insertEmptyLine = function(root, rootBlockName, attrs, forward) {
      if (rootBlockName === "") {
        return insertBr(root, forward);
      } else {
        return insertBlock$1(root, forward, rootBlockName, attrs);
      }
    };
    var getClosestTargetBlock = function(pos, root) {
      var isRoot = curry(eq$2, root);
      return closest(SugarElement.fromDom(pos.container()), isBlock, isRoot).filter(isTarget);
    };
    var isAtFirstOrLastLine = function(root, forward, pos) {
      return forward ? isAtLastLine(root.dom, pos) : isAtFirstLine(root.dom, pos);
    };
    var moveCaretToNewEmptyLine = function(editor, forward) {
      var root = SugarElement.fromDom(editor.getBody());
      var pos = CaretPosition.fromRangeStart(editor.selection.getRng());
      var rootBlock = getForcedRootBlock(editor);
      var rootBlockAttrs = getForcedRootBlockAttrs(editor);
      return getClosestTargetBlock(pos, root).exists(function() {
        if (isAtFirstOrLastLine(root, forward, pos)) {
          var rng = insertEmptyLine(root, rootBlock, rootBlockAttrs, forward);
          editor.selection.setRng(rng);
          return true;
        } else {
          return false;
        }
      });
    };
    var moveV$1 = function(editor, forward) {
      if (editor.selection.isCollapsed()) {
        return moveCaretToNewEmptyLine(editor, forward);
      } else {
        return false;
      }
    };
    var defaultPatterns = function(patterns) {
      return map(patterns, function(pattern) {
        return __assign2({
          shiftKey: false,
          altKey: false,
          ctrlKey: false,
          metaKey: false,
          keyCode: 0,
          action: noop
        }, pattern);
      });
    };
    var matchesEvent = function(pattern, evt) {
      return evt.keyCode === pattern.keyCode && evt.shiftKey === pattern.shiftKey && evt.altKey === pattern.altKey && evt.ctrlKey === pattern.ctrlKey && evt.metaKey === pattern.metaKey;
    };
    var match$1 = function(patterns, evt) {
      return bind(defaultPatterns(patterns), function(pattern) {
        return matchesEvent(pattern, evt) ? [pattern] : [];
      });
    };
    var action = function(f) {
      var x = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        x[_i - 1] = arguments[_i];
      }
      return function() {
        return f.apply(null, x);
      };
    };
    var execute = function(patterns, evt) {
      return find(match$1(patterns, evt), function(pattern) {
        return pattern.action();
      });
    };
    var moveH$1 = function(editor, forward) {
      var direction = forward ? HDirection.Forwards : HDirection.Backwards;
      var range2 = editor.selection.getRng();
      return moveHorizontally(editor, direction, range2, isBeforeMedia, isAfterMedia, isMedia).exists(function(newRange) {
        moveToRange(editor, newRange);
        return true;
      });
    };
    var moveV$2 = function(editor, down) {
      var direction = down ? 1 : -1;
      var range2 = editor.selection.getRng();
      return moveVertically(editor, direction, range2, isBeforeMedia, isAfterMedia, isMedia).exists(function(newRange) {
        moveToRange(editor, newRange);
        return true;
      });
    };
    var moveToLineEndPoint$3 = function(editor, forward) {
      var isNearMedia = forward ? isAfterMedia : isBeforeMedia;
      return moveToLineEndPoint(editor, forward, isNearMedia);
    };
    var deflate = function(rect, delta) {
      return {
        left: rect.left - delta,
        top: rect.top - delta,
        right: rect.right + delta * 2,
        bottom: rect.bottom + delta * 2,
        width: rect.width + delta,
        height: rect.height + delta
      };
    };
    var getCorners = function(getYAxisValue, tds) {
      return bind(tds, function(td) {
        var rect = deflate(clone$2(td.getBoundingClientRect()), -1);
        return [
          {
            x: rect.left,
            y: getYAxisValue(rect),
            cell: td
          },
          {
            x: rect.right,
            y: getYAxisValue(rect),
            cell: td
          }
        ];
      });
    };
    var findClosestCorner = function(corners, x, y) {
      return foldl(corners, function(acc, newCorner) {
        return acc.fold(function() {
          return Optional.some(newCorner);
        }, function(oldCorner) {
          var oldDist = Math.sqrt(Math.abs(oldCorner.x - x) + Math.abs(oldCorner.y - y));
          var newDist = Math.sqrt(Math.abs(newCorner.x - x) + Math.abs(newCorner.y - y));
          return Optional.some(newDist < oldDist ? newCorner : oldCorner);
        });
      }, Optional.none());
    };
    var getClosestCell$1 = function(getYAxisValue, isTargetCorner, table, x, y) {
      var cells = descendants$1(SugarElement.fromDom(table), "td,th,caption").map(function(e) {
        return e.dom;
      });
      var corners = filter(getCorners(getYAxisValue, cells), function(corner) {
        return isTargetCorner(corner, y);
      });
      return findClosestCorner(corners, x, y).map(function(corner) {
        return corner.cell;
      });
    };
    var getBottomValue = function(rect) {
      return rect.bottom;
    };
    var getTopValue = function(rect) {
      return rect.top;
    };
    var isAbove$1 = function(corner, y) {
      return corner.y < y;
    };
    var isBelow$1 = function(corner, y) {
      return corner.y > y;
    };
    var getClosestCellAbove = curry(getClosestCell$1, getBottomValue, isAbove$1);
    var getClosestCellBelow = curry(getClosestCell$1, getTopValue, isBelow$1);
    var findClosestPositionInAboveCell = function(table, pos) {
      return head(pos.getClientRects()).bind(function(rect) {
        return getClosestCellAbove(table, rect.left, rect.top);
      }).bind(function(cell) {
        return findClosestHorizontalPosition(getLastLinePositions(cell), pos);
      });
    };
    var findClosestPositionInBelowCell = function(table, pos) {
      return last(pos.getClientRects()).bind(function(rect) {
        return getClosestCellBelow(table, rect.left, rect.top);
      }).bind(function(cell) {
        return findClosestHorizontalPosition(getFirstLinePositions(cell), pos);
      });
    };
    var hasNextBreak = function(getPositionsUntil2, scope, lineInfo) {
      return lineInfo.breakAt.exists(function(breakPos) {
        return getPositionsUntil2(scope, breakPos).breakAt.isSome();
      });
    };
    var startsWithWrapBreak = function(lineInfo) {
      return lineInfo.breakType === BreakType.Wrap && lineInfo.positions.length === 0;
    };
    var startsWithBrBreak = function(lineInfo) {
      return lineInfo.breakType === BreakType.Br && lineInfo.positions.length === 1;
    };
    var isAtTableCellLine = function(getPositionsUntil2, scope, pos) {
      var lineInfo = getPositionsUntil2(scope, pos);
      if (startsWithWrapBreak(lineInfo) || !isBr(pos.getNode()) && startsWithBrBreak(lineInfo)) {
        return !hasNextBreak(getPositionsUntil2, scope, lineInfo);
      } else {
        return lineInfo.breakAt.isNone();
      }
    };
    var isAtFirstTableCellLine = curry(isAtTableCellLine, getPositionsUntilPreviousLine);
    var isAtLastTableCellLine = curry(isAtTableCellLine, getPositionsUntilNextLine);
    var isCaretAtStartOrEndOfTable = function(forward, rng, table) {
      var caretPos = CaretPosition.fromRangeStart(rng);
      return positionIn(!forward, table).exists(function(pos) {
        return pos.isEqual(caretPos);
      });
    };
    var navigateHorizontally = function(editor, forward, table, _td) {
      var rng = editor.selection.getRng();
      var direction = forward ? 1 : -1;
      if (isFakeCaretTableBrowser() && isCaretAtStartOrEndOfTable(forward, rng, table)) {
        showCaret(direction, editor, table, !forward, false).each(function(newRng) {
          moveToRange(editor, newRng);
        });
        return true;
      }
      return false;
    };
    var getClosestAbovePosition = function(root, table, start2) {
      return findClosestPositionInAboveCell(table, start2).orThunk(function() {
        return head(start2.getClientRects()).bind(function(rect) {
          return findClosestHorizontalPositionFromPoint(getPositionsAbove(root, CaretPosition.before(table)), rect.left);
        });
      }).getOr(CaretPosition.before(table));
    };
    var getClosestBelowPosition = function(root, table, start2) {
      return findClosestPositionInBelowCell(table, start2).orThunk(function() {
        return head(start2.getClientRects()).bind(function(rect) {
          return findClosestHorizontalPositionFromPoint(getPositionsBelow(root, CaretPosition.after(table)), rect.left);
        });
      }).getOr(CaretPosition.after(table));
    };
    var getTable = function(previous, pos) {
      var node = pos.getNode(previous);
      return isElement$1(node) && node.nodeName === "TABLE" ? Optional.some(node) : Optional.none();
    };
    var renderBlock = function(down, editor, table, pos) {
      var forcedRootBlock = getForcedRootBlock(editor);
      if (forcedRootBlock) {
        editor.undoManager.transact(function() {
          var element = SugarElement.fromTag(forcedRootBlock);
          setAll(element, getForcedRootBlockAttrs(editor));
          append(element, SugarElement.fromTag("br"));
          if (down) {
            after(SugarElement.fromDom(table), element);
          } else {
            before(SugarElement.fromDom(table), element);
          }
          var rng = editor.dom.createRng();
          rng.setStart(element.dom, 0);
          rng.setEnd(element.dom, 0);
          moveToRange(editor, rng);
        });
      } else {
        moveToRange(editor, pos.toRange());
      }
    };
    var moveCaret = function(editor, down, pos) {
      var table = down ? getTable(true, pos) : getTable(false, pos);
      var last2 = down === false;
      table.fold(function() {
        return moveToRange(editor, pos.toRange());
      }, function(table2) {
        return positionIn(last2, editor.getBody()).filter(function(lastPos) {
          return lastPos.isEqual(pos);
        }).fold(function() {
          return moveToRange(editor, pos.toRange());
        }, function(_) {
          return renderBlock(down, editor, table2, pos);
        });
      });
    };
    var navigateVertically = function(editor, down, table, td) {
      var rng = editor.selection.getRng();
      var pos = CaretPosition.fromRangeStart(rng);
      var root = editor.getBody();
      if (!down && isAtFirstTableCellLine(td, pos)) {
        var newPos = getClosestAbovePosition(root, table, pos);
        moveCaret(editor, down, newPos);
        return true;
      } else if (down && isAtLastTableCellLine(td, pos)) {
        var newPos = getClosestBelowPosition(root, table, pos);
        moveCaret(editor, down, newPos);
        return true;
      } else {
        return false;
      }
    };
    var move$1 = function(editor, forward, mover) {
      return Optional.from(editor.dom.getParent(editor.selection.getNode(), "td,th")).bind(function(td) {
        return Optional.from(editor.dom.getParent(td, "table")).map(function(table) {
          return mover(editor, forward, table, td);
        });
      }).getOr(false);
    };
    var moveH$2 = function(editor, forward) {
      return move$1(editor, forward, navigateHorizontally);
    };
    var moveV$3 = function(editor, forward) {
      return move$1(editor, forward, navigateVertically);
    };
    var executeKeydownOverride = function(editor, caret, evt) {
      var os2 = detect$3().os;
      execute([
        {
          keyCode: VK.RIGHT,
          action: action(moveH, editor, true)
        },
        {
          keyCode: VK.LEFT,
          action: action(moveH, editor, false)
        },
        {
          keyCode: VK.UP,
          action: action(moveV, editor, false)
        },
        {
          keyCode: VK.DOWN,
          action: action(moveV, editor, true)
        },
        {
          keyCode: VK.RIGHT,
          action: action(moveH$2, editor, true)
        },
        {
          keyCode: VK.LEFT,
          action: action(moveH$2, editor, false)
        },
        {
          keyCode: VK.UP,
          action: action(moveV$3, editor, false)
        },
        {
          keyCode: VK.DOWN,
          action: action(moveV$3, editor, true)
        },
        {
          keyCode: VK.RIGHT,
          action: action(moveH$1, editor, true)
        },
        {
          keyCode: VK.LEFT,
          action: action(moveH$1, editor, false)
        },
        {
          keyCode: VK.UP,
          action: action(moveV$2, editor, false)
        },
        {
          keyCode: VK.DOWN,
          action: action(moveV$2, editor, true)
        },
        {
          keyCode: VK.RIGHT,
          action: action(move, editor, caret, true)
        },
        {
          keyCode: VK.LEFT,
          action: action(move, editor, caret, false)
        },
        {
          keyCode: VK.RIGHT,
          ctrlKey: !os2.isOSX(),
          altKey: os2.isOSX(),
          action: action(moveNextWord, editor, caret)
        },
        {
          keyCode: VK.LEFT,
          ctrlKey: !os2.isOSX(),
          altKey: os2.isOSX(),
          action: action(movePrevWord, editor, caret)
        },
        {
          keyCode: VK.UP,
          action: action(moveV$1, editor, false)
        },
        {
          keyCode: VK.DOWN,
          action: action(moveV$1, editor, true)
        }
      ], evt).each(function(_) {
        evt.preventDefault();
      });
    };
    var setup$c = function(editor, caret) {
      editor.on("keydown", function(evt) {
        if (evt.isDefaultPrevented() === false) {
          executeKeydownOverride(editor, caret, evt);
        }
      });
    };
    var executeKeydownOverride$1 = function(editor, caret, evt) {
      execute([
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$9, editor, false)
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$4, editor, false)
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$4, editor, true)
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$3, editor, false)
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$3, editor, true)
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$6, editor, caret, false)
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$6, editor, caret, true)
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete, editor, false)
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete, editor, true)
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$5, editor, false)
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$5, editor, true)
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$8, editor, false)
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$8, editor, true)
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$2, editor, false)
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$2, editor, true)
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$1, editor, false)
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$1, editor, true)
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$7, editor, false)
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$7, editor, true)
        }
      ], evt).each(function(_) {
        evt.preventDefault();
      });
    };
    var executeKeyupOverride = function(editor, evt) {
      execute([
        {
          keyCode: VK.BACKSPACE,
          action: action(paddEmptyElement, editor)
        },
        {
          keyCode: VK.DELETE,
          action: action(paddEmptyElement, editor)
        }
      ], evt);
    };
    var setup$d = function(editor, caret) {
      editor.on("keydown", function(evt) {
        if (evt.isDefaultPrevented() === false) {
          executeKeydownOverride$1(editor, caret, evt);
        }
      });
      editor.on("keyup", function(evt) {
        if (evt.isDefaultPrevented() === false) {
          executeKeyupOverride(editor, evt);
        }
      });
    };
    var firstNonWhiteSpaceNodeSibling = function(node) {
      while (node) {
        if (node.nodeType === 1 || node.nodeType === 3 && node.data && /[\r\n\s]/.test(node.data)) {
          return node;
        }
        node = node.nextSibling;
      }
    };
    var moveToCaretPosition = function(editor, root) {
      var node, lastNode = root;
      var dom2 = editor.dom;
      var moveCaretBeforeOnEnterElementsMap = editor.schema.getMoveCaretBeforeOnEnterElements();
      if (!root) {
        return;
      }
      if (/^(LI|DT|DD)$/.test(root.nodeName)) {
        var firstChild2 = firstNonWhiteSpaceNodeSibling(root.firstChild);
        if (firstChild2 && /^(UL|OL|DL)$/.test(firstChild2.nodeName)) {
          root.insertBefore(dom2.doc.createTextNode(nbsp), root.firstChild);
        }
      }
      var rng = dom2.createRng();
      root.normalize();
      if (root.hasChildNodes()) {
        var walker = new DomTreeWalker(root, root);
        while (node = walker.current()) {
          if (isText$1(node)) {
            rng.setStart(node, 0);
            rng.setEnd(node, 0);
            break;
          }
          if (moveCaretBeforeOnEnterElementsMap[node.nodeName.toLowerCase()]) {
            rng.setStartBefore(node);
            rng.setEndBefore(node);
            break;
          }
          lastNode = node;
          node = walker.next();
        }
        if (!node) {
          rng.setStart(lastNode, 0);
          rng.setEnd(lastNode, 0);
        }
      } else {
        if (isBr(root)) {
          if (root.nextSibling && dom2.isBlock(root.nextSibling)) {
            rng.setStartBefore(root);
            rng.setEndBefore(root);
          } else {
            rng.setStartAfter(root);
            rng.setEndAfter(root);
          }
        } else {
          rng.setStart(root, 0);
          rng.setEnd(root, 0);
        }
      }
      editor.selection.setRng(rng);
      scrollRangeIntoView(editor, rng);
    };
    var getEditableRoot = function(dom2, node) {
      var root = dom2.getRoot();
      var parent2, editableRoot;
      parent2 = node;
      while (parent2 !== root && dom2.getContentEditable(parent2) !== "false") {
        if (dom2.getContentEditable(parent2) === "true") {
          editableRoot = parent2;
        }
        parent2 = parent2.parentNode;
      }
      return parent2 !== root ? editableRoot : root;
    };
    var getParentBlock$2 = function(editor) {
      return Optional.from(editor.dom.getParent(editor.selection.getStart(true), editor.dom.isBlock));
    };
    var getParentBlockName = function(editor) {
      return getParentBlock$2(editor).fold(constant(""), function(parentBlock) {
        return parentBlock.nodeName.toUpperCase();
      });
    };
    var isListItemParentBlock = function(editor) {
      return getParentBlock$2(editor).filter(function(elm) {
        return isListItem(SugarElement.fromDom(elm));
      }).isSome();
    };
    var hasFirstChild = function(elm, name2) {
      return elm.firstChild && elm.firstChild.nodeName === name2;
    };
    var isFirstChild = function(elm) {
      var _a;
      return ((_a = elm.parentNode) === null || _a === void 0 ? void 0 : _a.firstChild) === elm;
    };
    var hasParent$1 = function(elm, parentName) {
      return elm && elm.parentNode && elm.parentNode.nodeName === parentName;
    };
    var isListBlock = function(elm) {
      return elm && /^(OL|UL|LI)$/.test(elm.nodeName);
    };
    var isNestedList = function(elm) {
      return isListBlock(elm) && isListBlock(elm.parentNode);
    };
    var getContainerBlock = function(containerBlock) {
      var containerBlockParent = containerBlock.parentNode;
      if (/^(LI|DT|DD)$/.test(containerBlockParent.nodeName)) {
        return containerBlockParent;
      }
      return containerBlock;
    };
    var isFirstOrLastLi = function(containerBlock, parentBlock, first2) {
      var node = containerBlock[first2 ? "firstChild" : "lastChild"];
      while (node) {
        if (isElement$1(node)) {
          break;
        }
        node = node[first2 ? "nextSibling" : "previousSibling"];
      }
      return node === parentBlock;
    };
    var insert = function(editor, createNewBlock, containerBlock, parentBlock, newBlockName) {
      var dom2 = editor.dom;
      var rng = editor.selection.getRng();
      if (containerBlock === editor.getBody()) {
        return;
      }
      if (isNestedList(containerBlock)) {
        newBlockName = "LI";
      }
      var newBlock = newBlockName ? createNewBlock(newBlockName) : dom2.create("BR");
      if (isFirstOrLastLi(containerBlock, parentBlock, true) && isFirstOrLastLi(containerBlock, parentBlock, false)) {
        if (hasParent$1(containerBlock, "LI")) {
          var containerBlockParent = getContainerBlock(containerBlock);
          dom2.insertAfter(newBlock, containerBlockParent);
          if (isFirstChild(containerBlock)) {
            dom2.remove(containerBlockParent);
          } else {
            dom2.remove(containerBlock);
          }
        } else {
          dom2.replace(newBlock, containerBlock);
        }
      } else if (isFirstOrLastLi(containerBlock, parentBlock, true)) {
        if (hasParent$1(containerBlock, "LI")) {
          dom2.insertAfter(newBlock, getContainerBlock(containerBlock));
          newBlock.appendChild(dom2.doc.createTextNode(" "));
          newBlock.appendChild(containerBlock);
        } else {
          containerBlock.parentNode.insertBefore(newBlock, containerBlock);
        }
        dom2.remove(parentBlock);
      } else if (isFirstOrLastLi(containerBlock, parentBlock, false)) {
        dom2.insertAfter(newBlock, getContainerBlock(containerBlock));
        dom2.remove(parentBlock);
      } else {
        containerBlock = getContainerBlock(containerBlock);
        var tmpRng = rng.cloneRange();
        tmpRng.setStartAfter(parentBlock);
        tmpRng.setEndAfter(containerBlock);
        var fragment = tmpRng.extractContents();
        if (newBlockName === "LI" && hasFirstChild(fragment, "LI")) {
          newBlock = fragment.firstChild;
          dom2.insertAfter(fragment, containerBlock);
        } else {
          dom2.insertAfter(fragment, containerBlock);
          dom2.insertAfter(newBlock, containerBlock);
        }
        dom2.remove(parentBlock);
      }
      moveToCaretPosition(editor, newBlock);
    };
    var trimZwsp = function(fragment) {
      each(descendants(SugarElement.fromDom(fragment), isText), function(text) {
        var rawNode = text.dom;
        rawNode.nodeValue = trim$2(rawNode.nodeValue);
      });
    };
    var isEmptyAnchor = function(dom2, elm) {
      return elm && elm.nodeName === "A" && dom2.isEmpty(elm);
    };
    var isTableCell$5 = function(node) {
      return node && /^(TD|TH|CAPTION)$/.test(node.nodeName);
    };
    var emptyBlock = function(elm) {
      elm.innerHTML = '<br data-mce-bogus="1">';
    };
    var containerAndSiblingName = function(container, nodeName) {
      return container.nodeName === nodeName || container.previousSibling && container.previousSibling.nodeName === nodeName;
    };
    var canSplitBlock = function(dom2, node) {
      return node && dom2.isBlock(node) && !/^(TD|TH|CAPTION|FORM)$/.test(node.nodeName) && !/^(fixed|absolute)/i.test(node.style.position) && dom2.getContentEditable(node) !== "true";
    };
    var trimInlineElementsOnLeftSideOfBlock = function(dom2, nonEmptyElementsMap, block) {
      var node = block;
      var firstChilds = [];
      var i;
      if (!node) {
        return;
      }
      while (node = node.firstChild) {
        if (dom2.isBlock(node)) {
          return;
        }
        if (isElement$1(node) && !nonEmptyElementsMap[node.nodeName.toLowerCase()]) {
          firstChilds.push(node);
        }
      }
      i = firstChilds.length;
      while (i--) {
        node = firstChilds[i];
        if (!node.hasChildNodes() || node.firstChild === node.lastChild && node.firstChild.nodeValue === "") {
          dom2.remove(node);
        } else {
          if (isEmptyAnchor(dom2, node)) {
            dom2.remove(node);
          }
        }
      }
    };
    var normalizeZwspOffset = function(start2, container, offset) {
      if (isText$1(container) === false) {
        return offset;
      } else if (start2) {
        return offset === 1 && container.data.charAt(offset - 1) === ZWSP ? 0 : offset;
      } else {
        return offset === container.data.length - 1 && container.data.charAt(offset) === ZWSP ? container.data.length : offset;
      }
    };
    var includeZwspInRange = function(rng) {
      var newRng = rng.cloneRange();
      newRng.setStart(rng.startContainer, normalizeZwspOffset(true, rng.startContainer, rng.startOffset));
      newRng.setEnd(rng.endContainer, normalizeZwspOffset(false, rng.endContainer, rng.endOffset));
      return newRng;
    };
    var trimLeadingLineBreaks = function(node) {
      do {
        if (isText$1(node)) {
          node.nodeValue = node.nodeValue.replace(/^[\r\n]+/, "");
        }
        node = node.firstChild;
      } while (node);
    };
    var getEditableRoot$1 = function(dom2, node) {
      var root = dom2.getRoot();
      var parent2, editableRoot;
      parent2 = node;
      while (parent2 !== root && dom2.getContentEditable(parent2) !== "false") {
        if (dom2.getContentEditable(parent2) === "true") {
          editableRoot = parent2;
        }
        parent2 = parent2.parentNode;
      }
      return parent2 !== root ? editableRoot : root;
    };
    var applyAttributes = function(editor, node, forcedRootBlockAttrs) {
      var dom2 = editor.dom;
      Optional.from(forcedRootBlockAttrs.style).map(dom2.parseStyle).each(function(attrStyles) {
        var currentStyles = getAllRaw(SugarElement.fromDom(node));
        var newStyles = __assign2(__assign2({}, currentStyles), attrStyles);
        dom2.setStyles(node, newStyles);
      });
      var attrClassesOpt = Optional.from(forcedRootBlockAttrs.class).map(function(attrClasses) {
        return attrClasses.split(/\s+/);
      });
      var currentClassesOpt = Optional.from(node.className).map(function(currentClasses) {
        return filter(currentClasses.split(/\s+/), function(clazz) {
          return clazz !== "";
        });
      });
      lift2(attrClassesOpt, currentClassesOpt, function(attrClasses, currentClasses) {
        var filteredClasses = filter(currentClasses, function(clazz) {
          return !contains(attrClasses, clazz);
        });
        var newClasses = __spreadArrays(attrClasses, filteredClasses);
        dom2.setAttrib(node, "class", newClasses.join(" "));
      });
      var appliedAttrs = [
        "style",
        "class"
      ];
      var remainingAttrs = filter$1(forcedRootBlockAttrs, function(_, attrs) {
        return !contains(appliedAttrs, attrs);
      });
      dom2.setAttribs(node, remainingAttrs);
    };
    var setForcedBlockAttrs = function(editor, node) {
      var forcedRootBlockName = getForcedRootBlock(editor);
      if (forcedRootBlockName && forcedRootBlockName.toLowerCase() === node.tagName.toLowerCase()) {
        var forcedRootBlockAttrs = getForcedRootBlockAttrs(editor);
        applyAttributes(editor, node, forcedRootBlockAttrs);
      }
    };
    var wrapSelfAndSiblingsInDefaultBlock = function(editor, newBlockName, rng, container, offset) {
      var newBlock, parentBlock, startNode, node, next, rootBlockName;
      var blockName = newBlockName || "P";
      var dom2 = editor.dom, editableRoot = getEditableRoot$1(dom2, container);
      parentBlock = dom2.getParent(container, dom2.isBlock);
      if (!parentBlock || !canSplitBlock(dom2, parentBlock)) {
        parentBlock = parentBlock || editableRoot;
        if (parentBlock === editor.getBody() || isTableCell$5(parentBlock)) {
          rootBlockName = parentBlock.nodeName.toLowerCase();
        } else {
          rootBlockName = parentBlock.parentNode.nodeName.toLowerCase();
        }
        if (!parentBlock.hasChildNodes()) {
          newBlock = dom2.create(blockName);
          setForcedBlockAttrs(editor, newBlock);
          parentBlock.appendChild(newBlock);
          rng.setStart(newBlock, 0);
          rng.setEnd(newBlock, 0);
          return newBlock;
        }
        node = container;
        while (node.parentNode !== parentBlock) {
          node = node.parentNode;
        }
        while (node && !dom2.isBlock(node)) {
          startNode = node;
          node = node.previousSibling;
        }
        if (startNode && editor.schema.isValidChild(rootBlockName, blockName.toLowerCase())) {
          newBlock = dom2.create(blockName);
          setForcedBlockAttrs(editor, newBlock);
          startNode.parentNode.insertBefore(newBlock, startNode);
          node = startNode;
          while (node && !dom2.isBlock(node)) {
            next = node.nextSibling;
            newBlock.appendChild(node);
            node = next;
          }
          rng.setStart(container, offset);
          rng.setEnd(container, offset);
        }
      }
      return container;
    };
    var addBrToBlockIfNeeded = function(dom2, block) {
      block.normalize();
      var lastChild2 = block.lastChild;
      if (!lastChild2 || /^(left|right)$/gi.test(dom2.getStyle(lastChild2, "float", true))) {
        dom2.add(block, "br");
      }
    };
    var insert$1 = function(editor, evt) {
      var tmpRng, container, offset, parentBlock;
      var newBlock, fragment, containerBlock, parentBlockName, newBlockName, isAfterLastNodeInContainer;
      var dom2 = editor.dom;
      var schema = editor.schema, nonEmptyElementsMap = schema.getNonEmptyElements();
      var rng = editor.selection.getRng();
      var createNewBlock = function(name2) {
        var node = container, block, clonedNode, caretNode;
        var textInlineElements = schema.getTextInlineElements();
        if (name2 || parentBlockName === "TABLE" || parentBlockName === "HR") {
          block = dom2.create(name2 || newBlockName);
        } else {
          block = parentBlock.cloneNode(false);
        }
        caretNode = block;
        if (shouldKeepStyles(editor) === false) {
          dom2.setAttrib(block, "style", null);
          dom2.setAttrib(block, "class", null);
        } else {
          do {
            if (textInlineElements[node.nodeName]) {
              if (isCaretNode(node) || isBookmarkNode$1(node)) {
                continue;
              }
              clonedNode = node.cloneNode(false);
              dom2.setAttrib(clonedNode, "id", "");
              if (block.hasChildNodes()) {
                clonedNode.appendChild(block.firstChild);
                block.appendChild(clonedNode);
              } else {
                caretNode = clonedNode;
                block.appendChild(clonedNode);
              }
            }
          } while ((node = node.parentNode) && node !== editableRoot);
        }
        setForcedBlockAttrs(editor, block);
        emptyBlock(caretNode);
        return block;
      };
      var isCaretAtStartOrEndOfBlock = function(start2) {
        var node, name2;
        var normalizedOffset = normalizeZwspOffset(start2, container, offset);
        if (isText$1(container) && (start2 ? normalizedOffset > 0 : normalizedOffset < container.nodeValue.length)) {
          return false;
        }
        if (container.parentNode === parentBlock && isAfterLastNodeInContainer && !start2) {
          return true;
        }
        if (start2 && isElement$1(container) && container === parentBlock.firstChild) {
          return true;
        }
        if (containerAndSiblingName(container, "TABLE") || containerAndSiblingName(container, "HR")) {
          return isAfterLastNodeInContainer && !start2 || !isAfterLastNodeInContainer && start2;
        }
        var walker = new DomTreeWalker(container, parentBlock);
        if (isText$1(container)) {
          if (start2 && normalizedOffset === 0) {
            walker.prev();
          } else if (!start2 && normalizedOffset === container.nodeValue.length) {
            walker.next();
          }
        }
        while (node = walker.current()) {
          if (isElement$1(node)) {
            if (!node.getAttribute("data-mce-bogus")) {
              name2 = node.nodeName.toLowerCase();
              if (nonEmptyElementsMap[name2] && name2 !== "br") {
                return false;
              }
            }
          } else if (isText$1(node) && !isWhitespaceText(node.nodeValue)) {
            return false;
          }
          if (start2) {
            walker.prev();
          } else {
            walker.next();
          }
        }
        return true;
      };
      var insertNewBlockAfter = function() {
        if (/^(H[1-6]|PRE|FIGURE)$/.test(parentBlockName) && containerBlockName !== "HGROUP") {
          newBlock = createNewBlock(newBlockName);
        } else {
          newBlock = createNewBlock();
        }
        if (shouldEndContainerOnEmptyBlock(editor) && canSplitBlock(dom2, containerBlock) && dom2.isEmpty(parentBlock)) {
          newBlock = dom2.split(containerBlock, parentBlock);
        } else {
          dom2.insertAfter(newBlock, parentBlock);
        }
        moveToCaretPosition(editor, newBlock);
      };
      normalize(dom2, rng).each(function(normRng) {
        rng.setStart(normRng.startContainer, normRng.startOffset);
        rng.setEnd(normRng.endContainer, normRng.endOffset);
      });
      container = rng.startContainer;
      offset = rng.startOffset;
      newBlockName = getForcedRootBlock(editor);
      var shiftKey = !!(evt && evt.shiftKey);
      var ctrlKey = !!(evt && evt.ctrlKey);
      if (isElement$1(container) && container.hasChildNodes()) {
        isAfterLastNodeInContainer = offset > container.childNodes.length - 1;
        container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;
        if (isAfterLastNodeInContainer && isText$1(container)) {
          offset = container.nodeValue.length;
        } else {
          offset = 0;
        }
      }
      var editableRoot = getEditableRoot$1(dom2, container);
      if (!editableRoot) {
        return;
      }
      if (newBlockName && !shiftKey || !newBlockName && shiftKey) {
        container = wrapSelfAndSiblingsInDefaultBlock(editor, newBlockName, rng, container, offset);
      }
      parentBlock = dom2.getParent(container, dom2.isBlock);
      containerBlock = parentBlock ? dom2.getParent(parentBlock.parentNode, dom2.isBlock) : null;
      parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : "";
      var containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : "";
      if (containerBlockName === "LI" && !ctrlKey) {
        parentBlock = containerBlock;
        containerBlock = containerBlock.parentNode;
        parentBlockName = containerBlockName;
      }
      if (/^(LI|DT|DD)$/.test(parentBlockName)) {
        if (dom2.isEmpty(parentBlock)) {
          insert(editor, createNewBlock, containerBlock, parentBlock, newBlockName);
          return;
        }
      }
      if (newBlockName && parentBlock === editor.getBody()) {
        return;
      }
      newBlockName = newBlockName || "P";
      if (isCaretContainerBlock(parentBlock)) {
        newBlock = showCaretContainerBlock(parentBlock);
        if (dom2.isEmpty(parentBlock)) {
          emptyBlock(parentBlock);
        }
        setForcedBlockAttrs(editor, newBlock);
        moveToCaretPosition(editor, newBlock);
      } else if (isCaretAtStartOrEndOfBlock()) {
        insertNewBlockAfter();
      } else if (isCaretAtStartOrEndOfBlock(true)) {
        newBlock = parentBlock.parentNode.insertBefore(createNewBlock(), parentBlock);
        moveToCaretPosition(editor, containerAndSiblingName(parentBlock, "HR") ? newBlock : parentBlock);
      } else {
        tmpRng = includeZwspInRange(rng).cloneRange();
        tmpRng.setEndAfter(parentBlock);
        fragment = tmpRng.extractContents();
        trimZwsp(fragment);
        trimLeadingLineBreaks(fragment);
        newBlock = fragment.firstChild;
        dom2.insertAfter(fragment, parentBlock);
        trimInlineElementsOnLeftSideOfBlock(dom2, nonEmptyElementsMap, newBlock);
        addBrToBlockIfNeeded(dom2, parentBlock);
        if (dom2.isEmpty(parentBlock)) {
          emptyBlock(parentBlock);
        }
        newBlock.normalize();
        if (dom2.isEmpty(newBlock)) {
          dom2.remove(newBlock);
          insertNewBlockAfter();
        } else {
          setForcedBlockAttrs(editor, newBlock);
          moveToCaretPosition(editor, newBlock);
        }
      }
      dom2.setAttrib(newBlock, "id", "");
      editor.fire("NewBlock", { newBlock });
    };
    var hasRightSideContent = function(schema, container, parentBlock) {
      var walker = new DomTreeWalker(container, parentBlock);
      var node;
      var nonEmptyElementsMap = schema.getNonEmptyElements();
      while (node = walker.next()) {
        if (nonEmptyElementsMap[node.nodeName.toLowerCase()] || node.length > 0) {
          return true;
        }
      }
    };
    var moveSelectionToBr = function(editor, brElm, extraBr) {
      var rng = editor.dom.createRng();
      if (!extraBr) {
        rng.setStartAfter(brElm);
        rng.setEndAfter(brElm);
      } else {
        rng.setStartBefore(brElm);
        rng.setEndBefore(brElm);
      }
      editor.selection.setRng(rng);
      scrollRangeIntoView(editor, rng);
    };
    var insertBrAtCaret = function(editor, evt) {
      var selection = editor.selection;
      var dom2 = editor.dom;
      var rng = selection.getRng();
      var brElm;
      var extraBr;
      normalize(dom2, rng).each(function(normRng) {
        rng.setStart(normRng.startContainer, normRng.startOffset);
        rng.setEnd(normRng.endContainer, normRng.endOffset);
      });
      var offset = rng.startOffset;
      var container = rng.startContainer;
      if (container.nodeType === 1 && container.hasChildNodes()) {
        var isAfterLastNodeInContainer = offset > container.childNodes.length - 1;
        container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;
        if (isAfterLastNodeInContainer && container.nodeType === 3) {
          offset = container.nodeValue.length;
        } else {
          offset = 0;
        }
      }
      var parentBlock = dom2.getParent(container, dom2.isBlock);
      var containerBlock = parentBlock ? dom2.getParent(parentBlock.parentNode, dom2.isBlock) : null;
      var containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : "";
      var isControlKey = !!(evt && evt.ctrlKey);
      if (containerBlockName === "LI" && !isControlKey) {
        parentBlock = containerBlock;
      }
      if (container && container.nodeType === 3 && offset >= container.nodeValue.length) {
        if (!hasRightSideContent(editor.schema, container, parentBlock)) {
          brElm = dom2.create("br");
          rng.insertNode(brElm);
          rng.setStartAfter(brElm);
          rng.setEndAfter(brElm);
          extraBr = true;
        }
      }
      brElm = dom2.create("br");
      rangeInsertNode(dom2, rng, brElm);
      moveSelectionToBr(editor, brElm, extraBr);
      editor.undoManager.add();
    };
    var insertBrBefore = function(editor, inline) {
      var br = SugarElement.fromTag("br");
      before(SugarElement.fromDom(inline), br);
      editor.undoManager.add();
    };
    var insertBrAfter = function(editor, inline) {
      if (!hasBrAfter(editor.getBody(), inline)) {
        after(SugarElement.fromDom(inline), SugarElement.fromTag("br"));
      }
      var br = SugarElement.fromTag("br");
      after(SugarElement.fromDom(inline), br);
      moveSelectionToBr(editor, br.dom, false);
      editor.undoManager.add();
    };
    var isBeforeBr$1 = function(pos) {
      return isBr(pos.getNode());
    };
    var hasBrAfter = function(rootNode, startNode) {
      if (isBeforeBr$1(CaretPosition.after(startNode))) {
        return true;
      } else {
        return nextPosition(rootNode, CaretPosition.after(startNode)).map(function(pos) {
          return isBr(pos.getNode());
        }).getOr(false);
      }
    };
    var isAnchorLink = function(elm) {
      return elm && elm.nodeName === "A" && "href" in elm;
    };
    var isInsideAnchor = function(location) {
      return location.fold(never, isAnchorLink, isAnchorLink, never);
    };
    var readInlineAnchorLocation = function(editor) {
      var isInlineTarget$1 = curry(isInlineTarget, editor);
      var position = CaretPosition.fromRangeStart(editor.selection.getRng());
      return readLocation(isInlineTarget$1, editor.getBody(), position).filter(isInsideAnchor);
    };
    var insertBrOutsideAnchor = function(editor, location) {
      location.fold(noop, curry(insertBrBefore, editor), curry(insertBrAfter, editor), noop);
    };
    var insert$2 = function(editor, evt) {
      var anchorLocation = readInlineAnchorLocation(editor);
      if (anchorLocation.isSome()) {
        anchorLocation.each(curry(insertBrOutsideAnchor, editor));
      } else {
        insertBrAtCaret(editor, evt);
      }
    };
    var matchesSelector = function(editor, selector) {
      return getParentBlock$2(editor).filter(function(parentBlock) {
        return selector.length > 0 && is$1(SugarElement.fromDom(parentBlock), selector);
      }).isSome();
    };
    var shouldInsertBr = function(editor) {
      return matchesSelector(editor, getBrNewLineSelector(editor));
    };
    var shouldBlockNewLine = function(editor) {
      return matchesSelector(editor, getNoNewLineSelector(editor));
    };
    var newLineAction = Adt.generate([
      { br: [] },
      { block: [] },
      { none: [] }
    ]);
    var shouldBlockNewLine$1 = function(editor, _shiftKey) {
      return shouldBlockNewLine(editor);
    };
    var isBrMode = function(requiredState) {
      return function(editor, _shiftKey) {
        var brMode = getForcedRootBlock(editor) === "";
        return brMode === requiredState;
      };
    };
    var inListBlock = function(requiredState) {
      return function(editor, _shiftKey) {
        return isListItemParentBlock(editor) === requiredState;
      };
    };
    var inBlock = function(blockName, requiredState) {
      return function(editor, _shiftKey) {
        var state = getParentBlockName(editor) === blockName.toUpperCase();
        return state === requiredState;
      };
    };
    var inPreBlock = function(requiredState) {
      return inBlock("pre", requiredState);
    };
    var inSummaryBlock = function() {
      return inBlock("summary", true);
    };
    var shouldPutBrInPre$1 = function(requiredState) {
      return function(editor, _shiftKey) {
        return shouldPutBrInPre(editor) === requiredState;
      };
    };
    var inBrContext = function(editor, _shiftKey) {
      return shouldInsertBr(editor);
    };
    var hasShiftKey = function(_editor, shiftKey) {
      return shiftKey;
    };
    var canInsertIntoEditableRoot = function(editor) {
      var forcedRootBlock = getForcedRootBlock(editor);
      var rootEditable = getEditableRoot(editor.dom, editor.selection.getStart());
      return rootEditable && editor.schema.isValidChild(rootEditable.nodeName, forcedRootBlock ? forcedRootBlock : "P");
    };
    var match$2 = function(predicates, action2) {
      return function(editor, shiftKey) {
        var isMatch = foldl(predicates, function(res, p) {
          return res && p(editor, shiftKey);
        }, true);
        return isMatch ? Optional.some(action2) : Optional.none();
      };
    };
    var getAction$1 = function(editor, evt) {
      return evaluateUntil([
        match$2([shouldBlockNewLine$1], newLineAction.none()),
        match$2([inSummaryBlock()], newLineAction.br()),
        match$2([
          inPreBlock(true),
          shouldPutBrInPre$1(false),
          hasShiftKey
        ], newLineAction.br()),
        match$2([
          inPreBlock(true),
          shouldPutBrInPre$1(false)
        ], newLineAction.block()),
        match$2([
          inPreBlock(true),
          shouldPutBrInPre$1(true),
          hasShiftKey
        ], newLineAction.block()),
        match$2([
          inPreBlock(true),
          shouldPutBrInPre$1(true)
        ], newLineAction.br()),
        match$2([
          inListBlock(true),
          hasShiftKey
        ], newLineAction.br()),
        match$2([inListBlock(true)], newLineAction.block()),
        match$2([
          isBrMode(true),
          hasShiftKey,
          canInsertIntoEditableRoot
        ], newLineAction.block()),
        match$2([isBrMode(true)], newLineAction.br()),
        match$2([inBrContext], newLineAction.br()),
        match$2([
          isBrMode(false),
          hasShiftKey
        ], newLineAction.br()),
        match$2([canInsertIntoEditableRoot], newLineAction.block())
      ], [
        editor,
        !!(evt && evt.shiftKey)
      ]).getOr(newLineAction.none());
    };
    var insert$3 = function(editor, evt) {
      getAction$1(editor, evt).fold(function() {
        insert$2(editor, evt);
      }, function() {
        insert$1(editor, evt);
      }, noop);
    };
    var handleEnterKeyEvent = function(editor, event) {
      if (event.isDefaultPrevented()) {
        return;
      }
      event.preventDefault();
      endTypingLevelIgnoreLocks(editor.undoManager);
      editor.undoManager.transact(function() {
        if (editor.selection.isCollapsed() === false) {
          editor.execCommand("Delete");
        }
        insert$3(editor, event);
      });
    };
    var setup$e = function(editor) {
      editor.on("keydown", function(event) {
        if (event.keyCode === VK.ENTER) {
          handleEnterKeyEvent(editor, event);
        }
      });
    };
    var executeKeydownOverride$2 = function(editor, caret, evt) {
      execute([
        {
          keyCode: VK.END,
          action: action(moveToLineEndPoint$2, editor, true)
        },
        {
          keyCode: VK.HOME,
          action: action(moveToLineEndPoint$2, editor, false)
        },
        {
          keyCode: VK.END,
          action: action(moveToLineEndPoint$3, editor, true)
        },
        {
          keyCode: VK.HOME,
          action: action(moveToLineEndPoint$3, editor, false)
        },
        {
          keyCode: VK.END,
          action: action(moveToLineEndPoint$1, editor, true, caret)
        },
        {
          keyCode: VK.HOME,
          action: action(moveToLineEndPoint$1, editor, false, caret)
        }
      ], evt).each(function(_) {
        evt.preventDefault();
      });
    };
    var setup$f = function(editor, caret) {
      editor.on("keydown", function(evt) {
        if (evt.isDefaultPrevented() === false) {
          executeKeydownOverride$2(editor, caret, evt);
        }
      });
    };
    var browser$4 = detect$3().browser;
    var setupIeInput = function(editor) {
      var keypressThrotter = first(function() {
        if (!editor.composing) {
          normalizeNbspsInEditor(editor);
        }
      }, 0);
      if (browser$4.isIE()) {
        editor.on("keypress", function(_e) {
          keypressThrotter.throttle();
        });
        editor.on("remove", function(_e) {
          keypressThrotter.cancel();
        });
      }
    };
    var setup$g = function(editor) {
      setupIeInput(editor);
      editor.on("input", function(e) {
        if (e.isComposing === false) {
          normalizeNbspsInEditor(editor);
        }
      });
    };
    var platform$2 = detect$3();
    var executeKeyupAction = function(editor, caret, evt) {
      execute([
        {
          keyCode: VK.PAGE_UP,
          action: action(moveToLineEndPoint$1, editor, false, caret)
        },
        {
          keyCode: VK.PAGE_DOWN,
          action: action(moveToLineEndPoint$1, editor, true, caret)
        }
      ], evt);
    };
    var stopImmediatePropagation = function(e) {
      return e.stopImmediatePropagation();
    };
    var isPageUpDown = function(evt) {
      return evt.keyCode === VK.PAGE_UP || evt.keyCode === VK.PAGE_DOWN;
    };
    var setNodeChangeBlocker = function(blocked, editor, block) {
      if (block && !blocked.get()) {
        editor.on("NodeChange", stopImmediatePropagation, true);
      } else if (!block && blocked.get()) {
        editor.off("NodeChange", stopImmediatePropagation);
      }
      blocked.set(block);
    };
    var setup$h = function(editor, caret) {
      if (platform$2.os.isOSX()) {
        return;
      }
      var blocked = Cell(false);
      editor.on("keydown", function(evt) {
        if (isPageUpDown(evt)) {
          setNodeChangeBlocker(blocked, editor, true);
        }
      });
      editor.on("keyup", function(evt) {
        if (evt.isDefaultPrevented() === false) {
          executeKeyupAction(editor, caret, evt);
        }
        if (isPageUpDown(evt) && blocked.get()) {
          setNodeChangeBlocker(blocked, editor, false);
          editor.nodeChanged();
        }
      });
    };
    var insertTextAtPosition = function(text, pos) {
      var container = pos.container();
      var offset = pos.offset();
      if (isText$1(container)) {
        container.insertData(offset, text);
        return Optional.some(CaretPosition(container, offset + text.length));
      } else {
        return getElementFromPosition(pos).map(function(elm) {
          var textNode = SugarElement.fromText(text);
          if (pos.isAtEnd()) {
            after(elm, textNode);
          } else {
            before(elm, textNode);
          }
          return CaretPosition(textNode.dom, text.length);
        });
      }
    };
    var insertNbspAtPosition = curry(insertTextAtPosition, nbsp);
    var insertSpaceAtPosition = curry(insertTextAtPosition, " ");
    var locationToCaretPosition = function(root) {
      return function(location) {
        return location.fold(function(element) {
          return prevPosition(root.dom, CaretPosition.before(element));
        }, function(element) {
          return firstPositionIn(element);
        }, function(element) {
          return lastPositionIn(element);
        }, function(element) {
          return nextPosition(root.dom, CaretPosition.after(element));
        });
      };
    };
    var insertInlineBoundarySpaceOrNbsp = function(root, pos) {
      return function(checkPos) {
        return needsToHaveNbsp(root, checkPos) ? insertNbspAtPosition(pos) : insertSpaceAtPosition(pos);
      };
    };
    var setSelection$1 = function(editor) {
      return function(pos) {
        editor.selection.setRng(pos.toRange());
        editor.nodeChanged();
        return true;
      };
    };
    var insertSpaceOrNbspAtSelection = function(editor) {
      var pos = CaretPosition.fromRangeStart(editor.selection.getRng());
      var root = SugarElement.fromDom(editor.getBody());
      if (editor.selection.isCollapsed()) {
        var isInlineTarget$1 = curry(isInlineTarget, editor);
        var caretPosition = CaretPosition.fromRangeStart(editor.selection.getRng());
        return readLocation(isInlineTarget$1, editor.getBody(), caretPosition).bind(locationToCaretPosition(root)).bind(insertInlineBoundarySpaceOrNbsp(root, pos)).exists(setSelection$1(editor));
      } else {
        return false;
      }
    };
    var executeKeydownOverride$3 = function(editor, evt) {
      execute([{
        keyCode: VK.SPACEBAR,
        action: action(insertSpaceOrNbspAtSelection, editor)
      }], evt).each(function(_) {
        evt.preventDefault();
      });
    };
    var setup$i = function(editor) {
      editor.on("keydown", function(evt) {
        if (evt.isDefaultPrevented() === false) {
          executeKeydownOverride$3(editor, evt);
        }
      });
    };
    var registerKeyboardOverrides = function(editor) {
      var caret = setupSelectedState(editor);
      setup$b(editor);
      setup$c(editor, caret);
      setup$d(editor, caret);
      setup$e(editor);
      setup$i(editor);
      setup$g(editor);
      setup$f(editor, caret);
      setup$h(editor, caret);
      return caret;
    };
    var setup$j = function(editor) {
      if (!isRtc(editor)) {
        return registerKeyboardOverrides(editor);
      } else {
        return Cell(null);
      }
    };
    var NodeChange = function() {
      function NodeChange2(editor) {
        this.lastPath = [];
        this.editor = editor;
        var lastRng;
        var self2 = this;
        if (!("onselectionchange" in editor.getDoc())) {
          editor.on("NodeChange click mouseup keyup focus", function(e) {
            var nativeRng = editor.selection.getRng();
            var fakeRng = {
              startContainer: nativeRng.startContainer,
              startOffset: nativeRng.startOffset,
              endContainer: nativeRng.endContainer,
              endOffset: nativeRng.endOffset
            };
            if (e.type === "nodechange" || !isEq$1(fakeRng, lastRng)) {
              editor.fire("SelectionChange");
            }
            lastRng = fakeRng;
          });
        }
        editor.on("contextmenu", function() {
          editor.fire("SelectionChange");
        });
        editor.on("SelectionChange", function() {
          var startElm = editor.selection.getStart(true);
          if (!startElm || !Env.range && editor.selection.isCollapsed()) {
            return;
          }
          if (hasAnyRanges(editor) && !self2.isSameElementPath(startElm) && editor.dom.isChildOf(startElm, editor.getBody())) {
            editor.nodeChanged({ selectionChange: true });
          }
        });
        editor.on("mouseup", function(e) {
          if (!e.isDefaultPrevented() && hasAnyRanges(editor)) {
            if (editor.selection.getNode().nodeName === "IMG") {
              Delay.setEditorTimeout(editor, function() {
                editor.nodeChanged();
              });
            } else {
              editor.nodeChanged();
            }
          }
        });
      }
      NodeChange2.prototype.nodeChanged = function(args) {
        var selection = this.editor.selection;
        var node, parents2, root;
        if (this.editor.initialized && selection && !shouldDisableNodeChange(this.editor) && !this.editor.mode.isReadOnly()) {
          root = this.editor.getBody();
          node = selection.getStart(true) || root;
          if (node.ownerDocument !== this.editor.getDoc() || !this.editor.dom.isChildOf(node, root)) {
            node = root;
          }
          parents2 = [];
          this.editor.dom.getParent(node, function(node2) {
            if (node2 === root) {
              return true;
            }
            parents2.push(node2);
          });
          args = args || {};
          args.element = node;
          args.parents = parents2;
          this.editor.fire("NodeChange", args);
        }
      };
      NodeChange2.prototype.isSameElementPath = function(startElm) {
        var i;
        var currentPath = this.editor.$(startElm).parentsUntil(this.editor.getBody()).add(startElm);
        if (currentPath.length === this.lastPath.length) {
          for (i = currentPath.length; i >= 0; i--) {
            if (currentPath[i] !== this.lastPath[i]) {
              break;
            }
          }
          if (i === -1) {
            this.lastPath = currentPath;
            return true;
          }
        }
        this.lastPath = currentPath;
        return false;
      };
      return NodeChange2;
    }();
    var preventSummaryToggle = function(editor) {
      editor.on("click", function(e) {
        if (editor.dom.getParent(e.target, "details")) {
          e.preventDefault();
        }
      });
    };
    var filterDetails = function(editor) {
      editor.parser.addNodeFilter("details", function(elms) {
        each(elms, function(details) {
          details.attr("data-mce-open", details.attr("open"));
          details.attr("open", "open");
        });
      });
      editor.serializer.addNodeFilter("details", function(elms) {
        each(elms, function(details) {
          var open = details.attr("data-mce-open");
          details.attr("open", isString(open) ? open : null);
          details.attr("data-mce-open", null);
        });
      });
    };
    var setup$k = function(editor) {
      preventSummaryToggle(editor);
      filterDetails(editor);
    };
    var isTextBlockNode = function(node) {
      return isElement$1(node) && isTextBlock(SugarElement.fromDom(node));
    };
    var normalizeSelection$1 = function(editor) {
      var rng = editor.selection.getRng();
      var startPos = CaretPosition.fromRangeStart(rng);
      var endPos = CaretPosition.fromRangeEnd(rng);
      if (CaretPosition.isElementPosition(startPos)) {
        var container = startPos.container();
        if (isTextBlockNode(container)) {
          firstPositionIn(container).each(function(pos) {
            return rng.setStart(pos.container(), pos.offset());
          });
        }
      }
      if (CaretPosition.isElementPosition(endPos)) {
        var container = startPos.container();
        if (isTextBlockNode(container)) {
          lastPositionIn(container).each(function(pos) {
            return rng.setEnd(pos.container(), pos.offset());
          });
        }
      }
      editor.selection.setRng(normalize$2(rng));
    };
    var setup$l = function(editor) {
      editor.on("click", function(e) {
        if (e.detail >= 3) {
          normalizeSelection$1(editor);
        }
      });
    };
    var value$1 = function() {
      var subject = Cell(Optional.none());
      var clear2 = function() {
        return subject.set(Optional.none());
      };
      var set2 = function(s) {
        return subject.set(Optional.some(s));
      };
      var isSet = function() {
        return subject.get().isSome();
      };
      var on2 = function(f) {
        return subject.get().each(f);
      };
      return {
        clear: clear2,
        set: set2,
        isSet,
        on: on2
      };
    };
    var getAbsolutePosition = function(elm) {
      var clientRect = elm.getBoundingClientRect();
      var doc2 = elm.ownerDocument;
      var docElem2 = doc2.documentElement;
      var win = doc2.defaultView;
      return {
        top: clientRect.top + win.pageYOffset - docElem2.clientTop,
        left: clientRect.left + win.pageXOffset - docElem2.clientLeft
      };
    };
    var getBodyPosition = function(editor) {
      return editor.inline ? getAbsolutePosition(editor.getBody()) : {
        left: 0,
        top: 0
      };
    };
    var getScrollPosition = function(editor) {
      var body = editor.getBody();
      return editor.inline ? {
        left: body.scrollLeft,
        top: body.scrollTop
      } : {
        left: 0,
        top: 0
      };
    };
    var getBodyScroll = function(editor) {
      var body = editor.getBody(), docElm = editor.getDoc().documentElement;
      var inlineScroll = {
        left: body.scrollLeft,
        top: body.scrollTop
      };
      var iframeScroll = {
        left: body.scrollLeft || docElm.scrollLeft,
        top: body.scrollTop || docElm.scrollTop
      };
      return editor.inline ? inlineScroll : iframeScroll;
    };
    var getMousePosition = function(editor, event) {
      if (event.target.ownerDocument !== editor.getDoc()) {
        var iframePosition = getAbsolutePosition(editor.getContentAreaContainer());
        var scrollPosition = getBodyScroll(editor);
        return {
          left: event.pageX - iframePosition.left + scrollPosition.left,
          top: event.pageY - iframePosition.top + scrollPosition.top
        };
      }
      return {
        left: event.pageX,
        top: event.pageY
      };
    };
    var calculatePosition = function(bodyPosition, scrollPosition, mousePosition) {
      return {
        pageX: mousePosition.left - bodyPosition.left + scrollPosition.left,
        pageY: mousePosition.top - bodyPosition.top + scrollPosition.top
      };
    };
    var calc = function(editor, event) {
      return calculatePosition(getBodyPosition(editor), getScrollPosition(editor), getMousePosition(editor, event));
    };
    var isContentEditableFalse$a = isContentEditableFalse, isContentEditableTrue$3 = isContentEditableTrue;
    var isDraggable = function(rootElm, elm) {
      return isContentEditableFalse$a(elm) && elm !== rootElm;
    };
    var isValidDropTarget = function(editor, targetElement, dragElement) {
      if (targetElement === dragElement || editor.dom.isChildOf(targetElement, dragElement)) {
        return false;
      }
      return !isContentEditableFalse$a(targetElement);
    };
    var cloneElement = function(elm) {
      var cloneElm = elm.cloneNode(true);
      cloneElm.removeAttribute("data-mce-selected");
      return cloneElm;
    };
    var createGhost = function(editor, elm, width, height) {
      var dom2 = editor.dom;
      var clonedElm = elm.cloneNode(true);
      dom2.setStyles(clonedElm, {
        width,
        height
      });
      dom2.setAttrib(clonedElm, "data-mce-selected", null);
      var ghostElm = dom2.create("div", {
        "class": "mce-drag-container",
        "data-mce-bogus": "all",
        "unselectable": "on",
        "contenteditable": "false"
      });
      dom2.setStyles(ghostElm, {
        position: "absolute",
        opacity: 0.5,
        overflow: "hidden",
        border: 0,
        padding: 0,
        margin: 0,
        width,
        height
      });
      dom2.setStyles(clonedElm, {
        margin: 0,
        boxSizing: "border-box"
      });
      ghostElm.appendChild(clonedElm);
      return ghostElm;
    };
    var appendGhostToBody = function(ghostElm, bodyElm) {
      if (ghostElm.parentNode !== bodyElm) {
        bodyElm.appendChild(ghostElm);
      }
    };
    var moveGhost = function(ghostElm, position, width, height, maxX, maxY) {
      var overflowX = 0, overflowY = 0;
      ghostElm.style.left = position.pageX + "px";
      ghostElm.style.top = position.pageY + "px";
      if (position.pageX + width > maxX) {
        overflowX = position.pageX + width - maxX;
      }
      if (position.pageY + height > maxY) {
        overflowY = position.pageY + height - maxY;
      }
      ghostElm.style.width = width - overflowX + "px";
      ghostElm.style.height = height - overflowY + "px";
    };
    var removeElement = function(elm) {
      if (elm && elm.parentNode) {
        elm.parentNode.removeChild(elm);
      }
    };
    var isLeftMouseButtonPressed = function(e) {
      return e.button === 0;
    };
    var applyRelPos = function(state, position) {
      return {
        pageX: position.pageX - state.relX,
        pageY: position.pageY + 5
      };
    };
    var start$1 = function(state, editor) {
      return function(e) {
        if (isLeftMouseButtonPressed(e)) {
          var ceElm = find(editor.dom.getParents(e.target), or(isContentEditableFalse$a, isContentEditableTrue$3)).getOr(null);
          if (isDraggable(editor.getBody(), ceElm)) {
            var elmPos = editor.dom.getPos(ceElm);
            var bodyElm = editor.getBody();
            var docElm = editor.getDoc().documentElement;
            state.set({
              element: ceElm,
              dragging: false,
              screenX: e.screenX,
              screenY: e.screenY,
              maxX: (editor.inline ? bodyElm.scrollWidth : docElm.offsetWidth) - 2,
              maxY: (editor.inline ? bodyElm.scrollHeight : docElm.offsetHeight) - 2,
              relX: e.pageX - elmPos.x,
              relY: e.pageY - elmPos.y,
              width: ceElm.offsetWidth,
              height: ceElm.offsetHeight,
              ghost: createGhost(editor, ceElm, ceElm.offsetWidth, ceElm.offsetHeight)
            });
          }
        }
      };
    };
    var move$2 = function(state, editor) {
      var throttledPlaceCaretAt = Delay.throttle(function(clientX, clientY) {
        editor._selectionOverrides.hideFakeCaret();
        editor.selection.placeCaretAt(clientX, clientY);
      }, 0);
      editor.on("remove", throttledPlaceCaretAt.stop);
      return function(e) {
        return state.on(function(state2) {
          var movement = Math.max(Math.abs(e.screenX - state2.screenX), Math.abs(e.screenY - state2.screenY));
          if (!state2.dragging && movement > 10) {
            var args = editor.fire("dragstart", { target: state2.element });
            if (args.isDefaultPrevented()) {
              return;
            }
            state2.dragging = true;
            editor.focus();
          }
          if (state2.dragging) {
            var targetPos = applyRelPos(state2, calc(editor, e));
            appendGhostToBody(state2.ghost, editor.getBody());
            moveGhost(state2.ghost, targetPos, state2.width, state2.height, state2.maxX, state2.maxY);
            throttledPlaceCaretAt(e.clientX, e.clientY);
          }
        });
      };
    };
    var getRawTarget = function(selection) {
      var rng = selection.getSel().getRangeAt(0);
      var startContainer = rng.startContainer;
      return startContainer.nodeType === 3 ? startContainer.parentNode : startContainer;
    };
    var drop = function(state, editor) {
      return function(e) {
        state.on(function(state2) {
          if (state2.dragging) {
            if (isValidDropTarget(editor, getRawTarget(editor.selection), state2.element)) {
              var targetClone_1 = cloneElement(state2.element);
              var args = editor.fire("drop", {
                clientX: e.clientX,
                clientY: e.clientY
              });
              if (!args.isDefaultPrevented()) {
                editor.undoManager.transact(function() {
                  removeElement(state2.element);
                  editor.insertContent(editor.dom.getOuterHTML(targetClone_1));
                  editor._selectionOverrides.hideFakeCaret();
                });
              }
            }
          }
        });
        removeDragState(state);
      };
    };
    var stop = function(state, editor) {
      return function() {
        state.on(function(state2) {
          if (state2.dragging) {
            editor.fire("dragend");
          }
        });
        removeDragState(state);
      };
    };
    var removeDragState = function(state) {
      state.on(function(state2) {
        removeElement(state2.ghost);
      });
      state.clear();
    };
    var bindFakeDragEvents = function(editor) {
      var state = value$1();
      var pageDom = DOMUtils.DOM;
      var rootDocument = document;
      var dragStartHandler = start$1(state, editor);
      var dragHandler = move$2(state, editor);
      var dropHandler = drop(state, editor);
      var dragEndHandler = stop(state, editor);
      editor.on("mousedown", dragStartHandler);
      editor.on("mousemove", dragHandler);
      editor.on("mouseup", dropHandler);
      pageDom.bind(rootDocument, "mousemove", dragHandler);
      pageDom.bind(rootDocument, "mouseup", dragEndHandler);
      editor.on("remove", function() {
        pageDom.unbind(rootDocument, "mousemove", dragHandler);
        pageDom.unbind(rootDocument, "mouseup", dragEndHandler);
      });
    };
    var blockIeDrop = function(editor) {
      editor.on("drop", function(e) {
        var realTarget = typeof e.clientX !== "undefined" ? editor.getDoc().elementFromPoint(e.clientX, e.clientY) : null;
        if (isContentEditableFalse$a(realTarget) || editor.dom.getContentEditableParent(realTarget) === "false") {
          e.preventDefault();
        }
      });
    };
    var blockUnsupportedFileDrop = function(editor) {
      var preventFileDrop = function(e) {
        if (!e.isDefaultPrevented()) {
          var dataTransfer = e.dataTransfer;
          if (dataTransfer && (contains(dataTransfer.types, "Files") || dataTransfer.files.length > 0)) {
            e.preventDefault();
            if (e.type === "drop") {
              displayError(editor, "Dropped file type is not supported");
            }
          }
        }
      };
      var preventFileDropIfUIElement = function(e) {
        if (isUIElement(editor, e.target)) {
          preventFileDrop(e);
        }
      };
      var setup2 = function() {
        var pageDom = DOMUtils.DOM;
        var dom2 = editor.dom;
        var doc2 = document;
        var editorRoot = editor.inline ? editor.getBody() : editor.getDoc();
        var eventNames = [
          "drop",
          "dragover"
        ];
        each(eventNames, function(name2) {
          pageDom.bind(doc2, name2, preventFileDropIfUIElement);
          dom2.bind(editorRoot, name2, preventFileDrop);
        });
        editor.on("remove", function() {
          each(eventNames, function(name2) {
            pageDom.unbind(doc2, name2, preventFileDropIfUIElement);
            dom2.unbind(editorRoot, name2, preventFileDrop);
          });
        });
      };
      editor.on("init", function() {
        Delay.setEditorTimeout(editor, setup2, 0);
      });
    };
    var init = function(editor) {
      bindFakeDragEvents(editor);
      blockIeDrop(editor);
      if (shouldBlockUnsupportedDrop(editor)) {
        blockUnsupportedFileDrop(editor);
      }
    };
    var setup$m = function(editor) {
      var renderFocusCaret = first(function() {
        if (!editor.removed && editor.getBody().contains(document.activeElement)) {
          var rng = editor.selection.getRng();
          if (rng.collapsed) {
            var caretRange = renderRangeCaret(editor, rng, false);
            editor.selection.setRng(caretRange);
          }
        }
      }, 0);
      editor.on("focus", function() {
        renderFocusCaret.throttle();
      });
      editor.on("blur", function() {
        renderFocusCaret.cancel();
      });
    };
    var setup$n = function(editor) {
      editor.on("init", function() {
        editor.on("focusin", function(e) {
          var target = e.target;
          if (isMedia(target)) {
            var ceRoot = getContentEditableRoot(editor.getBody(), target);
            var node = isContentEditableFalse(ceRoot) ? ceRoot : target;
            if (editor.selection.getNode() !== node) {
              selectNode(editor, node).each(function(rng) {
                return editor.selection.setRng(rng);
              });
            }
          }
        });
      });
    };
    var isContentEditableTrue$4 = isContentEditableTrue;
    var isContentEditableFalse$b = isContentEditableFalse;
    var getContentEditableRoot$1 = function(editor, node) {
      return getContentEditableRoot(editor.getBody(), node);
    };
    var SelectionOverrides = function(editor) {
      var selection = editor.selection, dom2 = editor.dom;
      var isBlock2 = dom2.isBlock;
      var rootNode = editor.getBody();
      var fakeCaret = FakeCaret(editor, rootNode, isBlock2, function() {
        return hasFocus$1(editor);
      });
      var realSelectionId = "sel-" + dom2.uniqueId();
      var elementSelectionAttr = "data-mce-selected";
      var selectedElement;
      var isFakeSelectionElement = function(node) {
        return dom2.hasClass(node, "mce-offscreen-selection");
      };
      var isFakeSelectionTargetElement = function(node) {
        return node !== rootNode && (isContentEditableFalse$b(node) || isMedia(node)) && dom2.isChildOf(node, rootNode);
      };
      var isNearFakeSelectionElement = function(pos) {
        return isBeforeContentEditableFalse(pos) || isAfterContentEditableFalse(pos) || isBeforeMedia(pos) || isAfterMedia(pos);
      };
      var getRealSelectionElement = function() {
        var container = dom2.get(realSelectionId);
        return container ? container.getElementsByTagName("*")[0] : container;
      };
      var setRange = function(range2) {
        if (range2) {
          selection.setRng(range2);
        }
      };
      var getRange = selection.getRng;
      var showCaret2 = function(direction, node, before2, scrollIntoView) {
        if (scrollIntoView === void 0) {
          scrollIntoView = true;
        }
        var e = editor.fire("ShowCaret", {
          target: node,
          direction,
          before: before2
        });
        if (e.isDefaultPrevented()) {
          return null;
        }
        if (scrollIntoView) {
          selection.scrollIntoView(node, direction === -1);
        }
        return fakeCaret.show(before2, node);
      };
      var showBlockCaretContainer2 = function(blockCaretContainer) {
        if (blockCaretContainer.hasAttribute("data-mce-caret")) {
          showCaretContainerBlock(blockCaretContainer);
          setRange(getRange());
          selection.scrollIntoView(blockCaretContainer);
        }
      };
      var registerEvents2 = function() {
        editor.on("mouseup", function(e) {
          var range2 = getRange();
          if (range2.collapsed && isXYInContentArea(editor, e.clientX, e.clientY)) {
            renderCaretAtRange(editor, range2, false).each(setRange);
          }
        });
        editor.on("click", function(e) {
          var contentEditableRoot = getContentEditableRoot$1(editor, e.target);
          if (contentEditableRoot) {
            if (isContentEditableFalse$b(contentEditableRoot)) {
              e.preventDefault();
              editor.focus();
            }
            if (isContentEditableTrue$4(contentEditableRoot)) {
              if (dom2.isChildOf(contentEditableRoot, selection.getNode())) {
                removeElementSelection();
              }
            }
          }
        });
        editor.on("blur NewBlock", removeElementSelection);
        editor.on("ResizeWindow FullscreenStateChanged", fakeCaret.reposition);
        var hasNormalCaretPosition = function(elm) {
          var caretWalker = CaretWalker(elm);
          if (!elm.firstChild) {
            return false;
          }
          var startPos = CaretPosition.before(elm.firstChild);
          var newPos = caretWalker.next(startPos);
          return newPos && !isNearFakeSelectionElement(newPos);
        };
        var isInSameBlock2 = function(node1, node2) {
          var block1 = dom2.getParent(node1, isBlock2);
          var block2 = dom2.getParent(node2, isBlock2);
          return block1 === block2;
        };
        var hasBetterMouseTarget = function(targetNode, caretNode) {
          var targetBlock = dom2.getParent(targetNode, isBlock2);
          var caretBlock = dom2.getParent(caretNode, isBlock2);
          if (targetBlock && targetNode !== caretBlock && dom2.isChildOf(targetBlock, caretBlock) && isContentEditableFalse$b(getContentEditableRoot$1(editor, targetBlock)) === false) {
            return true;
          }
          return targetBlock && !isInSameBlock2(targetBlock, caretBlock) && hasNormalCaretPosition(targetBlock);
        };
        editor.on("tap", function(e) {
          var targetElm = e.target;
          var contentEditableRoot = getContentEditableRoot$1(editor, targetElm);
          if (isContentEditableFalse$b(contentEditableRoot)) {
            e.preventDefault();
            selectNode(editor, contentEditableRoot).each(setElementSelection);
          } else if (isFakeSelectionTargetElement(targetElm)) {
            selectNode(editor, targetElm).each(setElementSelection);
          }
        }, true);
        editor.on("mousedown", function(e) {
          var targetElm = e.target;
          if (targetElm !== rootNode && targetElm.nodeName !== "HTML" && !dom2.isChildOf(targetElm, rootNode)) {
            return;
          }
          if (isXYInContentArea(editor, e.clientX, e.clientY) === false) {
            return;
          }
          var contentEditableRoot = getContentEditableRoot$1(editor, targetElm);
          if (contentEditableRoot) {
            if (isContentEditableFalse$b(contentEditableRoot)) {
              e.preventDefault();
              selectNode(editor, contentEditableRoot).each(setElementSelection);
            } else {
              removeElementSelection();
              if (!(isContentEditableTrue$4(contentEditableRoot) && e.shiftKey) && !isXYWithinRange(e.clientX, e.clientY, selection.getRng())) {
                hideFakeCaret();
                selection.placeCaretAt(e.clientX, e.clientY);
              }
            }
          } else if (isFakeSelectionTargetElement(targetElm)) {
            selectNode(editor, targetElm).each(setElementSelection);
          } else if (isFakeCaretTarget(targetElm) === false) {
            removeElementSelection();
            hideFakeCaret();
            var fakeCaretInfo = closestFakeCaret(rootNode, e.clientX, e.clientY);
            if (fakeCaretInfo) {
              if (!hasBetterMouseTarget(targetElm, fakeCaretInfo.node)) {
                e.preventDefault();
                var range2 = showCaret2(1, fakeCaretInfo.node, fakeCaretInfo.before, false);
                editor.getBody().focus();
                setRange(range2);
              }
            }
          }
        });
        editor.on("keypress", function(e) {
          if (VK.modifierPressed(e)) {
            return;
          }
          if (isContentEditableFalse$b(selection.getNode())) {
            e.preventDefault();
          }
        });
        editor.on("GetSelectionRange", function(e) {
          var rng = e.range;
          if (selectedElement) {
            if (!selectedElement.parentNode) {
              selectedElement = null;
              return;
            }
            rng = rng.cloneRange();
            rng.selectNode(selectedElement);
            e.range = rng;
          }
        });
        editor.on("SetSelectionRange", function(e) {
          e.range = normalizeShortEndedElementSelection(e.range);
          var rng = setElementSelection(e.range, e.forward);
          if (rng) {
            e.range = rng;
          }
        });
        var isPasteBin = function(node) {
          return node.id === "mcepastebin";
        };
        editor.on("AfterSetSelectionRange", function(e) {
          var rng = e.range;
          var parentNode = rng.startContainer.parentNode;
          if (!isRangeInCaretContainer(rng) && !isPasteBin(parentNode)) {
            hideFakeCaret();
          }
          if (!isFakeSelectionElement(parentNode)) {
            removeElementSelection();
          }
        });
        editor.on("copy", function(e) {
          var clipboardData = e.clipboardData;
          if (!e.isDefaultPrevented() && e.clipboardData && !Env.ie) {
            var realSelectionElement = getRealSelectionElement();
            if (realSelectionElement) {
              e.preventDefault();
              clipboardData.clearData();
              clipboardData.setData("text/html", realSelectionElement.outerHTML);
              clipboardData.setData("text/plain", realSelectionElement.outerText || realSelectionElement.innerText);
            }
          }
        });
        init(editor);
        setup$m(editor);
        setup$n(editor);
      };
      var isWithinCaretContainer = function(node) {
        return isCaretContainer(node) || startsWithCaretContainer(node) || endsWithCaretContainer(node);
      };
      var isRangeInCaretContainer = function(rng) {
        return isWithinCaretContainer(rng.startContainer) || isWithinCaretContainer(rng.endContainer);
      };
      var normalizeShortEndedElementSelection = function(rng) {
        var shortEndedElements = editor.schema.getShortEndedElements();
        var newRng = dom2.createRng();
        var startContainer = rng.startContainer;
        var startOffset = rng.startOffset;
        var endContainer = rng.endContainer;
        var endOffset = rng.endOffset;
        if (has(shortEndedElements, startContainer.nodeName.toLowerCase())) {
          if (startOffset === 0) {
            newRng.setStartBefore(startContainer);
          } else {
            newRng.setStartAfter(startContainer);
          }
        } else {
          newRng.setStart(startContainer, startOffset);
        }
        if (has(shortEndedElements, endContainer.nodeName.toLowerCase())) {
          if (endOffset === 0) {
            newRng.setEndBefore(endContainer);
          } else {
            newRng.setEndAfter(endContainer);
          }
        } else {
          newRng.setEnd(endContainer, endOffset);
        }
        return newRng;
      };
      var setupOffscreenSelection = function(node, targetClone, origTargetClone) {
        var $ = editor.$;
        var $realSelectionContainer = descendant(SugarElement.fromDom(editor.getBody()), "#" + realSelectionId).fold(function() {
          return $([]);
        }, function(elm) {
          return $([elm.dom]);
        });
        if ($realSelectionContainer.length === 0) {
          $realSelectionContainer = $('<div data-mce-bogus="all" class="mce-offscreen-selection"></div>').attr("id", realSelectionId);
          $realSelectionContainer.appendTo(editor.getBody());
        }
        var newRange = dom2.createRng();
        if (targetClone === origTargetClone && Env.ie) {
          $realSelectionContainer.empty().append('<p style="font-size: 0" data-mce-bogus="all">\xA0</p>').append(targetClone);
          newRange.setStartAfter($realSelectionContainer[0].firstChild.firstChild);
          newRange.setEndAfter(targetClone);
        } else {
          $realSelectionContainer.empty().append(nbsp).append(targetClone).append(nbsp);
          newRange.setStart($realSelectionContainer[0].firstChild, 1);
          newRange.setEnd($realSelectionContainer[0].lastChild, 0);
        }
        $realSelectionContainer.css({ top: dom2.getPos(node, editor.getBody()).y });
        $realSelectionContainer[0].focus();
        var sel = selection.getSel();
        sel.removeAllRanges();
        sel.addRange(newRange);
        return newRange;
      };
      var selectElement = function(elm) {
        var targetClone = elm.cloneNode(true);
        var e = editor.fire("ObjectSelected", {
          target: elm,
          targetClone
        });
        if (e.isDefaultPrevented()) {
          return null;
        }
        var range2 = setupOffscreenSelection(elm, e.targetClone, targetClone);
        var nodeElm = SugarElement.fromDom(elm);
        each(descendants$1(SugarElement.fromDom(editor.getBody()), "*[data-mce-selected]"), function(elm2) {
          if (!eq$2(nodeElm, elm2)) {
            remove$1(elm2, elementSelectionAttr);
          }
        });
        if (!dom2.getAttrib(elm, elementSelectionAttr)) {
          elm.setAttribute(elementSelectionAttr, "1");
        }
        selectedElement = elm;
        hideFakeCaret();
        return range2;
      };
      var setElementSelection = function(range2, forward) {
        if (!range2) {
          return null;
        }
        if (range2.collapsed) {
          if (!isRangeInCaretContainer(range2)) {
            var dir2 = forward ? 1 : -1;
            var caretPosition = getNormalizedRangeEndPoint(dir2, rootNode, range2);
            var beforeNode = caretPosition.getNode(!forward);
            if (isFakeCaretTarget(beforeNode)) {
              return showCaret2(dir2, beforeNode, forward ? !caretPosition.isAtEnd() : false, false);
            }
            var afterNode = caretPosition.getNode(forward);
            if (isFakeCaretTarget(afterNode)) {
              return showCaret2(dir2, afterNode, forward ? false : !caretPosition.isAtEnd(), false);
            }
          }
          return null;
        }
        var startContainer = range2.startContainer;
        var startOffset = range2.startOffset;
        var endOffset = range2.endOffset;
        if (startContainer.nodeType === 3 && startOffset === 0 && isContentEditableFalse$b(startContainer.parentNode)) {
          startContainer = startContainer.parentNode;
          startOffset = dom2.nodeIndex(startContainer);
          startContainer = startContainer.parentNode;
        }
        if (startContainer.nodeType !== 1) {
          return null;
        }
        if (endOffset === startOffset + 1 && startContainer === range2.endContainer) {
          var node = startContainer.childNodes[startOffset];
          if (isFakeSelectionTargetElement(node)) {
            return selectElement(node);
          }
        }
        return null;
      };
      var removeElementSelection = function() {
        if (selectedElement) {
          selectedElement.removeAttribute(elementSelectionAttr);
        }
        descendant(SugarElement.fromDom(editor.getBody()), "#" + realSelectionId).each(remove);
        selectedElement = null;
      };
      var destroy2 = function() {
        fakeCaret.destroy();
        selectedElement = null;
      };
      var hideFakeCaret = function() {
        fakeCaret.hide();
      };
      if (Env.ceFalse && !isRtc(editor)) {
        registerEvents2();
      }
      return {
        showCaret: showCaret2,
        showBlockCaretContainer: showBlockCaretContainer2,
        hideFakeCaret,
        destroy: destroy2
      };
    };
    var Quirks = function(editor) {
      var each2 = Tools.each;
      var BACKSPACE = VK.BACKSPACE, DELETE2 = VK.DELETE, dom2 = editor.dom, selection = editor.selection, parser = editor.parser;
      var isGecko = Env.gecko, isIE2 = Env.ie, isWebKit = Env.webkit;
      var mceInternalUrlPrefix = "data:text/mce-internal,";
      var mceInternalDataType = isIE2 ? "Text" : "URL";
      var setEditorCommandState2 = function(cmd, state) {
        try {
          editor.getDoc().execCommand(cmd, false, state);
        } catch (ex) {
        }
      };
      var isDefaultPrevented = function(e) {
        return e.isDefaultPrevented();
      };
      var setMceInternalContent = function(e) {
        var selectionHtml, internalContent;
        if (e.dataTransfer) {
          if (editor.selection.isCollapsed() && e.target.tagName === "IMG") {
            selection.select(e.target);
          }
          selectionHtml = editor.selection.getContent();
          if (selectionHtml.length > 0) {
            internalContent = mceInternalUrlPrefix + escape(editor.id) + "," + escape(selectionHtml);
            e.dataTransfer.setData(mceInternalDataType, internalContent);
          }
        }
      };
      var getMceInternalContent = function(e) {
        var internalContent;
        if (e.dataTransfer) {
          internalContent = e.dataTransfer.getData(mceInternalDataType);
          if (internalContent && internalContent.indexOf(mceInternalUrlPrefix) >= 0) {
            internalContent = internalContent.substr(mceInternalUrlPrefix.length).split(",");
            return {
              id: unescape(internalContent[0]),
              html: unescape(internalContent[1])
            };
          }
        }
        return null;
      };
      var insertClipboardContents = function(content, internal) {
        if (editor.queryCommandSupported("mceInsertClipboardContent")) {
          editor.execCommand("mceInsertClipboardContent", false, {
            content,
            internal
          });
        } else {
          editor.execCommand("mceInsertContent", false, content);
        }
      };
      var emptyEditorWhenDeleting = function() {
        var serializeRng = function(rng) {
          var body = dom2.create("body");
          var contents = rng.cloneContents();
          body.appendChild(contents);
          return selection.serializer.serialize(body, { format: "html" });
        };
        var allContentsSelected = function(rng) {
          var selection2 = serializeRng(rng);
          var allRng = dom2.createRng();
          allRng.selectNode(editor.getBody());
          var allSelection = serializeRng(allRng);
          return selection2 === allSelection;
        };
        editor.on("keydown", function(e) {
          var keyCode = e.keyCode;
          var isCollapsed, body;
          if (!isDefaultPrevented(e) && (keyCode === DELETE2 || keyCode === BACKSPACE)) {
            isCollapsed = editor.selection.isCollapsed();
            body = editor.getBody();
            if (isCollapsed && !dom2.isEmpty(body)) {
              return;
            }
            if (!isCollapsed && !allContentsSelected(editor.selection.getRng())) {
              return;
            }
            e.preventDefault();
            editor.setContent("");
            if (body.firstChild && dom2.isBlock(body.firstChild)) {
              editor.selection.setCursorLocation(body.firstChild, 0);
            } else {
              editor.selection.setCursorLocation(body, 0);
            }
            editor.nodeChanged();
          }
        });
      };
      var selectAll = function() {
        editor.shortcuts.add("meta+a", null, "SelectAll");
      };
      var inputMethodFocus = function() {
        if (!editor.inline) {
          dom2.bind(editor.getDoc(), "mousedown mouseup", function(e) {
            var rng;
            if (e.target === editor.getDoc().documentElement) {
              rng = selection.getRng();
              editor.getBody().focus();
              if (e.type === "mousedown") {
                if (isCaretContainer(rng.startContainer)) {
                  return;
                }
                selection.placeCaretAt(e.clientX, e.clientY);
              } else {
                selection.setRng(rng);
              }
            }
          });
        }
      };
      var removeHrOnBackspace = function() {
        editor.on("keydown", function(e) {
          if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {
            if (!editor.getBody().getElementsByTagName("hr").length) {
              return;
            }
            if (selection.isCollapsed() && selection.getRng().startOffset === 0) {
              var node = selection.getNode();
              var previousSibling = node.previousSibling;
              if (node.nodeName === "HR") {
                dom2.remove(node);
                e.preventDefault();
                return;
              }
              if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === "hr") {
                dom2.remove(previousSibling);
                e.preventDefault();
              }
            }
          }
        });
      };
      var focusBody2 = function() {
        if (!Range.prototype.getClientRects) {
          editor.on("mousedown", function(e) {
            if (!isDefaultPrevented(e) && e.target.nodeName === "HTML") {
              var body_1 = editor.getBody();
              body_1.blur();
              Delay.setEditorTimeout(editor, function() {
                body_1.focus();
              });
            }
          });
        }
      };
      var selectControlElements = function() {
        editor.on("click", function(e) {
          var target = e.target;
          if (/^(IMG|HR)$/.test(target.nodeName) && dom2.getContentEditableParent(target) !== "false") {
            e.preventDefault();
            editor.selection.select(target);
            editor.nodeChanged();
          }
          if (target.nodeName === "A" && dom2.hasClass(target, "mce-item-anchor")) {
            e.preventDefault();
            selection.select(target);
          }
        });
      };
      var removeStylesWhenDeletingAcrossBlockElements = function() {
        var getAttributeApplyFunction = function() {
          var template = dom2.getAttribs(selection.getStart().cloneNode(false));
          return function() {
            var target = selection.getStart();
            if (target !== editor.getBody()) {
              dom2.setAttrib(target, "style", null);
              each2(template, function(attr) {
                target.setAttributeNode(attr.cloneNode(true));
              });
            }
          };
        };
        var isSelectionAcrossElements = function() {
          return !selection.isCollapsed() && dom2.getParent(selection.getStart(), dom2.isBlock) !== dom2.getParent(selection.getEnd(), dom2.isBlock);
        };
        editor.on("keypress", function(e) {
          var applyAttributes2;
          if (!isDefaultPrevented(e) && (e.keyCode === 8 || e.keyCode === 46) && isSelectionAcrossElements()) {
            applyAttributes2 = getAttributeApplyFunction();
            editor.getDoc().execCommand("delete", false, null);
            applyAttributes2();
            e.preventDefault();
            return false;
          }
        });
        dom2.bind(editor.getDoc(), "cut", function(e) {
          var applyAttributes2;
          if (!isDefaultPrevented(e) && isSelectionAcrossElements()) {
            applyAttributes2 = getAttributeApplyFunction();
            Delay.setEditorTimeout(editor, function() {
              applyAttributes2();
            });
          }
        });
      };
      var disableBackspaceIntoATable = function() {
        editor.on("keydown", function(e) {
          if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {
            if (selection.isCollapsed() && selection.getRng().startOffset === 0) {
              var previousSibling = selection.getNode().previousSibling;
              if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === "table") {
                e.preventDefault();
                return false;
              }
            }
          }
        });
      };
      var removeBlockQuoteOnBackSpace = function() {
        editor.on("keydown", function(e) {
          var rng, parent2;
          if (isDefaultPrevented(e) || e.keyCode !== VK.BACKSPACE) {
            return;
          }
          rng = selection.getRng();
          var container = rng.startContainer;
          var offset = rng.startOffset;
          var root = dom2.getRoot();
          parent2 = container;
          if (!rng.collapsed || offset !== 0) {
            return;
          }
          while (parent2 && parent2.parentNode && parent2.parentNode.firstChild === parent2 && parent2.parentNode !== root) {
            parent2 = parent2.parentNode;
          }
          if (parent2.tagName === "BLOCKQUOTE") {
            editor.formatter.toggle("blockquote", null, parent2);
            rng = dom2.createRng();
            rng.setStart(container, 0);
            rng.setEnd(container, 0);
            selection.setRng(rng);
          }
        });
      };
      var setGeckoEditingOptions = function() {
        var setOpts = function() {
          setEditorCommandState2("StyleWithCSS", false);
          setEditorCommandState2("enableInlineTableEditing", false);
          if (!getObjectResizing(editor)) {
            setEditorCommandState2("enableObjectResizing", false);
          }
        };
        if (!isReadOnly(editor)) {
          editor.on("BeforeExecCommand mousedown", setOpts);
        }
      };
      var addBrAfterLastLinks = function() {
        var fixLinks = function() {
          each2(dom2.select("a"), function(node) {
            var parentNode = node.parentNode;
            var root = dom2.getRoot();
            if (parentNode.lastChild === node) {
              while (parentNode && !dom2.isBlock(parentNode)) {
                if (parentNode.parentNode.lastChild !== parentNode || parentNode === root) {
                  return;
                }
                parentNode = parentNode.parentNode;
              }
              dom2.add(parentNode, "br", { "data-mce-bogus": 1 });
            }
          });
        };
        editor.on("SetContent ExecCommand", function(e) {
          if (e.type === "setcontent" || e.command === "mceInsertLink") {
            fixLinks();
          }
        });
      };
      var setDefaultBlockType = function() {
        if (getForcedRootBlock(editor)) {
          editor.on("init", function() {
            setEditorCommandState2("DefaultParagraphSeparator", getForcedRootBlock(editor));
          });
        }
      };
      var normalizeSelection2 = function() {
        editor.on("keyup focusin mouseup", function(e) {
          if (!VK.modifierPressed(e)) {
            selection.normalize();
          }
        }, true);
      };
      var showBrokenImageIcon = function() {
        editor.contentStyles.push("img:-moz-broken {-moz-force-broken-image-icon:1;min-width:24px;min-height:24px}");
      };
      var restoreFocusOnKeyDown = function() {
        if (!editor.inline) {
          editor.on("keydown", function() {
            if (document.activeElement === document.body) {
              editor.getWin().focus();
            }
          });
        }
      };
      var bodyHeight = function() {
        if (!editor.inline) {
          editor.contentStyles.push("body {min-height: 150px}");
          editor.on("click", function(e) {
            var rng;
            if (e.target.nodeName === "HTML") {
              if (Env.ie > 11) {
                editor.getBody().focus();
                return;
              }
              rng = editor.selection.getRng();
              editor.getBody().focus();
              editor.selection.setRng(rng);
              editor.selection.normalize();
              editor.nodeChanged();
            }
          });
        }
      };
      var blockCmdArrowNavigation = function() {
        if (Env.mac) {
          editor.on("keydown", function(e) {
            if (VK.metaKeyPressed(e) && !e.shiftKey && (e.keyCode === 37 || e.keyCode === 39)) {
              e.preventDefault();
              var selection_1 = editor.selection.getSel();
              selection_1.modify("move", e.keyCode === 37 ? "backward" : "forward", "lineboundary");
            }
          });
        }
      };
      var disableAutoUrlDetect = function() {
        setEditorCommandState2("AutoUrlDetect", false);
      };
      var tapLinksAndImages = function() {
        editor.on("click", function(e) {
          var elm = e.target;
          do {
            if (elm.tagName === "A") {
              e.preventDefault();
              return;
            }
          } while (elm = elm.parentNode);
        });
        editor.contentStyles.push(".mce-content-body {-webkit-touch-callout: none}");
      };
      var blockFormSubmitInsideEditor = function() {
        editor.on("init", function() {
          editor.dom.bind(editor.getBody(), "submit", function(e) {
            e.preventDefault();
          });
        });
      };
      var removeAppleInterchangeBrs = function() {
        parser.addNodeFilter("br", function(nodes) {
          var i = nodes.length;
          while (i--) {
            if (nodes[i].attr("class") === "Apple-interchange-newline") {
              nodes[i].remove();
            }
          }
        });
      };
      var ieInternalDragAndDrop = function() {
        editor.on("dragstart", function(e) {
          setMceInternalContent(e);
        });
        editor.on("drop", function(e) {
          if (!isDefaultPrevented(e)) {
            var internalContent = getMceInternalContent(e);
            if (internalContent && internalContent.id !== editor.id) {
              e.preventDefault();
              var rng = fromPoint$1(e.x, e.y, editor.getDoc());
              selection.setRng(rng);
              insertClipboardContents(internalContent.html, true);
            }
          }
        });
      };
      var refreshContentEditable = noop;
      var isHidden = function() {
        if (!isGecko || editor.removed) {
          return false;
        }
        var sel = editor.selection.getSel();
        return !sel || !sel.rangeCount || sel.rangeCount === 0;
      };
      var setupRtc = function() {
        if (isWebKit) {
          selectControlElements();
          blockFormSubmitInsideEditor();
          selectAll();
          if (Env.iOS) {
            restoreFocusOnKeyDown();
            bodyHeight();
            tapLinksAndImages();
          }
        }
        if (isGecko) {
          focusBody2();
          setGeckoEditingOptions();
          showBrokenImageIcon();
          blockCmdArrowNavigation();
        }
      };
      var setup2 = function() {
        removeBlockQuoteOnBackSpace();
        emptyEditorWhenDeleting();
        if (!Env.windowsPhone) {
          normalizeSelection2();
        }
        if (isWebKit) {
          inputMethodFocus();
          selectControlElements();
          setDefaultBlockType();
          blockFormSubmitInsideEditor();
          disableBackspaceIntoATable();
          removeAppleInterchangeBrs();
          if (Env.iOS) {
            restoreFocusOnKeyDown();
            bodyHeight();
            tapLinksAndImages();
          } else {
            selectAll();
          }
        }
        if (Env.ie >= 11) {
          bodyHeight();
          disableBackspaceIntoATable();
        }
        if (Env.ie) {
          selectAll();
          disableAutoUrlDetect();
          ieInternalDragAndDrop();
        }
        if (isGecko) {
          removeHrOnBackspace();
          focusBody2();
          removeStylesWhenDeletingAcrossBlockElements();
          setGeckoEditingOptions();
          addBrAfterLastLinks();
          showBrokenImageIcon();
          blockCmdArrowNavigation();
          disableBackspaceIntoATable();
        }
      };
      if (isRtc(editor)) {
        setupRtc();
      } else {
        setup2();
      }
      return {
        refreshContentEditable,
        isHidden
      };
    };
    var DOM$4 = DOMUtils.DOM;
    var appendStyle = function(editor, text) {
      var body = SugarElement.fromDom(editor.getBody());
      var container = getStyleContainer(getRootNode(body));
      var style = SugarElement.fromTag("style");
      set(style, "type", "text/css");
      append(style, SugarElement.fromText(text));
      append(container, style);
      editor.on("remove", function() {
        remove(style);
      });
    };
    var getRootName = function(editor) {
      return editor.inline ? editor.getElement().nodeName.toLowerCase() : void 0;
    };
    var removeUndefined = function(obj) {
      return filter$1(obj, function(v) {
        return isUndefined(v) === false;
      });
    };
    var mkParserSettings = function(editor) {
      var settings = editor.settings;
      var blobCache = editor.editorUpload.blobCache;
      return removeUndefined({
        allow_conditional_comments: settings.allow_conditional_comments,
        allow_html_data_urls: settings.allow_html_data_urls,
        allow_svg_data_urls: settings.allow_svg_data_urls,
        allow_html_in_named_anchor: settings.allow_html_in_named_anchor,
        allow_script_urls: settings.allow_script_urls,
        allow_unsafe_link_target: settings.allow_unsafe_link_target,
        convert_fonts_to_spans: settings.convert_fonts_to_spans,
        fix_list_elements: settings.fix_list_elements,
        font_size_legacy_values: settings.font_size_legacy_values,
        forced_root_block: settings.forced_root_block,
        forced_root_block_attrs: settings.forced_root_block_attrs,
        padd_empty_with_br: settings.padd_empty_with_br,
        preserve_cdata: settings.preserve_cdata,
        remove_trailing_brs: settings.remove_trailing_brs,
        inline_styles: settings.inline_styles,
        root_name: getRootName(editor),
        validate: true,
        blob_cache: blobCache,
        images_dataimg_filter: settings.images_dataimg_filter
      });
    };
    var mkSerializerSettings = function(editor) {
      var settings = editor.settings;
      return __assign2(__assign2({}, mkParserSettings(editor)), removeUndefined({
        url_converter: settings.url_converter,
        url_converter_scope: settings.url_converter_scope,
        element_format: settings.element_format,
        entities: settings.entities,
        entity_encoding: settings.entity_encoding,
        indent: settings.indent,
        indent_after: settings.indent_after,
        indent_before: settings.indent_before,
        block_elements: settings.block_elements,
        boolean_attributes: settings.boolean_attributes,
        custom_elements: settings.custom_elements,
        extended_valid_elements: settings.extended_valid_elements,
        invalid_elements: settings.invalid_elements,
        invalid_styles: settings.invalid_styles,
        move_caret_before_on_enter_elements: settings.move_caret_before_on_enter_elements,
        non_empty_elements: settings.non_empty_elements,
        schema: settings.schema,
        self_closing_elements: settings.self_closing_elements,
        short_ended_elements: settings.short_ended_elements,
        special: settings.special,
        text_block_elements: settings.text_block_elements,
        text_inline_elements: settings.text_inline_elements,
        valid_children: settings.valid_children,
        valid_classes: settings.valid_classes,
        valid_elements: settings.valid_elements,
        valid_styles: settings.valid_styles,
        verify_html: settings.verify_html,
        whitespace_elements: settings.whitespace_elements
      }));
    };
    var createParser = function(editor) {
      var parser = DomParser(mkParserSettings(editor), editor.schema);
      parser.addAttributeFilter("src,href,style,tabindex", function(nodes, name2) {
        var i = nodes.length, node, value2;
        var dom2 = editor.dom;
        var internalName = "data-mce-" + name2;
        while (i--) {
          node = nodes[i];
          value2 = node.attr(name2);
          if (value2 && !node.attr(internalName)) {
            if (value2.indexOf("data:") === 0 || value2.indexOf("blob:") === 0) {
              continue;
            }
            if (name2 === "style") {
              value2 = dom2.serializeStyle(dom2.parseStyle(value2), node.name);
              if (!value2.length) {
                value2 = null;
              }
              node.attr(internalName, value2);
              node.attr(name2, value2);
            } else if (name2 === "tabindex") {
              node.attr(internalName, value2);
              node.attr(name2, null);
            } else {
              node.attr(internalName, editor.convertURL(value2, name2, node.name));
            }
          }
        }
      });
      parser.addNodeFilter("script", function(nodes) {
        var i = nodes.length;
        while (i--) {
          var node = nodes[i];
          var type2 = node.attr("type") || "no/type";
          if (type2.indexOf("mce-") !== 0) {
            node.attr("type", "mce-" + type2);
          }
        }
      });
      if (editor.settings.preserve_cdata) {
        parser.addNodeFilter("#cdata", function(nodes) {
          var i = nodes.length;
          while (i--) {
            var node = nodes[i];
            node.type = 8;
            node.name = "#comment";
            node.value = "[CDATA[" + editor.dom.encode(node.value) + "]]";
          }
        });
      }
      parser.addNodeFilter("p,h1,h2,h3,h4,h5,h6,div", function(nodes) {
        var i = nodes.length;
        var nonEmptyElements = editor.schema.getNonEmptyElements();
        while (i--) {
          var node = nodes[i];
          if (node.isEmpty(nonEmptyElements) && node.getAll("br").length === 0) {
            node.append(new AstNode("br", 1)).shortEnded = true;
          }
        }
      });
      return parser;
    };
    var autoFocus = function(editor) {
      if (editor.settings.auto_focus) {
        Delay.setEditorTimeout(editor, function() {
          var focusEditor2;
          if (editor.settings.auto_focus === true) {
            focusEditor2 = editor;
          } else {
            focusEditor2 = editor.editorManager.get(editor.settings.auto_focus);
          }
          if (!focusEditor2.destroyed) {
            focusEditor2.focus();
          }
        }, 100);
      }
    };
    var moveSelectionToFirstCaretPosition = function(editor) {
      var root = editor.dom.getRoot();
      if (!editor.inline && (!hasAnyRanges(editor) || editor.selection.getStart(true) === root)) {
        firstPositionIn(root).each(function(pos) {
          var node = pos.getNode();
          var caretPos = isTable(node) ? firstPositionIn(node).getOr(pos) : pos;
          if (Env.browser.isIE()) {
            storeNative(editor, caretPos.toRange());
          } else {
            editor.selection.setRng(caretPos.toRange());
          }
        });
      }
    };
    var initEditor2 = function(editor) {
      editor.bindPendingEventDelegates();
      editor.initialized = true;
      fireInit(editor);
      editor.focus(true);
      moveSelectionToFirstCaretPosition(editor);
      editor.nodeChanged({ initial: true });
      editor.execCallback("init_instance_callback", editor);
      autoFocus(editor);
    };
    var getStyleSheetLoader = function(editor) {
      return editor.inline ? editor.ui.styleSheetLoader : editor.dom.styleSheetLoader;
    };
    var makeStylesheetLoadingPromises = function(editor, css, framedFonts) {
      var promises = [new promiseObj(function(resolve2, reject) {
        return getStyleSheetLoader(editor).loadAll(css, resolve2, reject);
      })];
      if (editor.inline) {
        return promises;
      } else {
        return promises.concat([new promiseObj(function(resolve2, reject) {
          return editor.ui.styleSheetLoader.loadAll(framedFonts, resolve2, reject);
        })]);
      }
    };
    var loadContentCss = function(editor, css) {
      var styleSheetLoader = getStyleSheetLoader(editor);
      var fontCss = getFontCss(editor);
      var removeCss = function() {
        styleSheetLoader.unloadAll(css);
        if (!editor.inline) {
          editor.ui.styleSheetLoader.unloadAll(fontCss);
        }
      };
      var loaded = function() {
        if (editor.removed) {
          removeCss();
        } else {
          editor.on("remove", removeCss);
          initEditor2(editor);
        }
      };
      promiseObj.all(makeStylesheetLoadingPromises(editor, css, fontCss)).then(loaded).catch(loaded);
    };
    var preInit = function(editor) {
      var settings = editor.settings, doc2 = editor.getDoc(), body = editor.getBody();
      if (!settings.browser_spellcheck && !settings.gecko_spellcheck) {
        doc2.body.spellcheck = false;
        DOM$4.setAttrib(body, "spellcheck", "false");
      }
      editor.quirks = Quirks(editor);
      firePostRender(editor);
      var directionality = getDirectionality(editor);
      if (directionality !== void 0) {
        body.dir = directionality;
      }
      if (settings.protect) {
        editor.on("BeforeSetContent", function(e) {
          Tools.each(settings.protect, function(pattern) {
            e.content = e.content.replace(pattern, function(str) {
              return "<!--mce:protected " + escape(str) + "-->";
            });
          });
        });
      }
      editor.on("SetContent", function() {
        editor.addVisual(editor.getBody());
      });
      if (!isRtc(editor)) {
        editor.load({
          initial: true,
          format: "html"
        });
      }
      editor.startContent = editor.getContent({ format: "raw" });
      editor.on("compositionstart compositionend", function(e) {
        editor.composing = e.type === "compositionstart";
      });
      if (editor.contentStyles.length > 0) {
        var contentCssText_1 = "";
        Tools.each(editor.contentStyles, function(style) {
          contentCssText_1 += style + "\r\n";
        });
        editor.dom.addStyle(contentCssText_1);
      }
      loadContentCss(editor, editor.contentCSS);
      if (settings.content_style) {
        appendStyle(editor, settings.content_style);
      }
    };
    var initContentBody = function(editor, skipWrite) {
      var settings = editor.settings;
      var targetElm = editor.getElement();
      var doc2 = editor.getDoc();
      if (!settings.inline) {
        editor.getElement().style.visibility = editor.orgVisibility;
      }
      if (!skipWrite && !editor.inline) {
        doc2.open();
        doc2.write(editor.iframeHTML);
        doc2.close();
      }
      if (editor.inline) {
        DOM$4.addClass(targetElm, "mce-content-body");
        editor.contentDocument = doc2 = document;
        editor.contentWindow = window;
        editor.bodyElement = targetElm;
        editor.contentAreaContainer = targetElm;
      }
      var body = editor.getBody();
      body.disabled = true;
      editor.readonly = !!settings.readonly;
      if (!editor.readonly) {
        if (editor.inline && DOM$4.getStyle(body, "position", true) === "static") {
          body.style.position = "relative";
        }
        body.contentEditable = editor.getParam("content_editable_state", true);
      }
      body.disabled = false;
      editor.editorUpload = EditorUpload(editor);
      editor.schema = Schema(settings);
      editor.dom = DOMUtils(doc2, {
        keep_values: true,
        url_converter: editor.convertURL,
        url_converter_scope: editor,
        hex_colors: settings.force_hex_style_colors,
        update_styles: true,
        root_element: editor.inline ? editor.getBody() : null,
        collect: function() {
          return editor.inline;
        },
        schema: editor.schema,
        contentCssCors: shouldUseContentCssCors(editor),
        referrerPolicy: getReferrerPolicy(editor),
        onSetAttrib: function(e) {
          editor.fire("SetAttrib", e);
        }
      });
      editor.parser = createParser(editor);
      editor.serializer = DomSerializer(mkSerializerSettings(editor), editor);
      editor.selection = EditorSelection(editor.dom, editor.getWin(), editor.serializer, editor);
      editor.annotator = Annotator(editor);
      editor.formatter = Formatter(editor);
      editor.undoManager = UndoManager(editor);
      editor._nodeChangeDispatcher = new NodeChange(editor);
      editor._selectionOverrides = SelectionOverrides(editor);
      setup$9(editor);
      setup$k(editor);
      if (!isRtc(editor)) {
        setup$l(editor);
      }
      var caret = setup$j(editor);
      setup$8(editor, caret);
      setup$a(editor);
      setup$7(editor);
      firePreInit(editor);
      setup$5(editor).fold(function() {
        preInit(editor);
      }, function(loadingRtc) {
        editor.setProgressState(true);
        loadingRtc.then(function(_rtcMode) {
          editor.setProgressState(false);
          preInit(editor);
        }, function(err) {
          editor.notificationManager.open({
            type: "error",
            text: String(err)
          });
          preInit(editor);
        });
      });
    };
    var DOM$5 = DOMUtils.DOM;
    var relaxDomain = function(editor, ifr) {
      if (document.domain !== window.location.hostname && Env.browser.isIE()) {
        var bodyUuid = uuid2("mce");
        editor[bodyUuid] = function() {
          initContentBody(editor);
        };
        var domainRelaxUrl = 'javascript:(function(){document.open();document.domain="' + document.domain + '";var ed = window.parent.tinymce.get("' + editor.id + '");document.write(ed.iframeHTML);document.close();ed.' + bodyUuid + "(true);})()";
        DOM$5.setAttrib(ifr, "src", domainRelaxUrl);
        return true;
      }
      return false;
    };
    var createIframeElement = function(id, title, height, customAttrs) {
      var iframe = SugarElement.fromTag("iframe");
      setAll(iframe, customAttrs);
      setAll(iframe, {
        id: id + "_ifr",
        frameBorder: "0",
        allowTransparency: "true",
        title
      });
      add$3(iframe, "tox-edit-area__iframe");
      return iframe;
    };
    var getIframeHtml = function(editor) {
      var iframeHTML = getDocType(editor) + "<html><head>";
      if (getDocumentBaseUrl(editor) !== editor.documentBaseUrl) {
        iframeHTML += '<base href="' + editor.documentBaseURI.getURI() + '" />';
      }
      iframeHTML += '<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />';
      var bodyId = getBodyId(editor);
      var bodyClass = getBodyClass(editor);
      if (getContentSecurityPolicy(editor)) {
        iframeHTML += '<meta http-equiv="Content-Security-Policy" content="' + getContentSecurityPolicy(editor) + '" />';
      }
      iframeHTML += '</head><body id="' + bodyId + '" class="mce-content-body ' + bodyClass + '" data-id="' + editor.id + '"><br></body></html>';
      return iframeHTML;
    };
    var createIframe = function(editor, o) {
      var title = editor.editorManager.translate("Rich Text Area. Press ALT-0 for help.");
      var ifr = createIframeElement(editor.id, title, o.height, getIframeAttrs(editor)).dom;
      ifr.onload = function() {
        ifr.onload = null;
        editor.fire("load");
      };
      var isDomainRelaxed = relaxDomain(editor, ifr);
      editor.contentAreaContainer = o.iframeContainer;
      editor.iframeElement = ifr;
      editor.iframeHTML = getIframeHtml(editor);
      DOM$5.add(o.iframeContainer, ifr);
      return isDomainRelaxed;
    };
    var init$1 = function(editor, boxInfo) {
      var isDomainRelaxed = createIframe(editor, boxInfo);
      if (boxInfo.editorContainer) {
        DOM$5.get(boxInfo.editorContainer).style.display = editor.orgDisplay;
        editor.hidden = DOM$5.isHidden(boxInfo.editorContainer);
      }
      editor.getElement().style.display = "none";
      DOM$5.setAttrib(editor.id, "aria-hidden", "true");
      if (!isDomainRelaxed) {
        initContentBody(editor);
      }
    };
    var DOM$6 = DOMUtils.DOM;
    var initPlugin = function(editor, initializedPlugins, plugin) {
      var Plugin = PluginManager.get(plugin);
      var pluginUrl = PluginManager.urls[plugin] || editor.documentBaseUrl.replace(/\/$/, "");
      plugin = Tools.trim(plugin);
      if (Plugin && Tools.inArray(initializedPlugins, plugin) === -1) {
        Tools.each(PluginManager.dependencies(plugin), function(dep) {
          initPlugin(editor, initializedPlugins, dep);
        });
        if (editor.plugins[plugin]) {
          return;
        }
        try {
          var pluginInstance = new Plugin(editor, pluginUrl, editor.$);
          editor.plugins[plugin] = pluginInstance;
          if (pluginInstance.init) {
            pluginInstance.init(editor, pluginUrl);
            initializedPlugins.push(plugin);
          }
        } catch (e) {
          pluginInitError(editor, plugin, e);
        }
      }
    };
    var trimLegacyPrefix = function(name2) {
      return name2.replace(/^\-/, "");
    };
    var initPlugins = function(editor) {
      var initializedPlugins = [];
      Tools.each(getPlugins(editor).split(/[ ,]/), function(name2) {
        initPlugin(editor, initializedPlugins, trimLegacyPrefix(name2));
      });
    };
    var initIcons = function(editor) {
      var iconPackName = Tools.trim(getIconPackName(editor));
      var currentIcons = editor.ui.registry.getAll().icons;
      var loadIcons2 = __assign2(__assign2({}, IconManager.get("default").icons), IconManager.get(iconPackName).icons);
      each$1(loadIcons2, function(svgData, icon) {
        if (!has(currentIcons, icon)) {
          editor.ui.registry.addIcon(icon, svgData);
        }
      });
    };
    var initTheme = function(editor) {
      var theme = getTheme(editor);
      if (isString(theme)) {
        editor.settings.theme = trimLegacyPrefix(theme);
        var Theme = ThemeManager.get(theme);
        editor.theme = new Theme(editor, ThemeManager.urls[theme]);
        if (editor.theme.init) {
          editor.theme.init(editor, ThemeManager.urls[theme] || editor.documentBaseUrl.replace(/\/$/, ""), editor.$);
        }
      } else {
        editor.theme = {};
      }
    };
    var renderFromLoadedTheme = function(editor) {
      return editor.theme.renderUI();
    };
    var renderFromThemeFunc = function(editor) {
      var elm = editor.getElement();
      var theme = getTheme(editor);
      var info = theme(editor, elm);
      if (info.editorContainer.nodeType) {
        info.editorContainer.id = info.editorContainer.id || editor.id + "_parent";
      }
      if (info.iframeContainer && info.iframeContainer.nodeType) {
        info.iframeContainer.id = info.iframeContainer.id || editor.id + "_iframecontainer";
      }
      info.height = info.iframeHeight ? info.iframeHeight : elm.offsetHeight;
      return info;
    };
    var createThemeFalseResult = function(element) {
      return {
        editorContainer: element,
        iframeContainer: element,
        api: {}
      };
    };
    var renderThemeFalseIframe = function(targetElement) {
      var iframeContainer = DOM$6.create("div");
      DOM$6.insertAfter(iframeContainer, targetElement);
      return createThemeFalseResult(iframeContainer);
    };
    var renderThemeFalse = function(editor) {
      var targetElement = editor.getElement();
      return editor.inline ? createThemeFalseResult(null) : renderThemeFalseIframe(targetElement);
    };
    var renderThemeUi = function(editor) {
      var elm = editor.getElement();
      editor.orgDisplay = elm.style.display;
      if (isString(getTheme(editor))) {
        return renderFromLoadedTheme(editor);
      } else if (isFunction(getTheme(editor))) {
        return renderFromThemeFunc(editor);
      } else {
        return renderThemeFalse(editor);
      }
    };
    var augmentEditorUiApi = function(editor, api2) {
      var uiApiFacade = {
        show: Optional.from(api2.show).getOr(noop),
        hide: Optional.from(api2.hide).getOr(noop),
        disable: Optional.from(api2.disable).getOr(noop),
        isDisabled: Optional.from(api2.isDisabled).getOr(never),
        enable: function() {
          if (!editor.mode.isReadOnly()) {
            Optional.from(api2.enable).map(call);
          }
        }
      };
      editor.ui = __assign2(__assign2({}, editor.ui), uiApiFacade);
    };
    var init$2 = function(editor) {
      editor.fire("ScriptsLoaded");
      initIcons(editor);
      initTheme(editor);
      initPlugins(editor);
      var renderInfo = renderThemeUi(editor);
      augmentEditorUiApi(editor, Optional.from(renderInfo.api).getOr({}));
      var boxInfo = {
        editorContainer: renderInfo.editorContainer,
        iframeContainer: renderInfo.iframeContainer
      };
      editor.editorContainer = boxInfo.editorContainer ? boxInfo.editorContainer : null;
      appendContentCssFromSettings(editor);
      if (editor.inline) {
        return initContentBody(editor);
      } else {
        return init$1(editor, boxInfo);
      }
    };
    var DOM$7 = DOMUtils.DOM;
    var hasSkipLoadPrefix = function(name2) {
      return name2.charAt(0) === "-";
    };
    var loadLanguage = function(scriptLoader, editor) {
      var languageCode = getLanguageCode(editor);
      var languageUrl = getLanguageUrl(editor);
      if (I18n.hasCode(languageCode) === false && languageCode !== "en") {
        var url_1 = languageUrl !== "" ? languageUrl : editor.editorManager.baseURL + "/langs/" + languageCode + ".js";
        scriptLoader.add(url_1, noop, void 0, function() {
          languageLoadError(editor, url_1, languageCode);
        });
      }
    };
    var loadTheme = function(scriptLoader, editor, suffix, callback) {
      var theme = getTheme(editor);
      if (isString(theme)) {
        if (!hasSkipLoadPrefix(theme) && !ThemeManager.urls.hasOwnProperty(theme)) {
          var themeUrl = getThemeUrl(editor);
          if (themeUrl) {
            ThemeManager.load(theme, editor.documentBaseURI.toAbsolute(themeUrl));
          } else {
            ThemeManager.load(theme, "themes/" + theme + "/theme" + suffix + ".js");
          }
        }
        scriptLoader.loadQueue(function() {
          ThemeManager.waitFor(theme, callback);
        });
      } else {
        callback();
      }
    };
    var getIconsUrlMetaFromUrl = function(editor) {
      return Optional.from(getIconsUrl(editor)).filter(function(url) {
        return url.length > 0;
      }).map(function(url) {
        return {
          url,
          name: Optional.none()
        };
      });
    };
    var getIconsUrlMetaFromName = function(editor, name2, suffix) {
      return Optional.from(name2).filter(function(name3) {
        return name3.length > 0 && !IconManager.has(name3);
      }).map(function(name3) {
        return {
          url: editor.editorManager.baseURL + "/icons/" + name3 + "/icons" + suffix + ".js",
          name: Optional.some(name3)
        };
      });
    };
    var loadIcons = function(scriptLoader, editor, suffix) {
      var defaultIconsUrl = getIconsUrlMetaFromName(editor, "default", suffix);
      var customIconsUrl = getIconsUrlMetaFromUrl(editor).orThunk(function() {
        return getIconsUrlMetaFromName(editor, getIconPackName(editor), "");
      });
      each(cat([
        defaultIconsUrl,
        customIconsUrl
      ]), function(urlMeta) {
        scriptLoader.add(urlMeta.url, noop, void 0, function() {
          iconsLoadError(editor, urlMeta.url, urlMeta.name.getOrUndefined());
        });
      });
    };
    var loadPlugins = function(editor, suffix) {
      Tools.each(getExternalPlugins(editor), function(url, name2) {
        PluginManager.load(name2, url, noop, void 0, function() {
          pluginLoadError(editor, url, name2);
        });
        editor.settings.plugins += " " + name2;
      });
      Tools.each(getPlugins(editor).split(/[ ,]/), function(plugin) {
        plugin = Tools.trim(plugin);
        if (plugin && !PluginManager.urls[plugin]) {
          if (hasSkipLoadPrefix(plugin)) {
            plugin = plugin.substr(1, plugin.length);
            var dependencies = PluginManager.dependencies(plugin);
            Tools.each(dependencies, function(depPlugin) {
              var defaultSettings = {
                prefix: "plugins/",
                resource: depPlugin,
                suffix: "/plugin" + suffix + ".js"
              };
              var dep = PluginManager.createUrl(defaultSettings, depPlugin);
              PluginManager.load(dep.resource, dep, noop, void 0, function() {
                pluginLoadError(editor, dep.prefix + dep.resource + dep.suffix, dep.resource);
              });
            });
          } else {
            var url_2 = {
              prefix: "plugins/",
              resource: plugin,
              suffix: "/plugin" + suffix + ".js"
            };
            PluginManager.load(plugin, url_2, noop, void 0, function() {
              pluginLoadError(editor, url_2.prefix + url_2.resource + url_2.suffix, plugin);
            });
          }
        }
      });
    };
    var loadScripts = function(editor, suffix) {
      var scriptLoader = ScriptLoader2.ScriptLoader;
      loadTheme(scriptLoader, editor, suffix, function() {
        loadLanguage(scriptLoader, editor);
        loadIcons(scriptLoader, editor, suffix);
        loadPlugins(editor, suffix);
        scriptLoader.loadQueue(function() {
          if (!editor.removed) {
            init$2(editor);
          }
        }, editor, function() {
          if (!editor.removed) {
            init$2(editor);
          }
        });
      });
    };
    var getStyleSheetLoader$1 = function(element, editor) {
      return instance.forElement(element, {
        contentCssCors: hasContentCssCors(editor),
        referrerPolicy: getReferrerPolicy(editor)
      });
    };
    var render = function(editor) {
      var id = editor.id;
      I18n.setCode(getLanguageCode(editor));
      var readyHandler = function() {
        DOM$7.unbind(window, "ready", readyHandler);
        editor.render();
      };
      if (!EventUtils.Event.domLoaded) {
        DOM$7.bind(window, "ready", readyHandler);
        return;
      }
      if (!editor.getElement()) {
        return;
      }
      if (!Env.contentEditable) {
        return;
      }
      var element = SugarElement.fromDom(editor.getElement());
      var snapshot = clone(element);
      editor.on("remove", function() {
        eachr(element.dom.attributes, function(attr) {
          return remove$1(element, attr.name);
        });
        setAll(element, snapshot);
      });
      editor.ui.styleSheetLoader = getStyleSheetLoader$1(element, editor);
      if (!isInline$1(editor)) {
        editor.orgVisibility = editor.getElement().style.visibility;
        editor.getElement().style.visibility = "hidden";
      } else {
        editor.inline = true;
      }
      var form = editor.getElement().form || DOM$7.getParent(id, "form");
      if (form) {
        editor.formElement = form;
        if (hasHiddenInput(editor) && !isTextareaOrInput(editor.getElement())) {
          DOM$7.insertAfter(DOM$7.create("input", {
            type: "hidden",
            name: id
          }), id);
          editor.hasHiddenInput = true;
        }
        editor.formEventDelegate = function(e) {
          editor.fire(e.type, e);
        };
        DOM$7.bind(form, "submit reset", editor.formEventDelegate);
        editor.on("reset", function() {
          editor.resetContent();
        });
        if (shouldPatchSubmit(editor) && !form.submit.nodeType && !form.submit.length && !form._mceOldSubmit) {
          form._mceOldSubmit = form.submit;
          form.submit = function() {
            editor.editorManager.triggerSave();
            editor.setDirty(false);
            return form._mceOldSubmit(form);
          };
        }
      }
      editor.windowManager = WindowManager(editor);
      editor.notificationManager = NotificationManager(editor);
      if (isEncodingXml(editor)) {
        editor.on("GetContent", function(e) {
          if (e.save) {
            e.content = DOM$7.encode(e.content);
          }
        });
      }
      if (shouldAddFormSubmitTrigger(editor)) {
        editor.on("submit", function() {
          if (editor.initialized) {
            editor.save();
          }
        });
      }
      if (shouldAddUnloadTrigger(editor)) {
        editor._beforeUnload = function() {
          if (editor.initialized && !editor.destroyed && !editor.isHidden()) {
            editor.save({
              format: "raw",
              no_events: true,
              set_dirty: false
            });
          }
        };
        editor.editorManager.on("BeforeUnload", editor._beforeUnload);
      }
      editor.editorManager.add(editor);
      loadScripts(editor, editor.suffix);
    };
    var addVisual$1 = function(editor, elm) {
      return addVisual(editor, elm);
    };
    var legacyPropNames = {
      "font-size": "size",
      "font-family": "face"
    };
    var getSpecifiedFontProp = function(propName, rootElm, elm) {
      var getProperty = function(elm2) {
        return getRaw(elm2, propName).orThunk(function() {
          if (name(elm2) === "font") {
            return get$1(legacyPropNames, propName).bind(function(legacyPropName) {
              return getOpt(elm2, legacyPropName);
            });
          } else {
            return Optional.none();
          }
        });
      };
      var isRoot = function(elm2) {
        return eq$2(SugarElement.fromDom(rootElm), elm2);
      };
      return closest$2(SugarElement.fromDom(elm), function(elm2) {
        return getProperty(elm2);
      }, isRoot);
    };
    var normalizeFontFamily = function(fontFamily) {
      return fontFamily.replace(/[\'\"\\]/g, "").replace(/,\s+/g, ",");
    };
    var getComputedFontProp = function(propName, elm) {
      return Optional.from(DOMUtils.DOM.getStyle(elm, propName, true));
    };
    var getFontProp = function(propName) {
      return function(rootElm, elm) {
        return Optional.from(elm).map(SugarElement.fromDom).filter(isElement).bind(function(element) {
          return getSpecifiedFontProp(propName, rootElm, element.dom).or(getComputedFontProp(propName, element.dom));
        }).getOr("");
      };
    };
    var getFontSize = getFontProp("font-size");
    var getFontFamily = compose(normalizeFontFamily, getFontProp("font-family"));
    var findFirstCaretElement = function(editor) {
      return firstPositionIn(editor.getBody()).map(function(caret) {
        var container = caret.container();
        return isText$1(container) ? container.parentNode : container;
      });
    };
    var getCaretElement = function(editor) {
      return Optional.from(editor.selection.getRng()).bind(function(rng) {
        var root = editor.getBody();
        var atStartOfNode = rng.startContainer === root && rng.startOffset === 0;
        return atStartOfNode ? Optional.none() : Optional.from(editor.selection.getStart(true));
      });
    };
    var mapRange = function(editor, mapper) {
      return getCaretElement(editor).orThunk(curry(findFirstCaretElement, editor)).map(SugarElement.fromDom).filter(isElement).map(mapper);
    };
    var fromFontSizeNumber = function(editor, value2) {
      if (/^[0-9.]+$/.test(value2)) {
        var fontSizeNumber = parseInt(value2, 10);
        if (fontSizeNumber >= 1 && fontSizeNumber <= 7) {
          var fontSizes = getFontStyleValues(editor);
          var fontClasses = getFontSizeClasses(editor);
          if (fontClasses) {
            return fontClasses[fontSizeNumber - 1] || value2;
          } else {
            return fontSizes[fontSizeNumber - 1] || value2;
          }
        } else {
          return value2;
        }
      } else {
        return value2;
      }
    };
    var normalizeFontNames = function(font) {
      var fonts = font.split(/\s*,\s*/);
      return map(fonts, function(font2) {
        if (font2.indexOf(" ") !== -1 && !(startsWith(font2, '"') || startsWith(font2, "'"))) {
          return "'" + font2 + "'";
        } else {
          return font2;
        }
      }).join(",");
    };
    var fontNameAction = function(editor, value2) {
      var font = fromFontSizeNumber(editor, value2);
      editor.formatter.toggle("fontname", { value: normalizeFontNames(font) });
      editor.nodeChanged();
    };
    var fontNameQuery = function(editor) {
      return mapRange(editor, function(elm) {
        return getFontFamily(editor.getBody(), elm.dom);
      }).getOr("");
    };
    var fontSizeAction = function(editor, value2) {
      editor.formatter.toggle("fontsize", { value: fromFontSizeNumber(editor, value2) });
      editor.nodeChanged();
    };
    var fontSizeQuery = function(editor) {
      return mapRange(editor, function(elm) {
        return getFontSize(editor.getBody(), elm.dom);
      }).getOr("");
    };
    var lineHeightQuery = function(editor) {
      return mapRange(editor, function(elm) {
        var root = SugarElement.fromDom(editor.getBody());
        var specifiedStyle = closest$2(elm, function(elm2) {
          return getRaw(elm2, "line-height");
        }, curry(eq$2, root));
        var computedStyle = function() {
          var lineHeight = parseFloat(get$5(elm, "line-height"));
          var fontSize = parseFloat(get$5(elm, "font-size"));
          return String(lineHeight / fontSize);
        };
        return specifiedStyle.getOrThunk(computedStyle);
      }).getOr("");
    };
    var lineHeightAction = function(editor, lineHeight) {
      editor.formatter.toggle("lineheight", { value: String(lineHeight) });
      editor.nodeChanged();
    };
    var processValue = function(value2) {
      var details;
      if (typeof value2 !== "string") {
        details = Tools.extend({
          paste: value2.paste,
          data: { paste: value2.paste }
        }, value2);
        return {
          content: value2.content,
          details
        };
      }
      return {
        content: value2,
        details: {}
      };
    };
    var insertAtCaret$1 = function(editor, value2) {
      var result = processValue(value2);
      insertContent(editor, result.content, result.details);
    };
    var each$f = Tools.each;
    var map$3 = Tools.map, inArray$2 = Tools.inArray;
    var EditorCommands = function() {
      function EditorCommands2(editor) {
        this.commands = {
          state: {},
          exec: {},
          value: {}
        };
        this.editor = editor;
        this.setupCommands(editor);
      }
      EditorCommands2.prototype.execCommand = function(command, ui, value2, args) {
        var func, state = false;
        var self2 = this;
        if (self2.editor.removed) {
          return;
        }
        if (!/^(mceAddUndoLevel|mceEndUndoLevel|mceBeginUndoLevel|mceRepaint)$/.test(command) && (!args || !args.skip_focus)) {
          self2.editor.focus();
        } else {
          restore(self2.editor);
        }
        args = self2.editor.fire("BeforeExecCommand", {
          command,
          ui,
          value: value2
        });
        if (args.isDefaultPrevented()) {
          return false;
        }
        var customCommand = command.toLowerCase();
        if (func = self2.commands.exec[customCommand]) {
          func(customCommand, ui, value2);
          self2.editor.fire("ExecCommand", {
            command,
            ui,
            value: value2
          });
          return true;
        }
        each$f(this.editor.plugins, function(p) {
          if (p.execCommand && p.execCommand(command, ui, value2)) {
            self2.editor.fire("ExecCommand", {
              command,
              ui,
              value: value2
            });
            state = true;
            return false;
          }
        });
        if (state) {
          return state;
        }
        if (self2.editor.theme && self2.editor.theme.execCommand && self2.editor.theme.execCommand(command, ui, value2)) {
          self2.editor.fire("ExecCommand", {
            command,
            ui,
            value: value2
          });
          return true;
        }
        try {
          state = self2.editor.getDoc().execCommand(command, ui, value2);
        } catch (ex) {
        }
        if (state) {
          self2.editor.fire("ExecCommand", {
            command,
            ui,
            value: value2
          });
          return true;
        }
        return false;
      };
      EditorCommands2.prototype.queryCommandState = function(command) {
        var func;
        if (this.editor.quirks.isHidden() || this.editor.removed) {
          return;
        }
        command = command.toLowerCase();
        if (func = this.commands.state[command]) {
          return func(command);
        }
        try {
          return this.editor.getDoc().queryCommandState(command);
        } catch (ex) {
        }
        return false;
      };
      EditorCommands2.prototype.queryCommandValue = function(command) {
        var func;
        if (this.editor.quirks.isHidden() || this.editor.removed) {
          return;
        }
        command = command.toLowerCase();
        if (func = this.commands.value[command]) {
          return func(command);
        }
        try {
          return this.editor.getDoc().queryCommandValue(command);
        } catch (ex) {
        }
      };
      EditorCommands2.prototype.addCommands = function(commandList, type2) {
        if (type2 === void 0) {
          type2 = "exec";
        }
        var self2 = this;
        each$f(commandList, function(callback, command) {
          each$f(command.toLowerCase().split(","), function(command2) {
            self2.commands[type2][command2] = callback;
          });
        });
      };
      EditorCommands2.prototype.addCommand = function(command, callback, scope) {
        var _this = this;
        command = command.toLowerCase();
        this.commands.exec[command] = function(command2, ui, value2, args) {
          return callback.call(scope || _this.editor, ui, value2, args);
        };
      };
      EditorCommands2.prototype.queryCommandSupported = function(command) {
        command = command.toLowerCase();
        if (this.commands.exec[command]) {
          return true;
        }
        try {
          return this.editor.getDoc().queryCommandSupported(command);
        } catch (ex) {
        }
        return false;
      };
      EditorCommands2.prototype.addQueryStateHandler = function(command, callback, scope) {
        var _this = this;
        command = command.toLowerCase();
        this.commands.state[command] = function() {
          return callback.call(scope || _this.editor);
        };
      };
      EditorCommands2.prototype.addQueryValueHandler = function(command, callback, scope) {
        var _this = this;
        command = command.toLowerCase();
        this.commands.value[command] = function() {
          return callback.call(scope || _this.editor);
        };
      };
      EditorCommands2.prototype.hasCustomCommand = function(command) {
        command = command.toLowerCase();
        return !!this.commands.exec[command];
      };
      EditorCommands2.prototype.execNativeCommand = function(command, ui, value2) {
        if (ui === void 0) {
          ui = false;
        }
        if (value2 === void 0) {
          value2 = null;
        }
        return this.editor.getDoc().execCommand(command, ui, value2);
      };
      EditorCommands2.prototype.isFormatMatch = function(name2) {
        return this.editor.formatter.match(name2);
      };
      EditorCommands2.prototype.toggleFormat = function(name2, value2) {
        this.editor.formatter.toggle(name2, value2 ? { value: value2 } : void 0);
        this.editor.nodeChanged();
      };
      EditorCommands2.prototype.storeSelection = function(type2) {
        this.selectionBookmark = this.editor.selection.getBookmark(type2);
      };
      EditorCommands2.prototype.restoreSelection = function() {
        this.editor.selection.moveToBookmark(this.selectionBookmark);
      };
      EditorCommands2.prototype.setupCommands = function(editor) {
        var self2 = this;
        this.addCommands({
          "mceResetDesignMode,mceBeginUndoLevel": noop,
          "mceEndUndoLevel,mceAddUndoLevel": function() {
            editor.undoManager.add();
          },
          "Cut,Copy,Paste": function(command) {
            var doc2 = editor.getDoc();
            var failed;
            try {
              self2.execNativeCommand(command);
            } catch (ex) {
              failed = true;
            }
            if (command === "paste" && !doc2.queryCommandEnabled(command)) {
              failed = true;
            }
            if (failed || !doc2.queryCommandSupported(command)) {
              var msg = editor.translate("Your browser doesn't support direct access to the clipboard. Please use the Ctrl+X/C/V keyboard shortcuts instead.");
              if (Env.mac) {
                msg = msg.replace(/Ctrl\+/g, "\u2318+");
              }
              editor.notificationManager.open({
                text: msg,
                type: "error"
              });
            }
          },
          "unlink": function() {
            if (editor.selection.isCollapsed()) {
              var elm = editor.dom.getParent(editor.selection.getStart(), "a");
              if (elm) {
                editor.dom.remove(elm, true);
              }
              return;
            }
            editor.formatter.remove("link");
          },
          "JustifyLeft,JustifyCenter,JustifyRight,JustifyFull,JustifyNone": function(command) {
            var align = command.substring(7);
            if (align === "full") {
              align = "justify";
            }
            each$f("left,center,right,justify".split(","), function(name2) {
              if (align !== name2) {
                editor.formatter.remove("align" + name2);
              }
            });
            if (align !== "none") {
              self2.toggleFormat("align" + align);
            }
          },
          "InsertUnorderedList,InsertOrderedList": function(command) {
            var listParent;
            self2.execNativeCommand(command);
            var listElm = editor.dom.getParent(editor.selection.getNode(), "ol,ul");
            if (listElm) {
              listParent = listElm.parentNode;
              if (/^(H[1-6]|P|ADDRESS|PRE)$/.test(listParent.nodeName)) {
                self2.storeSelection();
                editor.dom.split(listParent, listElm);
                self2.restoreSelection();
              }
            }
          },
          "Bold,Italic,Underline,Strikethrough,Superscript,Subscript": function(command) {
            self2.toggleFormat(command);
          },
          "ForeColor,HiliteColor": function(command, ui, value2) {
            self2.toggleFormat(command, value2);
          },
          "FontName": function(command, ui, value2) {
            fontNameAction(editor, value2);
          },
          "FontSize": function(command, ui, value2) {
            fontSizeAction(editor, value2);
          },
          "LineHeight": function(command, ui, value2) {
            lineHeightAction(editor, value2);
          },
          "RemoveFormat": function(command) {
            editor.formatter.remove(command);
          },
          "mceBlockQuote": function() {
            self2.toggleFormat("blockquote");
          },
          "FormatBlock": function(command, ui, value2) {
            return self2.toggleFormat(value2 || "p");
          },
          "mceCleanup": function() {
            var bookmark = editor.selection.getBookmark();
            editor.setContent(editor.getContent());
            editor.selection.moveToBookmark(bookmark);
          },
          "mceRemoveNode": function(command, ui, value2) {
            var node = value2 || editor.selection.getNode();
            if (node !== editor.getBody()) {
              self2.storeSelection();
              editor.dom.remove(node, true);
              self2.restoreSelection();
            }
          },
          "mceSelectNodeDepth": function(command, ui, value2) {
            var counter = 0;
            editor.dom.getParent(editor.selection.getNode(), function(node) {
              if (node.nodeType === 1 && counter++ === value2) {
                editor.selection.select(node);
                return false;
              }
            }, editor.getBody());
          },
          "mceSelectNode": function(command, ui, value2) {
            editor.selection.select(value2);
          },
          "mceInsertContent": function(command, ui, value2) {
            insertAtCaret$1(editor, value2);
          },
          "mceInsertRawHTML": function(command, ui, value2) {
            editor.selection.setContent("tiny_mce_marker");
            var content = editor.getContent();
            editor.setContent(content.replace(/tiny_mce_marker/g, function() {
              return value2;
            }));
          },
          "mceInsertNewLine": function(command, ui, value2) {
            insert$3(editor, value2);
          },
          "mceToggleFormat": function(command, ui, value2) {
            self2.toggleFormat(value2);
          },
          "mceSetContent": function(command, ui, value2) {
            editor.setContent(value2);
          },
          "Indent,Outdent": function(command) {
            handle(editor, command);
          },
          "mceRepaint": noop,
          "InsertHorizontalRule": function() {
            editor.execCommand("mceInsertContent", false, "<hr />");
          },
          "mceToggleVisualAid": function() {
            editor.hasVisual = !editor.hasVisual;
            editor.addVisual();
          },
          "mceReplaceContent": function(command, ui, value2) {
            editor.execCommand("mceInsertContent", false, value2.replace(/\{\$selection\}/g, editor.selection.getContent({ format: "text" })));
          },
          "mceInsertLink": function(command, ui, value2) {
            if (typeof value2 === "string") {
              value2 = { href: value2 };
            }
            var anchor = editor.dom.getParent(editor.selection.getNode(), "a");
            value2.href = value2.href.replace(/ /g, "%20");
            if (!anchor || !value2.href) {
              editor.formatter.remove("link");
            }
            if (value2.href) {
              editor.formatter.apply("link", value2, anchor);
            }
          },
          "selectAll": function() {
            var editingHost = editor.dom.getParent(editor.selection.getStart(), isContentEditableTrue);
            if (editingHost) {
              var rng = editor.dom.createRng();
              rng.selectNodeContents(editingHost);
              editor.selection.setRng(rng);
            }
          },
          "mceNewDocument": function() {
            editor.setContent("");
          },
          "InsertLineBreak": function(command, ui, value2) {
            insert$2(editor, value2);
            return true;
          }
        });
        var alignStates = function(name2) {
          return function() {
            var selection = editor.selection;
            var nodes = selection.isCollapsed() ? [editor.dom.getParent(selection.getNode(), editor.dom.isBlock)] : selection.getSelectedBlocks();
            var matches2 = map$3(nodes, function(node) {
              return !!editor.formatter.matchNode(node, name2);
            });
            return inArray$2(matches2, true) !== -1;
          };
        };
        self2.addCommands({
          "JustifyLeft": alignStates("alignleft"),
          "JustifyCenter": alignStates("aligncenter"),
          "JustifyRight": alignStates("alignright"),
          "JustifyFull": alignStates("alignjustify"),
          "Bold,Italic,Underline,Strikethrough,Superscript,Subscript": function(command) {
            return self2.isFormatMatch(command);
          },
          "mceBlockQuote": function() {
            return self2.isFormatMatch("blockquote");
          },
          "Outdent": function() {
            return canOutdent(editor);
          },
          "InsertUnorderedList,InsertOrderedList": function(command) {
            var list = editor.dom.getParent(editor.selection.getNode(), "ul,ol");
            return list && (command === "insertunorderedlist" && list.tagName === "UL" || command === "insertorderedlist" && list.tagName === "OL");
          }
        }, "state");
        self2.addCommands({
          Undo: function() {
            editor.undoManager.undo();
          },
          Redo: function() {
            editor.undoManager.redo();
          }
        });
        self2.addQueryValueHandler("FontName", function() {
          return fontNameQuery(editor);
        }, this);
        self2.addQueryValueHandler("FontSize", function() {
          return fontSizeQuery(editor);
        }, this);
        self2.addQueryValueHandler("LineHeight", function() {
          return lineHeightQuery(editor);
        }, this);
      };
      return EditorCommands2;
    }();
    var internalContentEditableAttr = "data-mce-contenteditable";
    var toggleClass = function(elm, cls, state) {
      if (has$2(elm, cls) && state === false) {
        remove$4(elm, cls);
      } else if (state) {
        add$3(elm, cls);
      }
    };
    var setEditorCommandState = function(editor, cmd, state) {
      try {
        editor.getDoc().execCommand(cmd, false, String(state));
      } catch (ex) {
      }
    };
    var setContentEditable = function(elm, state) {
      elm.dom.contentEditable = state ? "true" : "false";
    };
    var switchOffContentEditableTrue = function(elm) {
      each(descendants$1(elm, '*[contenteditable="true"]'), function(elm2) {
        set(elm2, internalContentEditableAttr, "true");
        setContentEditable(elm2, false);
      });
    };
    var switchOnContentEditableTrue = function(elm) {
      each(descendants$1(elm, "*[" + internalContentEditableAttr + '="true"]'), function(elm2) {
        remove$1(elm2, internalContentEditableAttr);
        setContentEditable(elm2, true);
      });
    };
    var removeFakeSelection = function(editor) {
      Optional.from(editor.selection.getNode()).each(function(elm) {
        elm.removeAttribute("data-mce-selected");
      });
    };
    var restoreFakeSelection = function(editor) {
      editor.selection.setRng(editor.selection.getRng());
    };
    var toggleReadOnly = function(editor, state) {
      var body = SugarElement.fromDom(editor.getBody());
      toggleClass(body, "mce-content-readonly", state);
      if (state) {
        editor.selection.controlSelection.hideResizeRect();
        editor._selectionOverrides.hideFakeCaret();
        removeFakeSelection(editor);
        editor.readonly = true;
        setContentEditable(body, false);
        switchOffContentEditableTrue(body);
      } else {
        editor.readonly = false;
        setContentEditable(body, true);
        switchOnContentEditableTrue(body);
        setEditorCommandState(editor, "StyleWithCSS", false);
        setEditorCommandState(editor, "enableInlineTableEditing", false);
        setEditorCommandState(editor, "enableObjectResizing", false);
        if (hasEditorOrUiFocus(editor)) {
          editor.focus();
        }
        restoreFakeSelection(editor);
        editor.nodeChanged();
      }
    };
    var isReadOnly$1 = function(editor) {
      return editor.readonly;
    };
    var registerFilters = function(editor) {
      editor.parser.addAttributeFilter("contenteditable", function(nodes) {
        if (isReadOnly$1(editor)) {
          each(nodes, function(node) {
            node.attr(internalContentEditableAttr, node.attr("contenteditable"));
            node.attr("contenteditable", "false");
          });
        }
      });
      editor.serializer.addAttributeFilter(internalContentEditableAttr, function(nodes) {
        if (isReadOnly$1(editor)) {
          each(nodes, function(node) {
            node.attr("contenteditable", node.attr(internalContentEditableAttr));
          });
        }
      });
      editor.serializer.addTempAttr(internalContentEditableAttr);
    };
    var registerReadOnlyContentFilters = function(editor) {
      if (editor.serializer) {
        registerFilters(editor);
      } else {
        editor.on("PreInit", function() {
          registerFilters(editor);
        });
      }
    };
    var isClickEvent = function(e) {
      return e.type === "click";
    };
    var getAnchorHrefOpt = function(editor, elm) {
      var isRoot = function(elm2) {
        return eq$2(elm2, SugarElement.fromDom(editor.getBody()));
      };
      return closest$1(elm, "a", isRoot).bind(function(a) {
        return getOpt(a, "href");
      });
    };
    var processReadonlyEvents = function(editor, e) {
      if (isClickEvent(e) && !VK.metaKeyPressed(e)) {
        var elm = SugarElement.fromDom(e.target);
        getAnchorHrefOpt(editor, elm).each(function(href) {
          e.preventDefault();
          if (/^#/.test(href)) {
            var targetEl = editor.dom.select(href + ',[name="' + removeLeading(href, "#") + '"]');
            if (targetEl.length) {
              editor.selection.scrollIntoView(targetEl[0], true);
            }
          } else {
            window.open(href, "_blank", "rel=noopener noreferrer,menubar=yes,toolbar=yes,location=yes,status=yes,resizable=yes,scrollbars=yes");
          }
        });
      }
    };
    var registerReadOnlySelectionBlockers = function(editor) {
      editor.on("ShowCaret", function(e) {
        if (isReadOnly$1(editor)) {
          e.preventDefault();
        }
      });
      editor.on("ObjectSelected", function(e) {
        if (isReadOnly$1(editor)) {
          e.preventDefault();
        }
      });
    };
    var nativeEvents = Tools.makeMap("focus blur focusin focusout click dblclick mousedown mouseup mousemove mouseover beforepaste paste cut copy selectionchange mouseout mouseenter mouseleave wheel keydown keypress keyup input beforeinput contextmenu dragstart dragend dragover draggesture dragdrop drop drag submit compositionstart compositionend compositionupdate touchstart touchmove touchend touchcancel", " ");
    var EventDispatcher = function() {
      function EventDispatcher2(settings) {
        this.bindings = {};
        this.settings = settings || {};
        this.scope = this.settings.scope || this;
        this.toggleEvent = this.settings.toggleEvent || never;
      }
      EventDispatcher2.isNative = function(name2) {
        return !!nativeEvents[name2.toLowerCase()];
      };
      EventDispatcher2.prototype.fire = function(nameIn, argsIn) {
        var name2 = nameIn.toLowerCase();
        var args = argsIn || {};
        args.type = name2;
        if (!args.target) {
          args.target = this.scope;
        }
        if (!args.preventDefault) {
          args.preventDefault = function() {
            args.isDefaultPrevented = always;
          };
          args.stopPropagation = function() {
            args.isPropagationStopped = always;
          };
          args.stopImmediatePropagation = function() {
            args.isImmediatePropagationStopped = always;
          };
          args.isDefaultPrevented = never;
          args.isPropagationStopped = never;
          args.isImmediatePropagationStopped = never;
        }
        if (this.settings.beforeFire) {
          this.settings.beforeFire(args);
        }
        var handlers = this.bindings[name2];
        if (handlers) {
          for (var i = 0, l = handlers.length; i < l; i++) {
            var callback = handlers[i];
            if (callback.once) {
              this.off(name2, callback.func);
            }
            if (args.isImmediatePropagationStopped()) {
              args.stopPropagation();
              return args;
            }
            if (callback.func.call(this.scope, args) === false) {
              args.preventDefault();
              return args;
            }
          }
        }
        return args;
      };
      EventDispatcher2.prototype.on = function(name2, callback, prepend2, extra2) {
        if (callback === false) {
          callback = never;
        }
        if (callback) {
          var wrappedCallback = { func: callback };
          if (extra2) {
            Tools.extend(wrappedCallback, extra2);
          }
          var names = name2.toLowerCase().split(" ");
          var i = names.length;
          while (i--) {
            var currentName = names[i];
            var handlers = this.bindings[currentName];
            if (!handlers) {
              handlers = this.bindings[currentName] = [];
              this.toggleEvent(currentName, true);
            }
            if (prepend2) {
              handlers.unshift(wrappedCallback);
            } else {
              handlers.push(wrappedCallback);
            }
          }
        }
        return this;
      };
      EventDispatcher2.prototype.off = function(name2, callback) {
        var _this = this;
        if (name2) {
          var names = name2.toLowerCase().split(" ");
          var i = names.length;
          while (i--) {
            var currentName = names[i];
            var handlers = this.bindings[currentName];
            if (!currentName) {
              each$1(this.bindings, function(_value, bindingName) {
                _this.toggleEvent(bindingName, false);
                delete _this.bindings[bindingName];
              });
              return this;
            }
            if (handlers) {
              if (!callback) {
                handlers.length = 0;
              } else {
                var hi = handlers.length;
                while (hi--) {
                  if (handlers[hi].func === callback) {
                    handlers = handlers.slice(0, hi).concat(handlers.slice(hi + 1));
                    this.bindings[currentName] = handlers;
                  }
                }
              }
              if (!handlers.length) {
                this.toggleEvent(name2, false);
                delete this.bindings[currentName];
              }
            }
          }
        } else {
          each$1(this.bindings, function(_value, name3) {
            _this.toggleEvent(name3, false);
          });
          this.bindings = {};
        }
        return this;
      };
      EventDispatcher2.prototype.once = function(name2, callback, prepend2) {
        return this.on(name2, callback, prepend2, { once: true });
      };
      EventDispatcher2.prototype.has = function(name2) {
        name2 = name2.toLowerCase();
        return !(!this.bindings[name2] || this.bindings[name2].length === 0);
      };
      return EventDispatcher2;
    }();
    var getEventDispatcher = function(obj) {
      if (!obj._eventDispatcher) {
        obj._eventDispatcher = new EventDispatcher({
          scope: obj,
          toggleEvent: function(name2, state) {
            if (EventDispatcher.isNative(name2) && obj.toggleNativeEvent) {
              obj.toggleNativeEvent(name2, state);
            }
          }
        });
      }
      return obj._eventDispatcher;
    };
    var Observable = {
      fire: function(name2, args, bubble) {
        var self2 = this;
        if (self2.removed && name2 !== "remove" && name2 !== "detach") {
          return args;
        }
        var dispatcherArgs = getEventDispatcher(self2).fire(name2, args);
        if (bubble !== false && self2.parent) {
          var parent_1 = self2.parent();
          while (parent_1 && !dispatcherArgs.isPropagationStopped()) {
            parent_1.fire(name2, dispatcherArgs, false);
            parent_1 = parent_1.parent();
          }
        }
        return dispatcherArgs;
      },
      on: function(name2, callback, prepend2) {
        return getEventDispatcher(this).on(name2, callback, prepend2);
      },
      off: function(name2, callback) {
        return getEventDispatcher(this).off(name2, callback);
      },
      once: function(name2, callback) {
        return getEventDispatcher(this).once(name2, callback);
      },
      hasEventListeners: function(name2) {
        return getEventDispatcher(this).has(name2);
      }
    };
    var DOM$8 = DOMUtils.DOM;
    var customEventRootDelegates;
    var getEventTarget = function(editor, eventName) {
      if (eventName === "selectionchange") {
        return editor.getDoc();
      }
      if (!editor.inline && /^mouse|touch|click|contextmenu|drop|dragover|dragend/.test(eventName)) {
        return editor.getDoc().documentElement;
      }
      var eventRoot = getEventRoot(editor);
      if (eventRoot) {
        if (!editor.eventRoot) {
          editor.eventRoot = DOM$8.select(eventRoot)[0];
        }
        return editor.eventRoot;
      }
      return editor.getBody();
    };
    var isListening = function(editor) {
      return !editor.hidden && !isReadOnly$1(editor);
    };
    var fireEvent = function(editor, eventName, e) {
      if (isListening(editor)) {
        editor.fire(eventName, e);
      } else if (isReadOnly$1(editor)) {
        processReadonlyEvents(editor, e);
      }
    };
    var bindEventDelegate = function(editor, eventName) {
      var delegate;
      if (!editor.delegates) {
        editor.delegates = {};
      }
      if (editor.delegates[eventName] || editor.removed) {
        return;
      }
      var eventRootElm = getEventTarget(editor, eventName);
      if (getEventRoot(editor)) {
        if (!customEventRootDelegates) {
          customEventRootDelegates = {};
          editor.editorManager.on("removeEditor", function() {
            if (!editor.editorManager.activeEditor) {
              if (customEventRootDelegates) {
                each$1(customEventRootDelegates, function(_value, name2) {
                  editor.dom.unbind(getEventTarget(editor, name2));
                });
                customEventRootDelegates = null;
              }
            }
          });
        }
        if (customEventRootDelegates[eventName]) {
          return;
        }
        delegate = function(e) {
          var target = e.target;
          var editors2 = editor.editorManager.get();
          var i = editors2.length;
          while (i--) {
            var body = editors2[i].getBody();
            if (body === target || DOM$8.isChildOf(target, body)) {
              fireEvent(editors2[i], eventName, e);
            }
          }
        };
        customEventRootDelegates[eventName] = delegate;
        DOM$8.bind(eventRootElm, eventName, delegate);
      } else {
        delegate = function(e) {
          fireEvent(editor, eventName, e);
        };
        DOM$8.bind(eventRootElm, eventName, delegate);
        editor.delegates[eventName] = delegate;
      }
    };
    var EditorObservable = __assign2(__assign2({}, Observable), {
      bindPendingEventDelegates: function() {
        var self2 = this;
        Tools.each(self2._pendingNativeEvents, function(name2) {
          bindEventDelegate(self2, name2);
        });
      },
      toggleNativeEvent: function(name2, state) {
        var self2 = this;
        if (name2 === "focus" || name2 === "blur") {
          return;
        }
        if (state) {
          if (self2.initialized) {
            bindEventDelegate(self2, name2);
          } else {
            if (!self2._pendingNativeEvents) {
              self2._pendingNativeEvents = [name2];
            } else {
              self2._pendingNativeEvents.push(name2);
            }
          }
        } else if (self2.initialized) {
          self2.dom.unbind(getEventTarget(self2, name2), name2, self2.delegates[name2]);
          delete self2.delegates[name2];
        }
      },
      unbindAllNativeEvents: function() {
        var self2 = this;
        var body = self2.getBody();
        var dom2 = self2.dom;
        if (self2.delegates) {
          each$1(self2.delegates, function(value2, name2) {
            self2.dom.unbind(getEventTarget(self2, name2), name2, value2);
          });
          delete self2.delegates;
        }
        if (!self2.inline && body && dom2) {
          body.onload = null;
          dom2.unbind(self2.getWin());
          dom2.unbind(self2.getDoc());
        }
        if (dom2) {
          dom2.unbind(body);
          dom2.unbind(self2.getContainer());
        }
      }
    });
    var defaultModes = [
      "design",
      "readonly"
    ];
    var switchToMode = function(editor, activeMode, availableModes, mode) {
      var oldMode = availableModes[activeMode.get()];
      var newMode = availableModes[mode];
      try {
        newMode.activate();
      } catch (e) {
        console.error("problem while activating editor mode " + mode + ":", e);
        return;
      }
      oldMode.deactivate();
      if (oldMode.editorReadOnly !== newMode.editorReadOnly) {
        toggleReadOnly(editor, newMode.editorReadOnly);
      }
      activeMode.set(mode);
      fireSwitchMode(editor, mode);
    };
    var setMode = function(editor, availableModes, activeMode, mode) {
      if (mode === activeMode.get()) {
        return;
      } else if (!has(availableModes, mode)) {
        throw new Error("Editor mode '" + mode + "' is invalid");
      }
      if (editor.initialized) {
        switchToMode(editor, activeMode, availableModes, mode);
      } else {
        editor.on("init", function() {
          return switchToMode(editor, activeMode, availableModes, mode);
        });
      }
    };
    var registerMode = function(availableModes, mode, api2) {
      var _a;
      if (contains(defaultModes, mode)) {
        throw new Error("Cannot override default mode " + mode);
      }
      return __assign2(__assign2({}, availableModes), (_a = {}, _a[mode] = __assign2(__assign2({}, api2), {
        deactivate: function() {
          try {
            api2.deactivate();
          } catch (e) {
            console.error("problem while deactivating editor mode " + mode + ":", e);
          }
        }
      }), _a));
    };
    var create$5 = function(editor) {
      var activeMode = Cell("design");
      var availableModes = Cell({
        design: {
          activate: noop,
          deactivate: noop,
          editorReadOnly: false
        },
        readonly: {
          activate: noop,
          deactivate: noop,
          editorReadOnly: true
        }
      });
      registerReadOnlyContentFilters(editor);
      registerReadOnlySelectionBlockers(editor);
      return {
        isReadOnly: function() {
          return isReadOnly$1(editor);
        },
        set: function(mode) {
          return setMode(editor, availableModes.get(), activeMode, mode);
        },
        get: function() {
          return activeMode.get();
        },
        register: function(mode, api2) {
          availableModes.set(registerMode(availableModes.get(), mode, api2));
        }
      };
    };
    var each$g = Tools.each, explode$3 = Tools.explode;
    var keyCodeLookup = {
      f1: 112,
      f2: 113,
      f3: 114,
      f4: 115,
      f5: 116,
      f6: 117,
      f7: 118,
      f8: 119,
      f9: 120,
      f10: 121,
      f11: 122,
      f12: 123
    };
    var modifierNames = Tools.makeMap("alt,ctrl,shift,meta,access");
    var parseShortcut = function(pattern) {
      var key;
      var shortcut = {};
      each$g(explode$3(pattern.toLowerCase(), "+"), function(value2) {
        if (value2 in modifierNames) {
          shortcut[value2] = true;
        } else {
          if (/^[0-9]{2,}$/.test(value2)) {
            shortcut.keyCode = parseInt(value2, 10);
          } else {
            shortcut.charCode = value2.charCodeAt(0);
            shortcut.keyCode = keyCodeLookup[value2] || value2.toUpperCase().charCodeAt(0);
          }
        }
      });
      var id = [shortcut.keyCode];
      for (key in modifierNames) {
        if (shortcut[key]) {
          id.push(key);
        } else {
          shortcut[key] = false;
        }
      }
      shortcut.id = id.join(",");
      if (shortcut.access) {
        shortcut.alt = true;
        if (Env.mac) {
          shortcut.ctrl = true;
        } else {
          shortcut.shift = true;
        }
      }
      if (shortcut.meta) {
        if (Env.mac) {
          shortcut.meta = true;
        } else {
          shortcut.ctrl = true;
          shortcut.meta = false;
        }
      }
      return shortcut;
    };
    var Shortcuts = function() {
      function Shortcuts2(editor) {
        this.shortcuts = {};
        this.pendingPatterns = [];
        this.editor = editor;
        var self2 = this;
        editor.on("keyup keypress keydown", function(e) {
          if ((self2.hasModifier(e) || self2.isFunctionKey(e)) && !e.isDefaultPrevented()) {
            each$g(self2.shortcuts, function(shortcut) {
              if (self2.matchShortcut(e, shortcut)) {
                self2.pendingPatterns = shortcut.subpatterns.slice(0);
                if (e.type === "keydown") {
                  self2.executeShortcutAction(shortcut);
                }
                return true;
              }
            });
            if (self2.matchShortcut(e, self2.pendingPatterns[0])) {
              if (self2.pendingPatterns.length === 1) {
                if (e.type === "keydown") {
                  self2.executeShortcutAction(self2.pendingPatterns[0]);
                }
              }
              self2.pendingPatterns.shift();
            }
          }
        });
      }
      Shortcuts2.prototype.add = function(pattern, desc, cmdFunc, scope) {
        var self2 = this;
        var func = self2.normalizeCommandFunc(cmdFunc);
        each$g(explode$3(Tools.trim(pattern)), function(pattern2) {
          var shortcut = self2.createShortcut(pattern2, desc, func, scope);
          self2.shortcuts[shortcut.id] = shortcut;
        });
        return true;
      };
      Shortcuts2.prototype.remove = function(pattern) {
        var shortcut = this.createShortcut(pattern);
        if (this.shortcuts[shortcut.id]) {
          delete this.shortcuts[shortcut.id];
          return true;
        }
        return false;
      };
      Shortcuts2.prototype.normalizeCommandFunc = function(cmdFunc) {
        var self2 = this;
        var cmd = cmdFunc;
        if (typeof cmd === "string") {
          return function() {
            self2.editor.execCommand(cmd, false, null);
          };
        } else if (Tools.isArray(cmd)) {
          return function() {
            self2.editor.execCommand(cmd[0], cmd[1], cmd[2]);
          };
        } else {
          return cmd;
        }
      };
      Shortcuts2.prototype.createShortcut = function(pattern, desc, cmdFunc, scope) {
        var shortcuts = Tools.map(explode$3(pattern, ">"), parseShortcut);
        shortcuts[shortcuts.length - 1] = Tools.extend(shortcuts[shortcuts.length - 1], {
          func: cmdFunc,
          scope: scope || this.editor
        });
        return Tools.extend(shortcuts[0], {
          desc: this.editor.translate(desc),
          subpatterns: shortcuts.slice(1)
        });
      };
      Shortcuts2.prototype.hasModifier = function(e) {
        return e.altKey || e.ctrlKey || e.metaKey;
      };
      Shortcuts2.prototype.isFunctionKey = function(e) {
        return e.type === "keydown" && e.keyCode >= 112 && e.keyCode <= 123;
      };
      Shortcuts2.prototype.matchShortcut = function(e, shortcut) {
        if (!shortcut) {
          return false;
        }
        if (shortcut.ctrl !== e.ctrlKey || shortcut.meta !== e.metaKey) {
          return false;
        }
        if (shortcut.alt !== e.altKey || shortcut.shift !== e.shiftKey) {
          return false;
        }
        if (e.keyCode === shortcut.keyCode || e.charCode && e.charCode === shortcut.charCode) {
          e.preventDefault();
          return true;
        }
        return false;
      };
      Shortcuts2.prototype.executeShortcutAction = function(shortcut) {
        return shortcut.func ? shortcut.func.call(shortcut.scope) : null;
      };
      return Shortcuts2;
    }();
    var create$6 = function() {
      var buttons = {};
      var menuItems = {};
      var popups = {};
      var icons = {};
      var contextMenus = {};
      var contextToolbars = {};
      var sidebars = {};
      var add2 = function(collection, type2) {
        return function(name2, spec) {
          return collection[name2.toLowerCase()] = __assign2(__assign2({}, spec), { type: type2 });
        };
      };
      var addIcon = function(name2, svgData) {
        return icons[name2.toLowerCase()] = svgData;
      };
      return {
        addButton: add2(buttons, "button"),
        addGroupToolbarButton: add2(buttons, "grouptoolbarbutton"),
        addToggleButton: add2(buttons, "togglebutton"),
        addMenuButton: add2(buttons, "menubutton"),
        addSplitButton: add2(buttons, "splitbutton"),
        addMenuItem: add2(menuItems, "menuitem"),
        addNestedMenuItem: add2(menuItems, "nestedmenuitem"),
        addToggleMenuItem: add2(menuItems, "togglemenuitem"),
        addAutocompleter: add2(popups, "autocompleter"),
        addContextMenu: add2(contextMenus, "contextmenu"),
        addContextToolbar: add2(contextToolbars, "contexttoolbar"),
        addContextForm: add2(contextToolbars, "contextform"),
        addSidebar: add2(sidebars, "sidebar"),
        addIcon,
        getAll: function() {
          return {
            buttons,
            menuItems,
            icons,
            popups,
            contextMenus,
            contextToolbars,
            sidebars
          };
        }
      };
    };
    var registry = function() {
      var bridge = create$6();
      return {
        addAutocompleter: bridge.addAutocompleter,
        addButton: bridge.addButton,
        addContextForm: bridge.addContextForm,
        addContextMenu: bridge.addContextMenu,
        addContextToolbar: bridge.addContextToolbar,
        addIcon: bridge.addIcon,
        addMenuButton: bridge.addMenuButton,
        addMenuItem: bridge.addMenuItem,
        addNestedMenuItem: bridge.addNestedMenuItem,
        addSidebar: bridge.addSidebar,
        addSplitButton: bridge.addSplitButton,
        addToggleButton: bridge.addToggleButton,
        addGroupToolbarButton: bridge.addGroupToolbarButton,
        addToggleMenuItem: bridge.addToggleMenuItem,
        getAll: bridge.getAll
      };
    };
    var each$h = Tools.each, trim$4 = Tools.trim;
    var queryParts = "source protocol authority userInfo user password host port relative path directory file query anchor".split(" ");
    var DEFAULT_PORTS = {
      ftp: 21,
      http: 80,
      https: 443,
      mailto: 25
    };
    var URI = function() {
      function URI2(url, settings) {
        url = trim$4(url);
        this.settings = settings || {};
        var baseUri = this.settings.base_uri;
        var self2 = this;
        if (/^([\w\-]+):([^\/]{2})/i.test(url) || /^\s*#/.test(url)) {
          self2.source = url;
          return;
        }
        var isProtocolRelative = url.indexOf("//") === 0;
        if (url.indexOf("/") === 0 && !isProtocolRelative) {
          url = (baseUri ? baseUri.protocol || "http" : "http") + "://mce_host" + url;
        }
        if (!/^[\w\-]*:?\/\//.test(url)) {
          var baseUrl = this.settings.base_uri ? this.settings.base_uri.path : new URI2(document.location.href).directory;
          if (this.settings.base_uri && this.settings.base_uri.protocol == "") {
            url = "//mce_host" + self2.toAbsPath(baseUrl, url);
          } else {
            var match2 = /([^#?]*)([#?]?.*)/.exec(url);
            url = (baseUri && baseUri.protocol || "http") + "://mce_host" + self2.toAbsPath(baseUrl, match2[1]) + match2[2];
          }
        }
        url = url.replace(/@@/g, "(mce_at)");
        var urlMatch = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@\/]*):?([^:@\/]*))?@)?(\[[a-zA-Z0-9:.%]+\]|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/.exec(url);
        each$h(queryParts, function(v, i) {
          var part = urlMatch[i];
          if (part) {
            part = part.replace(/\(mce_at\)/g, "@@");
          }
          self2[v] = part;
        });
        if (baseUri) {
          if (!self2.protocol) {
            self2.protocol = baseUri.protocol;
          }
          if (!self2.userInfo) {
            self2.userInfo = baseUri.userInfo;
          }
          if (!self2.port && self2.host === "mce_host") {
            self2.port = baseUri.port;
          }
          if (!self2.host || self2.host === "mce_host") {
            self2.host = baseUri.host;
          }
          self2.source = "";
        }
        if (isProtocolRelative) {
          self2.protocol = "";
        }
      }
      URI2.parseDataUri = function(uri) {
        var type2;
        var uriComponents = decodeURIComponent(uri).split(",");
        var matches2 = /data:([^;]+)/.exec(uriComponents[0]);
        if (matches2) {
          type2 = matches2[1];
        }
        return {
          type: type2,
          data: uriComponents[1]
        };
      };
      URI2.getDocumentBaseUrl = function(loc) {
        var baseUrl;
        if (loc.protocol.indexOf("http") !== 0 && loc.protocol !== "file:") {
          baseUrl = loc.href;
        } else {
          baseUrl = loc.protocol + "//" + loc.host + loc.pathname;
        }
        if (/^[^:]+:\/\/\/?[^\/]+\//.test(baseUrl)) {
          baseUrl = baseUrl.replace(/[\?#].*$/, "").replace(/[\/\\][^\/]+$/, "");
          if (!/[\/\\]$/.test(baseUrl)) {
            baseUrl += "/";
          }
        }
        return baseUrl;
      };
      URI2.prototype.setPath = function(path) {
        var pathMatch = /^(.*?)\/?(\w+)?$/.exec(path);
        this.path = pathMatch[0];
        this.directory = pathMatch[1];
        this.file = pathMatch[2];
        this.source = "";
        this.getURI();
      };
      URI2.prototype.toRelative = function(uri) {
        var output;
        if (uri === "./") {
          return uri;
        }
        var relativeUri = new URI2(uri, { base_uri: this });
        if (relativeUri.host !== "mce_host" && this.host !== relativeUri.host && relativeUri.host || this.port !== relativeUri.port || this.protocol !== relativeUri.protocol && relativeUri.protocol !== "") {
          return relativeUri.getURI();
        }
        var tu = this.getURI(), uu = relativeUri.getURI();
        if (tu === uu || tu.charAt(tu.length - 1) === "/" && tu.substr(0, tu.length - 1) === uu) {
          return tu;
        }
        output = this.toRelPath(this.path, relativeUri.path);
        if (relativeUri.query) {
          output += "?" + relativeUri.query;
        }
        if (relativeUri.anchor) {
          output += "#" + relativeUri.anchor;
        }
        return output;
      };
      URI2.prototype.toAbsolute = function(uri, noHost) {
        var absoluteUri = new URI2(uri, { base_uri: this });
        return absoluteUri.getURI(noHost && this.isSameOrigin(absoluteUri));
      };
      URI2.prototype.isSameOrigin = function(uri) {
        if (this.host == uri.host && this.protocol == uri.protocol) {
          if (this.port == uri.port) {
            return true;
          }
          var defaultPort = DEFAULT_PORTS[this.protocol];
          if (defaultPort && (this.port || defaultPort) == (uri.port || defaultPort)) {
            return true;
          }
        }
        return false;
      };
      URI2.prototype.toRelPath = function(base, path) {
        var breakPoint = 0, out = "", i, l;
        var normalizedBase = base.substring(0, base.lastIndexOf("/")).split("/");
        var items = path.split("/");
        if (normalizedBase.length >= items.length) {
          for (i = 0, l = normalizedBase.length; i < l; i++) {
            if (i >= items.length || normalizedBase[i] !== items[i]) {
              breakPoint = i + 1;
              break;
            }
          }
        }
        if (normalizedBase.length < items.length) {
          for (i = 0, l = items.length; i < l; i++) {
            if (i >= normalizedBase.length || normalizedBase[i] !== items[i]) {
              breakPoint = i + 1;
              break;
            }
          }
        }
        if (breakPoint === 1) {
          return path;
        }
        for (i = 0, l = normalizedBase.length - (breakPoint - 1); i < l; i++) {
          out += "../";
        }
        for (i = breakPoint - 1, l = items.length; i < l; i++) {
          if (i !== breakPoint - 1) {
            out += "/" + items[i];
          } else {
            out += items[i];
          }
        }
        return out;
      };
      URI2.prototype.toAbsPath = function(base, path) {
        var i, nb = 0, o = [], outPath;
        var tr = /\/$/.test(path) ? "/" : "";
        var normalizedBase = base.split("/");
        var normalizedPath = path.split("/");
        each$h(normalizedBase, function(k) {
          if (k) {
            o.push(k);
          }
        });
        normalizedBase = o;
        for (i = normalizedPath.length - 1, o = []; i >= 0; i--) {
          if (normalizedPath[i].length === 0 || normalizedPath[i] === ".") {
            continue;
          }
          if (normalizedPath[i] === "..") {
            nb++;
            continue;
          }
          if (nb > 0) {
            nb--;
            continue;
          }
          o.push(normalizedPath[i]);
        }
        i = normalizedBase.length - nb;
        if (i <= 0) {
          outPath = reverse(o).join("/");
        } else {
          outPath = normalizedBase.slice(0, i).join("/") + "/" + reverse(o).join("/");
        }
        if (outPath.indexOf("/") !== 0) {
          outPath = "/" + outPath;
        }
        if (tr && outPath.lastIndexOf("/") !== outPath.length - 1) {
          outPath += tr;
        }
        return outPath;
      };
      URI2.prototype.getURI = function(noProtoHost) {
        if (noProtoHost === void 0) {
          noProtoHost = false;
        }
        var s;
        if (!this.source || noProtoHost) {
          s = "";
          if (!noProtoHost) {
            if (this.protocol) {
              s += this.protocol + "://";
            } else {
              s += "//";
            }
            if (this.userInfo) {
              s += this.userInfo + "@";
            }
            if (this.host) {
              s += this.host;
            }
            if (this.port) {
              s += ":" + this.port;
            }
          }
          if (this.path) {
            s += this.path;
          }
          if (this.query) {
            s += "?" + this.query;
          }
          if (this.anchor) {
            s += "#" + this.anchor;
          }
          this.source = s;
        }
        return this.source;
      };
      return URI2;
    }();
    var DOM$9 = DOMUtils.DOM;
    var extend$3 = Tools.extend, each$i = Tools.each;
    var resolve$3 = Tools.resolve;
    var ie$1 = Env.ie;
    var Editor = function() {
      function Editor2(id, settings, editorManager) {
        var _this = this;
        this.plugins = {};
        this.contentCSS = [];
        this.contentStyles = [];
        this.loadedCSS = {};
        this.isNotDirty = false;
        this.editorManager = editorManager;
        this.documentBaseUrl = editorManager.documentBaseURL;
        extend$3(this, EditorObservable);
        this.settings = getEditorSettings(this, id, this.documentBaseUrl, editorManager.defaultSettings, settings);
        if (this.settings.suffix) {
          editorManager.suffix = this.settings.suffix;
        }
        this.suffix = editorManager.suffix;
        if (this.settings.base_url) {
          editorManager._setBaseUrl(this.settings.base_url);
        }
        this.baseUri = editorManager.baseURI;
        if (this.settings.referrer_policy) {
          ScriptLoader2.ScriptLoader._setReferrerPolicy(this.settings.referrer_policy);
          DOMUtils.DOM.styleSheetLoader._setReferrerPolicy(this.settings.referrer_policy);
        }
        AddOnManager.languageLoad = this.settings.language_load;
        AddOnManager.baseURL = editorManager.baseURL;
        this.id = id;
        this.setDirty(false);
        this.documentBaseURI = new URI(this.settings.document_base_url, { base_uri: this.baseUri });
        this.baseURI = this.baseUri;
        this.inline = !!this.settings.inline;
        this.shortcuts = new Shortcuts(this);
        this.editorCommands = new EditorCommands(this);
        if (this.settings.cache_suffix) {
          Env.cacheSuffix = this.settings.cache_suffix.replace(/^[\?\&]+/, "");
        }
        this.ui = {
          registry: registry(),
          styleSheetLoader: void 0,
          show: noop,
          hide: noop,
          enable: noop,
          disable: noop,
          isDisabled: never
        };
        var self2 = this;
        var modeInstance = create$5(self2);
        this.mode = modeInstance;
        this.setMode = modeInstance.set;
        editorManager.fire("SetupEditor", { editor: this });
        this.execCallback("setup", this);
        this.$ = DomQuery.overrideDefaults(function() {
          return {
            context: _this.inline ? _this.getBody() : _this.getDoc(),
            element: _this.getBody()
          };
        });
      }
      Editor2.prototype.render = function() {
        render(this);
      };
      Editor2.prototype.focus = function(skipFocus) {
        focus$1(this, skipFocus);
      };
      Editor2.prototype.hasFocus = function() {
        return hasFocus$1(this);
      };
      Editor2.prototype.execCallback = function(name2) {
        var x = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          x[_i - 1] = arguments[_i];
        }
        var self2 = this;
        var callback = self2.settings[name2], scope;
        if (!callback) {
          return;
        }
        if (self2.callbackLookup && (scope = self2.callbackLookup[name2])) {
          callback = scope.func;
          scope = scope.scope;
        }
        if (typeof callback === "string") {
          scope = callback.replace(/\.\w+$/, "");
          scope = scope ? resolve$3(scope) : 0;
          callback = resolve$3(callback);
          self2.callbackLookup = self2.callbackLookup || {};
          self2.callbackLookup[name2] = {
            func: callback,
            scope
          };
        }
        return callback.apply(scope || self2, x);
      };
      Editor2.prototype.translate = function(text) {
        return I18n.translate(text);
      };
      Editor2.prototype.getParam = function(name2, defaultVal, type2) {
        return getParam(this, name2, defaultVal, type2);
      };
      Editor2.prototype.hasPlugin = function(name2, loaded) {
        var hasPlugin = contains(getPlugins(this).split(/[ ,]/), name2);
        if (hasPlugin) {
          return loaded ? PluginManager.get(name2) !== void 0 : true;
        } else {
          return false;
        }
      };
      Editor2.prototype.nodeChanged = function(args) {
        this._nodeChangeDispatcher.nodeChanged(args);
      };
      Editor2.prototype.addCommand = function(name2, callback, scope) {
        this.editorCommands.addCommand(name2, callback, scope);
      };
      Editor2.prototype.addQueryStateHandler = function(name2, callback, scope) {
        this.editorCommands.addQueryStateHandler(name2, callback, scope);
      };
      Editor2.prototype.addQueryValueHandler = function(name2, callback, scope) {
        this.editorCommands.addQueryValueHandler(name2, callback, scope);
      };
      Editor2.prototype.addShortcut = function(pattern, desc, cmdFunc, scope) {
        this.shortcuts.add(pattern, desc, cmdFunc, scope);
      };
      Editor2.prototype.execCommand = function(cmd, ui, value2, args) {
        return this.editorCommands.execCommand(cmd, ui, value2, args);
      };
      Editor2.prototype.queryCommandState = function(cmd) {
        return this.editorCommands.queryCommandState(cmd);
      };
      Editor2.prototype.queryCommandValue = function(cmd) {
        return this.editorCommands.queryCommandValue(cmd);
      };
      Editor2.prototype.queryCommandSupported = function(cmd) {
        return this.editorCommands.queryCommandSupported(cmd);
      };
      Editor2.prototype.show = function() {
        var self2 = this;
        if (self2.hidden) {
          self2.hidden = false;
          if (self2.inline) {
            self2.getBody().contentEditable = "true";
          } else {
            DOM$9.show(self2.getContainer());
            DOM$9.hide(self2.id);
          }
          self2.load();
          self2.fire("show");
        }
      };
      Editor2.prototype.hide = function() {
        var self2 = this, doc2 = self2.getDoc();
        if (!self2.hidden) {
          if (ie$1 && doc2 && !self2.inline) {
            doc2.execCommand("SelectAll");
          }
          self2.save();
          if (self2.inline) {
            self2.getBody().contentEditable = "false";
            if (self2 === self2.editorManager.focusedEditor) {
              self2.editorManager.focusedEditor = null;
            }
          } else {
            DOM$9.hide(self2.getContainer());
            DOM$9.setStyle(self2.id, "display", self2.orgDisplay);
          }
          self2.hidden = true;
          self2.fire("hide");
        }
      };
      Editor2.prototype.isHidden = function() {
        return !!this.hidden;
      };
      Editor2.prototype.setProgressState = function(state, time) {
        this.fire("ProgressState", {
          state,
          time
        });
      };
      Editor2.prototype.load = function(args) {
        var self2 = this;
        var elm = self2.getElement(), html;
        if (self2.removed) {
          return "";
        }
        if (elm) {
          args = args || {};
          args.load = true;
          var value2 = isTextareaOrInput(elm) ? elm.value : elm.innerHTML;
          html = self2.setContent(value2, args);
          args.element = elm;
          if (!args.no_events) {
            self2.fire("LoadContent", args);
          }
          args.element = elm = null;
          return html;
        }
      };
      Editor2.prototype.save = function(args) {
        var self2 = this;
        var elm = self2.getElement(), html, form;
        if (!elm || !self2.initialized || self2.removed) {
          return;
        }
        args = args || {};
        args.save = true;
        args.element = elm;
        html = args.content = self2.getContent(args);
        if (!args.no_events) {
          self2.fire("SaveContent", args);
        }
        if (args.format === "raw") {
          self2.fire("RawSaveContent", args);
        }
        html = args.content;
        if (!isTextareaOrInput(elm)) {
          if (args.is_removing || !self2.inline) {
            elm.innerHTML = html;
          }
          if (form = DOM$9.getParent(self2.id, "form")) {
            each$i(form.elements, function(elm2) {
              if (elm2.name === self2.id) {
                elm2.value = html;
                return false;
              }
            });
          }
        } else {
          elm.value = html;
        }
        args.element = elm = null;
        if (args.set_dirty !== false) {
          self2.setDirty(false);
        }
        return html;
      };
      Editor2.prototype.setContent = function(content, args) {
        return setContent$2(this, content, args);
      };
      Editor2.prototype.getContent = function(args) {
        return getContent$2(this, args);
      };
      Editor2.prototype.insertContent = function(content, args) {
        if (args) {
          content = extend$3({ content }, args);
        }
        this.execCommand("mceInsertContent", false, content);
      };
      Editor2.prototype.resetContent = function(initialContent) {
        if (initialContent === void 0) {
          setContent$2(this, this.startContent, { format: "raw" });
        } else {
          setContent$2(this, initialContent);
        }
        this.undoManager.reset();
        this.setDirty(false);
        this.nodeChanged();
      };
      Editor2.prototype.isDirty = function() {
        return !this.isNotDirty;
      };
      Editor2.prototype.setDirty = function(state) {
        var oldState = !this.isNotDirty;
        this.isNotDirty = !state;
        if (state && state !== oldState) {
          this.fire("dirty");
        }
      };
      Editor2.prototype.getContainer = function() {
        var self2 = this;
        if (!self2.container) {
          self2.container = DOM$9.get(self2.editorContainer || self2.id + "_parent");
        }
        return self2.container;
      };
      Editor2.prototype.getContentAreaContainer = function() {
        return this.contentAreaContainer;
      };
      Editor2.prototype.getElement = function() {
        if (!this.targetElm) {
          this.targetElm = DOM$9.get(this.id);
        }
        return this.targetElm;
      };
      Editor2.prototype.getWin = function() {
        var self2 = this;
        var elm;
        if (!self2.contentWindow) {
          elm = self2.iframeElement;
          if (elm) {
            self2.contentWindow = elm.contentWindow;
          }
        }
        return self2.contentWindow;
      };
      Editor2.prototype.getDoc = function() {
        var self2 = this;
        var win;
        if (!self2.contentDocument) {
          win = self2.getWin();
          if (win) {
            self2.contentDocument = win.document;
          }
        }
        return self2.contentDocument;
      };
      Editor2.prototype.getBody = function() {
        var doc2 = this.getDoc();
        return this.bodyElement || (doc2 ? doc2.body : null);
      };
      Editor2.prototype.convertURL = function(url, name2, elm) {
        var self2 = this, settings = self2.settings;
        if (settings.urlconverter_callback) {
          return self2.execCallback("urlconverter_callback", url, elm, true, name2);
        }
        if (!settings.convert_urls || elm && elm.nodeName === "LINK" || url.indexOf("file:") === 0 || url.length === 0) {
          return url;
        }
        if (settings.relative_urls) {
          return self2.documentBaseURI.toRelative(url);
        }
        url = self2.documentBaseURI.toAbsolute(url, settings.remove_script_host);
        return url;
      };
      Editor2.prototype.addVisual = function(elm) {
        addVisual$1(this, elm);
      };
      Editor2.prototype.remove = function() {
        remove$7(this);
      };
      Editor2.prototype.destroy = function(automatic) {
        destroy(this, automatic);
      };
      Editor2.prototype.uploadImages = function(callback) {
        return this.editorUpload.uploadImages(callback);
      };
      Editor2.prototype._scanForImages = function() {
        return this.editorUpload.scanForImages();
      };
      Editor2.prototype.addButton = function() {
        throw new Error("editor.addButton has been removed in tinymce 5x, use editor.ui.registry.addButton or editor.ui.registry.addToggleButton or editor.ui.registry.addSplitButton instead");
      };
      Editor2.prototype.addSidebar = function() {
        throw new Error("editor.addSidebar has been removed in tinymce 5x, use editor.ui.registry.addSidebar instead");
      };
      Editor2.prototype.addMenuItem = function() {
        throw new Error("editor.addMenuItem has been removed in tinymce 5x, use editor.ui.registry.addMenuItem instead");
      };
      Editor2.prototype.addContextToolbar = function() {
        throw new Error("editor.addContextToolbar has been removed in tinymce 5x, use editor.ui.registry.addContextToolbar instead");
      };
      return Editor2;
    }();
    var DOM$a = DOMUtils.DOM;
    var explode$4 = Tools.explode, each$j = Tools.each, extend$4 = Tools.extend;
    var instanceCounter = 0, boundGlobalEvents = false;
    var beforeUnloadDelegate;
    var legacyEditors = [];
    var editors = [];
    var isValidLegacyKey = function(id) {
      return id !== "length";
    };
    var globalEventDelegate = function(e) {
      var type2 = e.type;
      each$j(EditorManager.get(), function(editor) {
        switch (type2) {
          case "scroll":
            editor.fire("ScrollWindow", e);
            break;
          case "resize":
            editor.fire("ResizeWindow", e);
            break;
        }
      });
    };
    var toggleGlobalEvents = function(state) {
      if (state !== boundGlobalEvents) {
        if (state) {
          DomQuery(window).on("resize scroll", globalEventDelegate);
        } else {
          DomQuery(window).off("resize scroll", globalEventDelegate);
        }
        boundGlobalEvents = state;
      }
    };
    var removeEditorFromList = function(targetEditor) {
      var oldEditors = editors;
      delete legacyEditors[targetEditor.id];
      for (var i = 0; i < legacyEditors.length; i++) {
        if (legacyEditors[i] === targetEditor) {
          legacyEditors.splice(i, 1);
          break;
        }
      }
      editors = filter(editors, function(editor) {
        return targetEditor !== editor;
      });
      if (EditorManager.activeEditor === targetEditor) {
        EditorManager.activeEditor = editors.length > 0 ? editors[0] : null;
      }
      if (EditorManager.focusedEditor === targetEditor) {
        EditorManager.focusedEditor = null;
      }
      return oldEditors.length !== editors.length;
    };
    var purgeDestroyedEditor = function(editor) {
      if (editor && editor.initialized && !(editor.getContainer() || editor.getBody()).parentNode) {
        removeEditorFromList(editor);
        editor.unbindAllNativeEvents();
        editor.destroy(true);
        editor.removed = true;
        editor = null;
      }
      return editor;
    };
    var isQuirksMode = document.compatMode !== "CSS1Compat";
    var EditorManager = __assign2(__assign2({}, Observable), {
      baseURI: null,
      baseURL: null,
      defaultSettings: {},
      documentBaseURL: null,
      suffix: null,
      $: DomQuery,
      majorVersion: "5",
      minorVersion: "8.2",
      releaseDate: "2021-06-23",
      editors: legacyEditors,
      i18n: I18n,
      activeEditor: null,
      focusedEditor: null,
      settings: {},
      setup: function() {
        var self2 = this;
        var baseURL, documentBaseURL, suffix = "";
        documentBaseURL = URI.getDocumentBaseUrl(document.location);
        if (/^[^:]+:\/\/\/?[^\/]+\//.test(documentBaseURL)) {
          documentBaseURL = documentBaseURL.replace(/[\?#].*$/, "").replace(/[\/\\][^\/]+$/, "");
          if (!/[\/\\]$/.test(documentBaseURL)) {
            documentBaseURL += "/";
          }
        }
        var preInit2 = window.tinymce || window.tinyMCEPreInit;
        if (preInit2) {
          baseURL = preInit2.base || preInit2.baseURL;
          suffix = preInit2.suffix;
        } else {
          var scripts = document.getElementsByTagName("script");
          for (var i = 0; i < scripts.length; i++) {
            var src = scripts[i].src || "";
            if (src === "") {
              continue;
            }
            var srcScript = src.substring(src.lastIndexOf("/"));
            if (/tinymce(\.full|\.jquery|)(\.min|\.dev|)\.js/.test(src)) {
              if (srcScript.indexOf(".min") !== -1) {
                suffix = ".min";
              }
              baseURL = src.substring(0, src.lastIndexOf("/"));
              break;
            }
          }
          if (!baseURL && document.currentScript) {
            var src = document.currentScript.src;
            if (src.indexOf(".min") !== -1) {
              suffix = ".min";
            }
            baseURL = src.substring(0, src.lastIndexOf("/"));
          }
        }
        self2.baseURL = new URI(documentBaseURL).toAbsolute(baseURL);
        self2.documentBaseURL = documentBaseURL;
        self2.baseURI = new URI(self2.baseURL);
        self2.suffix = suffix;
        setup$2(self2);
      },
      overrideDefaults: function(defaultSettings) {
        var baseUrl = defaultSettings.base_url;
        if (baseUrl) {
          this._setBaseUrl(baseUrl);
        }
        var suffix = defaultSettings.suffix;
        if (defaultSettings.suffix) {
          this.suffix = suffix;
        }
        this.defaultSettings = defaultSettings;
        var pluginBaseUrls = defaultSettings.plugin_base_urls;
        if (pluginBaseUrls !== void 0) {
          each$1(pluginBaseUrls, function(pluginBaseUrl, pluginName) {
            AddOnManager.PluginManager.urls[pluginName] = pluginBaseUrl;
          });
        }
      },
      init: function(settings) {
        var self2 = this;
        var result;
        var invalidInlineTargets = Tools.makeMap("area base basefont br col frame hr img input isindex link meta param embed source wbr track colgroup option table tbody tfoot thead tr th td script noscript style textarea video audio iframe object menu", " ");
        var isInvalidInlineTarget = function(settings2, elm) {
          return settings2.inline && elm.tagName.toLowerCase() in invalidInlineTargets;
        };
        var createId = function(elm) {
          var id = elm.id;
          if (!id) {
            id = get$1(elm, "name").filter(function(name2) {
              return !DOM$a.get(name2);
            }).getOrThunk(DOM$a.uniqueId);
            elm.setAttribute("id", id);
          }
          return id;
        };
        var execCallback = function(name2) {
          var callback = settings[name2];
          if (!callback) {
            return;
          }
          return callback.apply(self2, []);
        };
        var hasClass2 = function(elm, className) {
          return className.constructor === RegExp ? className.test(elm.className) : DOM$a.hasClass(elm, className);
        };
        var findTargets = function(settings2) {
          var targets = [];
          if (Env.browser.isIE() && Env.browser.version.major < 11) {
            initError("TinyMCE does not support the browser you are using. For a list of supported browsers please see: https://www.tinymce.com/docs/get-started/system-requirements/");
            return [];
          } else if (isQuirksMode) {
            initError("Failed to initialize the editor as the document is not in standards mode. TinyMCE requires standards mode.");
            return [];
          }
          if (settings2.types) {
            each$j(settings2.types, function(type2) {
              targets = targets.concat(DOM$a.select(type2.selector));
            });
            return targets;
          } else if (settings2.selector) {
            return DOM$a.select(settings2.selector);
          } else if (settings2.target) {
            return [settings2.target];
          }
          switch (settings2.mode) {
            case "exact":
              var l = settings2.elements || "";
              if (l.length > 0) {
                each$j(explode$4(l), function(id) {
                  var elm = DOM$a.get(id);
                  if (elm) {
                    targets.push(elm);
                  } else {
                    each$j(document.forms, function(f) {
                      each$j(f.elements, function(e) {
                        if (e.name === id) {
                          id = "mce_editor_" + instanceCounter++;
                          DOM$a.setAttrib(e, "id", id);
                          targets.push(e);
                        }
                      });
                    });
                  }
                });
              }
              break;
            case "textareas":
            case "specific_textareas":
              each$j(DOM$a.select("textarea"), function(elm) {
                if (settings2.editor_deselector && hasClass2(elm, settings2.editor_deselector)) {
                  return;
                }
                if (!settings2.editor_selector || hasClass2(elm, settings2.editor_selector)) {
                  targets.push(elm);
                }
              });
              break;
          }
          return targets;
        };
        var provideResults = function(editors2) {
          result = editors2;
        };
        var initEditors = function() {
          var initCount = 0;
          var editors2 = [];
          var targets;
          var createEditor = function(id, settings2, targetElm) {
            var editor = new Editor(id, settings2, self2);
            editors2.push(editor);
            editor.on("init", function() {
              if (++initCount === targets.length) {
                provideResults(editors2);
              }
            });
            editor.targetElm = editor.targetElm || targetElm;
            editor.render();
          };
          DOM$a.unbind(window, "ready", initEditors);
          execCallback("onpageload");
          targets = DomQuery.unique(findTargets(settings));
          if (settings.types) {
            each$j(settings.types, function(type2) {
              Tools.each(targets, function(elm) {
                if (DOM$a.is(elm, type2.selector)) {
                  createEditor(createId(elm), extend$4({}, settings, type2), elm);
                  return false;
                }
                return true;
              });
            });
            return;
          }
          Tools.each(targets, function(elm) {
            purgeDestroyedEditor(self2.get(elm.id));
          });
          targets = Tools.grep(targets, function(elm) {
            return !self2.get(elm.id);
          });
          if (targets.length === 0) {
            provideResults([]);
          } else {
            each$j(targets, function(elm) {
              if (isInvalidInlineTarget(settings, elm)) {
                initError("Could not initialize inline editor on invalid inline target element", elm);
              } else {
                createEditor(createId(elm), settings, elm);
              }
            });
          }
        };
        self2.settings = settings;
        DOM$a.bind(window, "ready", initEditors);
        return new promiseObj(function(resolve2) {
          if (result) {
            resolve2(result);
          } else {
            provideResults = function(editors2) {
              resolve2(editors2);
            };
          }
        });
      },
      get: function(id) {
        if (arguments.length === 0) {
          return editors.slice(0);
        } else if (isString(id)) {
          return find(editors, function(editor) {
            return editor.id === id;
          }).getOr(null);
        } else if (isNumber(id)) {
          return editors[id] ? editors[id] : null;
        } else {
          return null;
        }
      },
      add: function(editor) {
        var self2 = this;
        var existingEditor = legacyEditors[editor.id];
        if (existingEditor === editor) {
          return editor;
        }
        if (self2.get(editor.id) === null) {
          if (isValidLegacyKey(editor.id)) {
            legacyEditors[editor.id] = editor;
          }
          legacyEditors.push(editor);
          editors.push(editor);
        }
        toggleGlobalEvents(true);
        self2.activeEditor = editor;
        self2.fire("AddEditor", { editor });
        if (!beforeUnloadDelegate) {
          beforeUnloadDelegate = function(e) {
            var event = self2.fire("BeforeUnload");
            if (event.returnValue) {
              e.preventDefault();
              e.returnValue = event.returnValue;
              return event.returnValue;
            }
          };
          window.addEventListener("beforeunload", beforeUnloadDelegate);
        }
        return editor;
      },
      createEditor: function(id, settings) {
        return this.add(new Editor(id, settings, this));
      },
      remove: function(selector) {
        var self2 = this;
        var i, editor;
        if (!selector) {
          for (i = editors.length - 1; i >= 0; i--) {
            self2.remove(editors[i]);
          }
          return;
        }
        if (isString(selector)) {
          each$j(DOM$a.select(selector), function(elm) {
            editor = self2.get(elm.id);
            if (editor) {
              self2.remove(editor);
            }
          });
          return;
        }
        editor = selector;
        if (isNull(self2.get(editor.id))) {
          return null;
        }
        if (removeEditorFromList(editor)) {
          self2.fire("RemoveEditor", { editor });
        }
        if (editors.length === 0) {
          window.removeEventListener("beforeunload", beforeUnloadDelegate);
        }
        editor.remove();
        toggleGlobalEvents(editors.length > 0);
        return editor;
      },
      execCommand: function(cmd, ui, value2) {
        var self2 = this, editor = self2.get(value2);
        switch (cmd) {
          case "mceAddEditor":
            if (!self2.get(value2)) {
              new Editor(value2, self2.settings, self2).render();
            }
            return true;
          case "mceRemoveEditor":
            if (editor) {
              editor.remove();
            }
            return true;
          case "mceToggleEditor":
            if (!editor) {
              self2.execCommand("mceAddEditor", false, value2);
              return true;
            }
            if (editor.isHidden()) {
              editor.show();
            } else {
              editor.hide();
            }
            return true;
        }
        if (self2.activeEditor) {
          return self2.activeEditor.execCommand(cmd, ui, value2);
        }
        return false;
      },
      triggerSave: function() {
        each$j(editors, function(editor) {
          editor.save();
        });
      },
      addI18n: function(code, items) {
        I18n.add(code, items);
      },
      translate: function(text) {
        return I18n.translate(text);
      },
      setActive: function(editor) {
        var activeEditor = this.activeEditor;
        if (this.activeEditor !== editor) {
          if (activeEditor) {
            activeEditor.fire("deactivate", { relatedTarget: editor });
          }
          editor.fire("activate", { relatedTarget: activeEditor });
        }
        this.activeEditor = editor;
      },
      _setBaseUrl: function(baseUrl) {
        this.baseURL = new URI(this.documentBaseURL).toAbsolute(baseUrl.replace(/\/+$/, ""));
        this.baseURI = new URI(this.baseURL);
      }
    });
    EditorManager.setup();
    var min = Math.min, max = Math.max, round$1 = Math.round;
    var relativePosition = function(rect, targetRect, rel) {
      var x = targetRect.x;
      var y = targetRect.y;
      var w = rect.w;
      var h2 = rect.h;
      var targetW = targetRect.w;
      var targetH = targetRect.h;
      var relChars = (rel || "").split("");
      if (relChars[0] === "b") {
        y += targetH;
      }
      if (relChars[1] === "r") {
        x += targetW;
      }
      if (relChars[0] === "c") {
        y += round$1(targetH / 2);
      }
      if (relChars[1] === "c") {
        x += round$1(targetW / 2);
      }
      if (relChars[3] === "b") {
        y -= h2;
      }
      if (relChars[4] === "r") {
        x -= w;
      }
      if (relChars[3] === "c") {
        y -= round$1(h2 / 2);
      }
      if (relChars[4] === "c") {
        x -= round$1(w / 2);
      }
      return create$7(x, y, w, h2);
    };
    var findBestRelativePosition = function(rect, targetRect, constrainRect, rels) {
      var pos, i;
      for (i = 0; i < rels.length; i++) {
        pos = relativePosition(rect, targetRect, rels[i]);
        if (pos.x >= constrainRect.x && pos.x + pos.w <= constrainRect.w + constrainRect.x && pos.y >= constrainRect.y && pos.y + pos.h <= constrainRect.h + constrainRect.y) {
          return rels[i];
        }
      }
      return null;
    };
    var inflate = function(rect, w, h2) {
      return create$7(rect.x - w, rect.y - h2, rect.w + w * 2, rect.h + h2 * 2);
    };
    var intersect = function(rect, cropRect) {
      var x1 = max(rect.x, cropRect.x);
      var y1 = max(rect.y, cropRect.y);
      var x2 = min(rect.x + rect.w, cropRect.x + cropRect.w);
      var y2 = min(rect.y + rect.h, cropRect.y + cropRect.h);
      if (x2 - x1 < 0 || y2 - y1 < 0) {
        return null;
      }
      return create$7(x1, y1, x2 - x1, y2 - y1);
    };
    var clamp$1 = function(rect, clampRect, fixedSize) {
      var x1 = rect.x;
      var y1 = rect.y;
      var x2 = rect.x + rect.w;
      var y2 = rect.y + rect.h;
      var cx2 = clampRect.x + clampRect.w;
      var cy2 = clampRect.y + clampRect.h;
      var underflowX1 = max(0, clampRect.x - x1);
      var underflowY1 = max(0, clampRect.y - y1);
      var overflowX2 = max(0, x2 - cx2);
      var overflowY2 = max(0, y2 - cy2);
      x1 += underflowX1;
      y1 += underflowY1;
      if (fixedSize) {
        x2 += underflowX1;
        y2 += underflowY1;
        x1 -= overflowX2;
        y1 -= overflowY2;
      }
      x2 -= overflowX2;
      y2 -= overflowY2;
      return create$7(x1, y1, x2 - x1, y2 - y1);
    };
    var create$7 = function(x, y, w, h2) {
      return {
        x,
        y,
        w,
        h: h2
      };
    };
    var fromClientRect = function(clientRect) {
      return create$7(clientRect.left, clientRect.top, clientRect.width, clientRect.height);
    };
    var Rect = {
      inflate,
      relativePosition,
      findBestRelativePosition,
      intersect,
      clamp: clamp$1,
      create: create$7,
      fromClientRect
    };
    var awaiter = function(resolveCb, rejectCb, timeout) {
      if (timeout === void 0) {
        timeout = 1e3;
      }
      var done2 = false;
      var timer = null;
      var complete = function(completer) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          if (!done2) {
            done2 = true;
            if (timer !== null) {
              clearTimeout(timer);
              timer = null;
            }
            completer.apply(null, args);
          }
        };
      };
      var resolve2 = complete(resolveCb);
      var reject = complete(rejectCb);
      var start2 = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (!done2 && timer === null) {
          timer = setTimeout(function() {
            return reject.apply(null, args);
          }, timeout);
        }
      };
      return {
        start: start2,
        resolve: resolve2,
        reject
      };
    };
    var create$8 = function() {
      var tasks = {};
      var resultFns = {};
      var load = function(id, url) {
        var loadErrMsg = 'Script at URL "' + url + '" failed to load';
        var runErrMsg = 'Script at URL "' + url + "\" did not call `tinymce.Resource.add('" + id + "', data)` within 1 second";
        if (tasks[id] !== void 0) {
          return tasks[id];
        } else {
          var task = new promiseObj(function(resolve2, reject) {
            var waiter = awaiter(resolve2, reject);
            resultFns[id] = waiter.resolve;
            ScriptLoader2.ScriptLoader.loadScript(url, function() {
              return waiter.start(runErrMsg);
            }, function() {
              return waiter.reject(loadErrMsg);
            });
          });
          tasks[id] = task;
          return task;
        }
      };
      var add2 = function(id, data2) {
        if (resultFns[id] !== void 0) {
          resultFns[id](data2);
          delete resultFns[id];
        }
        tasks[id] = promiseObj.resolve(data2);
      };
      return {
        load,
        add: add2
      };
    };
    var Resource = create$8();
    var each$k = Tools.each, extend$5 = Tools.extend;
    var extendClass, initializing;
    var Class = function() {
    };
    Class.extend = extendClass = function(props) {
      var self2 = this;
      var _super = self2.prototype;
      var Class2 = function() {
        var i, mixins, mixin;
        var self3 = this;
        if (!initializing) {
          if (self3.init) {
            self3.init.apply(self3, arguments);
          }
          mixins = self3.Mixins;
          if (mixins) {
            i = mixins.length;
            while (i--) {
              mixin = mixins[i];
              if (mixin.init) {
                mixin.init.apply(self3, arguments);
              }
            }
          }
        }
      };
      var dummy = function() {
        return this;
      };
      var createMethod = function(name2, fn) {
        return function() {
          var self3 = this;
          var tmp = self3._super;
          self3._super = _super[name2];
          var ret = fn.apply(self3, arguments);
          self3._super = tmp;
          return ret;
        };
      };
      initializing = true;
      var prototype = new self2();
      initializing = false;
      if (props.Mixins) {
        each$k(props.Mixins, function(mixin) {
          for (var name_1 in mixin) {
            if (name_1 !== "init") {
              props[name_1] = mixin[name_1];
            }
          }
        });
        if (_super.Mixins) {
          props.Mixins = _super.Mixins.concat(props.Mixins);
        }
      }
      if (props.Methods) {
        each$k(props.Methods.split(","), function(name2) {
          props[name2] = dummy;
        });
      }
      if (props.Properties) {
        each$k(props.Properties.split(","), function(name2) {
          var fieldName = "_" + name2;
          props[name2] = function(value2) {
            var self3 = this;
            if (value2 !== void 0) {
              self3[fieldName] = value2;
              return self3;
            }
            return self3[fieldName];
          };
        });
      }
      if (props.Statics) {
        each$k(props.Statics, function(func, name2) {
          Class2[name2] = func;
        });
      }
      if (props.Defaults && _super.Defaults) {
        props.Defaults = extend$5({}, _super.Defaults, props.Defaults);
      }
      each$1(props, function(member, name2) {
        if (typeof member === "function" && _super[name2]) {
          prototype[name2] = createMethod(name2, member);
        } else {
          prototype[name2] = member;
        }
      });
      Class2.prototype = prototype;
      Class2.constructor = Class2;
      Class2.extend = extendClass;
      return Class2;
    };
    var min$1 = Math.min, max$1 = Math.max, round$2 = Math.round;
    var Color = function(value2) {
      var self2 = {};
      var r2 = 0, g = 0, b = 0;
      var rgb2hsv = function(r3, g2, b2) {
        var h2, s, v;
        h2 = 0;
        s = 0;
        v = 0;
        r3 = r3 / 255;
        g2 = g2 / 255;
        b2 = b2 / 255;
        var minRGB = min$1(r3, min$1(g2, b2));
        var maxRGB = max$1(r3, max$1(g2, b2));
        if (minRGB === maxRGB) {
          v = minRGB;
          return {
            h: 0,
            s: 0,
            v: v * 100
          };
        }
        var d = r3 === minRGB ? g2 - b2 : b2 === minRGB ? r3 - g2 : b2 - r3;
        h2 = r3 === minRGB ? 3 : b2 === minRGB ? 1 : 5;
        h2 = 60 * (h2 - d / (maxRGB - minRGB));
        s = (maxRGB - minRGB) / maxRGB;
        v = maxRGB;
        return {
          h: round$2(h2),
          s: round$2(s * 100),
          v: round$2(v * 100)
        };
      };
      var hsvToRgb = function(hue, saturation, brightness) {
        hue = (parseInt(hue, 10) || 0) % 360;
        saturation = parseInt(saturation, 10) / 100;
        brightness = parseInt(brightness, 10) / 100;
        saturation = max$1(0, min$1(saturation, 1));
        brightness = max$1(0, min$1(brightness, 1));
        if (saturation === 0) {
          r2 = g = b = round$2(255 * brightness);
          return;
        }
        var side = hue / 60;
        var chroma = brightness * saturation;
        var x = chroma * (1 - Math.abs(side % 2 - 1));
        var match2 = brightness - chroma;
        switch (Math.floor(side)) {
          case 0:
            r2 = chroma;
            g = x;
            b = 0;
            break;
          case 1:
            r2 = x;
            g = chroma;
            b = 0;
            break;
          case 2:
            r2 = 0;
            g = chroma;
            b = x;
            break;
          case 3:
            r2 = 0;
            g = x;
            b = chroma;
            break;
          case 4:
            r2 = x;
            g = 0;
            b = chroma;
            break;
          case 5:
            r2 = chroma;
            g = 0;
            b = x;
            break;
          default:
            r2 = g = b = 0;
        }
        r2 = round$2(255 * (r2 + match2));
        g = round$2(255 * (g + match2));
        b = round$2(255 * (b + match2));
      };
      var toHex2 = function() {
        var hex = function(val) {
          val = parseInt(val, 10).toString(16);
          return val.length > 1 ? val : "0" + val;
        };
        return "#" + hex(r2) + hex(g) + hex(b);
      };
      var toRgb = function() {
        return {
          r: r2,
          g,
          b
        };
      };
      var toHsv = function() {
        return rgb2hsv(r2, g, b);
      };
      var parse = function(value3) {
        var matches2;
        if (typeof value3 === "object") {
          if ("r" in value3) {
            r2 = value3.r;
            g = value3.g;
            b = value3.b;
          } else if ("v" in value3) {
            hsvToRgb(value3.h, value3.s, value3.v);
          }
        } else {
          if (matches2 = /rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)[^\)]*\)/gi.exec(value3)) {
            r2 = parseInt(matches2[1], 10);
            g = parseInt(matches2[2], 10);
            b = parseInt(matches2[3], 10);
          } else if (matches2 = /#([0-F]{2})([0-F]{2})([0-F]{2})/gi.exec(value3)) {
            r2 = parseInt(matches2[1], 16);
            g = parseInt(matches2[2], 16);
            b = parseInt(matches2[3], 16);
          } else if (matches2 = /#([0-F])([0-F])([0-F])/gi.exec(value3)) {
            r2 = parseInt(matches2[1] + matches2[1], 16);
            g = parseInt(matches2[2] + matches2[2], 16);
            b = parseInt(matches2[3] + matches2[3], 16);
          }
        }
        r2 = r2 < 0 ? 0 : r2 > 255 ? 255 : r2;
        g = g < 0 ? 0 : g > 255 ? 255 : g;
        b = b < 0 ? 0 : b > 255 ? 255 : b;
        return self2;
      };
      if (value2) {
        parse(value2);
      }
      self2.toRgb = toRgb;
      self2.toHsv = toHsv;
      self2.toHex = toHex2;
      self2.parse = parse;
      return self2;
    };
    var serialize = function(obj) {
      var data2 = JSON.stringify(obj);
      if (!isString(data2)) {
        return data2;
      }
      return data2.replace(/[\u0080-\uFFFF]/g, function(match2) {
        var hexCode = match2.charCodeAt(0).toString(16);
        return "\\u" + "0000".substring(hexCode.length) + hexCode;
      });
    };
    var JSONUtils = {
      serialize,
      parse: function(text) {
        try {
          return JSON.parse(text);
        } catch (ex) {
        }
      }
    };
    var JSONP = {
      callbacks: {},
      count: 0,
      send: function(settings) {
        var self2 = this, dom2 = DOMUtils.DOM, count2 = settings.count !== void 0 ? settings.count : self2.count;
        var id = "tinymce_jsonp_" + count2;
        self2.callbacks[count2] = function(json) {
          dom2.remove(id);
          delete self2.callbacks[count2];
          settings.callback(json);
        };
        dom2.add(dom2.doc.body, "script", {
          id,
          src: settings.url,
          type: "text/javascript"
        });
        self2.count++;
      }
    };
    var XHR = __assign2(__assign2({}, Observable), {
      send: function(settings) {
        var xhr, count2 = 0;
        var ready = function() {
          if (!settings.async || xhr.readyState === 4 || count2++ > 1e4) {
            if (settings.success && count2 < 1e4 && xhr.status === 200) {
              settings.success.call(settings.success_scope, "" + xhr.responseText, xhr, settings);
            } else if (settings.error) {
              settings.error.call(settings.error_scope, count2 > 1e4 ? "TIMED_OUT" : "GENERAL", xhr, settings);
            }
            xhr = null;
          } else {
            Delay.setTimeout(ready, 10);
          }
        };
        settings.scope = settings.scope || this;
        settings.success_scope = settings.success_scope || settings.scope;
        settings.error_scope = settings.error_scope || settings.scope;
        settings.async = settings.async !== false;
        settings.data = settings.data || "";
        XHR.fire("beforeInitialize", { settings });
        xhr = new XMLHttpRequest();
        if (xhr.overrideMimeType) {
          xhr.overrideMimeType(settings.content_type);
        }
        xhr.open(settings.type || (settings.data ? "POST" : "GET"), settings.url, settings.async);
        if (settings.crossDomain) {
          xhr.withCredentials = true;
        }
        if (settings.content_type) {
          xhr.setRequestHeader("Content-Type", settings.content_type);
        }
        if (settings.requestheaders) {
          Tools.each(settings.requestheaders, function(header) {
            xhr.setRequestHeader(header.key, header.value);
          });
        }
        xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
        xhr = XHR.fire("beforeSend", {
          xhr,
          settings
        }).xhr;
        xhr.send(settings.data);
        if (!settings.async) {
          return ready();
        }
        Delay.setTimeout(ready, 10);
      }
    });
    var extend$6 = Tools.extend;
    var JSONRequest = function() {
      function JSONRequest2(settings) {
        this.settings = extend$6({}, settings);
        this.count = 0;
      }
      JSONRequest2.sendRPC = function(o) {
        return new JSONRequest2().send(o);
      };
      JSONRequest2.prototype.send = function(args) {
        var ecb = args.error, scb = args.success;
        var xhrArgs = extend$6(this.settings, args);
        xhrArgs.success = function(c, x) {
          c = JSONUtils.parse(c);
          if (typeof c === "undefined") {
            c = { error: "JSON Parse error." };
          }
          if (c.error) {
            ecb.call(xhrArgs.error_scope || xhrArgs.scope, c.error, x);
          } else {
            scb.call(xhrArgs.success_scope || xhrArgs.scope, c.result);
          }
        };
        xhrArgs.error = function(ty, x) {
          if (ecb) {
            ecb.call(xhrArgs.error_scope || xhrArgs.scope, ty, x);
          }
        };
        xhrArgs.data = JSONUtils.serialize({
          id: args.id || "c" + this.count++,
          method: args.method,
          params: args.params
        });
        xhrArgs.content_type = "application/json";
        XHR.send(xhrArgs);
      };
      return JSONRequest2;
    }();
    var create$9 = function() {
      return function() {
        var data2 = {};
        var keys2 = [];
        var storage = {
          getItem: function(key) {
            var item = data2[key];
            return item ? item : null;
          },
          setItem: function(key, value2) {
            keys2.push(key);
            data2[key] = String(value2);
          },
          key: function(index) {
            return keys2[index];
          },
          removeItem: function(key) {
            keys2 = keys2.filter(function(k) {
              return k === key;
            });
            delete data2[key];
          },
          clear: function() {
            keys2 = [];
            data2 = {};
          },
          length: 0
        };
        Object.defineProperty(storage, "length", {
          get: function() {
            return keys2.length;
          },
          configurable: false,
          enumerable: false
        });
        return storage;
      }();
    };
    var localStorage;
    try {
      var test = "__storage_test__";
      localStorage = window.localStorage;
      localStorage.setItem(test, test);
      localStorage.removeItem(test);
    } catch (e) {
      localStorage = create$9();
    }
    var LocalStorage = localStorage;
    var publicApi = {
      geom: { Rect },
      util: {
        Promise: promiseObj,
        Delay,
        Tools,
        VK,
        URI,
        Class,
        EventDispatcher,
        Observable,
        I18n,
        XHR,
        JSON: JSONUtils,
        JSONRequest,
        JSONP,
        LocalStorage,
        Color,
        ImageUploader
      },
      dom: {
        EventUtils,
        Sizzle,
        DomQuery,
        TreeWalker: DomTreeWalker,
        TextSeeker,
        DOMUtils,
        ScriptLoader: ScriptLoader2,
        RangeUtils,
        Serializer: DomSerializer,
        StyleSheetLoader,
        ControlSelection,
        BookmarkManager,
        Selection: EditorSelection,
        Event: EventUtils.Event
      },
      html: {
        Styles,
        Entities,
        Node: AstNode,
        Schema,
        SaxParser,
        DomParser,
        Writer,
        Serializer: HtmlSerializer
      },
      Env,
      AddOnManager,
      Annotator,
      Formatter,
      UndoManager,
      EditorCommands,
      WindowManager,
      NotificationManager,
      EditorObservable,
      Shortcuts,
      Editor,
      FocusManager,
      EditorManager,
      DOM: DOMUtils.DOM,
      ScriptLoader: ScriptLoader2.ScriptLoader,
      PluginManager,
      ThemeManager,
      IconManager,
      Resource,
      trim: Tools.trim,
      isArray: Tools.isArray,
      is: Tools.is,
      toArray: Tools.toArray,
      makeMap: Tools.makeMap,
      each: Tools.each,
      map: Tools.map,
      grep: Tools.grep,
      inArray: Tools.inArray,
      extend: Tools.extend,
      create: Tools.create,
      walk: Tools.walk,
      createNS: Tools.createNS,
      resolve: Tools.resolve,
      explode: Tools.explode,
      _addCacheSuffix: Tools._addCacheSuffix,
      isOpera: Env.opera,
      isWebKit: Env.webkit,
      isIE: Env.ie,
      isGecko: Env.gecko,
      isMac: Env.mac
    };
    var tinymce2 = Tools.extend(EditorManager, publicApi);
    var exportToModuleLoaders = function(tinymce3) {
      {
        try {
          module.exports = tinymce3;
        } catch (_) {
        }
      }
    };
    var exportToWindowGlobal = function(tinymce3) {
      window.tinymce = tinymce3;
      window.tinyMCE = tinymce3;
    };
    exportToWindowGlobal(tinymce2);
    exportToModuleLoaders(tinymce2);
  })();
})(tinymce$2);
var tinymce$1 = tinymce$2.exports;
var validEvents = [
  "onActivate",
  "onAddUndo",
  "onBeforeAddUndo",
  "onBeforeExecCommand",
  "onBeforeGetContent",
  "onBeforeRenderUI",
  "onBeforeSetContent",
  "onBeforePaste",
  "onBlur",
  "onChange",
  "onClearUndos",
  "onClick",
  "onContextMenu",
  "onCopy",
  "onCut",
  "onDblclick",
  "onDeactivate",
  "onDirty",
  "onDrag",
  "onDragDrop",
  "onDragEnd",
  "onDragGesture",
  "onDragOver",
  "onDrop",
  "onExecCommand",
  "onFocus",
  "onFocusIn",
  "onFocusOut",
  "onGetContent",
  "onHide",
  "onInit",
  "onKeyDown",
  "onKeyPress",
  "onKeyUp",
  "onLoadContent",
  "onMouseDown",
  "onMouseEnter",
  "onMouseLeave",
  "onMouseMove",
  "onMouseOut",
  "onMouseOver",
  "onMouseUp",
  "onNodeChange",
  "onObjectResizeStart",
  "onObjectResized",
  "onObjectSelected",
  "onPaste",
  "onPostProcess",
  "onPostRender",
  "onPreProcess",
  "onProgressState",
  "onRedo",
  "onRemove",
  "onReset",
  "onSaveContent",
  "onSelectionChange",
  "onSetAttrib",
  "onSetContent",
  "onShow",
  "onSubmit",
  "onUndo",
  "onVisualAid"
];
var isValidKey = function(key) {
  return validEvents.map(function(event) {
    return event.toLowerCase();
  }).indexOf(key.toLowerCase()) !== -1;
};
var bindHandlers = function(initEvent, listeners, editor) {
  Object.keys(listeners).filter(isValidKey).forEach(function(key) {
    var handler = listeners[key];
    if (typeof handler === "function") {
      if (key === "onInit") {
        handler(initEvent, editor);
      } else {
        editor.on(key.substring(2), function(e) {
          return handler(e, editor);
        });
      }
    }
  });
};
var bindModelHandlers = function(props, ctx, editor, modelValue) {
  var modelEvents = props.modelEvents ? props.modelEvents : null;
  var normalizedEvents = Array.isArray(modelEvents) ? modelEvents.join(" ") : modelEvents;
  editor.on(normalizedEvents ? normalizedEvents : "input  focus focusin click focusout drop ObjectResized keydown paste ExecCommand ObjectSelected", function() {
    ctx.emit("update:modelValue", typeof editor.getTpContent === "function" ? editor.getTpContent({ format: props.outputFormat }) : editor.getContent({ format: props.outputFormat }));
  });
  tinymce$1.tinymcePlugin && setIntervalFn((clear) => {
    if (typeof editor.getTpContent === "function") {
      clear();
      ctx.emit("update:modelValue", editor.getTpContent({ format: props.outputFormat }));
      ctx.emit("update:modelValue", editor.getTpContent({ format: props.outputFormat }));
    }
  }, 50);
};
var initEditor = function(initEvent, props, ctx, editor, modelValue, content) {
  typeof editor.setTpContent === "function" ? editor.setTpContent(content()) : editor.setContent(content());
  if (ctx.attrs["onUpdate:modelValue"]) {
    bindModelHandlers(props, ctx, editor);
  }
  bindHandlers(initEvent, ctx.attrs, editor);
};
var unique = 0;
var uuid = function(prefix) {
  var time = Date.now();
  var random = Math.floor(Math.random() * 1e9);
  unique++;
  return prefix + "_" + random + unique + String(time);
};
var isTextarea = function(element) {
  return element !== null && element.tagName.toLowerCase() === "textarea";
};
var normalizePluginArray = function(plugins) {
  if (typeof plugins === "undefined" || plugins === "") {
    return [];
  }
  return Array.isArray(plugins) ? plugins : plugins.split(" ");
};
var mergePlugins = function(initPlugins, inputPlugins) {
  return normalizePluginArray(initPlugins).concat(normalizePluginArray(inputPlugins));
};
var isNullOrUndefined = function(value) {
  return value === null || value === void 0;
};
const setIntervalFn = (func, delay, outTime) => {
  !outTime && (outTime = delay * 1e3);
  let setIntervalObj = {
    id: null,
    outTime,
    outId: null
  };
  setIntervalObj.id = setInterval((obj) => {
    func(() => {
      clearTimeout(obj.outId);
      clearInterval(obj.id);
    });
  }, delay, setIntervalObj);
  setIntervalObj.outId = setTimeout(() => {
    setIntervalObj.id && clearInterval(setIntervalObj.id);
  }, setIntervalObj.outTime);
};
const editorProps = {
  apiKey: String,
  cloudChannel: String,
  id: String,
  init: Object,
  initialValue: String,
  inline: Boolean,
  modelEvents: [String, Array],
  plugins: [String, Array],
  tagName: String,
  toolbar: [String, Array],
  modelValue: String,
  disabled: Boolean,
  tinymceScriptSrc: String,
  outputFormat: {
    type: String,
    validator: function(prop) {
      return prop === "html" || prop === "text";
    }
  }
};
var createState = function() {
  return {
    listeners: [],
    scriptId: uuid("tiny-script"),
    scriptLoaded: false
  };
};
var CreateScriptLoader = function() {
  var state = createState();
  var injectScriptTag = function(scriptId, doc, url, callback) {
    var scriptTag = doc.createElement("script");
    scriptTag.referrerPolicy = "origin";
    scriptTag.type = "application/javascript";
    scriptTag.id = scriptId;
    scriptTag.src = url;
    var handler = function() {
      scriptTag.removeEventListener("load", handler);
      callback();
    };
    scriptTag.addEventListener("load", handler);
    if (doc.head) {
      doc.head.appendChild(scriptTag);
    }
  };
  var load = function(doc, url, callback) {
    if (state.scriptLoaded) {
      callback();
    } else {
      state.listeners.push(callback);
      if (!doc.getElementById(state.scriptId)) {
        injectScriptTag(state.scriptId, doc, url, function() {
          state.listeners.forEach(function(fn) {
            return fn();
          });
          state.scriptLoaded = true;
        });
      }
    }
  };
  return {
    load
  };
};
var ScriptLoader = CreateScriptLoader();
const defaultOptions = {
  min_height: 300,
  plugins: ["code hr"],
  toolbar: ["code hr"],
  schema: "html5",
  table_default_attributes: {
    "border": "1"
  },
  table_default_styles: {
    "border-collapse": "collapse",
    "width": "100%"
  },
  table_header_type: "sectionCells",
  table_responsive_width: true,
  file_picker_types: "file img media",
  fontsize_formats: "12px 14px 16px 18px 24px 36px 48px 56px 72px"
};
var __assign = globalThis && globalThis.__assign || function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var renderInline = function(ce, id, elementRef, tagName) {
  return ce("div", {}, ce(tagName ? tagName : "div", {
    id,
    ref: elementRef
  }));
};
var renderIframe = function(ce, id, elementRef) {
  return ce("div", {}, ce("textarea", {
    id,
    visibility: "hidden",
    ref: elementRef
  }));
};
const getGlobal = function() {
  return typeof window !== "undefined" ? window : global;
};
const getTinymce = function() {
  var global2 = getGlobal();
  return global2 && global2.tinymce ? global2.tinymce : null;
};
var tinymceVue = defineComponent({
  name: "TinymceEditor",
  props: editorProps,
  setup: function(props, ctx) {
    var conf = props.init ? __assign(defaultOptions, props.init) : {};
    var _a = toRefs(props), disabled = _a.disabled, modelValue = _a.modelValue, tagName = _a.tagName;
    var element = ref(null);
    var vueEditor = null;
    var elementId = props.id || uuid("tiny-vue");
    var inlineEditor = props.init && props.init.inline || props.inline;
    var modelBind = !!ctx.attrs["onUpdate:modelValue"];
    var mounting = true;
    var initialValue = props.initialValue ? props.initialValue : "";
    var cache = "";
    var getContent = function(isMounting) {
      return modelBind ? function() {
        return (modelValue === null || modelValue === void 0 ? void 0 : modelValue.value) ? modelValue.value : "";
      } : function() {
        return isMounting ? initialValue : cache;
      };
    };
    var initWrapper = function() {
      var content = getContent(mounting);
      var finalInit = __assign(__assign({}, conf), {
        readonly: props.disabled,
        selector: "#" + elementId,
        plugins: mergePlugins(conf.plugins, props.plugins),
        toolbar: props.toolbar || conf.toolbar,
        inline: inlineEditor,
        setup: function(editor) {
          vueEditor = editor;
          editor.on("init", function(e) {
            return initEditor(e, props, ctx, editor, modelValue, content);
          });
          editor.on("setContent", function(e) {
          });
          if (typeof conf.setup === "function") {
            conf.setup(editor);
          }
        }
      });
      if (isTextarea(element.value)) {
        element.value.style.visibility = "";
      }
      getTinymce().init(finalInit);
      mounting = false;
    };
    watch(disabled, function(disable) {
      var _a2;
      if (vueEditor !== null) {
        if (typeof ((_a2 = vueEditor.mode) === null || _a2 === void 0 ? void 0 : _a2.set) === "function") {
          vueEditor.mode.set(disable ? "readonly" : "design");
        } else {
          vueEditor.setMode(disable ? "readonly" : "design");
        }
      }
    });
    watch(tagName, function(_) {
      var _a2;
      if (!modelBind) {
        cache = typeof vueEditor.getTpContent === "function" ? vueEditor.getTpContent() : vueEditor.getContent();
      }
      (_a2 = getTinymce()) === null || _a2 === void 0 ? void 0 : _a2.remove(vueEditor);
      nextTick(function() {
        return initWrapper();
      });
    });
    onMounted(function() {
      if (getTinymce() !== null) {
        initWrapper();
      } else if (element.value && element.value.ownerDocument) {
        var channel = props.cloudChannel ? props.cloudChannel : "5";
        var apiKey = props.apiKey ? props.apiKey : "no-api-key";
        var scriptSrc = isNullOrUndefined(props.tinymceScriptSrc) ? "https://cdn.tiny.cloud/1/" + apiKey + "/tinymce/" + channel + "/tinymce.min.js" : props.tinymceScriptSrc;
        ScriptLoader.load(element.value.ownerDocument, scriptSrc, initWrapper);
      }
    });
    onBeforeUnmount(function() {
      if (getTinymce() !== null) {
        getTinymce().remove(vueEditor);
      }
    });
    if (!inlineEditor) {
      onActivated(function() {
        if (!mounting) {
          initWrapper();
        }
      });
      onDeactivated(function() {
        var _a2;
        if (!modelBind) {
          cache = typeof vueEditor.getTpContent === "function" ? vueEditor.getTpContent() : vueEditor.getContent();
        }
        (_a2 = getTinymce()) === null || _a2 === void 0 ? void 0 : _a2.remove(vueEditor);
      });
    }
    var rerender = function(init) {
      var _a2;
      cache = typeof vueEditor.getTpContent === "function" ? vueEditor.getTpContent() : vueEditor.getContent();
      (_a2 = getTinymce()) === null || _a2 === void 0 ? void 0 : _a2.remove(vueEditor);
      conf = __assign(__assign({}, conf), init);
      nextTick(function() {
        return initWrapper();
      });
    };
    ctx.expose({
      rerender
    });
    return function() {
      return inlineEditor ? renderInline(h, elementId, element, props.tagName) : renderIframe(h, elementId, element);
    };
  }
});
const TinymceEditor = Object.assign(tinymceVue, {
  install(app) {
    app.component(tinymceVue.name, tinymceVue);
  }
});
tinymce.addI18n("zh_CN", {
  "Redo": "\u6062\u590D",
  "Undo": "\u64A4\u9500",
  "Cut": "\u526A\u5207",
  "Copy": "\u590D\u5236",
  "Paste": "\u7C98\u8D34",
  "Select all": "\u5168\u9009",
  "New document": "\u65B0\u5EFA\u6587\u6863",
  "Ok": "\u786E\u5B9A",
  "Cancel": "\u53D6\u6D88",
  "Visual aids": "\u7F51\u683C\u7EBF",
  "Bold": "\u7C97\u4F53",
  "Italic": "\u659C\u4F53",
  "Underline": "\u4E0B\u5212\u7EBF",
  "Strikethrough": "\u5220\u9664\u7EBF",
  "Superscript": "\u4E0A\u6807",
  "Subscript": "\u4E0B\u6807",
  "Clear formatting": "\u6E05\u9664\u683C\u5F0F",
  "Align left": "\u5DE6\u5BF9\u9F50",
  "Align center": "\u5C45\u4E2D",
  "Align right": "\u53F3\u5BF9\u9F50",
  "Justify": "\u4E24\u7AEF\u5BF9\u9F50",
  "Bullet list": "\u7B26\u53F7\u5217\u8868",
  "Numbered list": "\u6570\u5B57\u5217\u8868",
  "Decrease indent": "\u51CF\u5C11\u7F29\u8FDB",
  "Increase indent": "\u589E\u52A0\u7F29\u8FDB",
  "Close": "\u5173\u95ED",
  "Formats": "\u683C\u5F0F",
  "Your browser doesn't support direct access to the clipboard. Please use the Ctrl+X/C/V keyboard shortcuts instead.": "\u5F53\u524D\u6D4F\u89C8\u5668\u4E0D\u652F\u6301\u8BBF\u95EE\u526A\u8D34\u677F\uFF0C\u8BF7\u4F7F\u7528\u5FEB\u6377\u952ECtrl+X/C/V\u590D\u5236\u7C98\u8D34",
  "Headers": "\u6807\u9898",
  "Header 1": "\u6807\u98981",
  "Header 2": "\u6807\u98982",
  "Header 3": "\u6807\u98983",
  "Header 4": "\u6807\u98984",
  "Header 5": "\u6807\u98985",
  "Header 6": "\u6807\u98986",
  "Headings": "\u6807\u9898",
  "Heading 1": "\u6807\u98981",
  "Heading 2": "\u6807\u98982",
  "Heading 3": "\u6807\u98983",
  "Heading 4": "\u6807\u98984",
  "Heading 5": "\u6807\u98985",
  "Heading 6": "\u6807\u98986",
  "Preformatted": "\u9884\u683C\u5F0F\u5316",
  "Div": "Div\u533A\u5757",
  "Pre": "\u9884\u683C\u5F0F\u6587\u672C",
  "Code": "\u4EE3\u7801",
  "Paragraph": "\u6BB5\u843D",
  "Blockquote": "\u5F15\u7528",
  "Inline": "\u6587\u672C",
  "Blocks": "\u533A\u5757",
  "Paste is now in plain text mode. Contents will now be pasted as plain text until you toggle this option off.": "\u5F53\u524D\u4E3A\u7EAF\u6587\u672C\u7C98\u8D34\u6A21\u5F0F\uFF0C\u518D\u6B21\u70B9\u51FB\u53EF\u4EE5\u56DE\u5230\u666E\u901A\u7C98\u8D34\u6A21\u5F0F\u3002",
  "Fonts": "\u5B57\u4F53",
  "Font Sizes": "\u5B57\u53F7",
  "Class": "Class",
  "Browse for an image": "\u6D4F\u89C8\u56FE\u50CF",
  "OR": "\u6216",
  "Drop an image here": "\u62D6\u653E\u4E00\u5F20\u56FE\u7247\u6587\u4EF6\u81F3\u6B64",
  "Upload": "\u4E0A\u4F20",
  "Block": "\u5757",
  "Align": "\u5BF9\u9F50",
  "Default": "\u9ED8\u8BA4",
  "Circle": "\u7A7A\u5FC3\u5706",
  "Disc": "\u5B9E\u5FC3\u5706",
  "Square": "\u65B9\u5757",
  "Lower Alpha": "\u5C0F\u5199\u82F1\u6587\u5B57\u6BCD",
  "Lower Greek": "\u5C0F\u5199\u5E0C\u814A\u5B57\u6BCD",
  "Lower Roman": "\u5C0F\u5199\u7F57\u9A6C\u5B57\u6BCD",
  "Upper Alpha": "\u5927\u5199\u82F1\u6587\u5B57\u6BCD",
  "Upper Roman": "\u5927\u5199\u7F57\u9A6C\u5B57\u6BCD",
  "Anchor...": "\u951A\u70B9...",
  "Name": "\u540D\u79F0",
  "Id": "id",
  "Id should start with a letter, followed only by letters, numbers, dashes, dots, colons or underscores.": "id\u5E94\u8BE5\u4EE5\u5B57\u6BCD\u5F00\u5934\uFF0C\u540E\u8DDF\u5B57\u6BCD\u3001\u6570\u5B57\u3001\u6A2A\u7EBF\u3001\u70B9\u3001\u5192\u53F7\u6216\u4E0B\u5212\u7EBF\u3002",
  "You have unsaved changes are you sure you want to navigate away?": "\u4F60\u5BF9\u6587\u6863\u7684\u4FEE\u6539\u5C1A\u672A\u4FDD\u5B58\uFF0C\u786E\u5B9A\u79BB\u5F00\u5417\uFF1F",
  "Restore last draft": "\u6062\u590D\u4E0A\u6B21\u7684\u8349\u7A3F",
  "Special characters...": "\u7279\u6B8A\u5B57\u7B26...",
  "Source code": "HTML\u6E90\u7801",
  "Insert/Edit code sample": "\u63D2\u5165/\u7F16\u8F91\u4EE3\u7801\u793A\u4F8B",
  "Language": "\u8BED\u8A00",
  "Code sample...": "\u4EE3\u7801\u793A\u4F8B...",
  "Color Picker": "\u9009\u53D6\u989C\u8272",
  "R": "R",
  "G": "G",
  "B": "B",
  "Left to right": "\u4ECE\u5DE6\u5230\u53F3",
  "Right to left": "\u4ECE\u53F3\u5230\u5DE6",
  "Emoticons...": "\u8868\u60C5\u7B26\u53F7...",
  "Metadata and Document Properties": "\u5143\u6570\u636E\u548C\u6587\u6863\u5C5E\u6027",
  "Title": "\u6807\u9898",
  "Keywords": "\u5173\u952E\u8BCD",
  "Description": "\u63CF\u8FF0",
  "Robots": "\u673A\u5668\u4EBA",
  "Author": "\u4F5C\u8005",
  "Encoding": "\u7F16\u7801",
  "Fullscreen": "\u5168\u5C4F",
  "Action": "\u64CD\u4F5C",
  "Shortcut": "\u5FEB\u6377\u952E",
  "Help": "\u5E2E\u52A9",
  "Address": "\u5730\u5740",
  "Focus to menubar": "\u79FB\u52A8\u7126\u70B9\u5230\u83DC\u5355\u680F",
  "Focus to toolbar": "\u79FB\u52A8\u7126\u70B9\u5230\u5DE5\u5177\u680F",
  "Focus to element path": "\u79FB\u52A8\u7126\u70B9\u5230\u5143\u7D20\u8DEF\u5F84",
  "Focus to contextual toolbar": "\u79FB\u52A8\u7126\u70B9\u5230\u4E0A\u4E0B\u6587\u83DC\u5355",
  "Insert link (if link plugin activated)": "\u63D2\u5165\u94FE\u63A5 (\u5982\u679C\u94FE\u63A5\u63D2\u4EF6\u5DF2\u6FC0\u6D3B)",
  "Save (if save plugin activated)": "\u4FDD\u5B58(\u5982\u679C\u4FDD\u5B58\u63D2\u4EF6\u5DF2\u6FC0\u6D3B)",
  "Find (if searchreplace plugin activated)": "\u67E5\u627E(\u5982\u679C\u67E5\u627E\u66FF\u6362\u63D2\u4EF6\u5DF2\u6FC0\u6D3B)",
  "Plugins installed ({0}):": "\u5DF2\u5B89\u88C5\u63D2\u4EF6 ({0})\uFF1A",
  "Premium plugins:": "\u4F18\u79C0\u63D2\u4EF6\uFF1A",
  "Learn more...": "\u4E86\u89E3\u66F4\u591A...",
  "You are using {0}": "\u4F60\u6B63\u5728\u4F7F\u7528 {0}",
  "Plugins": "\u63D2\u4EF6",
  "Handy Shortcuts": "\u5FEB\u6377\u952E",
  "Horizontal line": "\u6C34\u5E73\u5206\u5272\u7EBF",
  "Insert/edit image": "\u63D2\u5165/\u7F16\u8F91\u56FE\u7247",
  "Image description": "\u56FE\u7247\u63CF\u8FF0",
  "Source": "\u5730\u5740",
  "Dimensions": "\u5927\u5C0F",
  "Constrain proportions": "\u4FDD\u6301\u5BBD\u9AD8\u6BD4",
  "General": "\u5E38\u89C4",
  "Advanced": "\u9AD8\u7EA7",
  "Style": "\u6837\u5F0F",
  "Vertical space": "\u5782\u76F4\u8FB9\u8DDD",
  "Horizontal space": "\u6C34\u5E73\u8FB9\u8DDD",
  "Border": "\u8FB9\u6846",
  "Insert image": "\u63D2\u5165\u56FE\u7247",
  "Image...": "\u56FE\u7247...",
  "Image list": "\u56FE\u7247\u5217\u8868",
  "Rotate counterclockwise": "\u9006\u65F6\u9488\u65CB\u8F6C",
  "Rotate clockwise": "\u987A\u65F6\u9488\u65CB\u8F6C",
  "Flip vertically": "\u5782\u76F4\u7FFB\u8F6C",
  "Flip horizontally": "\u6C34\u5E73\u7FFB\u8F6C",
  "Edit image": "\u7F16\u8F91\u56FE\u7247",
  "Image options": "\u56FE\u7247\u9009\u9879",
  "Zoom in": "\u653E\u5927",
  "Zoom out": "\u7F29\u5C0F",
  "Crop": "\u88C1\u526A",
  "Resize": "\u8C03\u6574\u5927\u5C0F",
  "Orientation": "\u65B9\u5411",
  "Brightness": "\u4EAE\u5EA6",
  "Sharpen": "\u9510\u5316",
  "Contrast": "\u5BF9\u6BD4\u5EA6",
  "Color levels": "\u8272\u9636",
  "Gamma": "\u4F3D\u9A6C\u503C",
  "Invert": "\u53CD\u8F6C",
  "Apply": "\u5E94\u7528",
  "Back": "\u540E\u9000",
  "Insert date/time": "\u63D2\u5165\u65E5\u671F/\u65F6\u95F4",
  "Date/time": "\u65E5\u671F/\u65F6\u95F4",
  "Insert/Edit Link": "\u63D2\u5165/\u7F16\u8F91\u94FE\u63A5",
  "Insert/edit link": "\u63D2\u5165/\u7F16\u8F91\u94FE\u63A5",
  "Text to display": "\u663E\u793A\u6587\u5B57",
  "Url": "\u5730\u5740",
  "Open link in...": "\u94FE\u63A5\u6253\u5F00\u65B9\u5F0F...",
  "Current window": "\u5F53\u524D\u7A97\u53E3\u6253\u5F00",
  "None": "\u5728\u5F53\u524D\u7A97\u53E3/\u6846\u67B6\u6253\u5F00",
  "New window": "\u5728\u65B0\u7A97\u53E3\u6253\u5F00",
  "Remove link": "\u5220\u9664\u94FE\u63A5",
  "Anchors": "\u951A\u70B9",
  "Link...": "\u94FE\u63A5...",
  "Paste or type a link": "\u7C98\u8D34\u6216\u8F93\u5165\u94FE\u63A5",
  "The URL you entered seems to be an email address. Do you want to add the required mailto: prefix?": "\u4F60\u6240\u586B\u5199\u7684URL\u5730\u5740\u4E3A\u90AE\u4EF6\u5730\u5740\uFF0C\u9700\u8981\u52A0\u4E0Amailto:\u524D\u7F00\u5417\uFF1F",
  "The URL you entered seems to be an external link. Do you want to add the required http:// prefix?": "\u4F60\u6240\u586B\u5199\u7684URL\u5730\u5740\u5C5E\u4E8E\u5916\u90E8\u94FE\u63A5\uFF0C\u9700\u8981\u52A0\u4E0Ahttp://:\u524D\u7F00\u5417\uFF1F",
  "Link list": "\u94FE\u63A5\u5217\u8868",
  "Insert video": "\u63D2\u5165\u89C6\u9891",
  "Insert/edit video": "\u63D2\u5165/\u7F16\u8F91\u89C6\u9891",
  "Insert/edit media": "\u63D2\u5165/\u7F16\u8F91\u5A92\u4F53",
  "Alternative source": "\u66FF\u4EE3\u8D44\u6E90",
  "Alternative image URL": "\u8D44\u6E90\u5907\u7528\u5730\u5740",
  "Media poster (Image URL)": "\u5C01\u9762(\u56FE\u7247\u5730\u5740)",
  "Paste your embed code below:": "\u5C06\u5185\u5D4C\u4EE3\u7801\u7C98\u8D34\u5728\u4E0B\u9762:",
  "Embed": "\u5185\u5D4C",
  "Media...": "\u591A\u5A92\u4F53...",
  "Nonbreaking space": "\u4E0D\u95F4\u65AD\u7A7A\u683C",
  "Page break": "\u5206\u9875\u7B26",
  "Paste as text": "\u7C98\u8D34\u4E3A\u6587\u672C",
  "Preview": "\u9884\u89C8",
  "Print...": "\u6253\u5370...",
  "Save": "\u4FDD\u5B58",
  "Find": "\u67E5\u627E",
  "Replace with": "\u66FF\u6362\u4E3A",
  "Replace": "\u66FF\u6362",
  "Replace all": "\u66FF\u6362\u5168\u90E8",
  "Previous": "\u4E0A\u4E00\u4E2A",
  "Next": "\u4E0B\u4E00\u4E2A",
  "Find and replace...": "\u67E5\u627E\u5E76\u66FF\u6362...",
  "Could not find the specified string.": "\u672A\u627E\u5230\u641C\u7D22\u5185\u5BB9\u3002",
  "Match case": "\u533A\u5206\u5927\u5C0F\u5199",
  "Find whole words only": "\u5168\u5355\u8BCD\u5339\u914D",
  "Spell check": "\u62FC\u5199\u68C0\u67E5",
  "Ignore": "\u5FFD\u7565",
  "Ignore all": "\u5FFD\u7565\u5168\u90E8",
  "Finish": "\u5B8C\u6210",
  "Add to Dictionary": "\u6DFB\u52A0\u5230\u5B57\u5178",
  "Insert table": "\u63D2\u5165\u8868\u683C",
  "Table properties": "\u8868\u683C\u5C5E\u6027",
  "Delete table": "\u5220\u9664\u8868\u683C",
  "Cell": "\u5355\u5143\u683C",
  "Row": "\u884C",
  "Column": "\u5217",
  "Cell properties": "\u5355\u5143\u683C\u5C5E\u6027",
  "Merge cells": "\u5408\u5E76\u5355\u5143\u683C",
  "Split cell": "\u62C6\u5206\u5355\u5143\u683C",
  "Insert row before": "\u5728\u4E0A\u65B9\u63D2\u5165",
  "Insert row after": "\u5728\u4E0B\u65B9\u63D2\u5165",
  "Delete row": "\u5220\u9664\u884C",
  "Row properties": "\u884C\u5C5E\u6027",
  "Cut row": "\u526A\u5207\u884C",
  "Copy row": "\u590D\u5236\u884C",
  "Paste row before": "\u7C98\u8D34\u5230\u4E0A\u65B9",
  "Paste row after": "\u7C98\u8D34\u5230\u4E0B\u65B9",
  "Insert column before": "\u5728\u5DE6\u4FA7\u63D2\u5165",
  "Insert column after": "\u5728\u53F3\u4FA7\u63D2\u5165",
  "Delete column": "\u5220\u9664\u5217",
  "Cols": "\u5217",
  "Rows": "\u884C",
  "Width": "\u5BBD",
  "Height": "\u9AD8",
  "Cell spacing": "\u5355\u5143\u683C\u5916\u95F4\u8DDD",
  "Cell padding": "\u5355\u5143\u683C\u5185\u8FB9\u8DDD",
  "Show caption": "\u663E\u793A\u6807\u9898",
  "Left": "\u5DE6\u5BF9\u9F50",
  "Center": "\u5C45\u4E2D",
  "Right": "\u53F3\u5BF9\u9F50",
  "Cell type": "\u5355\u5143\u683C\u7C7B\u578B",
  "Scope": "\u8303\u56F4",
  "Alignment": "\u5BF9\u9F50\u65B9\u5F0F",
  "H Align": "\u6C34\u5E73\u5BF9\u9F50",
  "V Align": "\u5782\u76F4\u5BF9\u9F50",
  "Top": "\u9876\u90E8\u5BF9\u9F50",
  "Middle": "\u5782\u76F4\u5C45\u4E2D",
  "Bottom": "\u5E95\u90E8\u5BF9\u9F50",
  "Header cell": "\u8868\u5934\u5355\u5143\u683C",
  "Row group": "\u884C\u7EC4",
  "Column group": "\u5217\u7EC4",
  "Row type": "\u884C\u7C7B\u578B",
  "Header": "\u8868\u5934",
  "Body": "\u8868\u4F53",
  "Footer": "\u8868\u5C3E",
  "Border color": "\u8FB9\u6846\u989C\u8272",
  "Insert template...": "\u63D2\u5165\u6A21\u677F...",
  "Templates": "\u6A21\u677F",
  "Template": "\u6A21\u677F",
  "Text color": "\u6587\u5B57\u989C\u8272",
  "Background color": "\u80CC\u666F\u8272",
  "Custom...": "\u81EA\u5B9A\u4E49...",
  "Custom color": "\u81EA\u5B9A\u4E49\u989C\u8272",
  "No color": "\u65E0",
  "Remove color": "\u5220\u9664\u989C\u8272",
  "Table of Contents": "\u76EE\u5F55",
  "Show blocks": "\u663E\u793A\u533A\u5757\u8FB9\u6846",
  "Show invisible characters": "\u663E\u793A\u4E0D\u53EF\u89C1\u5B57\u7B26",
  "Word count": "\u5B57\u6570\u7EDF\u8BA1",
  "Words: {0}": "\u5B57\u6570\uFF1A{0}",
  "{0} words": "{0} \u4E2A\u5B57",
  "File": "\u6587\u4EF6",
  "Edit": "\u7F16\u8F91",
  "Insert": "\u63D2\u5165",
  "View": "\u67E5\u770B",
  "Format": "\u683C\u5F0F",
  "Table": "\u8868\u683C",
  "Tools": "\u5DE5\u5177",
  "Powered by {0}": "Powered by {0}",
  "Rich Text Area. Press ALT-F9 for menu. Press ALT-F10 for toolbar. Press ALT-0 for help": "\u5728\u7F16\u8F91\u533A\u6309ALT+F9\u6253\u5F00\u83DC\u5355\uFF0C\u6309ALT+F10\u6253\u5F00\u5DE5\u5177\u680F\uFF0C\u6309ALT+0\u67E5\u770B\u5E2E\u52A9",
  "Image title": "\u56FE\u7247\u6807\u9898",
  "Border width": "\u8FB9\u6846\u5BBD\u5EA6",
  "Border style": "\u8FB9\u6846\u6837\u5F0F",
  "Error": "\u9519\u8BEF",
  "Warn": "\u8B66\u544A",
  "Valid": "\u6709\u6548",
  "To open the popup, press Shift+Enter": "\u6B64\u5FEB\u6377\u4E3A\u8F6F\u56DE\u8F66\uFF08\u63D2\u5165<br>\uFF09",
  "Rich Text Area. Press ALT-0 for help.": "\u7F16\u8F91\u533A. \u6309Alt+0\u952E\u6253\u5F00\u5E2E\u52A9",
  "System Font": "\u9ED8\u8BA4\u5B57\u4F53",
  "Failed to upload image: {0}": "\u56FE\u7247\u4E0A\u4F20\u5931\u8D25: {0}",
  "Failed to load plugin: {0} from url {1}": "\u63D2\u4EF6\u52A0\u8F7D\u5931\u8D25: {0} - {1}",
  "Failed to load plugin url: {0}": "\u63D2\u4EF6\u52A0\u8F7D\u5931\u8D25: {0}",
  "Failed to initialize plugin: {0}": "\u63D2\u4EF6\u521D\u59CB\u5316\u5931\u8D25: {0}",
  "example": "\u793A\u4F8B",
  "Search": "\u67E5\u627E",
  "All": "\u5168\u90E8",
  "Currency": "\u8D27\u5E01",
  "Text": "\u6587\u672C",
  "Quotations": "\u5F15\u7528",
  "Mathematical": "\u6570\u5B66\u8FD0\u7B97\u7B26",
  "Extended Latin": "\u62C9\u4E01\u8BED\u6269\u5145",
  "Symbols": "\u7B26\u53F7",
  "Arrows": "\u7BAD\u5934",
  "User Defined": "\u81EA\u5B9A\u4E49",
  "dollar sign": "\u7F8E\u5143",
  "currency sign": "\u8D27\u5E01",
  "euro-currency sign": "\u6B27\u5143",
  "colon sign": "\u5192\u53F7",
  "cruzeiro sign": "\u514B\u9C81\u8D5B\u7F57\u5E01",
  "french franc sign": "\u6CD5\u90CE",
  "lira sign": "\u91CC\u62C9",
  "mill sign": "\u5BC6\u5C14",
  "naira sign": "\u5948\u62C9",
  "peseta sign": "\u6BD4\u585E\u5854",
  "rupee sign": "\u5362\u6BD4",
  "won sign": "\u97E9\u5143",
  "new sheqel sign": "\u65B0\u8C22\u514B\u5C14",
  "dong sign": "\u8D8A\u5357\u76FE",
  "kip sign": "\u8001\u631D\u57FA\u666E",
  "tugrik sign": "\u56FE\u683C\u91CC\u514B",
  "drachma sign": "\u5FB7\u62C9\u514B\u9A6C",
  "german penny symbol": "\u5FB7\u56FD\u4FBF\u58EB",
  "peso sign": "\u6BD4\u7D22",
  "guarani sign": "\u74DC\u62C9\u5C3C",
  "austral sign": "\u6FB3\u5143",
  "hryvnia sign": "\u683C\u91CC\u592B\u5C3C\u4E9A",
  "cedi sign": "\u585E\u5730",
  "livre tournois sign": "\u91CC\u5F17\u5F17\u5C14",
  "spesmilo sign": "\u4E00\u5343spesoj\u7684\u8D27\u5E01\u7B26\u53F7\uFF0C\u8BE5\u8D27\u5E01\u672A\u4F7F\u7528",
  "tenge sign": "\u575A\u6208",
  "indian rupee sign": "\u5370\u5EA6\u5362\u6BD4",
  "turkish lira sign": "\u571F\u8033\u5176\u91CC\u62C9",
  "nordic mark sign": "\u5317\u6B27\u9A6C\u514B",
  "manat sign": "\u9A6C\u7EB3\u7279",
  "ruble sign": "\u5362\u5E03",
  "yen character": "\u65E5\u5143",
  "yuan character": "\u4EBA\u6C11\u5E01\u5143",
  "yuan character, in hong kong and taiwan": "\u5143\u7684\u7E41\u4F53\u5B57",
  "yen/yuan character variant one": "\u5143\uFF08\u5927\u5199\uFF09",
  "Loading emoticons...": "\u6B63\u5728\u52A0\u8F7D\u8868\u60C5\u6587\u5B57...",
  "Could not load emoticons": "\u4E0D\u80FD\u52A0\u8F7D\u8868\u60C5\u6587\u5B57",
  "People": "\u4EBA\u7C7B",
  "Animals and Nature": "\u52A8\u7269\u548C\u81EA\u7136",
  "Food and Drink": "\u98DF\u7269\u548C\u996E\u54C1",
  "Activity": "\u6D3B\u52A8",
  "Travel and Places": "\u65C5\u6E38\u548C\u5730\u70B9",
  "Objects": "\u7269\u4EF6",
  "Flags": "\u65D7\u5E1C",
  "Characters": "\u5B57\u6570",
  "Characters (no spaces)": "\u5B57\u6570\uFF08\u4E0D\u542B\u7A7A\u683C\uFF09",
  "Error: Form submit field collision.": "\u9519\u8BEF: \u8868\u5355\u63D0\u4EA4\u5B57\u6BB5\u51B2\u7A81.",
  "Error: No form element found.": "\u9519\u8BEF: \u672A\u627E\u5230\u53EF\u7528\u7684form.",
  "Update": "\u66F4\u65B0",
  "Color swatch": "\u989C\u8272\u6837\u672C",
  "Turquoise": "\u9752\u7EFF",
  "Green": "\u7EFF\u8272",
  "Blue": "\u84DD\u8272",
  "Purple": "\u7D2B\u8272",
  "Navy Blue": "\u6D77\u519B\u84DD",
  "Dark Turquoise": "\u6DF1\u84DD\u7EFF\u8272",
  "Dark Green": "\u6697\u7EFF",
  "Medium Blue": "\u4E2D\u84DD",
  "Medium Purple": "\u4E2D\u7D2B",
  "Midnight Blue": "\u6DF1\u84DD",
  "Yellow": "\u9EC4\u8272",
  "Orange": "\u6A59\u8272",
  "Red": "\u7EA2\u8272",
  "Light Gray": "\u6D45\u7070",
  "Gray": "\u7070\u8272",
  "Dark Yellow": "\u6697\u9EC4",
  "Dark Orange": "\u6697\u6A59",
  "Dark Red": "\u6697\u7EA2",
  "Medium Gray": "\u4E2D\u7070",
  "Dark Gray": "\u6DF1\u7070",
  "Black": "\u9ED1\u8272",
  "White": "\u767D\u8272",
  "Switch to or from fullscreen mode": "\u5207\u6362\u5168\u5C4F\u6A21\u5F0F",
  "Open help dialog": "\u6253\u5F00\u5E2E\u52A9\u5BF9\u8BDD\u6846",
  "history": "\u5386\u53F2",
  "styles": "\u6837\u5F0F",
  "formatting": "\u683C\u5F0F\u5316",
  "alignment": "\u5BF9\u9F50",
  "indentation": "\u7F29\u8FDB",
  "permanent pen": "\u8BB0\u53F7\u7B14",
  "comments": "\u6CE8\u91CA",
  "Anchor": "\u951A\u70B9",
  "Special character": "\u7279\u6B8A\u5B57\u7B26",
  "Code sample": "\u4EE3\u7801\u793A\u4F8B",
  "Color": "\u989C\u8272",
  "Emoticons": "\u8868\u60C5",
  "Document properties": "\u6587\u6863\u5C5E\u6027",
  "Image": "\u56FE\u7247",
  "Insert link": "\u63D2\u5165\u94FE\u63A5",
  "Target": "\u76EE\u6807",
  "Link": "\u94FE\u63A5",
  "Poster": "\u5C01\u9762",
  "Media": "\u97F3\u89C6\u9891",
  "Print": "\u6253\u5370",
  "Prev": "\u4E0A\u4E00\u4E2A",
  "Find and replace": "\u67E5\u627E\u5E76\u66FF\u6362",
  "Whole words": "\u5168\u5B57\u5339\u914D",
  "Spellcheck": "\u62FC\u5199\u68C0\u67E5",
  "Caption": "\u6807\u9898",
  "Insert template": "\u63D2\u5165\u6A21\u677F",
  "Code view": "\u4EE3\u7801\u533A\u57DF",
  "Select...": "\u9009\u62E9...",
  "Format Painter": "\u683C\u5F0F\u5237",
  "No templates defined.": "\u65E0\u5185\u7F6E\u6A21\u677F",
  "Special character...": "\u7279\u6B8A\u5B57\u7B26...",
  "Open link": "\u6253\u5F00\u94FE\u63A5",
  "None": "\u65E0",
  "Count": "\u7EDF\u8BA1",
  "Document": "\u6574\u4E2A\u6587\u6863",
  "Selection": "\u9009\u53D6\u90E8\u5206",
  "Words": "\u5B57\u8BCD\u6570",
  "{0} characters": "{0} \u4E2A\u5B57\u7B26",
  "Alternative source URL": "\u66FF\u4EE3\u8D44\u6E90\u5730\u5740",
  "Alternative description": "\u66FF\u4EE3\u8BF4\u660E\u6587\u5B57",
  "Accessibility": "\u53EF\u8BBF\u95EE\u6027",
  "Image is decorative": "\u4EC5\u7528\u4E8E\u88C5\u9970",
  "Version": "\u7248\u672C",
  "Keyboard Navigation": "\u952E\u76D8\u5BFC\u822A",
  "Open popup menu for split buttons": "\u8BE5\u7EC4\u5408\u952E\u7684\u4F5C\u7528\u662F\u8F6F\u56DE\u8F66\uFF08\u63D2\u5165br\uFF09"
});
export { TinymceEditor as T };
